{
    "id": "rom-48k",
    "name": "ZX Spectrum 48K ROM",
    "type": "game",
    "source": "Richard Dymond \u2014 skoolkit.ca \u2014 standard 48K ROM routines",
    "baseAddress": 0,
    "machineType": "48k",
    "anchors": [],
    "labels": {
        "0": "START",
        "8": "ERROR_1",
        "10": "PRINT_A_1",
        "13": "unused",
        "18": "GET_CHAR",
        "1c": "TEST_CHAR",
        "20": "NEXT_CHAR",
        "25": "unused",
        "28": "FP_CALC",
        "2b": "unused",
        "30": "BC_SPACES",
        "38": "MASK_INT",
        "48": "KEY_INT",
        "53": "ERROR_2",
        "55": "ERROR_3",
        "5f": "unused",
        "66": "RESET",
        "70": "NO_RESET",
        "74": "CH_ADD_1",
        "77": "TEMP_PTR1",
        "78": "TEMP_PTR2",
        "7d": "SKIP_OVER",
        "90": "SKIPS",
        "95": "TOKENS",
        "205": "KEYTABLE_A",
        "22c": "KEYTABLE_B",
        "246": "KEYTABLE_C",
        "260": "KEYTABLE_D",
        "26a": "KEYTABLE_E",
        "284": "KEYTABLE_F",
        "28e": "KEY_SCAN",
        "296": "KEY_LINE",
        "29f": "KEY_3KEYS",
        "2a1": "KEY_BITS",
        "2ab": "KEY_DONE",
        "2bf": "KEYBOARD",
        "2c6": "K_ST_LOOP",
        "2d1": "K_CH_SET",
        "2f1": "K_NEW",
        "308": "K_END",
        "310": "K_REPEAT",
        "31e": "K_TEST",
        "32c": "K_MAIN",
        "333": "K_DECODE",
        "341": "K_E_LET",
        "34a": "K_LOOK_UP",
        "34f": "K_KLC_LET",
        "364": "K_TOKENS",
        "367": "K_DIGIT",
        "382": "K_8_9",
        "389": "K_GRA_DGT",
        "39d": "K_KLC_DGT",
        "3b2": "K_AT_CHAR",
        "3b5": "BEEPER",
        "3d6": "BE_H_L_LP",
        "3f2": "BE_AGAIN",
        "3f6": "BE_END",
        "3f8": "BEEP",
        "425": "BE_i_OK",
        "427": "BE_OCTAVE",
        "46c": "REPORT_B",
        "46e": "SEMITONES",
        "4aa": "PROGNAME",
        "4c2": "SA_BYTES",
        "4d0": "SA_FLAG",
        "4d8": "SA_LEADER",
        "4ea": "SA_SYNC_1",
        "4f2": "SA_SYNC_2",
        "4fe": "SA_LOOP",
        "505": "SA_LOOP_P",
        "507": "SA_START",
        "50e": "SA_PARITY",
        "511": "SA_BIT_2",
        "514": "SA_BIT_1",
        "51a": "SA_SET",
        "51c": "SA_OUT",
        "525": "SA_8_BITS",
        "53c": "SA_DELAY",
        "53f": "SA_LD_RET",
        "554": "SA_LD_END",
        "556": "LD_BYTES",
        "56b": "LD_BREAK",
        "56c": "LD_START",
        "574": "LD_WAIT",
        "580": "LD_LEADER",
        "58f": "LD_SYNC",
        "5a9": "LD_LOOP",
        "5b3": "LD_FLAG",
        "5bd": "LD_VERIFY",
        "5c2": "LD_NEXT",
        "5c4": "LD_DEC",
        "5c8": "LD_MARKER",
        "5ca": "LD_8_BITS",
        "5e3": "LD_EDGE_2",
        "5e7": "LD_EDGE_1",
        "5e9": "LD_DELAY",
        "5ed": "LD_SAMPLE",
        "605": "SAVE_ETC",
        "621": "SA_SPACE",
        "629": "SA_BLANK",
        "644": "SA_NULL",
        "64b": "SA_NAME",
        "652": "SA_DATA",
        "672": "SA_V_OLD",
        "685": "SA_V_NEW",
        "68f": "SA_V_TYPE",
        "692": "SA_DATA_1",
        "6a0": "SA_SCR",
        "6c3": "SA_CODE",
        "6e1": "SA_CODE_1",
        "6f0": "SA_CODE_2",
        "6f5": "SA_CODE_3",
        "6f9": "SA_CODE_4",
        "710": "SA_TYPE_3",
        "716": "SA_LINE",
        "723": "SA_LINE_1",
        "73a": "SA_TYPE_0",
        "75a": "SA_ALL",
        "767": "LD_LOOK_H",
        "78a": "LD_TYPE",
        "7a6": "LD_NAME",
        "7ad": "LD_CH_PR",
        "7cb": "VR_CONTRL",
        "7e9": "VR_CONT_1",
        "7f4": "VR_CONT_2",
        "800": "VR_CONT_3",
        "802": "LD_BLOCK",
        "806": "REPORT_R",
        "808": "LD_CONTRL",
        "819": "LD_CONT_1",
        "825": "LD_CONT_2",
        "82e": "LD_DATA",
        "84c": "LD_DATA_1",
        "873": "LD_PROG",
        "8ad": "LD_PROG_1",
        "8b6": "ME_CONTRL",
        "8d2": "ME_NEW_LP",
        "8d7": "ME_OLD_LP",
        "8df": "ME_OLD_L1",
        "8eb": "ME_NEW_L2",
        "8f0": "ME_VAR_LP",
        "8f9": "ME_OLD_VP",
        "901": "ME_OLD_V1",
        "909": "ME_OLD_V2",
        "912": "ME_OLD_V3",
        "91e": "ME_OLD_V4",
        "921": "ME_VAR_L1",
        "923": "ME_VAR_L2",
        "92c": "ME_ENTER",
        "93e": "ME_ENT_1",
        "955": "ME_ENT_2",
        "958": "ME_ENT_3",
        "970": "SA_CONTRL",
        "991": "SA_1_SEC",
        "9a1": "CASSETTE",
        "9c1": "BLOCK_HDR",
        "9f4": "PRINT_OUT",
        "a11": "CTRL_CHARS",
        "a23": "PO_BACK_1",
        "a38": "PO_BACK_2",
        "a3a": "PO_BACK_3",
        "a3d": "PO_RIGHT",
        "a4f": "PO_ENTER",
        "a5f": "PO_COMMA",
        "a69": "PO_QUEST",
        "a6d": "PO_TV_2",
        "a75": "PO_2_OPER",
        "a7a": "PO_1_OPER",
        "a7d": "PO_TV_1",
        "a80": "PO_CHANGE",
        "a87": "PO_CONT",
        "aac": "PO_AT_ERR",
        "abf": "PO_AT_SET",
        "ac2": "PO_TAB",
        "ac3": "PO_FILL",
        "ad0": "PO_SPACE",
        "ad9": "PO_ABLE",
        "adc": "PO_STORE",
        "af0": "PO_ST_E",
        "afc": "PO_ST_PR",
        "b03": "PO_FETCH",
        "b1d": "PO_F_PR",
        "b24": "PO_ANY",
        "b38": "PO_GR_1",
        "b3e": "PO_GR_2",
        "b4c": "PO_GR_3",
        "b52": "PO_T_UDG",
        "b5f": "PO_T",
        "b65": "PO_CHAR",
        "b6a": "PO_CHAR_2",
        "b76": "PO_CHAR_3",
        "b7f": "PR_ALL",
        "b93": "PR_ALL_1",
        "ba4": "PR_ALL_2",
        "bb6": "PR_ALL_3",
        "bb7": "PR_ALL_4",
        "bc1": "PR_ALL_5",
        "bd3": "PR_ALL_6",
        "bdb": "PO_ATTR",
        "bfa": "PO_ATTR_1",
        "c08": "PO_ATTR_2",
        "c0a": "PO_MSG",
        "c10": "PO_TOKENS",
        "c14": "PO_TABLE",
        "c22": "PO_EACH",
        "c35": "PO_TR_SP",
        "c3b": "PO_SAVE",
        "c41": "PO_SEARCH",
        "c44": "PO_STEP",
        "c55": "PO_SCR",
        "c86": "REPORT_5",
        "c88": "PO_SCR_2",
        "cd2": "PO_SCR_3",
        "cf0": "PO_SCR_3A",
        "cf8": "SCROLL",
        "d00": "REPORT_D",
        "d02": "PO_SCR_4",
        "d1c": "PO_SCR_4A",
        "d2d": "PO_SCR_4B",
        "d4d": "TEMPS",
        "d5b": "TEMPS_1",
        "d65": "TEMPS_2",
        "d6b": "CLS",
        "d6e": "CLS_LOWER",
        "d87": "CLS_1",
        "d89": "CLS_2",
        "d8e": "CLS_3",
        "d94": "CL_CHAN",
        "da0": "CL_CHAN_A",
        "daf": "CL_ALL",
        "dd9": "CL_SET",
        "dee": "CL_SET_1",
        "df4": "CL_SET_2",
        "dfe": "CL_SC_ALL",
        "e00": "CL_SCROLL",
        "e05": "CL_SCR_1",
        "e0d": "CL_SCR_2",
        "e19": "CL_SCR_3",
        "e44": "CL_LINE",
        "e4a": "CL_LINE_1",
        "e4d": "CL_LINE_2",
        "e80": "CL_LINE_3",
        "e88": "CL_ATTR",
        "e9b": "CL_ADDR",
        "eac": "COPY",
        "eb2": "COPY_1",
        "ec9": "COPY_2",
        "ecd": "COPY_BUFF",
        "ed3": "COPY_3",
        "eda": "COPY_END",
        "edf": "CLEAR_PRB",
        "ee7": "PRB_BYTES",
        "ef4": "COPY_LINE",
        "efd": "COPY_L_1",
        "f0c": "COPY_L_2",
        "f14": "COPY_L_3",
        "f18": "COPY_L_4",
        "f1e": "COPY_L_5",
        "f2c": "EDITOR",
        "f30": "ED_AGAIN",
        "f38": "ED_LOOP",
        "f6c": "ED_CONTR",
        "f81": "ADD_CHAR",
        "f8b": "ADD_CH_1",
        "f92": "ED_KEYS",
        "fa0": "EDITKEYS",
        "fa9": "ED_EDIT",
        "ff3": "ED_DOWN",
        "1001": "ED_STOP",
        "1007": "ED_LEFT",
        "100c": "ED_RIGHT",
        "1011": "ED_CUR",
        "1015": "ED_DELETE",
        "101e": "ED_IGNORE",
        "1024": "ED_ENTER",
        "1026": "ED_END",
        "1031": "ED_EDGE",
        "103e": "ED_EDGE_1",
        "1051": "ED_EDGE_2",
        "1059": "ED_UP",
        "106e": "ED_LIST",
        "1076": "ED_SYMBOL",
        "107c": "ED_GRAPH",
        "107f": "ED_ERROR",
        "1097": "CLEAR_SP",
        "10a8": "KEY_INPUT",
        "10db": "KEY_M_CL",
        "10e6": "KEY_MODE",
        "10f4": "KEY_FLAG",
        "10fa": "KEY_CONTR",
        "1105": "KEY_DATA",
        "110d": "KEY_NEXT",
        "1113": "KEY_CHAN",
        "111b": "KEY_DONE_2",
        "111d": "ED_COPY",
        "1150": "ED_BLANK",
        "115e": "ED_SPACES",
        "1167": "ED_FULL",
        "117c": "ED_C_DONE",
        "117e": "ED_C_END",
        "1190": "SET_HL",
        "1195": "SET_DE",
        "11a7": "REMOVE_FP",
        "11b7": "NEW",
        "11cb": "START_NEW",
        "11dc": "RAM_FILL",
        "11e2": "RAM_READ",
        "11ef": "RAM_DONE",
        "1219": "RAM_SET",
        "12a2": "MAIN_EXEC",
        "12a9": "MAIN_1",
        "12ac": "MAIN_2",
        "12cf": "MAIN_3",
        "1303": "MAIN_4",
        "1313": "MAIN_G",
        "133c": "MAIN_5",
        "1373": "MAIN_6",
        "1376": "MAIN_7",
        "1384": "MAIN_8",
        "1386": "MAIN_9",
        "1391": "REPORTS",
        "1537": "COMMA_SPC",
        "1539": "COPYRIGHT",
        "1555": "REPORT_G",
        "155d": "MAIN_ADD",
        "157d": "MAIN_ADD1",
        "15ab": "MAIN_ADD2",
        "15af": "CHANINFO",
        "15c4": "REPORT_J",
        "15c6": "STRMDATA",
        "15d4": "WAIT_KEY",
        "15de": "WAIT_KEY1",
        "15e6": "INPUT_AD",
        "15ef": "OUT_CODE",
        "15f2": "PRINT_A_2",
        "15f7": "CALL_SUB",
        "1601": "CHAN_OPEN",
        "160e": "REPORT_O",
        "1610": "CHAN_OP_1",
        "1615": "CHAN_FLAG",
        "162c": "CALL_JUMP",
        "162d": "CHANCODE",
        "1634": "CHAN_K",
        "1642": "CHAN_S",
        "1646": "CHAN_S_1",
        "164d": "CHAN_P",
        "1652": "ONE_SPACE",
        "1655": "MAKE_ROOM",
        "1664": "POINTERS",
        "166b": "PTR_NEXT",
        "167f": "PTR_DONE",
        "168f": "LINE_ZERO",
        "1691": "LINE_NO_A",
        "1695": "LINE_NO",
        "169e": "RESERVE",
        "16b0": "SET_MIN",
        "16bf": "SET_WORK",
        "16c5": "SET_STK",
        "16d4": "REC_EDIT",
        "16db": "INDEXER_1",
        "16dc": "INDEXER",
        "16e5": "CLOSE",
        "16fc": "CLOSE_1",
        "1701": "CLOSE_2",
        "1716": "CLOSESTRM",
        "171c": "CLOSE_STR",
        "171e": "STR_DATA",
        "1725": "REPORT_O_2",
        "1727": "STR_DATA1",
        "1736": "OPEN",
        "1756": "OPEN_1",
        "175d": "OPEN_2",
        "1765": "REPORT_F",
        "1767": "OPEN_3",
        "177a": "OPENSTRM",
        "1781": "OPEN_K",
        "1785": "OPEN_S",
        "1789": "OPEN_P",
        "178b": "OPEN_END",
        "1793": "CAT_ETC",
        "1795": "AUTO_LIST",
        "17ce": "AUTO_L_1",
        "17e1": "AUTO_L_2",
        "17e4": "AUTO_L_3",
        "17ed": "AUTO_L_4",
        "17f5": "LLIST",
        "17f9": "LIST",
        "17fb": "LIST_1",
        "1814": "LIST_2",
        "181a": "LIST_3",
        "181f": "LIST_4",
        "1822": "LIST_5",
        "1833": "LIST_ALL",
        "1835": "LIST_ALL_1",
        "1855": "OUT_LINE",
        "1865": "OUT_LINE1",
        "187d": "OUT_LINE2",
        "1881": "OUT_LINE3",
        "1894": "OUT_LINE4",
        "18a1": "OUT_LINE5",
        "18b4": "OUT_LINE6",
        "18b6": "NUMBER",
        "18c1": "OUT_FLASH",
        "18e1": "OUT_CURS",
        "18f3": "OUT_C_1",
        "1909": "OUT_C_2",
        "190f": "LN_FETCH",
        "191c": "LN_STORE",
        "1925": "OUT_SP_2",
        "192a": "OUT_SP_NO",
        "192b": "OUT_SP_1",
        "1937": "OUT_CHAR",
        "195a": "OUT_CH_1",
        "1968": "OUT_CH_2",
        "196c": "OUT_CH_3",
        "196e": "LINE_ADDR",
        "1974": "LINE_AD_1",
        "1980": "CP_LINES",
        "1988": "unused",
        "198b": "EACH_STMT",
        "1990": "EACH_S_1",
        "1998": "EACH_S_2",
        "199a": "EACH_S_3",
        "19a5": "EACH_S_4",
        "19ad": "EACH_S_5",
        "19b1": "EACH_S_6",
        "19b8": "NEXT_ONE",
        "19c7": "NEXT_O_1",
        "19ce": "NEXT_O_2",
        "19d5": "NEXT_O_3",
        "19d6": "NEXT_O_4",
        "19db": "NEXT_O_5",
        "19dd": "DIFFER",
        "19e5": "RECLAIM_1",
        "19e8": "RECLAIM_2",
        "19fb": "E_LINE_NO",
        "1a15": "E_L_1",
        "1a1b": "OUT_NUM_1",
        "1a28": "OUT_NUM_2",
        "1a30": "OUT_NUM_3",
        "1a42": "OUT_NUM_4",
        "1a48": "SYNTAX",
        "1a7a": "P_LET",
        "1a7d": "P_GO_TO",
        "1a81": "P_IF",
        "1a86": "P_GO_SUB",
        "1a8a": "P_STOP",
        "1a8d": "P_RETURN",
        "1a90": "P_FOR",
        "1a98": "P_NEXT",
        "1a9c": "P_PRINT",
        "1a9f": "P_INPUT",
        "1aa2": "P_DIM",
        "1aa5": "P_REM",
        "1aa8": "P_NEW",
        "1aab": "P_RUN",
        "1aae": "P_LIST",
        "1ab1": "P_POKE",
        "1ab5": "P_RANDOM",
        "1ab8": "P_CONT",
        "1abb": "P_CLEAR",
        "1abe": "P_CLS",
        "1ac1": "P_PLOT",
        "1ac5": "P_PAUSE",
        "1ac9": "P_READ",
        "1acc": "P_DATA",
        "1acf": "P_RESTORE",
        "1ad2": "P_DRAW",
        "1ad6": "P_COPY",
        "1ad9": "P_LPRINT",
        "1adc": "P_LLIST",
        "1adf": "P_SAVE",
        "1ae0": "P_LOAD",
        "1ae1": "P_VERIFY",
        "1ae2": "P_MERGE",
        "1ae3": "P_BEEP",
        "1ae7": "P_CIRCLE",
        "1aeb": "P_INK",
        "1aec": "P_PAPER",
        "1aed": "P_FLASH",
        "1aee": "P_BRIGHT",
        "1aef": "P_INVERSE",
        "1af0": "P_OVER",
        "1af1": "P_OUT",
        "1af5": "P_BORDER",
        "1af9": "P_DEF_FN",
        "1afc": "P_OPEN",
        "1b02": "P_CLOSE",
        "1b06": "P_FORMAT",
        "1b0a": "P_MOVE",
        "1b10": "P_ERASE",
        "1b14": "P_CAT",
        "1b17": "LINE_SCAN",
        "1b28": "STMT_LOOP",
        "1b29": "STMT_L_1",
        "1b52": "SCAN_LOOP",
        "1b55": "GET_PARAM",
        "1b6f": "SEPARATOR",
        "1b76": "STMT_RET",
        "1b7d": "STMT_R_1",
        "1b8a": "LINE_RUN",
        "1b9e": "LINE_NEW",
        "1bb2": "REM",
        "1bb3": "LINE_END",
        "1bbf": "LINE_USE",
        "1bd1": "NEXT_LINE",
        "1bec": "REPORT_N",
        "1bee": "CHECK_END",
        "1bf4": "STMT_NEXT",
        "1c01": "CMDCLASS",
        "1c0d": "CLASS_03",
        "1c10": "CLASS_00",
        "1c11": "CLASS_05",
        "1c1f": "CLASS_01",
        "1c22": "VAR_A_1",
        "1c2e": "REPORT_2",
        "1c30": "VAR_A_2",
        "1c46": "VAR_A_3",
        "1c4e": "CLASS_02",
        "1c56": "VAL_FET_1",
        "1c59": "VAL_FET_2",
        "1c6c": "CLASS_04",
        "1c79": "NEXT_2NUM",
        "1c7a": "CLASS_08",
        "1c82": "CLASS_06",
        "1c8a": "REPORT_C",
        "1c8c": "CLASS_0A",
        "1c96": "CLASS_07",
        "1cbe": "CLASS_09",
        "1cd6": "CL_09_1",
        "1cdb": "CLASS_0B",
        "1cde": "FETCH_NUM",
        "1ce6": "USE_ZERO",
        "1cee": "STOP",
        "1cf0": "IF_CMD",
        "1d00": "IF_1",
        "1d03": "FOR",
        "1d10": "F_USE_1",
        "1d16": "F_REORDER",
        "1d34": "F_L_S",
        "1d64": "F_LOOP",
        "1d7c": "F_FOUND",
        "1d84": "REPORT_I",
        "1d86": "LOOK_PROG",
        "1d8b": "LOOK_P_1",
        "1da3": "LOOK_P_2",
        "1dab": "NEXT",
        "1dd8": "REPORT_1",
        "1dda": "NEXT_LOOP",
        "1de2": "NEXT_1",
        "1de9": "NEXT_2",
        "1dec": "READ_3",
        "1ded": "READ",
        "1e0a": "READ_1",
        "1e1e": "READ_2",
        "1e27": "DATA",
        "1e2c": "DATA_1",
        "1e37": "DATA_2",
        "1e39": "PASS_BY",
        "1e42": "RESTORE",
        "1e45": "REST_RUN",
        "1e4f": "RANDOMIZE",
        "1e5a": "RAND_1",
        "1e5f": "CONTINUE",
        "1e67": "GO_TO",
        "1e73": "GO_TO_2",
        "1e7a": "OUT_CMD",
        "1e80": "POKE",
        "1e85": "TWO_PARAM",
        "1e8e": "TWO_P_1",
        "1e94": "FIND_INT1",
        "1e99": "FIND_INT2",
        "1e9c": "FIND_I_1",
        "1e9f": "REPORT_B_2",
        "1ea1": "RUN",
        "1eac": "CLEAR",
        "1eaf": "CLEAR_RUN",
        "1eb7": "CLEAR_1",
        "1eda": "REPORT_M",
        "1edc": "CLEAR_2",
        "1eed": "GO_SUB",
        "1f05": "TEST_ROOM",
        "1f15": "REPORT_4",
        "1f1a": "FREE_MEM",
        "1f23": "RETURN",
        "1f36": "REPORT_7",
        "1f3a": "PAUSE",
        "1f3d": "PAUSE_1",
        "1f49": "PAUSE_2",
        "1f4f": "PAUSE_END",
        "1f54": "BREAK_KEY",
        "1f60": "DEF_FN",
        "1f6a": "DEF_FN_1",
        "1f7d": "DEF_FN_2",
        "1f86": "DEF_FN_3",
        "1f89": "DEF_FN_4",
        "1f94": "DEF_FN_5",
        "1fa6": "DEF_FN_6",
        "1fbd": "DEF_FN_7",
        "1fc3": "UNSTACK_Z",
        "1fc9": "LPRINT",
        "1fcd": "PRINT",
        "1fcf": "PRINT_1",
        "1fdf": "PRINT_2",
        "1fe5": "PRINT_3",
        "1ff2": "PRINT_4",
        "1ff5": "PRINT_CR",
        "1ffc": "PR_ITEM_1",
        "200e": "PR_ITEM_2",
        "201e": "PR_AT_TAB",
        "2024": "PR_ITEM_3",
        "203c": "PR_STRING",
        "2045": "PR_END_Z",
        "2048": "PR_ST_END",
        "204e": "PR_POSN_1",
        "2061": "PR_POSN_2",
        "2067": "PR_POSN_3",
        "206e": "PR_POSN_4",
        "2070": "STR_ALTER",
        "2089": "INPUT",
        "2096": "INPUT_1",
        "20ad": "INPUT_2",
        "20c1": "IN_ITEM_1",
        "20d8": "IN_ITEM_2",
        "20ed": "IN_ITEM_3",
        "20fa": "IN_PROMPT",
        "211a": "IN_PR_1",
        "211c": "IN_PR_2",
        "2129": "IN_PR_3",
        "213a": "IN_VAR_1",
        "2148": "IN_VAR_2",
        "215e": "IN_VAR_3",
        "2161": "IN_VAR_4",
        "2174": "IN_VAR_5",
        "219b": "IN_VAR_6",
        "21af": "IN_NEXT_1",
        "21b2": "IN_NEXT_2",
        "21b9": "IN_ASSIGN",
        "21d0": "IN_STOP",
        "21d6": "IN_CHAN_K",
        "21e1": "CO_TEMP_1",
        "21e2": "CO_TEMP_2",
        "21f2": "CO_TEMP_3",
        "21fc": "CO_TEMP_4",
        "2211": "CO_TEMP_5",
        "2228": "CO_TEMP_6",
        "2234": "CO_TEMP_7",
        "223e": "CO_TEMP_8",
        "2244": "REPORT_K",
        "2246": "CO_TEMP_9",
        "2257": "CO_TEMP_A",
        "2258": "CO_TEMP_B",
        "226c": "CO_CHANGE",
        "2273": "CO_TEMP_C",
        "227d": "CO_TEMP_D",
        "2287": "CO_TEMP_E",
        "2294": "BORDER",
        "22a6": "BORDER_1",
        "22aa": "PIXEL_ADD",
        "22cb": "POINT_SUB",
        "22d4": "POINT_LP",
        "22dc": "PLOT",
        "22e5": "PLOT_SUB",
        "22f0": "PLOT_LOOP",
        "22fd": "PL_TST_IN",
        "2303": "PLOT_END",
        "2307": "STK_TO_BC",
        "2314": "STK_TO_A",
        "2320": "CIRCLE",
        "233b": "C_R_GRE_1",
        "235a": "C_ARC_GE1",
        "2382": "DRAW",
        "238d": "DR_3_PRMS",
        "23a3": "DR_SIN_NZ",
        "23c1": "DR_PRMS",
        "2420": "DRW_STEPS",
        "2425": "ARC_LOOP",
        "2439": "ARC_START",
        "245f": "ARC_END",
        "2477": "LINE_DRAW",
        "247d": "CD_PRMS1",
        "2495": "USE_252",
        "2497": "DRAW_SAVE",
        "24b7": "DRAW_LINE",
        "24c4": "DL_X_GE_Y",
        "24cb": "DL_LARGER",
        "24ce": "D_L_LOOP",
        "24d4": "D_L_DIAG",
        "24db": "D_L_HR_VT",
        "24df": "D_L_STEP",
        "24ec": "D_L_PLOT",
        "24f7": "D_L_RANGE",
        "24f9": "REPORT_B_3",
        "24fb": "SCANNING",
        "24ff": "S_LOOP_1",
        "250f": "S_QUOTE_S",
        "2522": "S_2_COORD",
        "252d": "S_RPORT_C",
        "2530": "SYNTAX_Z",
        "2535": "S_SCRN_S",
        "254f": "S_SCRN_LP",
        "255a": "S_SC_MTCH",
        "255d": "S_SC_ROWS",
        "2573": "S_SCR_NXT",
        "257d": "S_SCR_STO",
        "2580": "S_ATTR_S",
        "2596": "SCANFUNC",
        "25af": "S_U_PLUS",
        "25b3": "S_QUOTE",
        "25be": "S_Q_AGAIN",
        "25cb": "S_Q_COPY",
        "25d9": "S_Q_PRMS",
        "25db": "S_STRING",
        "25e8": "S_BRACKET",
        "25f5": "S_FN",
        "25f8": "S_RND",
        "2625": "S_RND_END",
        "2627": "S_PI",
        "2630": "S_PI_END",
        "2634": "S_INKEY",
        "2660": "S_IK_STK",
        "2665": "S_INK_EN",
        "2668": "S_SCREEN",
        "2672": "S_ATTR",
        "267b": "S_POINT",
        "2684": "S_ALPHNUM",
        "268d": "S_DECIMAL",
        "26b5": "S_STK_DEC",
        "26b6": "S_SD_SKIP",
        "26c3": "S_NUMERIC",
        "26c9": "S_LETTER",
        "26dd": "S_CONT_1",
        "26df": "S_NEGATE",
        "2707": "S_NO_TO_S",
        "270d": "S_PUSH_PO",
        "2712": "S_CONT_2",
        "2713": "S_CONT_3",
        "2723": "S_OPERTR",
        "2734": "S_LOOP",
        "274c": "S_STK_LST",
        "275b": "S_SYNTEST",
        "2761": "S_RPORT_C_2",
        "2764": "S_RUNTEST",
        "2770": "S_LOOPEND",
        "2773": "S_TIGHTER",
        "2788": "S_NOT_AND",
        "2790": "S_NEXT",
        "2795": "OPERATORS",
        "27b0": "PRIORITIES",
        "27bd": "S_FN_SBRN",
        "27d0": "SF_BRKT_1",
        "27d9": "SF_ARGMTS",
        "27e4": "SF_BRKT_2",
        "27e6": "SF_RPRT_C",
        "27e9": "SF_FLAG_6",
        "27f4": "SF_SYN_EN",
        "27f7": "SF_RUN",
        "2802": "SF_ARGMT1",
        "2808": "SF_FND_DF",
        "2814": "SF_CP_DEF",
        "2825": "SF_NOT_FD",
        "2831": "SF_VALUES",
        "2843": "SF_ARG_LP",
        "2852": "SF_ARG_VL",
        "2885": "SF_R_BR_2",
        "288b": "REPORT_Q",
        "288d": "SF_VALUE",
        "28ab": "FN_SKPOVR",
        "28b2": "LOOK_VARS",
        "28d4": "V_CHAR",
        "28de": "V_STR_VAR",
        "28e3": "V_TEST_FN",
        "28ef": "V_RUN_SYN",
        "28fd": "V_RUN",
        "2900": "V_EACH",
        "2912": "V_MATCHES",
        "2913": "V_SPACES",
        "2929": "V_GET_PTR",
        "292a": "V_NEXT",
        "2932": "V_80_BYTE",
        "2934": "V_SYNTAX",
        "293e": "V_FOUND_1",
        "293f": "V_FOUND_2",
        "2943": "V_PASS",
        "294b": "V_END",
        "2951": "STK_F_ARG",
        "295a": "SFA_LOOP",
        "296b": "SFA_CP_VR",
        "2981": "SFA_MATCH",
        "2991": "SFA_END",
        "2996": "STK_VAR",
        "29a1": "SV_SIMPLE",
        "29ae": "SV_ARRAYS",
        "29c0": "SV_PTR",
        "29c3": "SV_COMMA",
        "29d8": "SV_CLOSE",
        "29e0": "SV_CH_ADD",
        "29e7": "SV_COUNT",
        "29ea": "SV_LOOP",
        "29fb": "SV_MULT",
        "2a12": "SV_RPT_C",
        "2a20": "REPORT_3",
        "2a22": "SV_NUMBER",
        "2a2c": "SV_ELEM",
        "2a45": "SV_SLICE",
        "2a48": "SV_DIM",
        "2a49": "SV_SLICE2",
        "2a52": "SLICING",
        "2a7a": "SL_RPT_C",
        "2a81": "SL_SECOND",
        "2a94": "SL_DEFINE",
        "2aa8": "SL_OVER",
        "2aad": "SL_STORE",
        "2ab1": "STK_ST_0",
        "2ab2": "STK_STO",
        "2ab6": "STK_STORE",
        "2acc": "INT_EXP1",
        "2acd": "INT_EXP2",
        "2ae8": "I_CARRY",
        "2aeb": "I_RESTORE",
        "2aee": "DE_DE_1",
        "2af4": "GET_HLxDE",
        "2aff": "LET",
        "2b0b": "L_EACH_CH",
        "2b0c": "L_NO_SP",
        "2b1f": "L_TEST_CH",
        "2b29": "L_SPACES",
        "2b3e": "L_CHAR",
        "2b4f": "L_SINGLE",
        "2b59": "L_NUMERIC",
        "2b66": "L_EXISTS",
        "2b72": "L_DELETE",
        "2b9b": "L_LENGTH",
        "2ba3": "L_IN_W_S",
        "2ba6": "L_ENTER",
        "2baf": "L_ADD",
        "2bc0": "L_NEW",
        "2bc6": "L_STRING",
        "2bea": "L_FIRST",
        "2bf1": "STK_FETCH",
        "2c02": "DIM",
        "2c05": "D_RPORT_C",
        "2c15": "D_RUN",
        "2c1f": "D_LETTER",
        "2c2d": "D_SIZE",
        "2c2e": "D_NO_LOOP",
        "2c7c": "DIM_CLEAR",
        "2c7f": "DIM_SIZES",
        "2c88": "ALPHANUM",
        "2c8d": "ALPHA",
        "2c9b": "DEC_TO_FP",
        "2ca2": "BIN_DIGIT",
        "2cb3": "BIN_END",
        "2cb8": "NOT_BIN",
        "2ccb": "DECIMAL",
        "2ccf": "DEC_RPT_C",
        "2cd5": "DEC_STO_1",
        "2cda": "NXT_DGT_1",
        "2ceb": "E_FORMAT",
        "2cf2": "SIGN_FLAG",
        "2cfe": "SIGN_DONE",
        "2cff": "ST_E_PART",
        "2d18": "E_FP_JUMP",
        "2d1b": "NUMERIC",
        "2d22": "STK_DIGIT",
        "2d28": "STACK_A",
        "2d2b": "STACK_BC",
        "2d3b": "INT_TO_FP",
        "2d40": "NXT_DGT_2",
        "2d4f": "e_to_fp",
        "2d55": "E_SAVE",
        "2d60": "E_LOOP",
        "2d6d": "E_DIVSN",
        "2d6e": "E_FETCH",
        "2d71": "E_TST_END",
        "2d7b": "E_END",
        "2d7f": "INT_FETCH",
        "2d8c": "P_INT_STO",
        "2d8e": "INT_STORE",
        "2da2": "FP_TO_BC",
        "2dad": "FP_DELETE",
        "2dc1": "LOG_2_A",
        "2dd5": "FP_TO_A",
        "2de1": "FP_A_END",
        "2de3": "PRINT_FP",
        "2df2": "PF_NEGTVE",
        "2df8": "PF_POSTVE",
        "2e01": "PF_LOOP",
        "2e1e": "PF_SAVE",
        "2e24": "PF_SMALL",
        "2e56": "PF_LARGE",
        "2e6f": "PF_MEDIUM",
        "2e7b": "PF_BITS",
        "2e8a": "PF_BYTES",
        "2ea1": "PF_DIGITS",
        "2ea9": "PF_INSERT",
        "2eb3": "PF_TEST_2",
        "2eb8": "PF_ALL_9",
        "2ecb": "PF_MORE",
        "2ecf": "PF_FRACTN",
        "2edf": "PF_FRN_LP",
        "2eec": "PF_FR_DGT",
        "2eef": "PF_FR_EXX",
        "2f0c": "PF_ROUND",
        "2f18": "PF_RND_LP",
        "2f25": "PF_R_BACK",
        "2f2d": "PF_COUNT",
        "2f46": "PF_NOT_E",
        "2f4a": "PF_E_SBRN",
        "2f52": "PF_OUT_LP",
        "2f59": "PF_OUT_DT",
        "2f5e": "PF_DC_OUT",
        "2f64": "PF_DEC_0S",
        "2f6c": "PF_E_FRMT",
        "2f83": "PF_E_POS",
        "2f85": "PF_E_SIGN",
        "2f8b": "CA_10A_C",
        "2f9b": "PREP_ADD",
        "2faf": "NEG_BYTE",
        "2fba": "FETCH_TWO",
        "2fdd": "SHIFT_FP",
        "2fe5": "ONE_SHIFT",
        "2ff9": "ADDEND_0",
        "2ffb": "ZEROS_4_5",
        "3004": "ADD_BACK",
        "300d": "ALL_ADDED",
        "300f": "subtract",
        "3014": "addition",
        "303c": "ADDN_OFLW",
        "303e": "FULL_ADDN",
        "3055": "SHIFT_LEN",
        "307c": "TEST_NEG",
        "309f": "ADD_REP_6",
        "30a3": "END_COMPL",
        "30a5": "GO_NC_MLT",
        "30a9": "HL_HLxDE",
        "30b1": "HL_LOOP",
        "30bc": "HL_AGAIN",
        "30be": "HL_END",
        "30c0": "PREP_M_D",
        "30ca": "multiply",
        "30ea": "MULT_RSLT",
        "30ef": "MULT_OFLW",
        "30f0": "MULT_LONG",
        "3114": "MLT_LOOP",
        "311b": "NO_ADD",
        "3125": "STRT_MLT",
        "313b": "MAKE_EXPT",
        "313d": "DIVN_EXPT",
        "3146": "OFLW1_CLR",
        "3151": "OFLW2_CLR",
        "3155": "TEST_NORM",
        "3159": "NEAR_ZERO",
        "315d": "ZERO_RSLT",
        "315e": "SKIP_ZERO",
        "316c": "NORMALISE",
        "316e": "SHIFT_ONE",
        "3186": "NORML_NOW",
        "3195": "OFLOW_CLR",
        "31ad": "REPORT_6",
        "31af": "division",
        "31d2": "DIV_LOOP",
        "31db": "DIV_34TH",
        "31e2": "DIV_START",
        "31f2": "SUBN_ONLY",
        "31f9": "NO_RSTORE",
        "31fa": "COUNT_ONE",
        "3214": "truncate",
        "3221": "T_GR_ZERO",
        "3233": "T_FIRST",
        "323f": "T_SMALL",
        "3252": "T_NUMERIC",
        "325e": "T_TEST",
        "3261": "T_SHIFT",
        "3267": "T_STORE",
        "326c": "T_EXPNENT",
        "326d": "X_LARGE",
        "3272": "NIL_BYTES",
        "327e": "BYTE_ZERO",
        "3283": "BITS_ZERO",
        "328a": "LESS_MASK",
        "3290": "IX_END",
        "3293": "RE_ST_TWO",
        "3296": "RESTK_SUB",
        "3297": "re_stack",
        "32b1": "RS_NRMLSE",
        "32b2": "RSTK_LOOP",
        "32bd": "RS_STORE",
        "32c5": "CONSTANTS",
        "32c8": "stk_one",
        "32cc": "stk_half",
        "32ce": "stk_pi_2",
        "32d3": "stk_ten",
        "32d7": "CALCADDR",
        "335b": "CALCULATE",
        "335e": "GEN_ENT_1",
        "3362": "GEN_ENT_2",
        "3365": "RE_ENTRY",
        "336c": "SCAN_ENT",
        "3380": "FIRST_3D",
        "338c": "DOUBLE_A",
        "338e": "ENT_TABLE",
        "33a1": "delete",
        "33a2": "fp_calc_2",
        "33a9": "TEST_5_SP",
        "33b4": "STACK_NUM",
        "33c0": "duplicate",
        "33c6": "stk_data",
        "33c8": "STK_CONST",
        "33de": "FORM_EXP",
        "33f1": "STK_ZEROS",
        "33f7": "SKIP_CONS",
        "33f8": "SKIP_NEXT",
        "3406": "LOC_MEM",
        "340f": "get_mem",
        "341b": "stk_con",
        "342d": "st_mem",
        "343c": "exchange",
        "343e": "SWAP_BYTE",
        "3449": "series",
        "3453": "G_LOOP",
        "346a": "abs",
        "346e": "negate",
        "3474": "NEG_TEST",
        "3483": "INT_CASE",
        "3492": "sgn",
        "34a5": "f_in",
        "34ac": "peek",
        "34b0": "IN_PK_STK",
        "34b3": "usr_no",
        "34bc": "usr",
        "34d3": "USR_RANGE",
        "34e4": "USR_STACK",
        "34e7": "REPORT_A",
        "34e9": "TEST_ZERO",
        "34f9": "greater_0",
        "3501": "f_not",
        "3506": "less_0",
        "3507": "SIGN_TO_C",
        "350b": "FP_0_1",
        "351b": "no_or_no",
        "3524": "no_and_no",
        "352d": "str_no",
        "353b": "compare",
        "3543": "EX_OR_NOT",
        "354e": "NU_OR_STR",
        "3559": "STRINGS",
        "3564": "BYTE_COMP",
        "356b": "SECND_LOW",
        "3572": "BOTH_NULL",
        "3575": "SEC_PLUS",
        "3585": "FRST_LESS",
        "3588": "STR_TEST",
        "358c": "END_TESTS",
        "359c": "strs_add",
        "35b7": "OTHER_STR",
        "35bf": "STK_PNTRS",
        "35c9": "chrs",
        "35dc": "REPORT_B_4",
        "35de": "val",
        "360c": "V_RPORT_C",
        "361f": "str",
        "3645": "read_in",
        "365f": "R_I_STORE",
        "3669": "code",
        "3671": "STK_CODE",
        "3674": "len",
        "367a": "dec_jr_nz",
        "3686": "jump",
        "3687": "JUMP_2",
        "368f": "jump_true",
        "369b": "end_calc",
        "36a0": "n_mod_m",
        "36af": "int",
        "36b7": "X_NEG",
        "36c2": "EXIT",
        "36c4": "exp",
        "3703": "REPORT_6_2",
        "3705": "N_NEGTV",
        "370c": "RESULT_OK",
        "370e": "RSLT_ZERO",
        "3713": "ln",
        "371c": "VALID",
        "373d": "GRE_8",
        "3783": "get_argt",
        "37a1": "ZPLUS",
        "37a8": "YNEG",
        "37aa": "cos",
        "37b5": "sin",
        "37b7": "C_ENT",
        "37da": "tan",
        "37e2": "atn",
        "37f8": "SMALL",
        "37fa": "CASES",
        "3833": "asn",
        "3843": "acs",
        "384a": "sqr",
        "3851": "to_power",
        "385d": "XIS0",
        "386a": "ONE",
        "386c": "LAST",
        "386e": "unused",
        "3d00": "CHARSET",
        "5c00": "KSTATE",
        "5c08": "LAST_K",
        "5c09": "REPDEL",
        "5c0a": "REPPER",
        "5c0b": "DEFADD",
        "5c0d": "K_DATA",
        "5c0e": "TVDATA",
        "5c10": "STRMS",
        "5c36": "CHARS",
        "5c38": "RASP",
        "5c39": "PIP",
        "5c3a": "ERR_NR",
        "5c3b": "FLAGS",
        "5c3c": "TV_FLAG",
        "5c3d": "ERR_SP",
        "5c3f": "LIST_SP",
        "5c41": "MODE",
        "5c42": "NEWPPC",
        "5c44": "NSPPC",
        "5c45": "PPC",
        "5c47": "SUBPPC",
        "5c48": "BORDCR",
        "5c49": "E_PPC",
        "5c4b": "VARS",
        "5c4d": "DEST",
        "5c4f": "CHANS",
        "5c51": "CURCHL",
        "5c53": "PROG",
        "5c55": "NXTLIN",
        "5c57": "DATADD",
        "5c59": "E_LINE",
        "5c5b": "K_CUR",
        "5c5d": "CH_ADD",
        "5c5f": "X_PTR",
        "5c61": "WORKSP",
        "5c63": "STKBOT",
        "5c65": "STKEND",
        "5c67": "BREG",
        "5c68": "MEM",
        "5c6a": "FLAGS2",
        "5c6b": "DF_SZ",
        "5c6c": "S_TOP",
        "5c6e": "OLDPPC",
        "5c70": "OSPCC",
        "5c71": "FLAGX",
        "5c72": "STRLEN",
        "5c74": "T_ADDR",
        "5c76": "SEED",
        "5c78": "FRAMES",
        "5c7b": "UDG",
        "5c7d": "COORDS",
        "5c7f": "P_POSN",
        "5c80": "PR_CC",
        "5c82": "ECHO_E",
        "5c84": "DF_CC",
        "5c86": "DF_CCL",
        "5c88": "S_POSN",
        "5c8a": "S_POSNL",
        "5c8c": "SCR_CT",
        "5c8d": "ATTR_P",
        "5c8e": "MASK_P",
        "5c8f": "ATTR_T",
        "5c90": "MASK_T",
        "5c91": "P_FLAG",
        "5c92": "MEMBOT",
        "5cb0": "NMIADD",
        "5cb2": "RAMTOP",
        "5cb4": "P_RAMT",
        "5cb6": "CHINFO"
    },
    "regions": [
        {
            "start": 0,
            "end": 5,
            "type": "code"
        },
        {
            "start": 8,
            "end": 14,
            "type": "code"
        },
        {
            "start": 16,
            "end": 16,
            "type": "code"
        },
        {
            "start": 19,
            "end": 19,
            "type": "db"
        },
        {
            "start": 24,
            "end": 27,
            "type": "code"
        },
        {
            "start": 28,
            "end": 31,
            "type": "code"
        },
        {
            "start": 32,
            "end": 35,
            "type": "code"
        },
        {
            "start": 37,
            "end": 37,
            "type": "db"
        },
        {
            "start": 40,
            "end": 40,
            "type": "code"
        },
        {
            "start": 43,
            "end": 43,
            "type": "db"
        },
        {
            "start": 48,
            "end": 53,
            "type": "code"
        },
        {
            "start": 56,
            "end": 71,
            "type": "code"
        },
        {
            "start": 72,
            "end": 82,
            "type": "code"
        },
        {
            "start": 83,
            "end": 84,
            "type": "code"
        },
        {
            "start": 85,
            "end": 92,
            "type": "code"
        },
        {
            "start": 95,
            "end": 95,
            "type": "db"
        },
        {
            "start": 102,
            "end": 111,
            "type": "db"
        },
        {
            "start": 112,
            "end": 114,
            "type": "code"
        },
        {
            "start": 116,
            "end": 118,
            "type": "code"
        },
        {
            "start": 119,
            "end": 119,
            "type": "code"
        },
        {
            "start": 120,
            "end": 124,
            "type": "code"
        },
        {
            "start": 125,
            "end": 143,
            "type": "code"
        },
        {
            "start": 144,
            "end": 148,
            "type": "code"
        },
        {
            "start": 149,
            "end": 513,
            "type": "text"
        },
        {
            "start": 517,
            "end": 653,
            "type": "db"
        },
        {
            "start": 654,
            "end": 661,
            "type": "code"
        },
        {
            "start": 662,
            "end": 670,
            "type": "code"
        },
        {
            "start": 671,
            "end": 672,
            "type": "code"
        },
        {
            "start": 673,
            "end": 682,
            "type": "code"
        },
        {
            "start": 683,
            "end": 702,
            "type": "code"
        },
        {
            "start": 703,
            "end": 709,
            "type": "code"
        },
        {
            "start": 710,
            "end": 720,
            "type": "code"
        },
        {
            "start": 721,
            "end": 752,
            "type": "code"
        },
        {
            "start": 753,
            "end": 775,
            "type": "code"
        },
        {
            "start": 776,
            "end": 783,
            "type": "code"
        },
        {
            "start": 784,
            "end": 796,
            "type": "code"
        },
        {
            "start": 798,
            "end": 811,
            "type": "code"
        },
        {
            "start": 812,
            "end": 818,
            "type": "code"
        },
        {
            "start": 819,
            "end": 832,
            "type": "code"
        },
        {
            "start": 833,
            "end": 841,
            "type": "code"
        },
        {
            "start": 842,
            "end": 846,
            "type": "code"
        },
        {
            "start": 847,
            "end": 867,
            "type": "code"
        },
        {
            "start": 868,
            "end": 870,
            "type": "code"
        },
        {
            "start": 871,
            "end": 897,
            "type": "code"
        },
        {
            "start": 898,
            "end": 904,
            "type": "code"
        },
        {
            "start": 905,
            "end": 924,
            "type": "code"
        },
        {
            "start": 925,
            "end": 945,
            "type": "code"
        },
        {
            "start": 946,
            "end": 948,
            "type": "code"
        },
        {
            "start": 949,
            "end": 981,
            "type": "code"
        },
        {
            "start": 982,
            "end": 1009,
            "type": "code"
        },
        {
            "start": 1010,
            "end": 1013,
            "type": "code"
        },
        {
            "start": 1014,
            "end": 1015,
            "type": "code"
        },
        {
            "start": 1016,
            "end": 1060,
            "type": "code"
        },
        {
            "start": 1061,
            "end": 1062,
            "type": "code"
        },
        {
            "start": 1063,
            "end": 1131,
            "type": "code"
        },
        {
            "start": 1132,
            "end": 1133,
            "type": "code"
        },
        {
            "start": 1134,
            "end": 1189,
            "type": "db"
        },
        {
            "start": 1194,
            "end": 1217,
            "type": "db"
        },
        {
            "start": 1218,
            "end": 1231,
            "type": "code"
        },
        {
            "start": 1232,
            "end": 1239,
            "type": "code"
        },
        {
            "start": 1240,
            "end": 1257,
            "type": "code"
        },
        {
            "start": 1258,
            "end": 1265,
            "type": "code"
        },
        {
            "start": 1266,
            "end": 1277,
            "type": "code"
        },
        {
            "start": 1278,
            "end": 1284,
            "type": "code"
        },
        {
            "start": 1285,
            "end": 1286,
            "type": "code"
        },
        {
            "start": 1287,
            "end": 1293,
            "type": "code"
        },
        {
            "start": 1294,
            "end": 1296,
            "type": "code"
        },
        {
            "start": 1297,
            "end": 1299,
            "type": "code"
        },
        {
            "start": 1300,
            "end": 1305,
            "type": "code"
        },
        {
            "start": 1306,
            "end": 1307,
            "type": "code"
        },
        {
            "start": 1308,
            "end": 1316,
            "type": "code"
        },
        {
            "start": 1317,
            "end": 1339,
            "type": "code"
        },
        {
            "start": 1340,
            "end": 1342,
            "type": "code"
        },
        {
            "start": 1343,
            "end": 1363,
            "type": "code"
        },
        {
            "start": 1364,
            "end": 1365,
            "type": "code"
        },
        {
            "start": 1366,
            "end": 1386,
            "type": "code"
        },
        {
            "start": 1387,
            "end": 1387,
            "type": "code"
        },
        {
            "start": 1388,
            "end": 1395,
            "type": "code"
        },
        {
            "start": 1396,
            "end": 1407,
            "type": "code"
        },
        {
            "start": 1408,
            "end": 1422,
            "type": "code"
        },
        {
            "start": 1423,
            "end": 1448,
            "type": "code"
        },
        {
            "start": 1449,
            "end": 1458,
            "type": "code"
        },
        {
            "start": 1459,
            "end": 1468,
            "type": "code"
        },
        {
            "start": 1469,
            "end": 1473,
            "type": "code"
        },
        {
            "start": 1474,
            "end": 1475,
            "type": "code"
        },
        {
            "start": 1476,
            "end": 1479,
            "type": "code"
        },
        {
            "start": 1480,
            "end": 1481,
            "type": "code"
        },
        {
            "start": 1482,
            "end": 1506,
            "type": "code"
        },
        {
            "start": 1507,
            "end": 1510,
            "type": "code"
        },
        {
            "start": 1511,
            "end": 1512,
            "type": "code"
        },
        {
            "start": 1513,
            "end": 1516,
            "type": "code"
        },
        {
            "start": 1517,
            "end": 1540,
            "type": "code"
        },
        {
            "start": 1541,
            "end": 1568,
            "type": "code"
        },
        {
            "start": 1569,
            "end": 1576,
            "type": "code"
        },
        {
            "start": 1577,
            "end": 1603,
            "type": "code"
        },
        {
            "start": 1604,
            "end": 1610,
            "type": "code"
        },
        {
            "start": 1611,
            "end": 1617,
            "type": "code"
        },
        {
            "start": 1618,
            "end": 1649,
            "type": "code"
        },
        {
            "start": 1650,
            "end": 1668,
            "type": "code"
        },
        {
            "start": 1669,
            "end": 1678,
            "type": "code"
        },
        {
            "start": 1679,
            "end": 1681,
            "type": "code"
        },
        {
            "start": 1682,
            "end": 1695,
            "type": "code"
        },
        {
            "start": 1696,
            "end": 1730,
            "type": "code"
        },
        {
            "start": 1731,
            "end": 1760,
            "type": "code"
        },
        {
            "start": 1761,
            "end": 1775,
            "type": "code"
        },
        {
            "start": 1776,
            "end": 1780,
            "type": "code"
        },
        {
            "start": 1781,
            "end": 1784,
            "type": "code"
        },
        {
            "start": 1785,
            "end": 1807,
            "type": "code"
        },
        {
            "start": 1808,
            "end": 1813,
            "type": "code"
        },
        {
            "start": 1814,
            "end": 1826,
            "type": "code"
        },
        {
            "start": 1827,
            "end": 1849,
            "type": "code"
        },
        {
            "start": 1850,
            "end": 1881,
            "type": "code"
        },
        {
            "start": 1882,
            "end": 1894,
            "type": "code"
        },
        {
            "start": 1895,
            "end": 1929,
            "type": "code"
        },
        {
            "start": 1930,
            "end": 1957,
            "type": "code"
        },
        {
            "start": 1958,
            "end": 1964,
            "type": "code"
        },
        {
            "start": 1965,
            "end": 1992,
            "type": "code"
        },
        {
            "start": 1995,
            "end": 2024,
            "type": "code"
        },
        {
            "start": 2025,
            "end": 2035,
            "type": "code"
        },
        {
            "start": 2036,
            "end": 2047,
            "type": "code"
        },
        {
            "start": 2048,
            "end": 2048,
            "type": "code"
        },
        {
            "start": 2050,
            "end": 2053,
            "type": "code"
        },
        {
            "start": 2054,
            "end": 2055,
            "type": "code"
        },
        {
            "start": 2056,
            "end": 2072,
            "type": "code"
        },
        {
            "start": 2073,
            "end": 2084,
            "type": "code"
        },
        {
            "start": 2085,
            "end": 2093,
            "type": "code"
        },
        {
            "start": 2094,
            "end": 2123,
            "type": "code"
        },
        {
            "start": 2124,
            "end": 2162,
            "type": "code"
        },
        {
            "start": 2163,
            "end": 2220,
            "type": "code"
        },
        {
            "start": 2221,
            "end": 2227,
            "type": "code"
        },
        {
            "start": 2230,
            "end": 2257,
            "type": "code"
        },
        {
            "start": 2258,
            "end": 2262,
            "type": "code"
        },
        {
            "start": 2263,
            "end": 2270,
            "type": "code"
        },
        {
            "start": 2271,
            "end": 2282,
            "type": "code"
        },
        {
            "start": 2283,
            "end": 2287,
            "type": "code"
        },
        {
            "start": 2288,
            "end": 2296,
            "type": "code"
        },
        {
            "start": 2297,
            "end": 2304,
            "type": "code"
        },
        {
            "start": 2305,
            "end": 2312,
            "type": "code"
        },
        {
            "start": 2313,
            "end": 2321,
            "type": "code"
        },
        {
            "start": 2322,
            "end": 2333,
            "type": "code"
        },
        {
            "start": 2334,
            "end": 2336,
            "type": "code"
        },
        {
            "start": 2337,
            "end": 2338,
            "type": "code"
        },
        {
            "start": 2339,
            "end": 2346,
            "type": "code"
        },
        {
            "start": 2348,
            "end": 2365,
            "type": "code"
        },
        {
            "start": 2366,
            "end": 2388,
            "type": "code"
        },
        {
            "start": 2389,
            "end": 2391,
            "type": "code"
        },
        {
            "start": 2392,
            "end": 2415,
            "type": "code"
        },
        {
            "start": 2416,
            "end": 2448,
            "type": "code"
        },
        {
            "start": 2449,
            "end": 2462,
            "type": "code"
        },
        {
            "start": 2465,
            "end": 2540,
            "type": "text"
        },
        {
            "start": 2548,
            "end": 2574,
            "type": "code"
        },
        {
            "start": 2577,
            "end": 2594,
            "type": "db"
        },
        {
            "start": 2595,
            "end": 2615,
            "type": "code"
        },
        {
            "start": 2616,
            "end": 2617,
            "type": "code"
        },
        {
            "start": 2618,
            "end": 2618,
            "type": "code"
        },
        {
            "start": 2621,
            "end": 2638,
            "type": "code"
        },
        {
            "start": 2639,
            "end": 2652,
            "type": "code"
        },
        {
            "start": 2655,
            "end": 2663,
            "type": "code"
        },
        {
            "start": 2665,
            "end": 2667,
            "type": "code"
        },
        {
            "start": 2669,
            "end": 2676,
            "type": "code"
        },
        {
            "start": 2677,
            "end": 2681,
            "type": "code"
        },
        {
            "start": 2682,
            "end": 2684,
            "type": "code"
        },
        {
            "start": 2685,
            "end": 2687,
            "type": "code"
        },
        {
            "start": 2688,
            "end": 2731,
            "type": "code"
        },
        {
            "start": 2732,
            "end": 2750,
            "type": "code"
        },
        {
            "start": 2751,
            "end": 2753,
            "type": "code"
        },
        {
            "start": 2754,
            "end": 2754,
            "type": "code"
        },
        {
            "start": 2755,
            "end": 2767,
            "type": "code"
        },
        {
            "start": 2768,
            "end": 2776,
            "type": "code"
        },
        {
            "start": 2777,
            "end": 2777,
            "type": "code"
        },
        {
            "start": 2780,
            "end": 2799,
            "type": "code"
        },
        {
            "start": 2800,
            "end": 2811,
            "type": "code"
        },
        {
            "start": 2812,
            "end": 2818,
            "type": "code"
        },
        {
            "start": 2819,
            "end": 2844,
            "type": "code"
        },
        {
            "start": 2845,
            "end": 2851,
            "type": "code"
        },
        {
            "start": 2852,
            "end": 2871,
            "type": "code"
        },
        {
            "start": 2872,
            "end": 2877,
            "type": "code"
        },
        {
            "start": 2878,
            "end": 2891,
            "type": "code"
        },
        {
            "start": 2892,
            "end": 2897,
            "type": "code"
        },
        {
            "start": 2898,
            "end": 2910,
            "type": "code"
        },
        {
            "start": 2911,
            "end": 2916,
            "type": "code"
        },
        {
            "start": 2917,
            "end": 2921,
            "type": "code"
        },
        {
            "start": 2922,
            "end": 2933,
            "type": "code"
        },
        {
            "start": 2934,
            "end": 2942,
            "type": "code"
        },
        {
            "start": 2943,
            "end": 2962,
            "type": "code"
        },
        {
            "start": 2963,
            "end": 2979,
            "type": "code"
        },
        {
            "start": 2980,
            "end": 2997,
            "type": "code"
        },
        {
            "start": 2998,
            "end": 2998,
            "type": "code"
        },
        {
            "start": 2999,
            "end": 3008,
            "type": "code"
        },
        {
            "start": 3009,
            "end": 3026,
            "type": "code"
        },
        {
            "start": 3027,
            "end": 3033,
            "type": "code"
        },
        {
            "start": 3035,
            "end": 3065,
            "type": "code"
        },
        {
            "start": 3066,
            "end": 3079,
            "type": "code"
        },
        {
            "start": 3080,
            "end": 3081,
            "type": "code"
        },
        {
            "start": 3082,
            "end": 3087,
            "type": "code"
        },
        {
            "start": 3088,
            "end": 3091,
            "type": "code"
        },
        {
            "start": 3092,
            "end": 3105,
            "type": "code"
        },
        {
            "start": 3106,
            "end": 3124,
            "type": "code"
        },
        {
            "start": 3125,
            "end": 3129,
            "type": "code"
        },
        {
            "start": 3131,
            "end": 3136,
            "type": "code"
        },
        {
            "start": 3137,
            "end": 3139,
            "type": "code"
        },
        {
            "start": 3140,
            "end": 3156,
            "type": "code"
        },
        {
            "start": 3157,
            "end": 3205,
            "type": "code"
        },
        {
            "start": 3206,
            "end": 3207,
            "type": "code"
        },
        {
            "start": 3208,
            "end": 3281,
            "type": "code"
        },
        {
            "start": 3282,
            "end": 3311,
            "type": "code"
        },
        {
            "start": 3312,
            "end": 3327,
            "type": "code"
        },
        {
            "start": 3328,
            "end": 3329,
            "type": "code"
        },
        {
            "start": 3330,
            "end": 3355,
            "type": "code"
        },
        {
            "start": 3356,
            "end": 3372,
            "type": "code"
        },
        {
            "start": 3373,
            "end": 3404,
            "type": "code"
        },
        {
            "start": 3405,
            "end": 3418,
            "type": "code"
        },
        {
            "start": 3419,
            "end": 3428,
            "type": "code"
        },
        {
            "start": 3429,
            "end": 3434,
            "type": "code"
        },
        {
            "start": 3435,
            "end": 3437,
            "type": "code"
        },
        {
            "start": 3438,
            "end": 3462,
            "type": "code"
        },
        {
            "start": 3463,
            "end": 3464,
            "type": "code"
        },
        {
            "start": 3465,
            "end": 3469,
            "type": "code"
        },
        {
            "start": 3470,
            "end": 3475,
            "type": "code"
        },
        {
            "start": 3476,
            "end": 3487,
            "type": "code"
        },
        {
            "start": 3488,
            "end": 3501,
            "type": "code"
        },
        {
            "start": 3503,
            "end": 3542,
            "type": "code"
        },
        {
            "start": 3545,
            "end": 3565,
            "type": "code"
        },
        {
            "start": 3566,
            "end": 3571,
            "type": "code"
        },
        {
            "start": 3572,
            "end": 3579,
            "type": "code"
        },
        {
            "start": 3582,
            "end": 3583,
            "type": "code"
        },
        {
            "start": 3584,
            "end": 3588,
            "type": "code"
        },
        {
            "start": 3589,
            "end": 3596,
            "type": "code"
        },
        {
            "start": 3597,
            "end": 3608,
            "type": "code"
        },
        {
            "start": 3609,
            "end": 3650,
            "type": "code"
        },
        {
            "start": 3652,
            "end": 3657,
            "type": "code"
        },
        {
            "start": 3658,
            "end": 3660,
            "type": "code"
        },
        {
            "start": 3661,
            "end": 3711,
            "type": "code"
        },
        {
            "start": 3712,
            "end": 3719,
            "type": "code"
        },
        {
            "start": 3720,
            "end": 3738,
            "type": "code"
        },
        {
            "start": 3739,
            "end": 3755,
            "type": "code"
        },
        {
            "start": 3756,
            "end": 3761,
            "type": "code"
        },
        {
            "start": 3762,
            "end": 3784,
            "type": "code"
        },
        {
            "start": 3785,
            "end": 3787,
            "type": "code"
        },
        {
            "start": 3789,
            "end": 3794,
            "type": "code"
        },
        {
            "start": 3795,
            "end": 3801,
            "type": "code"
        },
        {
            "start": 3802,
            "end": 3806,
            "type": "code"
        },
        {
            "start": 3807,
            "end": 3814,
            "type": "code"
        },
        {
            "start": 3815,
            "end": 3825,
            "type": "code"
        },
        {
            "start": 3828,
            "end": 3836,
            "type": "code"
        },
        {
            "start": 3837,
            "end": 3851,
            "type": "code"
        },
        {
            "start": 3852,
            "end": 3859,
            "type": "code"
        },
        {
            "start": 3860,
            "end": 3863,
            "type": "code"
        },
        {
            "start": 3864,
            "end": 3869,
            "type": "code"
        },
        {
            "start": 3870,
            "end": 3883,
            "type": "code"
        },
        {
            "start": 3884,
            "end": 3887,
            "type": "code"
        },
        {
            "start": 3888,
            "end": 3947,
            "type": "code"
        },
        {
            "start": 3948,
            "end": 3968,
            "type": "code"
        },
        {
            "start": 3969,
            "end": 3978,
            "type": "code"
        },
        {
            "start": 3979,
            "end": 3985,
            "type": "code"
        },
        {
            "start": 3986,
            "end": 3999,
            "type": "code"
        },
        {
            "start": 4000,
            "end": 4008,
            "type": "db"
        },
        {
            "start": 4009,
            "end": 4082,
            "type": "code"
        },
        {
            "start": 4083,
            "end": 4096,
            "type": "code"
        },
        {
            "start": 4097,
            "end": 4101,
            "type": "code"
        },
        {
            "start": 4103,
            "end": 4106,
            "type": "code"
        },
        {
            "start": 4108,
            "end": 4112,
            "type": "code"
        },
        {
            "start": 4113,
            "end": 4116,
            "type": "code"
        },
        {
            "start": 4117,
            "end": 4123,
            "type": "code"
        },
        {
            "start": 4126,
            "end": 4129,
            "type": "code"
        },
        {
            "start": 4132,
            "end": 4133,
            "type": "code"
        },
        {
            "start": 4134,
            "end": 4144,
            "type": "code"
        },
        {
            "start": 4145,
            "end": 4157,
            "type": "code"
        },
        {
            "start": 4158,
            "end": 4176,
            "type": "code"
        },
        {
            "start": 4177,
            "end": 4184,
            "type": "code"
        },
        {
            "start": 4185,
            "end": 4205,
            "type": "code"
        },
        {
            "start": 4206,
            "end": 4211,
            "type": "code"
        },
        {
            "start": 4214,
            "end": 4220,
            "type": "code"
        },
        {
            "start": 4223,
            "end": 4244,
            "type": "code"
        },
        {
            "start": 4247,
            "end": 4263,
            "type": "code"
        },
        {
            "start": 4264,
            "end": 4314,
            "type": "code"
        },
        {
            "start": 4315,
            "end": 4325,
            "type": "code"
        },
        {
            "start": 4326,
            "end": 4339,
            "type": "code"
        },
        {
            "start": 4340,
            "end": 4345,
            "type": "code"
        },
        {
            "start": 4346,
            "end": 4356,
            "type": "code"
        },
        {
            "start": 4357,
            "end": 4370,
            "type": "code"
        },
        {
            "start": 4371,
            "end": 4378,
            "type": "code"
        },
        {
            "start": 4379,
            "end": 4380,
            "type": "code"
        },
        {
            "start": 4381,
            "end": 4431,
            "type": "code"
        },
        {
            "start": 4432,
            "end": 4445,
            "type": "code"
        },
        {
            "start": 4446,
            "end": 4475,
            "type": "code"
        },
        {
            "start": 4476,
            "end": 4477,
            "type": "code"
        },
        {
            "start": 4478,
            "end": 4495,
            "type": "code"
        },
        {
            "start": 4496,
            "end": 4500,
            "type": "code"
        },
        {
            "start": 4501,
            "end": 4518,
            "type": "code"
        },
        {
            "start": 4519,
            "end": 4534,
            "type": "code"
        },
        {
            "start": 4535,
            "end": 4554,
            "type": "code"
        },
        {
            "start": 4555,
            "end": 4571,
            "type": "code"
        },
        {
            "start": 4572,
            "end": 4577,
            "type": "code"
        },
        {
            "start": 4578,
            "end": 4590,
            "type": "code"
        },
        {
            "start": 4591,
            "end": 4632,
            "type": "code"
        },
        {
            "start": 4633,
            "end": 4768,
            "type": "code"
        },
        {
            "start": 4770,
            "end": 4776,
            "type": "code"
        },
        {
            "start": 4777,
            "end": 4779,
            "type": "code"
        },
        {
            "start": 4780,
            "end": 4814,
            "type": "code"
        },
        {
            "start": 4815,
            "end": 4866,
            "type": "code"
        },
        {
            "start": 4867,
            "end": 4882,
            "type": "code"
        },
        {
            "start": 4883,
            "end": 4923,
            "type": "code"
        },
        {
            "start": 4924,
            "end": 4978,
            "type": "code"
        },
        {
            "start": 4979,
            "end": 4981,
            "type": "code"
        },
        {
            "start": 4982,
            "end": 4995,
            "type": "code"
        },
        {
            "start": 4996,
            "end": 4997,
            "type": "code"
        },
        {
            "start": 4998,
            "end": 5006,
            "type": "code"
        },
        {
            "start": 5009,
            "end": 5431,
            "type": "text"
        },
        {
            "start": 5433,
            "end": 5433,
            "type": "text"
        },
        {
            "start": 5461,
            "end": 5466,
            "type": "code"
        },
        {
            "start": 5469,
            "end": 5500,
            "type": "code"
        },
        {
            "start": 5501,
            "end": 5546,
            "type": "code"
        },
        {
            "start": 5547,
            "end": 5548,
            "type": "code"
        },
        {
            "start": 5551,
            "end": 5571,
            "type": "db"
        },
        {
            "start": 5572,
            "end": 5573,
            "type": "code"
        },
        {
            "start": 5574,
            "end": 5586,
            "type": "dw"
        },
        {
            "start": 5588,
            "end": 5597,
            "type": "code"
        },
        {
            "start": 5598,
            "end": 5605,
            "type": "code"
        },
        {
            "start": 5606,
            "end": 5613,
            "type": "code"
        },
        {
            "start": 5615,
            "end": 5617,
            "type": "code"
        },
        {
            "start": 5618,
            "end": 5622,
            "type": "code"
        },
        {
            "start": 5623,
            "end": 5632,
            "type": "code"
        },
        {
            "start": 5633,
            "end": 5645,
            "type": "code"
        },
        {
            "start": 5646,
            "end": 5647,
            "type": "code"
        },
        {
            "start": 5648,
            "end": 5652,
            "type": "code"
        },
        {
            "start": 5653,
            "end": 5675,
            "type": "code"
        },
        {
            "start": 5676,
            "end": 5676,
            "type": "code"
        },
        {
            "start": 5677,
            "end": 5683,
            "type": "db"
        },
        {
            "start": 5684,
            "end": 5696,
            "type": "code"
        },
        {
            "start": 5698,
            "end": 5701,
            "type": "code"
        },
        {
            "start": 5702,
            "end": 5706,
            "type": "code"
        },
        {
            "start": 5709,
            "end": 5713,
            "type": "code"
        },
        {
            "start": 5714,
            "end": 5716,
            "type": "code"
        },
        {
            "start": 5717,
            "end": 5731,
            "type": "code"
        },
        {
            "start": 5732,
            "end": 5738,
            "type": "code"
        },
        {
            "start": 5739,
            "end": 5758,
            "type": "code"
        },
        {
            "start": 5759,
            "end": 5774,
            "type": "code"
        },
        {
            "start": 5775,
            "end": 5776,
            "type": "code"
        },
        {
            "start": 5777,
            "end": 5780,
            "type": "code"
        },
        {
            "start": 5781,
            "end": 5789,
            "type": "code"
        },
        {
            "start": 5790,
            "end": 5807,
            "type": "code"
        },
        {
            "start": 5808,
            "end": 5822,
            "type": "code"
        },
        {
            "start": 5823,
            "end": 5828,
            "type": "code"
        },
        {
            "start": 5829,
            "end": 5843,
            "type": "code"
        },
        {
            "start": 5844,
            "end": 5848,
            "type": "db"
        },
        {
            "start": 5851,
            "end": 5851,
            "type": "code"
        },
        {
            "start": 5852,
            "end": 5860,
            "type": "code"
        },
        {
            "start": 5861,
            "end": 5883,
            "type": "code"
        },
        {
            "start": 5884,
            "end": 5888,
            "type": "code"
        },
        {
            "start": 5889,
            "end": 5909,
            "type": "code"
        },
        {
            "start": 5910,
            "end": 5914,
            "type": "db"
        },
        {
            "start": 5916,
            "end": 5917,
            "type": "code"
        },
        {
            "start": 5918,
            "end": 5924,
            "type": "code"
        },
        {
            "start": 5925,
            "end": 5926,
            "type": "code"
        },
        {
            "start": 5927,
            "end": 5941,
            "type": "code"
        },
        {
            "start": 5942,
            "end": 5973,
            "type": "code"
        },
        {
            "start": 5974,
            "end": 5980,
            "type": "code"
        },
        {
            "start": 5981,
            "end": 5988,
            "type": "code"
        },
        {
            "start": 5989,
            "end": 5990,
            "type": "code"
        },
        {
            "start": 5991,
            "end": 6009,
            "type": "code"
        },
        {
            "start": 6010,
            "end": 6016,
            "type": "db"
        },
        {
            "start": 6017,
            "end": 6019,
            "type": "code"
        },
        {
            "start": 6021,
            "end": 6023,
            "type": "code"
        },
        {
            "start": 6025,
            "end": 6026,
            "type": "code"
        },
        {
            "start": 6027,
            "end": 6034,
            "type": "code"
        },
        {
            "start": 6035,
            "end": 6035,
            "type": "code"
        },
        {
            "start": 6037,
            "end": 6093,
            "type": "code"
        },
        {
            "start": 6094,
            "end": 6112,
            "type": "code"
        },
        {
            "start": 6113,
            "end": 6115,
            "type": "code"
        },
        {
            "start": 6116,
            "end": 6124,
            "type": "code"
        },
        {
            "start": 6125,
            "end": 6132,
            "type": "code"
        },
        {
            "start": 6133,
            "end": 6135,
            "type": "code"
        },
        {
            "start": 6137,
            "end": 6138,
            "type": "code"
        },
        {
            "start": 6139,
            "end": 6163,
            "type": "code"
        },
        {
            "start": 6164,
            "end": 6169,
            "type": "code"
        },
        {
            "start": 6170,
            "end": 6174,
            "type": "code"
        },
        {
            "start": 6175,
            "end": 6177,
            "type": "code"
        },
        {
            "start": 6178,
            "end": 6194,
            "type": "code"
        },
        {
            "start": 6195,
            "end": 6196,
            "type": "code"
        },
        {
            "start": 6197,
            "end": 6227,
            "type": "code"
        },
        {
            "start": 6229,
            "end": 6244,
            "type": "code"
        },
        {
            "start": 6245,
            "end": 6268,
            "type": "code"
        },
        {
            "start": 6269,
            "end": 6272,
            "type": "code"
        },
        {
            "start": 6273,
            "end": 6291,
            "type": "code"
        },
        {
            "start": 6292,
            "end": 6304,
            "type": "code"
        },
        {
            "start": 6305,
            "end": 6323,
            "type": "code"
        },
        {
            "start": 6324,
            "end": 6325,
            "type": "code"
        },
        {
            "start": 6326,
            "end": 6336,
            "type": "code"
        },
        {
            "start": 6337,
            "end": 6368,
            "type": "code"
        },
        {
            "start": 6369,
            "end": 6386,
            "type": "code"
        },
        {
            "start": 6387,
            "end": 6408,
            "type": "code"
        },
        {
            "start": 6409,
            "end": 6414,
            "type": "code"
        },
        {
            "start": 6415,
            "end": 6427,
            "type": "code"
        },
        {
            "start": 6428,
            "end": 6436,
            "type": "code"
        },
        {
            "start": 6437,
            "end": 6441,
            "type": "code"
        },
        {
            "start": 6442,
            "end": 6442,
            "type": "code"
        },
        {
            "start": 6443,
            "end": 6454,
            "type": "code"
        },
        {
            "start": 6455,
            "end": 6489,
            "type": "code"
        },
        {
            "start": 6490,
            "end": 6503,
            "type": "code"
        },
        {
            "start": 6504,
            "end": 6507,
            "type": "code"
        },
        {
            "start": 6508,
            "end": 6509,
            "type": "code"
        },
        {
            "start": 6510,
            "end": 6515,
            "type": "code"
        },
        {
            "start": 6516,
            "end": 6526,
            "type": "code"
        },
        {
            "start": 6528,
            "end": 6535,
            "type": "code"
        },
        {
            "start": 6536,
            "end": 6538,
            "type": "db"
        },
        {
            "start": 6539,
            "end": 6543,
            "type": "code"
        },
        {
            "start": 6544,
            "end": 6551,
            "type": "code"
        },
        {
            "start": 6552,
            "end": 6553,
            "type": "code"
        },
        {
            "start": 6554,
            "end": 6564,
            "type": "code"
        },
        {
            "start": 6565,
            "end": 6572,
            "type": "code"
        },
        {
            "start": 6573,
            "end": 6576,
            "type": "code"
        },
        {
            "start": 6577,
            "end": 6583,
            "type": "code"
        },
        {
            "start": 6584,
            "end": 6598,
            "type": "code"
        },
        {
            "start": 6599,
            "end": 6605,
            "type": "code"
        },
        {
            "start": 6606,
            "end": 6612,
            "type": "code"
        },
        {
            "start": 6613,
            "end": 6613,
            "type": "code"
        },
        {
            "start": 6614,
            "end": 6618,
            "type": "code"
        },
        {
            "start": 6619,
            "end": 6620,
            "type": "code"
        },
        {
            "start": 6621,
            "end": 6628,
            "type": "code"
        },
        {
            "start": 6629,
            "end": 6631,
            "type": "code"
        },
        {
            "start": 6632,
            "end": 6650,
            "type": "code"
        },
        {
            "start": 6651,
            "end": 6676,
            "type": "code"
        },
        {
            "start": 6677,
            "end": 6680,
            "type": "code"
        },
        {
            "start": 6683,
            "end": 6695,
            "type": "code"
        },
        {
            "start": 6696,
            "end": 6703,
            "type": "code"
        },
        {
            "start": 6704,
            "end": 6721,
            "type": "code"
        },
        {
            "start": 6722,
            "end": 6727,
            "type": "code"
        },
        {
            "start": 6728,
            "end": 6933,
            "type": "db"
        },
        {
            "start": 6935,
            "end": 6950,
            "type": "code"
        },
        {
            "start": 6952,
            "end": 6952,
            "type": "code"
        },
        {
            "start": 6953,
            "end": 6996,
            "type": "code"
        },
        {
            "start": 6997,
            "end": 7022,
            "type": "code"
        },
        {
            "start": 7023,
            "end": 7029,
            "type": "code"
        },
        {
            "start": 7030,
            "end": 7036,
            "type": "code"
        },
        {
            "start": 7037,
            "end": 7048,
            "type": "code"
        },
        {
            "start": 7050,
            "end": 7068,
            "type": "code"
        },
        {
            "start": 7070,
            "end": 7089,
            "type": "code"
        },
        {
            "start": 7090,
            "end": 7090,
            "type": "code"
        },
        {
            "start": 7091,
            "end": 7102,
            "type": "code"
        },
        {
            "start": 7103,
            "end": 7120,
            "type": "code"
        },
        {
            "start": 7121,
            "end": 7147,
            "type": "code"
        },
        {
            "start": 7148,
            "end": 7149,
            "type": "code"
        },
        {
            "start": 7150,
            "end": 7155,
            "type": "code"
        },
        {
            "start": 7156,
            "end": 7166,
            "type": "code"
        },
        {
            "start": 7169,
            "end": 7180,
            "type": "db"
        },
        {
            "start": 7181,
            "end": 7183,
            "type": "code"
        },
        {
            "start": 7184,
            "end": 7184,
            "type": "code"
        },
        {
            "start": 7185,
            "end": 7198,
            "type": "code"
        },
        {
            "start": 7199,
            "end": 7199,
            "type": "code"
        },
        {
            "start": 7202,
            "end": 7213,
            "type": "code"
        },
        {
            "start": 7214,
            "end": 7215,
            "type": "code"
        },
        {
            "start": 7216,
            "end": 7237,
            "type": "code"
        },
        {
            "start": 7238,
            "end": 7245,
            "type": "code"
        },
        {
            "start": 7246,
            "end": 7253,
            "type": "code"
        },
        {
            "start": 7254,
            "end": 7256,
            "type": "code"
        },
        {
            "start": 7257,
            "end": 7275,
            "type": "code"
        },
        {
            "start": 7276,
            "end": 7287,
            "type": "code"
        },
        {
            "start": 7289,
            "end": 7289,
            "type": "code"
        },
        {
            "start": 7290,
            "end": 7297,
            "type": "code"
        },
        {
            "start": 7298,
            "end": 7305,
            "type": "code"
        },
        {
            "start": 7306,
            "end": 7307,
            "type": "code"
        },
        {
            "start": 7308,
            "end": 7316,
            "type": "code"
        },
        {
            "start": 7318,
            "end": 7357,
            "type": "code"
        },
        {
            "start": 7358,
            "end": 7381,
            "type": "code"
        },
        {
            "start": 7382,
            "end": 7385,
            "type": "code"
        },
        {
            "start": 7387,
            "end": 7387,
            "type": "code"
        },
        {
            "start": 7390,
            "end": 7397,
            "type": "code"
        },
        {
            "start": 7398,
            "end": 7405,
            "type": "code"
        },
        {
            "start": 7406,
            "end": 7407,
            "type": "code"
        },
        {
            "start": 7408,
            "end": 7423,
            "type": "code"
        },
        {
            "start": 7424,
            "end": 7424,
            "type": "code"
        },
        {
            "start": 7427,
            "end": 7439,
            "type": "code"
        },
        {
            "start": 7440,
            "end": 7445,
            "type": "code"
        },
        {
            "start": 7446,
            "end": 7475,
            "type": "code"
        },
        {
            "start": 7476,
            "end": 7523,
            "type": "code"
        },
        {
            "start": 7524,
            "end": 7547,
            "type": "code"
        },
        {
            "start": 7548,
            "end": 7555,
            "type": "code"
        },
        {
            "start": 7556,
            "end": 7557,
            "type": "code"
        },
        {
            "start": 7558,
            "end": 7562,
            "type": "code"
        },
        {
            "start": 7563,
            "end": 7586,
            "type": "code"
        },
        {
            "start": 7587,
            "end": 7593,
            "type": "code"
        },
        {
            "start": 7595,
            "end": 7639,
            "type": "code"
        },
        {
            "start": 7640,
            "end": 7641,
            "type": "code"
        },
        {
            "start": 7642,
            "end": 7659,
            "type": "code"
        },
        {
            "start": 7660,
            "end": 7660,
            "type": "code"
        },
        {
            "start": 7661,
            "end": 7689,
            "type": "code"
        },
        {
            "start": 7690,
            "end": 7709,
            "type": "code"
        },
        {
            "start": 7710,
            "end": 7718,
            "type": "code"
        },
        {
            "start": 7719,
            "end": 7723,
            "type": "code"
        },
        {
            "start": 7724,
            "end": 7734,
            "type": "code"
        },
        {
            "start": 7735,
            "end": 7735,
            "type": "code"
        },
        {
            "start": 7737,
            "end": 7743,
            "type": "code"
        },
        {
            "start": 7746,
            "end": 7748,
            "type": "code"
        },
        {
            "start": 7749,
            "end": 7758,
            "type": "code"
        },
        {
            "start": 7759,
            "end": 7769,
            "type": "code"
        },
        {
            "start": 7770,
            "end": 7774,
            "type": "code"
        },
        {
            "start": 7775,
            "end": 7781,
            "type": "code"
        },
        {
            "start": 7783,
            "end": 7794,
            "type": "code"
        },
        {
            "start": 7795,
            "end": 7801,
            "type": "code"
        },
        {
            "start": 7802,
            "end": 7807,
            "type": "code"
        },
        {
            "start": 7808,
            "end": 7812,
            "type": "code"
        },
        {
            "start": 7813,
            "end": 7821,
            "type": "code"
        },
        {
            "start": 7822,
            "end": 7827,
            "type": "code"
        },
        {
            "start": 7828,
            "end": 7832,
            "type": "code"
        },
        {
            "start": 7833,
            "end": 7835,
            "type": "code"
        },
        {
            "start": 7836,
            "end": 7838,
            "type": "code"
        },
        {
            "start": 7839,
            "end": 7840,
            "type": "code"
        },
        {
            "start": 7841,
            "end": 7850,
            "type": "code"
        },
        {
            "start": 7852,
            "end": 7854,
            "type": "code"
        },
        {
            "start": 7855,
            "end": 7862,
            "type": "code"
        },
        {
            "start": 7863,
            "end": 7897,
            "type": "code"
        },
        {
            "start": 7898,
            "end": 7899,
            "type": "code"
        },
        {
            "start": 7900,
            "end": 7916,
            "type": "code"
        },
        {
            "start": 7917,
            "end": 7938,
            "type": "code"
        },
        {
            "start": 7941,
            "end": 7956,
            "type": "code"
        },
        {
            "start": 7957,
            "end": 7959,
            "type": "code"
        },
        {
            "start": 7962,
            "end": 7970,
            "type": "db"
        },
        {
            "start": 7971,
            "end": 7989,
            "type": "code"
        },
        {
            "start": 7990,
            "end": 7993,
            "type": "code"
        },
        {
            "start": 7994,
            "end": 7996,
            "type": "code"
        },
        {
            "start": 7997,
            "end": 8008,
            "type": "code"
        },
        {
            "start": 8009,
            "end": 8014,
            "type": "code"
        },
        {
            "start": 8015,
            "end": 8019,
            "type": "code"
        },
        {
            "start": 8020,
            "end": 8031,
            "type": "code"
        },
        {
            "start": 8032,
            "end": 8041,
            "type": "code"
        },
        {
            "start": 8042,
            "end": 8060,
            "type": "code"
        },
        {
            "start": 8061,
            "end": 8069,
            "type": "code"
        },
        {
            "start": 8070,
            "end": 8072,
            "type": "code"
        },
        {
            "start": 8073,
            "end": 8083,
            "type": "code"
        },
        {
            "start": 8084,
            "end": 8101,
            "type": "code"
        },
        {
            "start": 8102,
            "end": 8124,
            "type": "code"
        },
        {
            "start": 8125,
            "end": 8128,
            "type": "code"
        },
        {
            "start": 8131,
            "end": 8136,
            "type": "code"
        },
        {
            "start": 8137,
            "end": 8140,
            "type": "code"
        },
        {
            "start": 8141,
            "end": 8142,
            "type": "code"
        },
        {
            "start": 8143,
            "end": 8158,
            "type": "code"
        },
        {
            "start": 8159,
            "end": 8164,
            "type": "code"
        },
        {
            "start": 8165,
            "end": 8177,
            "type": "code"
        },
        {
            "start": 8178,
            "end": 8180,
            "type": "code"
        },
        {
            "start": 8181,
            "end": 8187,
            "type": "code"
        },
        {
            "start": 8188,
            "end": 8205,
            "type": "code"
        },
        {
            "start": 8206,
            "end": 8221,
            "type": "code"
        },
        {
            "start": 8222,
            "end": 8227,
            "type": "code"
        },
        {
            "start": 8228,
            "end": 8251,
            "type": "code"
        },
        {
            "start": 8252,
            "end": 8259,
            "type": "code"
        },
        {
            "start": 8261,
            "end": 8263,
            "type": "code"
        },
        {
            "start": 8264,
            "end": 8269,
            "type": "code"
        },
        {
            "start": 8270,
            "end": 8288,
            "type": "code"
        },
        {
            "start": 8289,
            "end": 8294,
            "type": "code"
        },
        {
            "start": 8295,
            "end": 8301,
            "type": "code"
        },
        {
            "start": 8302,
            "end": 8303,
            "type": "code"
        },
        {
            "start": 8304,
            "end": 8328,
            "type": "code"
        },
        {
            "start": 8329,
            "end": 8341,
            "type": "code"
        },
        {
            "start": 8342,
            "end": 8364,
            "type": "code"
        },
        {
            "start": 8365,
            "end": 8384,
            "type": "code"
        },
        {
            "start": 8385,
            "end": 8407,
            "type": "code"
        },
        {
            "start": 8408,
            "end": 8428,
            "type": "code"
        },
        {
            "start": 8429,
            "end": 8441,
            "type": "code"
        },
        {
            "start": 8442,
            "end": 8473,
            "type": "code"
        },
        {
            "start": 8474,
            "end": 8475,
            "type": "code"
        },
        {
            "start": 8476,
            "end": 8488,
            "type": "code"
        },
        {
            "start": 8489,
            "end": 8519,
            "type": "code"
        },
        {
            "start": 8520,
            "end": 8541,
            "type": "code"
        },
        {
            "start": 8542,
            "end": 8544,
            "type": "code"
        },
        {
            "start": 8545,
            "end": 8563,
            "type": "code"
        },
        {
            "start": 8564,
            "end": 8602,
            "type": "code"
        },
        {
            "start": 8603,
            "end": 8622,
            "type": "code"
        },
        {
            "start": 8623,
            "end": 8625,
            "type": "code"
        },
        {
            "start": 8626,
            "end": 8632,
            "type": "code"
        },
        {
            "start": 8633,
            "end": 8655,
            "type": "code"
        },
        {
            "start": 8656,
            "end": 8661,
            "type": "code"
        },
        {
            "start": 8662,
            "end": 8672,
            "type": "code"
        },
        {
            "start": 8673,
            "end": 8673,
            "type": "code"
        },
        {
            "start": 8674,
            "end": 8689,
            "type": "code"
        },
        {
            "start": 8690,
            "end": 8699,
            "type": "code"
        },
        {
            "start": 8700,
            "end": 8720,
            "type": "code"
        },
        {
            "start": 8721,
            "end": 8743,
            "type": "code"
        },
        {
            "start": 8744,
            "end": 8755,
            "type": "code"
        },
        {
            "start": 8756,
            "end": 8765,
            "type": "code"
        },
        {
            "start": 8766,
            "end": 8771,
            "type": "code"
        },
        {
            "start": 8772,
            "end": 8773,
            "type": "code"
        },
        {
            "start": 8774,
            "end": 8790,
            "type": "code"
        },
        {
            "start": 8791,
            "end": 8791,
            "type": "code"
        },
        {
            "start": 8792,
            "end": 8811,
            "type": "code"
        },
        {
            "start": 8812,
            "end": 8818,
            "type": "code"
        },
        {
            "start": 8819,
            "end": 8828,
            "type": "code"
        },
        {
            "start": 8829,
            "end": 8838,
            "type": "code"
        },
        {
            "start": 8839,
            "end": 8850,
            "type": "code"
        },
        {
            "start": 8852,
            "end": 8869,
            "type": "code"
        },
        {
            "start": 8870,
            "end": 8873,
            "type": "code"
        },
        {
            "start": 8874,
            "end": 8906,
            "type": "code"
        },
        {
            "start": 8907,
            "end": 8915,
            "type": "code"
        },
        {
            "start": 8916,
            "end": 8921,
            "type": "code"
        },
        {
            "start": 8924,
            "end": 8932,
            "type": "code"
        },
        {
            "start": 8933,
            "end": 8943,
            "type": "code"
        },
        {
            "start": 8944,
            "end": 8956,
            "type": "code"
        },
        {
            "start": 8957,
            "end": 8962,
            "type": "code"
        },
        {
            "start": 8963,
            "end": 8964,
            "type": "code"
        },
        {
            "start": 8967,
            "end": 8979,
            "type": "code"
        },
        {
            "start": 8980,
            "end": 8991,
            "type": "code"
        },
        {
            "start": 8992,
            "end": 9018,
            "type": "code"
        },
        {
            "start": 9019,
            "end": 9049,
            "type": "code"
        },
        {
            "start": 9050,
            "end": 9087,
            "type": "code"
        },
        {
            "start": 9090,
            "end": 9100,
            "type": "code"
        },
        {
            "start": 9101,
            "end": 9152,
            "type": "code"
        },
        {
            "start": 9153,
            "end": 9247,
            "type": "code"
        },
        {
            "start": 9248,
            "end": 9252,
            "type": "code"
        },
        {
            "start": 9253,
            "end": 9272,
            "type": "code"
        },
        {
            "start": 9273,
            "end": 9310,
            "type": "code"
        },
        {
            "start": 9311,
            "end": 9334,
            "type": "code"
        },
        {
            "start": 9335,
            "end": 9338,
            "type": "code"
        },
        {
            "start": 9341,
            "end": 9364,
            "type": "code"
        },
        {
            "start": 9365,
            "end": 9366,
            "type": "code"
        },
        {
            "start": 9367,
            "end": 9398,
            "type": "code"
        },
        {
            "start": 9399,
            "end": 9411,
            "type": "code"
        },
        {
            "start": 9412,
            "end": 9418,
            "type": "code"
        },
        {
            "start": 9419,
            "end": 9421,
            "type": "code"
        },
        {
            "start": 9422,
            "end": 9427,
            "type": "code"
        },
        {
            "start": 9428,
            "end": 9434,
            "type": "code"
        },
        {
            "start": 9435,
            "end": 9438,
            "type": "code"
        },
        {
            "start": 9439,
            "end": 9451,
            "type": "code"
        },
        {
            "start": 9452,
            "end": 9462,
            "type": "code"
        },
        {
            "start": 9463,
            "end": 9464,
            "type": "code"
        },
        {
            "start": 9465,
            "end": 9466,
            "type": "code"
        },
        {
            "start": 9467,
            "end": 9470,
            "type": "code"
        },
        {
            "start": 9471,
            "end": 9486,
            "type": "code"
        },
        {
            "start": 9487,
            "end": 9505,
            "type": "code"
        },
        {
            "start": 9506,
            "end": 9516,
            "type": "code"
        },
        {
            "start": 9517,
            "end": 9517,
            "type": "code"
        },
        {
            "start": 9520,
            "end": 9524,
            "type": "code"
        },
        {
            "start": 9525,
            "end": 9550,
            "type": "code"
        },
        {
            "start": 9551,
            "end": 9561,
            "type": "code"
        },
        {
            "start": 9562,
            "end": 9564,
            "type": "code"
        },
        {
            "start": 9565,
            "end": 9586,
            "type": "code"
        },
        {
            "start": 9587,
            "end": 9596,
            "type": "code"
        },
        {
            "start": 9597,
            "end": 9597,
            "type": "code"
        },
        {
            "start": 9600,
            "end": 9619,
            "type": "code"
        },
        {
            "start": 9622,
            "end": 9646,
            "type": "db"
        },
        {
            "start": 9647,
            "end": 9648,
            "type": "code"
        },
        {
            "start": 9651,
            "end": 9661,
            "type": "code"
        },
        {
            "start": 9662,
            "end": 9674,
            "type": "code"
        },
        {
            "start": 9675,
            "end": 9688,
            "type": "code"
        },
        {
            "start": 9689,
            "end": 9690,
            "type": "code"
        },
        {
            "start": 9691,
            "end": 9701,
            "type": "code"
        },
        {
            "start": 9704,
            "end": 9714,
            "type": "code"
        },
        {
            "start": 9717,
            "end": 9717,
            "type": "code"
        },
        {
            "start": 9720,
            "end": 9764,
            "type": "code"
        },
        {
            "start": 9765,
            "end": 9765,
            "type": "code"
        },
        {
            "start": 9767,
            "end": 9775,
            "type": "code"
        },
        {
            "start": 9776,
            "end": 9777,
            "type": "code"
        },
        {
            "start": 9780,
            "end": 9823,
            "type": "code"
        },
        {
            "start": 9824,
            "end": 9828,
            "type": "code"
        },
        {
            "start": 9829,
            "end": 9829,
            "type": "code"
        },
        {
            "start": 9832,
            "end": 9839,
            "type": "code"
        },
        {
            "start": 9842,
            "end": 9849,
            "type": "code"
        },
        {
            "start": 9851,
            "end": 9858,
            "type": "code"
        },
        {
            "start": 9860,
            "end": 9867,
            "type": "code"
        },
        {
            "start": 9869,
            "end": 9908,
            "type": "code"
        },
        {
            "start": 9909,
            "end": 9909,
            "type": "code"
        },
        {
            "start": 9910,
            "end": 9922,
            "type": "code"
        },
        {
            "start": 9923,
            "end": 9927,
            "type": "code"
        },
        {
            "start": 9929,
            "end": 9948,
            "type": "code"
        },
        {
            "start": 9949,
            "end": 9950,
            "type": "code"
        },
        {
            "start": 9951,
            "end": 9990,
            "type": "code"
        },
        {
            "start": 9991,
            "end": 9996,
            "type": "code"
        },
        {
            "start": 9997,
            "end": 10001,
            "type": "code"
        },
        {
            "start": 10002,
            "end": 10002,
            "type": "code"
        },
        {
            "start": 10003,
            "end": 10018,
            "type": "code"
        },
        {
            "start": 10019,
            "end": 10035,
            "type": "code"
        },
        {
            "start": 10036,
            "end": 10059,
            "type": "code"
        },
        {
            "start": 10060,
            "end": 10074,
            "type": "code"
        },
        {
            "start": 10075,
            "end": 10080,
            "type": "code"
        },
        {
            "start": 10081,
            "end": 10083,
            "type": "code"
        },
        {
            "start": 10084,
            "end": 10095,
            "type": "code"
        },
        {
            "start": 10096,
            "end": 10098,
            "type": "code"
        },
        {
            "start": 10099,
            "end": 10119,
            "type": "code"
        },
        {
            "start": 10120,
            "end": 10127,
            "type": "code"
        },
        {
            "start": 10128,
            "end": 10130,
            "type": "code"
        },
        {
            "start": 10133,
            "end": 10159,
            "type": "db"
        },
        {
            "start": 10160,
            "end": 10172,
            "type": "db"
        },
        {
            "start": 10173,
            "end": 10191,
            "type": "code"
        },
        {
            "start": 10192,
            "end": 10200,
            "type": "code"
        },
        {
            "start": 10201,
            "end": 10211,
            "type": "code"
        },
        {
            "start": 10212,
            "end": 10213,
            "type": "code"
        },
        {
            "start": 10214,
            "end": 10216,
            "type": "code"
        },
        {
            "start": 10217,
            "end": 10227,
            "type": "code"
        },
        {
            "start": 10228,
            "end": 10230,
            "type": "code"
        },
        {
            "start": 10231,
            "end": 10241,
            "type": "code"
        },
        {
            "start": 10242,
            "end": 10247,
            "type": "code"
        },
        {
            "start": 10248,
            "end": 10259,
            "type": "code"
        },
        {
            "start": 10260,
            "end": 10276,
            "type": "code"
        },
        {
            "start": 10277,
            "end": 10288,
            "type": "code"
        },
        {
            "start": 10289,
            "end": 10306,
            "type": "code"
        },
        {
            "start": 10307,
            "end": 10321,
            "type": "code"
        },
        {
            "start": 10322,
            "end": 10372,
            "type": "code"
        },
        {
            "start": 10373,
            "end": 10378,
            "type": "code"
        },
        {
            "start": 10379,
            "end": 10380,
            "type": "code"
        },
        {
            "start": 10381,
            "end": 10408,
            "type": "code"
        },
        {
            "start": 10411,
            "end": 10417,
            "type": "code"
        },
        {
            "start": 10418,
            "end": 10451,
            "type": "code"
        },
        {
            "start": 10452,
            "end": 10461,
            "type": "code"
        },
        {
            "start": 10462,
            "end": 10466,
            "type": "code"
        },
        {
            "start": 10467,
            "end": 10478,
            "type": "code"
        },
        {
            "start": 10479,
            "end": 10492,
            "type": "code"
        },
        {
            "start": 10493,
            "end": 10495,
            "type": "code"
        },
        {
            "start": 10496,
            "end": 10513,
            "type": "code"
        },
        {
            "start": 10514,
            "end": 10514,
            "type": "code"
        },
        {
            "start": 10515,
            "end": 10536,
            "type": "code"
        },
        {
            "start": 10537,
            "end": 10537,
            "type": "code"
        },
        {
            "start": 10538,
            "end": 10545,
            "type": "code"
        },
        {
            "start": 10546,
            "end": 10547,
            "type": "code"
        },
        {
            "start": 10548,
            "end": 10557,
            "type": "code"
        },
        {
            "start": 10558,
            "end": 10558,
            "type": "code"
        },
        {
            "start": 10559,
            "end": 10562,
            "type": "code"
        },
        {
            "start": 10563,
            "end": 10570,
            "type": "code"
        },
        {
            "start": 10571,
            "end": 10576,
            "type": "code"
        },
        {
            "start": 10577,
            "end": 10585,
            "type": "code"
        },
        {
            "start": 10586,
            "end": 10602,
            "type": "code"
        },
        {
            "start": 10603,
            "end": 10624,
            "type": "code"
        },
        {
            "start": 10625,
            "end": 10640,
            "type": "code"
        },
        {
            "start": 10641,
            "end": 10645,
            "type": "code"
        },
        {
            "start": 10646,
            "end": 10656,
            "type": "code"
        },
        {
            "start": 10657,
            "end": 10669,
            "type": "code"
        },
        {
            "start": 10670,
            "end": 10687,
            "type": "code"
        },
        {
            "start": 10688,
            "end": 10690,
            "type": "code"
        },
        {
            "start": 10691,
            "end": 10711,
            "type": "code"
        },
        {
            "start": 10712,
            "end": 10719,
            "type": "code"
        },
        {
            "start": 10720,
            "end": 10726,
            "type": "code"
        },
        {
            "start": 10727,
            "end": 10729,
            "type": "code"
        },
        {
            "start": 10730,
            "end": 10746,
            "type": "code"
        },
        {
            "start": 10747,
            "end": 10769,
            "type": "code"
        },
        {
            "start": 10770,
            "end": 10783,
            "type": "code"
        },
        {
            "start": 10784,
            "end": 10785,
            "type": "code"
        },
        {
            "start": 10786,
            "end": 10795,
            "type": "code"
        },
        {
            "start": 10796,
            "end": 10820,
            "type": "code"
        },
        {
            "start": 10821,
            "end": 10823,
            "type": "code"
        },
        {
            "start": 10824,
            "end": 10824,
            "type": "code"
        },
        {
            "start": 10825,
            "end": 10833,
            "type": "code"
        },
        {
            "start": 10834,
            "end": 10873,
            "type": "code"
        },
        {
            "start": 10874,
            "end": 10880,
            "type": "code"
        },
        {
            "start": 10881,
            "end": 10899,
            "type": "code"
        },
        {
            "start": 10900,
            "end": 10919,
            "type": "code"
        },
        {
            "start": 10920,
            "end": 10924,
            "type": "code"
        },
        {
            "start": 10925,
            "end": 10928,
            "type": "code"
        },
        {
            "start": 10929,
            "end": 10929,
            "type": "code"
        },
        {
            "start": 10930,
            "end": 10933,
            "type": "code"
        },
        {
            "start": 10934,
            "end": 10955,
            "type": "code"
        },
        {
            "start": 10956,
            "end": 10956,
            "type": "code"
        },
        {
            "start": 10957,
            "end": 10983,
            "type": "code"
        },
        {
            "start": 10984,
            "end": 10986,
            "type": "code"
        },
        {
            "start": 10987,
            "end": 10989,
            "type": "code"
        },
        {
            "start": 10990,
            "end": 10995,
            "type": "code"
        },
        {
            "start": 10996,
            "end": 11006,
            "type": "code"
        },
        {
            "start": 11007,
            "end": 11018,
            "type": "code"
        },
        {
            "start": 11019,
            "end": 11019,
            "type": "code"
        },
        {
            "start": 11020,
            "end": 11038,
            "type": "code"
        },
        {
            "start": 11039,
            "end": 11048,
            "type": "code"
        },
        {
            "start": 11049,
            "end": 11069,
            "type": "code"
        },
        {
            "start": 11070,
            "end": 11086,
            "type": "code"
        },
        {
            "start": 11087,
            "end": 11096,
            "type": "code"
        },
        {
            "start": 11097,
            "end": 11109,
            "type": "code"
        },
        {
            "start": 11110,
            "end": 11121,
            "type": "code"
        },
        {
            "start": 11122,
            "end": 11162,
            "type": "code"
        },
        {
            "start": 11163,
            "end": 11170,
            "type": "code"
        },
        {
            "start": 11171,
            "end": 11173,
            "type": "code"
        },
        {
            "start": 11174,
            "end": 11182,
            "type": "code"
        },
        {
            "start": 11183,
            "end": 11199,
            "type": "code"
        },
        {
            "start": 11200,
            "end": 11205,
            "type": "code"
        },
        {
            "start": 11206,
            "end": 11241,
            "type": "code"
        },
        {
            "start": 11242,
            "end": 11248,
            "type": "code"
        },
        {
            "start": 11249,
            "end": 11265,
            "type": "code"
        },
        {
            "start": 11266,
            "end": 11268,
            "type": "code"
        },
        {
            "start": 11269,
            "end": 11284,
            "type": "code"
        },
        {
            "start": 11285,
            "end": 11294,
            "type": "code"
        },
        {
            "start": 11295,
            "end": 11308,
            "type": "code"
        },
        {
            "start": 11309,
            "end": 11309,
            "type": "code"
        },
        {
            "start": 11310,
            "end": 11387,
            "type": "code"
        },
        {
            "start": 11388,
            "end": 11390,
            "type": "code"
        },
        {
            "start": 11391,
            "end": 11399,
            "type": "code"
        },
        {
            "start": 11400,
            "end": 11404,
            "type": "code"
        },
        {
            "start": 11405,
            "end": 11418,
            "type": "code"
        },
        {
            "start": 11419,
            "end": 11425,
            "type": "code"
        },
        {
            "start": 11426,
            "end": 11442,
            "type": "code"
        },
        {
            "start": 11443,
            "end": 11447,
            "type": "code"
        },
        {
            "start": 11448,
            "end": 11466,
            "type": "code"
        },
        {
            "start": 11467,
            "end": 11470,
            "type": "code"
        },
        {
            "start": 11471,
            "end": 11476,
            "type": "code"
        },
        {
            "start": 11477,
            "end": 11481,
            "type": "code"
        },
        {
            "start": 11482,
            "end": 11498,
            "type": "code"
        },
        {
            "start": 11499,
            "end": 11505,
            "type": "code"
        },
        {
            "start": 11506,
            "end": 11517,
            "type": "code"
        },
        {
            "start": 11518,
            "end": 11518,
            "type": "code"
        },
        {
            "start": 11519,
            "end": 11543,
            "type": "code"
        },
        {
            "start": 11544,
            "end": 11544,
            "type": "code"
        },
        {
            "start": 11547,
            "end": 11553,
            "type": "code"
        },
        {
            "start": 11554,
            "end": 11558,
            "type": "code"
        },
        {
            "start": 11560,
            "end": 11561,
            "type": "code"
        },
        {
            "start": 11563,
            "end": 11578,
            "type": "code"
        },
        {
            "start": 11579,
            "end": 11583,
            "type": "code"
        },
        {
            "start": 11584,
            "end": 11597,
            "type": "code"
        },
        {
            "start": 11599,
            "end": 11604,
            "type": "code"
        },
        {
            "start": 11605,
            "end": 11615,
            "type": "code"
        },
        {
            "start": 11616,
            "end": 11632,
            "type": "code"
        },
        {
            "start": 11633,
            "end": 11642,
            "type": "code"
        },
        {
            "start": 11643,
            "end": 11646,
            "type": "code"
        },
        {
            "start": 11647,
            "end": 11659,
            "type": "code"
        },
        {
            "start": 11660,
            "end": 11660,
            "type": "db"
        },
        {
            "start": 11662,
            "end": 11681,
            "type": "code"
        },
        {
            "start": 11682,
            "end": 11692,
            "type": "code"
        },
        {
            "start": 11693,
            "end": 11712,
            "type": "code"
        },
        {
            "start": 11713,
            "end": 11732,
            "type": "code"
        },
        {
            "start": 11733,
            "end": 11744,
            "type": "code"
        },
        {
            "start": 11745,
            "end": 11746,
            "type": "code"
        },
        {
            "start": 11747,
            "end": 11776,
            "type": "code"
        },
        {
            "start": 11777,
            "end": 11805,
            "type": "code"
        },
        {
            "start": 11806,
            "end": 11811,
            "type": "code"
        },
        {
            "start": 11812,
            "end": 11861,
            "type": "code"
        },
        {
            "start": 11862,
            "end": 11886,
            "type": "code"
        },
        {
            "start": 11887,
            "end": 11898,
            "type": "code"
        },
        {
            "start": 11899,
            "end": 11913,
            "type": "code"
        },
        {
            "start": 11914,
            "end": 11936,
            "type": "code"
        },
        {
            "start": 11937,
            "end": 11944,
            "type": "code"
        },
        {
            "start": 11945,
            "end": 11954,
            "type": "code"
        },
        {
            "start": 11955,
            "end": 11959,
            "type": "code"
        },
        {
            "start": 11960,
            "end": 11978,
            "type": "code"
        },
        {
            "start": 11979,
            "end": 11982,
            "type": "code"
        },
        {
            "start": 11983,
            "end": 11998,
            "type": "code"
        },
        {
            "start": 11999,
            "end": 12011,
            "type": "code"
        },
        {
            "start": 12012,
            "end": 12014,
            "type": "code"
        },
        {
            "start": 12015,
            "end": 12043,
            "type": "code"
        },
        {
            "start": 12044,
            "end": 12055,
            "type": "code"
        },
        {
            "start": 12056,
            "end": 12068,
            "type": "code"
        },
        {
            "start": 12069,
            "end": 12076,
            "type": "code"
        },
        {
            "start": 12077,
            "end": 12101,
            "type": "code"
        },
        {
            "start": 12102,
            "end": 12105,
            "type": "code"
        },
        {
            "start": 12106,
            "end": 12113,
            "type": "code"
        },
        {
            "start": 12114,
            "end": 12120,
            "type": "code"
        },
        {
            "start": 12121,
            "end": 12125,
            "type": "code"
        },
        {
            "start": 12126,
            "end": 12131,
            "type": "code"
        },
        {
            "start": 12132,
            "end": 12139,
            "type": "code"
        },
        {
            "start": 12140,
            "end": 12162,
            "type": "code"
        },
        {
            "start": 12163,
            "end": 12164,
            "type": "code"
        },
        {
            "start": 12165,
            "end": 12168,
            "type": "code"
        },
        {
            "start": 12171,
            "end": 12186,
            "type": "code"
        },
        {
            "start": 12187,
            "end": 12206,
            "type": "code"
        },
        {
            "start": 12207,
            "end": 12217,
            "type": "code"
        },
        {
            "start": 12218,
            "end": 12252,
            "type": "code"
        },
        {
            "start": 12253,
            "end": 12260,
            "type": "code"
        },
        {
            "start": 12261,
            "end": 12280,
            "type": "code"
        },
        {
            "start": 12281,
            "end": 12282,
            "type": "code"
        },
        {
            "start": 12283,
            "end": 12291,
            "type": "code"
        },
        {
            "start": 12292,
            "end": 12300,
            "type": "code"
        },
        {
            "start": 12301,
            "end": 12302,
            "type": "code"
        },
        {
            "start": 12303,
            "end": 12307,
            "type": "code"
        },
        {
            "start": 12308,
            "end": 12347,
            "type": "code"
        },
        {
            "start": 12348,
            "end": 12349,
            "type": "code"
        },
        {
            "start": 12350,
            "end": 12372,
            "type": "code"
        },
        {
            "start": 12373,
            "end": 12411,
            "type": "code"
        },
        {
            "start": 12412,
            "end": 12446,
            "type": "code"
        },
        {
            "start": 12447,
            "end": 12450,
            "type": "code"
        },
        {
            "start": 12451,
            "end": 12452,
            "type": "code"
        },
        {
            "start": 12453,
            "end": 12454,
            "type": "code"
        },
        {
            "start": 12457,
            "end": 12464,
            "type": "code"
        },
        {
            "start": 12465,
            "end": 12475,
            "type": "code"
        },
        {
            "start": 12476,
            "end": 12477,
            "type": "code"
        },
        {
            "start": 12478,
            "end": 12479,
            "type": "code"
        },
        {
            "start": 12480,
            "end": 12489,
            "type": "code"
        },
        {
            "start": 12490,
            "end": 12521,
            "type": "code"
        },
        {
            "start": 12522,
            "end": 12526,
            "type": "code"
        },
        {
            "start": 12527,
            "end": 12527,
            "type": "code"
        },
        {
            "start": 12528,
            "end": 12563,
            "type": "code"
        },
        {
            "start": 12564,
            "end": 12570,
            "type": "code"
        },
        {
            "start": 12571,
            "end": 12580,
            "type": "code"
        },
        {
            "start": 12581,
            "end": 12602,
            "type": "code"
        },
        {
            "start": 12603,
            "end": 12604,
            "type": "code"
        },
        {
            "start": 12605,
            "end": 12613,
            "type": "code"
        },
        {
            "start": 12614,
            "end": 12624,
            "type": "code"
        },
        {
            "start": 12625,
            "end": 12628,
            "type": "code"
        },
        {
            "start": 12629,
            "end": 12632,
            "type": "code"
        },
        {
            "start": 12633,
            "end": 12636,
            "type": "code"
        },
        {
            "start": 12637,
            "end": 12637,
            "type": "code"
        },
        {
            "start": 12638,
            "end": 12651,
            "type": "code"
        },
        {
            "start": 12652,
            "end": 12653,
            "type": "code"
        },
        {
            "start": 12654,
            "end": 12677,
            "type": "code"
        },
        {
            "start": 12678,
            "end": 12692,
            "type": "code"
        },
        {
            "start": 12693,
            "end": 12716,
            "type": "code"
        },
        {
            "start": 12717,
            "end": 12718,
            "type": "code"
        },
        {
            "start": 12719,
            "end": 12753,
            "type": "code"
        },
        {
            "start": 12754,
            "end": 12769,
            "type": "code"
        },
        {
            "start": 12770,
            "end": 12785,
            "type": "code"
        },
        {
            "start": 12786,
            "end": 12792,
            "type": "code"
        },
        {
            "start": 12793,
            "end": 12793,
            "type": "code"
        },
        {
            "start": 12794,
            "end": 12817,
            "type": "code"
        },
        {
            "start": 12820,
            "end": 12832,
            "type": "code"
        },
        {
            "start": 12833,
            "end": 12850,
            "type": "code"
        },
        {
            "start": 12851,
            "end": 12862,
            "type": "code"
        },
        {
            "start": 12863,
            "end": 12881,
            "type": "code"
        },
        {
            "start": 12882,
            "end": 12893,
            "type": "code"
        },
        {
            "start": 12894,
            "end": 12896,
            "type": "code"
        },
        {
            "start": 12897,
            "end": 12902,
            "type": "code"
        },
        {
            "start": 12903,
            "end": 12907,
            "type": "code"
        },
        {
            "start": 12908,
            "end": 12908,
            "type": "code"
        },
        {
            "start": 12909,
            "end": 12913,
            "type": "code"
        },
        {
            "start": 12914,
            "end": 12925,
            "type": "code"
        },
        {
            "start": 12926,
            "end": 12930,
            "type": "code"
        },
        {
            "start": 12931,
            "end": 12937,
            "type": "code"
        },
        {
            "start": 12938,
            "end": 12943,
            "type": "code"
        },
        {
            "start": 12944,
            "end": 12946,
            "type": "code"
        },
        {
            "start": 12947,
            "end": 12949,
            "type": "code"
        },
        {
            "start": 12950,
            "end": 12950,
            "type": "code"
        },
        {
            "start": 12951,
            "end": 12976,
            "type": "code"
        },
        {
            "start": 12977,
            "end": 12977,
            "type": "code"
        },
        {
            "start": 12978,
            "end": 12988,
            "type": "code"
        },
        {
            "start": 12989,
            "end": 12996,
            "type": "code"
        },
        {
            "start": 12997,
            "end": 13011,
            "type": "db"
        },
        {
            "start": 13015,
            "end": 13145,
            "type": "dw"
        },
        {
            "start": 13147,
            "end": 13149,
            "type": "code"
        },
        {
            "start": 13150,
            "end": 13153,
            "type": "code"
        },
        {
            "start": 13154,
            "end": 13163,
            "type": "code"
        },
        {
            "start": 13164,
            "end": 13183,
            "type": "code"
        },
        {
            "start": 13184,
            "end": 13195,
            "type": "code"
        },
        {
            "start": 13196,
            "end": 13197,
            "type": "code"
        },
        {
            "start": 13198,
            "end": 13217,
            "type": "code"
        },
        {
            "start": 13218,
            "end": 13223,
            "type": "code"
        },
        {
            "start": 13225,
            "end": 13235,
            "type": "code"
        },
        {
            "start": 13236,
            "end": 13247,
            "type": "code"
        },
        {
            "start": 13248,
            "end": 13253,
            "type": "code"
        },
        {
            "start": 13254,
            "end": 13255,
            "type": "code"
        },
        {
            "start": 13256,
            "end": 13277,
            "type": "code"
        },
        {
            "start": 13278,
            "end": 13296,
            "type": "code"
        },
        {
            "start": 13297,
            "end": 13301,
            "type": "code"
        },
        {
            "start": 13303,
            "end": 13303,
            "type": "code"
        },
        {
            "start": 13304,
            "end": 13316,
            "type": "code"
        },
        {
            "start": 13318,
            "end": 13326,
            "type": "code"
        },
        {
            "start": 13327,
            "end": 13338,
            "type": "code"
        },
        {
            "start": 13339,
            "end": 13356,
            "type": "code"
        },
        {
            "start": 13357,
            "end": 13371,
            "type": "code"
        },
        {
            "start": 13372,
            "end": 13373,
            "type": "code"
        },
        {
            "start": 13374,
            "end": 13384,
            "type": "code"
        },
        {
            "start": 13385,
            "end": 13417,
            "type": "code"
        },
        {
            "start": 13418,
            "end": 13420,
            "type": "code"
        },
        {
            "start": 13422,
            "end": 13427,
            "type": "code"
        },
        {
            "start": 13428,
            "end": 13442,
            "type": "code"
        },
        {
            "start": 13443,
            "end": 13457,
            "type": "code"
        },
        {
            "start": 13458,
            "end": 13476,
            "type": "code"
        },
        {
            "start": 13477,
            "end": 13482,
            "type": "code"
        },
        {
            "start": 13484,
            "end": 13487,
            "type": "code"
        },
        {
            "start": 13488,
            "end": 13488,
            "type": "code"
        },
        {
            "start": 13491,
            "end": 13499,
            "type": "code"
        },
        {
            "start": 13500,
            "end": 13522,
            "type": "code"
        },
        {
            "start": 13523,
            "end": 13539,
            "type": "code"
        },
        {
            "start": 13540,
            "end": 13542,
            "type": "code"
        },
        {
            "start": 13543,
            "end": 13544,
            "type": "code"
        },
        {
            "start": 13545,
            "end": 13560,
            "type": "code"
        },
        {
            "start": 13561,
            "end": 13567,
            "type": "code"
        },
        {
            "start": 13569,
            "end": 13572,
            "type": "code"
        },
        {
            "start": 13574,
            "end": 13574,
            "type": "code"
        },
        {
            "start": 13575,
            "end": 13578,
            "type": "code"
        },
        {
            "start": 13579,
            "end": 13594,
            "type": "code"
        },
        {
            "start": 13595,
            "end": 13602,
            "type": "code"
        },
        {
            "start": 13604,
            "end": 13611,
            "type": "code"
        },
        {
            "start": 13613,
            "end": 13626,
            "type": "code"
        },
        {
            "start": 13627,
            "end": 13634,
            "type": "code"
        },
        {
            "start": 13635,
            "end": 13645,
            "type": "code"
        },
        {
            "start": 13646,
            "end": 13656,
            "type": "code"
        },
        {
            "start": 13657,
            "end": 13667,
            "type": "code"
        },
        {
            "start": 13668,
            "end": 13674,
            "type": "code"
        },
        {
            "start": 13675,
            "end": 13681,
            "type": "code"
        },
        {
            "start": 13682,
            "end": 13684,
            "type": "code"
        },
        {
            "start": 13685,
            "end": 13700,
            "type": "code"
        },
        {
            "start": 13701,
            "end": 13703,
            "type": "code"
        },
        {
            "start": 13704,
            "end": 13707,
            "type": "code"
        },
        {
            "start": 13708,
            "end": 13723,
            "type": "code"
        },
        {
            "start": 13724,
            "end": 13750,
            "type": "code"
        },
        {
            "start": 13751,
            "end": 13757,
            "type": "code"
        },
        {
            "start": 13759,
            "end": 13768,
            "type": "code"
        },
        {
            "start": 13769,
            "end": 13787,
            "type": "code"
        },
        {
            "start": 13788,
            "end": 13789,
            "type": "code"
        },
        {
            "start": 13790,
            "end": 13835,
            "type": "code"
        },
        {
            "start": 13836,
            "end": 13853,
            "type": "code"
        },
        {
            "start": 13855,
            "end": 13892,
            "type": "code"
        },
        {
            "start": 13893,
            "end": 13918,
            "type": "code"
        },
        {
            "start": 13919,
            "end": 13926,
            "type": "code"
        },
        {
            "start": 13929,
            "end": 13936,
            "type": "code"
        },
        {
            "start": 13937,
            "end": 13937,
            "type": "code"
        },
        {
            "start": 13940,
            "end": 13943,
            "type": "code"
        },
        {
            "start": 13946,
            "end": 13957,
            "type": "code"
        },
        {
            "start": 13958,
            "end": 13958,
            "type": "code"
        },
        {
            "start": 13959,
            "end": 13966,
            "type": "code"
        },
        {
            "start": 13967,
            "end": 13978,
            "type": "code"
        },
        {
            "start": 13979,
            "end": 13983,
            "type": "code"
        },
        {
            "start": 13984,
            "end": 13998,
            "type": "code"
        },
        {
            "start": 13999,
            "end": 14019,
            "type": "code"
        },
        {
            "start": 14020,
            "end": 14082,
            "type": "code"
        },
        {
            "start": 14083,
            "end": 14084,
            "type": "code"
        },
        {
            "start": 14085,
            "end": 14091,
            "type": "code"
        },
        {
            "start": 14092,
            "end": 14093,
            "type": "code"
        },
        {
            "start": 14094,
            "end": 14098,
            "type": "code"
        },
        {
            "start": 14099,
            "end": 14210,
            "type": "code"
        },
        {
            "start": 14211,
            "end": 14249,
            "type": "code"
        },
        {
            "start": 14250,
            "end": 14260,
            "type": "code"
        },
        {
            "start": 14261,
            "end": 14297,
            "type": "code"
        },
        {
            "start": 14298,
            "end": 14305,
            "type": "code"
        },
        {
            "start": 14306,
            "end": 14327,
            "type": "code"
        },
        {
            "start": 14328,
            "end": 14386,
            "type": "code"
        },
        {
            "start": 14387,
            "end": 14402,
            "type": "code"
        },
        {
            "start": 14403,
            "end": 14409,
            "type": "code"
        },
        {
            "start": 14410,
            "end": 14416,
            "type": "code"
        },
        {
            "start": 14417,
            "end": 14445,
            "type": "code"
        },
        {
            "start": 14446,
            "end": 14446,
            "type": "db"
        },
        {
            "start": 15616,
            "end": 16383,
            "type": "db"
        },
        {
            "start": 23552,
            "end": 23556,
            "type": "db"
        },
        {
            "start": 23560,
            "end": 23560,
            "type": "db"
        },
        {
            "start": 23561,
            "end": 23561,
            "type": "db"
        },
        {
            "start": 23562,
            "end": 23562,
            "type": "db"
        },
        {
            "start": 23563,
            "end": 23563,
            "type": "db"
        },
        {
            "start": 23565,
            "end": 23565,
            "type": "db"
        },
        {
            "start": 23566,
            "end": 23566,
            "type": "db"
        },
        {
            "start": 23568,
            "end": 23604,
            "type": "db"
        },
        {
            "start": 23606,
            "end": 23606,
            "type": "db"
        },
        {
            "start": 23608,
            "end": 23608,
            "type": "db"
        },
        {
            "start": 23609,
            "end": 23609,
            "type": "db"
        },
        {
            "start": 23610,
            "end": 23610,
            "type": "db"
        },
        {
            "start": 23611,
            "end": 23611,
            "type": "db"
        },
        {
            "start": 23612,
            "end": 23612,
            "type": "db"
        },
        {
            "start": 23613,
            "end": 23613,
            "type": "db"
        },
        {
            "start": 23615,
            "end": 23615,
            "type": "db"
        },
        {
            "start": 23617,
            "end": 23617,
            "type": "db"
        },
        {
            "start": 23618,
            "end": 23618,
            "type": "db"
        },
        {
            "start": 23620,
            "end": 23620,
            "type": "db"
        },
        {
            "start": 23621,
            "end": 23621,
            "type": "db"
        },
        {
            "start": 23623,
            "end": 23623,
            "type": "db"
        },
        {
            "start": 23624,
            "end": 23624,
            "type": "db"
        },
        {
            "start": 23625,
            "end": 23625,
            "type": "db"
        },
        {
            "start": 23627,
            "end": 23627,
            "type": "db"
        },
        {
            "start": 23629,
            "end": 23629,
            "type": "db"
        },
        {
            "start": 23631,
            "end": 23631,
            "type": "db"
        },
        {
            "start": 23633,
            "end": 23633,
            "type": "db"
        },
        {
            "start": 23635,
            "end": 23635,
            "type": "db"
        },
        {
            "start": 23637,
            "end": 23637,
            "type": "db"
        },
        {
            "start": 23639,
            "end": 23639,
            "type": "db"
        },
        {
            "start": 23641,
            "end": 23641,
            "type": "db"
        },
        {
            "start": 23643,
            "end": 23643,
            "type": "db"
        },
        {
            "start": 23645,
            "end": 23645,
            "type": "db"
        },
        {
            "start": 23647,
            "end": 23647,
            "type": "db"
        },
        {
            "start": 23649,
            "end": 23649,
            "type": "db"
        },
        {
            "start": 23651,
            "end": 23651,
            "type": "db"
        },
        {
            "start": 23653,
            "end": 23653,
            "type": "db"
        },
        {
            "start": 23655,
            "end": 23655,
            "type": "db"
        },
        {
            "start": 23656,
            "end": 23656,
            "type": "db"
        },
        {
            "start": 23658,
            "end": 23658,
            "type": "db"
        },
        {
            "start": 23659,
            "end": 23659,
            "type": "db"
        },
        {
            "start": 23660,
            "end": 23660,
            "type": "db"
        },
        {
            "start": 23662,
            "end": 23662,
            "type": "db"
        },
        {
            "start": 23664,
            "end": 23664,
            "type": "db"
        },
        {
            "start": 23665,
            "end": 23665,
            "type": "db"
        },
        {
            "start": 23666,
            "end": 23666,
            "type": "db"
        },
        {
            "start": 23668,
            "end": 23668,
            "type": "db"
        },
        {
            "start": 23670,
            "end": 23670,
            "type": "db"
        },
        {
            "start": 23672,
            "end": 23672,
            "type": "db"
        },
        {
            "start": 23675,
            "end": 23675,
            "type": "db"
        },
        {
            "start": 23677,
            "end": 23678,
            "type": "db"
        },
        {
            "start": 23679,
            "end": 23679,
            "type": "db"
        },
        {
            "start": 23680,
            "end": 23680,
            "type": "db"
        },
        {
            "start": 23682,
            "end": 23682,
            "type": "db"
        },
        {
            "start": 23684,
            "end": 23684,
            "type": "db"
        },
        {
            "start": 23686,
            "end": 23686,
            "type": "db"
        },
        {
            "start": 23688,
            "end": 23688,
            "type": "db"
        },
        {
            "start": 23690,
            "end": 23690,
            "type": "db"
        },
        {
            "start": 23692,
            "end": 23692,
            "type": "db"
        },
        {
            "start": 23693,
            "end": 23693,
            "type": "db"
        },
        {
            "start": 23694,
            "end": 23694,
            "type": "db"
        },
        {
            "start": 23695,
            "end": 23695,
            "type": "db"
        },
        {
            "start": 23696,
            "end": 23696,
            "type": "db"
        },
        {
            "start": 23697,
            "end": 23697,
            "type": "db"
        },
        {
            "start": 23698,
            "end": 23723,
            "type": "db"
        },
        {
            "start": 23728,
            "end": 23728,
            "type": "db"
        },
        {
            "start": 23730,
            "end": 23730,
            "type": "db"
        },
        {
            "start": 23732,
            "end": 23732,
            "type": "db"
        },
        {
            "start": 23734,
            "end": 23754,
            "type": "db"
        }
    ],
    "comments": {
        "0": "Disable the 'keyboard interrupt'.",
        "1": "&00 for start (but &FF for 'NEW').",
        "2": "Top of possible RAM.",
        "5": "Jump forward.",
        "8": "The address reached by the interpreter",
        "b": "() is copied to the error pointer",
        "e": "() before proceeding.",
        "10": "Jump forward immediately.",
        "13": "Unused locations.",
        "18": "Fetch the value that is addressed by .",
        "1c": "Find out if the character is printable.",
        "1f": "Return if it is so.",
        "20": " needs to be incremented.",
        "23": "Jump back to test the new value.",
        "25": "Unused locations.",
        "28": "Jump forward immediately.",
        "2b": "Unused locations.",
        "30": "Save the 'number'.",
        "31": "Fetch the present address of the start of the work",
        "34": "space () and save that also before",
        "35": "proceeding.",
        "38": "Save the current values held in these registers.",
        "3a": "The lower two bytes of the frame counter",
        "3d": "() are incremented every 20 ms. (U.K.)",
        "3e": "The highest byte of the frame counter is only",
        "41": "incremented when the value of the lower two bytes is",
        "42": "zero.",
        "48": "Save the current values held in these registers.",
        "4a": "Now scan the keyboard.",
        "4d": "Restore the values.",
        "51": "The maskable interrupt is enabled before returning.",
        "53": "The address on the stack points to the error code.",
        "55": "It is transferred to .",
        "58": "The machine stack is cleared by setting the stack",
        "5c": "pointer to  before exiting via #R$16C5.",
        "5f": "Unused locations.",
        "66": "Save the current values held in these registers.",
        "68": "The two bytes of  must both be zero for",
        "6b": "the reset to occur.",
        "6d": "Note: this should have been '#S/JR Z/'!",
        "6f": "Jump to #R$0000.",
        "70": "Restore the current values to these registers and",
        "71": "return.",
        "74": "Fetch the address from .",
        "77": "Increment the pointer.",
        "78": "Set .",
        "7b": "Fetch the addressed value and then return.",
        "7d": "Return with the carry flag reset if ordinary character",
        "7f": "code.",
        "80": "Return if the end of the line has been reached.",
        "83": "Return with codes &00 to &0F but with carry set.",
        "86": "Return with codes &18 to &20 again with carry set.",
        "8a": "Skip over once.",
        "8b": "Jump forward with codes &10 to &15 (INK to OVER).",
        "8f": "Skip over once more (AT and TAB).",
        "90": "Return with the carry flag set and ",
        "91": "holding the appropriate address.",
        "95": "?",
        "96": "RND",
        "99": "INKEY$",
        "9f": "PI",
        "a1": "FN",
        "a3": "POINT",
        "a8": "SCREEN$",
        "af": "ATTR",
        "b3": "AT",
        "b5": "TAB",
        "b8": "VAL$",
        "bc": "CODE",
        "c0": "VAL",
        "c3": "LEN",
        "c6": "SIN",
        "c9": "COS",
        "cc": "TAN",
        "cf": "ASN",
        "d2": "ACS",
        "d5": "ATN",
        "d8": "LN",
        "da": "EXP",
        "dd": "INT",
        "e0": "SQR",
        "e3": "SGN",
        "e6": "ABS",
        "e9": "PEEK",
        "ed": "IN",
        "ef": "USR",
        "f2": "STR$",
        "f6": "CHR$",
        "fa": "NOT",
        "fd": "BIN",
        "100": "OR",
        "102": "AND",
        "105": "<=",
        "107": ">=",
        "109": "<>",
        "10b": "LINE",
        "10f": "THEN",
        "113": "TO",
        "115": "STEP",
        "119": "DEF FN",
        "11f": "CAT",
        "122": "FORMAT",
        "128": "MOVE",
        "12c": "ERASE",
        "131": "OPEN #",
        "137": "CLOSE #",
        "13e": "MERGE",
        "143": "VERIFY",
        "149": "BEEP",
        "14d": "CIRCLE",
        "153": "INK",
        "156": "PAPER",
        "15b": "FLASH",
        "160": "BRIGHT",
        "166": "INVERSE",
        "16d": "OVER",
        "171": "OUT",
        "174": "LPRINT",
        "17a": "LLIST",
        "17f": "STOP",
        "183": "READ",
        "187": "DATA",
        "18b": "RESTORE",
        "192": "NEW",
        "195": "BORDER",
        "19b": "CONTINUE",
        "1a3": "DIM",
        "1a6": "REM",
        "1a9": "FOR",
        "1ac": "GO TO",
        "1b1": "GO SUB",
        "1b7": "INPUT",
        "1bc": "LOAD",
        "1c0": "LIST",
        "1c4": "LET",
        "1c7": "PAUSE",
        "1cc": "NEXT",
        "1d0": "POKE",
        "1d4": "PRINT",
        "1d9": "PLOT",
        "1dd": "RUN",
        "1e0": "SAVE",
        "1e4": "RANDOMIZE",
        "1ed": "IF",
        "1ef": "CLS",
        "1f2": "DRAW",
        "1f6": "CLEAR",
        "1fb": "RETURN",
        "201": "COPY",
        "205": "B",
        "206": "H",
        "207": "Y",
        "208": "6",
        "209": "5",
        "20a": "T",
        "20b": "G",
        "20c": "V",
        "20d": "N",
        "20e": "J",
        "20f": "U",
        "210": "7",
        "211": "4",
        "212": "R",
        "213": "F",
        "214": "C",
        "215": "M",
        "216": "K",
        "217": "I",
        "218": "8",
        "219": "3",
        "21a": "E",
        "21b": "D",
        "21c": "X",
        "21d": "SYMBOL SHIFT",
        "21e": "L",
        "21f": "O",
        "220": "9",
        "221": "2",
        "222": "W",
        "223": "S",
        "224": "Z",
        "225": "SPACE",
        "226": "ENTER",
        "227": "P",
        "228": "0",
        "229": "1",
        "22a": "Q",
        "22b": "A",
        "22c": "READ",
        "22d": "BIN",
        "22e": "LPRINT",
        "22f": "DATA",
        "230": "TAN",
        "231": "SGN",
        "232": "ABS",
        "233": "SQR",
        "234": "CODE",
        "235": "VAL",
        "236": "LEN",
        "237": "USR",
        "238": "PI",
        "239": "INKEY$",
        "23a": "PEEK",
        "23b": "TAB",
        "23c": "SIN",
        "23d": "INT",
        "23e": "RESTORE",
        "23f": "RND",
        "240": "CHR$",
        "241": "LLIST",
        "242": "COS",
        "243": "EXP",
        "244": "STR$",
        "245": "LN",
        "246": "~",
        "247": "BRIGHT",
        "248": "PAPER",
        "249": "\\",
        "24a": "ATN",
        "24b": "{}",
        "24d": "CIRCLE",
        "24e": "IN",
        "24f": "VAL$",
        "250": "SCREEN$",
        "251": "ATTR",
        "252": "INVERSE",
        "253": "OVER",
        "254": "OUT",
        "255": "#CHR169",
        "256": "ASN",
        "257": "VERIFY",
        "258": "|",
        "259": "MERGE",
        "25a": "]",
        "25b": "FLASH",
        "25c": "ACS",
        "25d": "INK",
        "25e": "[",
        "25f": "BEEP",
        "260": "DELETE",
        "261": "EDIT",
        "262": "CAPS LOCK",
        "263": "TRUE VIDEO",
        "264": "INV. VIDEO",
        "265": "Cursor left",
        "266": "Cursor down",
        "267": "Cursor up",
        "268": "Cursor right",
        "269": "GRAPHICS",
        "26a": "STOP",
        "26b": "*",
        "26c": "?",
        "26d": "STEP",
        "26e": ">=",
        "26f": "TO",
        "270": "THEN",
        "271": "#power",
        "272": "AT",
        "273": "-",
        "274": "+",
        "275": "=",
        "276": ".",
        "277": ",",
        "278": ";",
        "279": "\"",
        "27a": "<=",
        "27b": "<",
        "27c": "NOT",
        "27d": ">",
        "27e": "OR",
        "27f": "/",
        "280": "<>",
        "281": "#CHR163",
        "282": "AND",
        "283": ":",
        "284": "FORMAT",
        "285": "DEF FN",
        "286": "FN",
        "287": "LINE",
        "288": "OPEN",
        "289": "CLOSE",
        "28a": "MOVE",
        "28b": "ERASE",
        "28c": "POINT",
        "28d": "CAT",
        "28e": "The initial key value for each line will be &2F,",
        "290": "Initialise #REGde to 'no-key'.",
        "293": "#REGc=port address, #REGb=counter.",
        "296": "Read from the port specified.",
        "298": "A pressed key in the line will set its respective bit,",
        "299": "from bit 0 (outer key) to bit 4 (inner key).",
        "29b": "Jump forward if none of the five keys in the line are",
        "29d": "The key-bits go to the #REGh register whilst the",
        "29e": "initial key value is fetched.",
        "29f": "If three keys are being pressed on the keyboard then",
        "2a0": "the #REGd register will no longer hold &FF - so return",
        "2a1": "Repeatedly subtract 8 from the present key value until",
        "2a3": "a key-bit is found.",
        "2a7": "Copy any earlier key value to the #REGd register.",
        "2a8": "Pass the new key value to the #REGe register.",
        "2a9": "If there is a second, or possibly a third, pressed key",
        "2ab": "The line has been scanned so the initial key value is",
        "2ac": "The counter is shifted and the jump taken if there are",
        "2ae": "still lines to be scanned.",
        "2b0": "Accept any key value which still has the #REGd register",
        "2b1": "holding &FF, i.e. a single key pressed or 'no-key'.",
        "2b3": "Accept the key value for a pair of keys if the #REGd",
        "2b5": "key is CAPS SHIFT.",
        "2b6": "Accept the key value for a pair of keys if the #REGd",
        "2b8": "key is SYMBOL SHIFT.",
        "2b9": "It is however possible for the #REGe key of a pair to",
        "2ba": "be SYMBOL SHIFT - so this has to be considered.",
        "2be": "Return with the zero flag set if it was SYMBOL SHIFT and",
        "2bf": "Fetch a key value in the #REGde register pair but",
        "2c2": "return immediately if the zero flag is reset.",
        "2c3": "Start with #R$5C00(KSTATE0).",
        "2c6": "Jump forward if a 'set is free', i.e.",
        "2c8": "#R$5C00(KSTATE0/4) holds &FF.",
        "2ca": "However if the set is not free decrease its '5 call",
        "2cb": "counter' and when it reaches zero signal the set as",
        "2cc": "free.",
        "2d1": "Fetch the low byte of the address and jump back if the",
        "2d2": "second set (#R$5C04(KSTATE4)) has still to be",
        "2d5": "considered.",
        "2d8": "Make the necessary tests and return if needed. Also",
        "2db": "change the key value to a 'main code'.",
        "2dc": "Look first at #R$5C00(KSTATE0).",
        "2df": "Jump forward if the codes match - indicating a repeat.",
        "2e2": "Save the address of #R$5C00(KSTATE0).",
        "2e3": "Now look at #R$5C04(KSTATE4).",
        "2e6": "Jump forward if the codes match - indicating a repeat.",
        "2e9": "Consider the second set.",
        "2eb": "Jump forward if 'free'.",
        "2ed": "Now consider the first set.",
        "2ee": "Continue if the set is 'free' but exit if not.",
        "2f1": "The code is passed to the #REGe register and to",
        "2f2": "#R$5C00(KSTATE0/4).",
        "2f3": "The '5 call counter' for this set is reset to '5'.",
        "2f6": "The third system variable of the set holds the",
        "2f7": " value (normally 0.7 secs.).",
        "2fb": "Point to #R$5C00(KSTATE3/7).",
        "2fc": "Fetch .",
        "2ff": "Fetch .",
        "302": "Save the pointer whilst the 'main code' is decoded.",
        "307": "The final code value is saved in #R$5C00(KSTATE3/7),",
        "308": "Enter the final code value into  and",
        "30b": "signal 'a new key' by setting bit 5 of .",
        "30f": "Finally return.",
        "310": "Point to the '5 call counter' of the set being used",
        "311": "and reset it to 5.",
        "313": "Point to the third system variable - the",
        "314": "/ value - and decrement",
        "315": "Exit from the #R$02BF subroutine if the delay period",
        "316": "However once it has passed the delay period for the",
        "319": "next repeat is to be .",
        "31a": "The repeat has been accepted so the final code value",
        "31b": "is fetched from #R$5C00(KSTATE3/7) and passed to",
        "31c": "#R$0308.",
        "31e": "Copy the shift byte.",
        "31f": "Clear the #REGd register for later.",
        "321": "Move the key number.",
        "322": "Return now if the key was 'CAPS SHIFT' only or",
        "324": "'no-key'.",
        "325": "Jump forward unless the #REGe key was SYMBOL SHIFT.",
        "329": "However accept SYMBOL SHIFT and another key; return",
        "32b": "with SYMBOL SHIFT only.",
        "32c": "The base address of the #R$0205#$0205(main key table).",
        "32f": "Index into the table and fetch the 'main code'.",
        "331": "Signal 'valid keystroke' before returning.",
        "333": "Copy the 'main code'.",
        "334": "Jump forward if a digit key is being considered; also",
        "336": "SPACE, ENTER and both shifts.",
        "338": "Decrement the  value.",
        "339": "Jump forward, as needed, for modes 'K', 'L', 'C' and",
        "33c": "'E'.",
        "33e": "Add the offset.",
        "340": "Return with the 'final code'.",
        "341": "The base address for #R$022C(table 'b').",
        "344": "Jump forward to use this table if neither shift key is",
        "345": "being pressed.",
        "347": "Otherwise use the base address for #R$0246(table 'c').",
        "34a": "Clear the #REGd register.",
        "34c": "Index the required table and fetch the 'final code'.",
        "34e": "Then return.",
        "34f": "The base address for #R$026A(table 'e').",
        "352": "Jump back if using the SYMBOL SHIFT key and a letter",
        "354": "key.",
        "356": "Jump forward if currently in 'K' mode.",
        "35a": "If CAPS LOCK is set (bit 3 of #R$5C6A(FLAGS2) set)",
        "35e": "then return with the 'main code'.",
        "35f": "Also return in the same manner if CAPS SHIFT is being",
        "360": "pressed.",
        "361": "However if lower case codes are required then &20 has",
        "363": "to be added to the 'main code' to give the correct",
        "364": "Add the required offset and return.",
        "367": "Proceed only with the digit keys, i.e. return with",
        "369": "SPACE (&20), ENTER (&0D) and both shifts (&0E).",
        "36a": "Now separate the digit keys into three groups -",
        "36b": "Jump with 'K', 'L' and 'C' modes, and also with 'G'",
        "36e": "mode. Continue with 'E' mode.",
        "370": "The base address for #R$0284(table 'f').",
        "373": "Use this table for SYMBOL SHIFT and a digit key in",
        "375": "extended mode.",
        "377": "Jump forward with digit keys '8' and '9'.",
        "37b": "Reduce the range &30 to &37 giving &10 to &17.",
        "37d": "Return with this 'paper colour code' if CAPS SHIFT is",
        "37e": "not being used.",
        "37f": "But if it is then the range is to be &18 to &1F",
        "381": "instead - indicating an 'ink colour code'.",
        "382": "&38 and &39 go to &02 and &03.",
        "384": "Return with these codes if CAPS SHIFT is not being",
        "385": "used. (These are 'BRIGHT' codes.)",
        "386": "Subtract '2' if CAPS SHIFT is being used; giving &00",
        "388": "and &01 (as 'FLASH' codes).",
        "389": "The base address of #R$0260(table 'd').",
        "38c": "Use this table directly for both digit key '9' that is",
        "38e": "to give GRAPHICS, and digit key '0' that is to give",
        "390": "DELETE.",
        "394": "For keys '1' to '8' make the range &80 to &87.",
        "398": "Return with a value from this range if neither shift",
        "399": "key is being pressed.",
        "39a": "But if 'shifted' make the range &88 to &8F.",
        "39d": "Return directly if neither shift key is being used.",
        "39e": "(Final codes &30 to &39.)",
        "39f": "Use #R$0260(table 'd') if the CAPS SHIFT key is also",
        "3a1": "being pressed.",
        "3a6": "Reduce the range to give &20 to &29.",
        "3a8": "Separate the '@' character from the others.",
        "3ac": "The '_' character has also to be separated.",
        "3ae": "Return now with the 'final codes' &21, &23 to &29.",
        "3af": "Give the '_' character a code of &5F.",
        "3b2": "Give the '@' character a code of &40.",
        "3b5": "Disable the interrupt for the duration of a 'beep'.",
        "3b6": "Save #REGl temporarily.",
        "3b7": "Each '1' in the #REGl register is to count 4 T states,",
        "3b9": "but take INT (#REGl/4) and count 16 T states instead.",
        "3bb": "Go back to the original value in #REGl and find how",
        "3bc": "many were lost by taking 3-(#REGa mod 4).",
        "3c1": "The base address of the timing loop.",
        "3c5": "Alter the length of the timing loop. Use an earlier",
        "3c7": "Fetch the present border colour from ",
        "3ca": "and move it to bits 2, 1 and 0 of the #REGa register.",
        "3cf": "Ensure the MIC output is 'off'.",
        "3d1": "Add 4 T states for each earlier entry point that is",
        "3d2": "used.",
        "3d4": "The values in the #REGb and #REGc registers will come",
        "3d5": "from the #REGh and #REGl registers - see below.",
        "3d6": "The 'timing loop', i.e. #REGbc*4 T states. (But note",
        "3d7": "that at the half-cycle point, #REGc will be equal to",
        "3d9": "#REGl+1.)",
        "3df": "Flip bit 4.",
        "3e1": "Perform the '#S/OUT/' operation, leaving the border",
        "3e3": "Reset the #REGb register.",
        "3e4": "Save the #REGa register.",
        "3e5": "Jump if at the half-cycle point.",
        "3e9": "Jump forward if the last complete pass has been made",
        "3ea": "already.",
        "3ed": "Fetch the saved value.",
        "3ee": "Reset the #REGc register.",
        "3ef": "Decrease the pass counter.",
        "3f0": "Jump back to the required starting location of the loop.",
        "3f2": "Reset the #REGc register.",
        "3f3": "Add 16 T states as this path is shorter.",
        "3f4": "Jump back.",
        "3f6": "Enable interrupt.",
        "3f7": "Finally return.",
        "3f8": "The floating-point calculator is used to",
        "3f9": "#R$33C0: t, P, P",
        "3fa": "#R$36AF: t, P, i (where i=INT P)",
        "3fb": "#R$342D(st_mem_0): t, P, i (mem-0 holds i)",
        "3fc": "#R$300F: t, p (where p is the fractional part",
        "3fd": "#R$33C6: Stack the decimal value",
        "3fe": "K=0.0577622606 (which is a little below",
        "403": "#R$30CA: t, pK",
        "404": "#R$341B(stk_one): t, pK, 1",
        "405": "#R$3014: t, pK+1",
        "406": "#R$369B",
        "407": "This is 'mem-0-1st' ().",
        "40a": "Fetch the exponent of i.",
        "40b": "Give an error if i is not in the integral",
        "40c": "(short) form.",
        "40e": "Copy the sign byte to the #REGc register.",
        "410": "Copy the low-byte to the #REGb register, and",
        "411": "to the #REGa register.",
        "413": "Again give report B if i does not satisfy",
        "414": "the test: -128<=i<=+127.",
        "41c": "Fetch the low-byte and test it further.",
        "41f": "Accept -60<=i<=67.",
        "422": "Reject -128 to -61.",
        "425": "Start '6' octaves below middle C.",
        "427": "Repeatedly reduce i in order to find the",
        "428": "correct octave.",
        "42c": "Add back the last subtraction.",
        "42e": "Save the octave number.",
        "42f": "The base address of the '#R$046E(semitone",
        "432": "Consider the table and pass the 'A th.'",
        "435": "value to the calculator stack. (Call it C.)",
        "438": "t, pK+1, C",
        "439": "#R$30CA: t, C(pK+1)",
        "43a": "#R$369B",
        "43b": "Fetch the octave number.",
        "43c": "Multiply the 'last value' by 2 to the power",
        "43d": "of the octave number.",
        "43e": "t, f",
        "43f": "#R$342D(st_mem_0): Copy the frequency (f) to",
        "440": "#R$33A1: t",
        "441": "#R$33C0: t, t",
        "442": "#R$369B",
        "443": "The value 'INT t' must be in the range &00",
        "446": "to &0A.",
        "44a": "t",
        "44b": "#R$340F(get_mem_0): t, f",
        "44c": "#R$30CA: f*t",
        "44d": "#R$340F(get_mem_0): f*t, f",
        "44e": "#R$33C6: Stack the value",
        "44f": "(3.5*10#power6)/8=437500",
        "454": "#R$343C: f*t, 437500, f",
        "455": "#R$31AF: f*t, 437500/f",
        "456": "#R$33C6: f*t, 437500/f, 30.125",
        "459": "#R$300F: f*t, 437500/f-30.125",
        "45a": "#R$369B",
        "45b": "The 'timing loop' value is compressed into",
        "45e": "the #REGbc register pair and saved.",
        "45f": "The f*t value is compressed into the #REGbc",
        "462": "Move the 'timing loop' value to the #REGhl",
        "463": "Move the f*t value to the #REGde register",
        "464": "pair.",
        "465": "Return if f*t has given the result of 'no",
        "466": "cycles' required.",
        "468": "Decrease the cycle number and jump to",
        "469": "#R$03B5 (making at least one pass).",
        "46c": "Call the error handling routine.",
        "46e": "261.63 Hz - C",
        "473": "277.18 Hz - C#",
        "478": "293.66 Hz - D",
        "47d": "311.13 Hz - D#",
        "482": "329.63 Hz - E",
        "487": "349.23 Hz - F",
        "48c": "369.99 Hz - F#",
        "491": "392.00 Hz - G",
        "496": "415.30 Hz - G#",
        "49b": "440.00 Hz - A",
        "4a0": "466.16 Hz - A#",
        "4a5": "493.88 Hz - B",
        "4c2": "Pre-load the machine stack with the address #R$053F.",
        "4c6": "This constant will give a leader of about 5 seconds for",
        "4c9": "Jump forward if saving a header.",
        "4cd": "This constant will give a leader of about 2 seconds for",
        "4d0": "The flag is saved.",
        "4d1": "The 'length' is incremented and the 'base address'",
        "4d2": "reduced to allow for the flag.",
        "4d4": "The maskable interrupt is disabled during the save.",
        "4d5": "Signal 'MIC on' and border to be red.",
        "4d7": "Give a value to #REGb.",
        "4d8": "The main timing period.",
        "4da": "MIC on/off, border red/cyan, on each pass.",
        "4de": "The main timing constant.",
        "4e0": "Decrease the low counter.",
        "4e1": "Jump back for another pulse.",
        "4e3": "Allow for the longer path (reduce by 13 T states).",
        "4e4": "Decrease the high counter.",
        "4e5": "Jump back for another pulse until completion of the",
        "4ea": "MIC off for 667 T states from '#S/OUT/ to #S/OUT/'.",
        "4ec": "MIC on and red.",
        "4ee": "Signal 'MIC off and cyan'.",
        "4f0": "MIC on for 735 T States from '#S/OUT/ to #S/OUT/'.",
        "4f4": "Now MIC off and border cyan.",
        "4f6": "&3B is a timing constant; &0E signals 'MIC off and",
        "4f9": "Fetch the flag and pass it to the #REGl register for",
        "4fa": "'sending'.",
        "4fb": "Jump forward into the saving loop.",
        "4fe": "The 'length' counter is tested and the jump taken when",
        "4ff": "it has reached zero.",
        "502": "Fetch the next byte that is to be saved.",
        "505": "Fetch the current 'parity'.",
        "506": "Include the present byte.",
        "507": "Restore the 'parity'. Note that on entry here the 'flag'",
        "508": "Signal 'MIC on and blue'.",
        "50a": "Set the carry flag. This will act as a 'marker' for the",
        "50b": "Jump forward.",
        "50e": "Get final 'parity' value.",
        "50f": "Jump back.",
        "511": "Come here on the second pass and fetch 'MIC off and",
        "512": "Set the zero flag to show 'second pass'.",
        "514": "The main timing loop; always 801 T states on a second",
        "516": "Jump, taking the shorter path, if saving a '0'.",
        "518": "However if saving a '1' then add 855 T states.",
        "51c": "On the first pass 'MIC on and blue' and on the second",
        "51e": "Set the timing constant for the second pass.",
        "520": "Jump back at the end of the first pass; otherwise",
        "522": "reclaim 13 T states.",
        "523": "Clear the carry flag and set #REGa to hold &01 (MIC on",
        "524": "and blue) before continuing into the '8 bit loop'.",
        "525": "Move bit 7 to the carry and the 'marker' leftwards.",
        "527": "Save the bit unless finished with the byte.",
        "52a": "Decrease the 'counter'.",
        "52b": "Advance the 'base address'.",
        "52d": "Set the timing constant for the first bit of the next",
        "52f": "Return (to #R$053F) if the BREAK key is being pressed.",
        "535": "Otherwise test the 'counter' and jump back even if it",
        "536": "has reached zero (so as to send the 'parity' byte).",
        "53a": "Exit when the 'counter' reaches &FFFF. But first give a",
        "53c": "short delay.",
        "53f": "Save the carry flag. (It is reset after a loading",
        "540": "Fetch the original border colour from its system",
        "543": "variable ().",
        "545": "Move the border colour to bits 2, 1 and 0.",
        "548": "Set the border to its original colour.",
        "54a": "Read the BREAK key for a last time.",
        "54f": "Enable the maskable interrupt.",
        "550": "Jump unless a break is to be made.",
        "552": "Call the error handling routine.",
        "554": "Retrieve the carry flag.",
        "555": "Return to the calling routine.",
        "556": "This resets the zero flag. (#REGd cannot hold &FF.)",
        "557": "The #REGa register holds &00 for a header and &FF for a",
        "558": "Restore #REGd to its original value.",
        "559": "The maskable interrupt is now disabled.",
        "55a": "The border is made white.",
        "55e": "Preload the machine stack with the address #R$053F.",
        "562": "Make an initial read of port '254'.",
        "564": "Rotate the byte obtained but keep only the EAR bit.",
        "567": "Signal red border.",
        "569": "Store the value in the #REGc register (&22 for 'off' and",
        "56a": "Set the zero flag.",
        "56b": "Return if the BREAK key is being pressed.",
        "56c": "Return with the carry flag reset if there is no 'edge'",
        "56f": "within approx. 14,000 T states. But if an 'edge' is",
        "571": "The length of this waiting period will be almost one",
        "574": "second in duration.",
        "57b": "Continue only if two edges are found within the allowed",
        "57e": "time period.",
        "580": "The timing constant.",
        "582": "Continue only if two edges are found within the allowed",
        "585": "time period.",
        "587": "However the edges must have been found within about",
        "589": "3,000 T states of each other.",
        "58c": "Count the pair of edges in the #REGh register until",
        "58d": "'256' pairs have been found.",
        "58f": "The timing constant.",
        "591": "Every edge is considered until two edges are found",
        "594": "close together - these will be the start and finishing",
        "596": "edges of the 'off' sync pulse.",
        "59b": "The finishing edge of the 'on' pulse must exist.",
        "59e": "(Return carry flag reset.)",
        "59f": "The border colours from now on will be blue and yellow.",
        "5a3": "Initialise the 'parity matching' byte to zero.",
        "5a5": "Set the timing constant for the flag byte.",
        "5a7": "Jump forward into the byte loading loop.",
        "5a9": "Fetch the flags.",
        "5aa": "Jump forward only when handling the first byte.",
        "5ac": "Jump forward if verifying a tape.",
        "5ae": "Make the actual load when required.",
        "5b1": "Jump forward to load the next byte.",
        "5b3": "Keep the carry flag in a safe place temporarily.",
        "5b5": "Return now if the type flag does not match the first",
        "5b6": "byte on the tape. (Carry flag reset.)",
        "5b7": "Restore the carry flag now.",
        "5ba": "Increase the counter to compensate for its 'decrease'",
        "5bb": "after the jump.",
        "5bd": "Fetch the original byte.",
        "5c0": "Match it against the new byte.",
        "5c1": "Return if 'no match'. (Carry flag reset.)",
        "5c2": "Increase the 'destination'.",
        "5c4": "Decrease the 'counter'.",
        "5c5": "Save the flags.",
        "5c6": "Set the timing constant.",
        "5c8": "Clear the 'object' register apart from a 'marker' bit.",
        "5ca": "Find the length of the 'off' and 'on' pulses of the next",
        "5cd": "Return if the time period is exceeded. (Carry flag",
        "5ce": "Compare the length against approx. 2,400 T states,",
        "5d0": "resetting the carry flag for a '0' and setting it for a",
        "5d1": "Include the new bit in the #REGl register.",
        "5d3": "Set the timing constant for the next bit.",
        "5d5": "Jump back whilst there are still bits to be fetched.",
        "5d8": "Fetch the 'parity matching' byte and include the new",
        "5d9": "byte.",
        "5da": "Save it once again.",
        "5db": "Make a further pass if the #REGde register pair does",
        "5dc": "not hold zero.",
        "5df": "Fetch the 'parity matching' byte.",
        "5e0": "Return with the carry flag set if the value is zero.",
        "5e2": "(Carry flag reset if in error.)",
        "5e3": "In effect call #R$05E7 twice, returning in between if",
        "5e6": "there is an error.",
        "5e7": "Wait 358 T states before entering the sampling loop.",
        "5ed": "Count each pass.",
        "5ee": "Return carry reset and zero set if 'time-up'.",
        "5ef": "Read from port &7FFE, i.e. BREAK and EAR.",
        "5f3": "Shift the byte.",
        "5f4": "Return carry reset and zero reset if BREAK was pressed.",
        "5f5": "Now test the byte against the 'last edge-type'; jump",
        "5f6": "back unless it has changed.",
        "5fa": "Change the 'last edge-type' and border colour.",
        "5fd": "Keep only the border colour.",
        "5ff": "Signal 'MIC off'.",
        "601": "Change the border colour (red/cyan or blue/yellow).",
        "603": "Signal the successful search before returning.",
        "605": "Drop the address - #R$1B52.",
        "606": "Reduce  by &E0, giving &00 for",
        "609": "SAVE, &01 for LOAD, &02 for VERIFY and &03 for MERGE.",
        "60e": "Pass the parameters of the 'name' to the calculator",
        "611": "Jump forward if checking syntax.",
        "616": "Allow seventeen locations for the header of a SAVE",
        "619": "(=&00) but thirty four for the other",
        "61c": "commands.",
        "621": "The required amount of space is made in the work",
        "622": "Copy the start address to the #REGix register pair.",
        "625": "A program name can have up to ten characters but",
        "627": "first enter eleven space characters into the prepared",
        "629": "area.",
        "62d": "A null name is &FF only.",
        "631": "The parameters of the name are fetched and its length",
        "634": "This is '-10'.",
        "637": "In effect jump forward if the length of the name is",
        "638": "not too long (i.e. no more than ten characters).",
        "63c": "But allow for the LOADing, VERIFYing and MERGEing of",
        "63f": "programs (>&00) with 'null' names or",
        "640": "extra long names.",
        "642": "Call the error handling routine.",
        "644": "Jump forward if the name has a 'null' length.",
        "648": "But truncate longer names.",
        "64b": "Copy the start address to the #REGhl register pair.",
        "64e": "Step to the second location.",
        "64f": "Switch the pointers over and copy the name.",
        "652": "Is the present code the token 'DATA'?",
        "655": "Jump if not.",
        "657": "However it is not possible to have 'MERGE name DATA'",
        "65a": "(=&03).",
        "65f": "Advance .",
        "660": "Look in the variables area for the array.",
        "663": "Set bit 7 of the array's name.",
        "665": "Jump if handling an existing array.",
        "667": "Signal 'using a new array'.",
        "66a": "Consider the value in  and give an",
        "66d": "error if trying to SAVE or VERIFY a new array.",
        "670": "Call the error handling routine.",
        "672": "Note: (this fails to exclude",
        "675": "Jump forward if checking syntax.",
        "67a": "Point to the 'low length' of the variable.",
        "67b": "The low length byte goes into the work space,",
        "67c": "followed by the high length byte.",
        "684": "Step past the length bytes.",
        "685": "Copy the array's name.",
        "688": "Assume an array of numbers.",
        "68a": "Jump if it is so.",
        "68e": "It is an array of characters.",
        "68f": "Save the 'type' in the first location of the header",
        "692": "Save the pointer in #REGde.",
        "693": "Is the next character a ')'?",
        "696": "Give report C if it is not.",
        "698": "Advance .",
        "699": "Move on to the next statement if checking syntax.",
        "69c": "Return the pointer to the #REGhl register pair before",
        "69d": "jumping forward. (The pointer indicates the start of",
        "6a0": "Is the present code the token SCREEN$?",
        "6a2": "Jump if not.",
        "6a4": "However it is not possible to have 'MERGE name",
        "6a7": "SCREEN$' (=&03).",
        "6ac": "Advance .",
        "6ad": "Move on to the next statement if checking syntax.",
        "6b0": "The display area and the attribute area occupy &1B00",
        "6b4": "locations and these locations start at &4000; these",
        "6b8": "details are passed to the header area in the work",
        "6bb": "space.",
        "6c1": "Jump forward.",
        "6c3": "Is the present code the token 'CODE'?",
        "6c5": "Jump if not.",
        "6c7": "However it is not possible to have 'MERGE name CODE'",
        "6ca": "(=&03).",
        "6cf": "Advance .",
        "6d0": "Jump forward if the statement has not finished.",
        "6d5": "However it is not possible to have 'SAVE name CODE'",
        "6d8": "(=&00) by itself.",
        "6dc": "Put a zero on the calculator stack - for the 'start'.",
        "6df": "Jump forward.",
        "6e1": "Fetch the first number.",
        "6e4": "Is the present character a comma?",
        "6e7": "Jump if it is - the number was a 'starting address'.",
        "6e9": "However refuse 'SAVE name CODE' that does not have a",
        "6ec": "'start' and a 'length' (=&00).",
        "6f0": "Put a zero on the calculator stack - for the 'length'.",
        "6f3": "Jump forward.",
        "6f5": "Advance .",
        "6f6": "Fetch the 'length'.",
        "6f9": "But move on to the next statement now if checking",
        "6fc": "Compress the 'length' into the #REGbc register pair",
        "6ff": "and store it.",
        "705": "Compress the 'starting address' into the #REGbc",
        "708": "register pair and store it.",
        "70e": "Transfer the 'pointer' to the #REGhl register pair as",
        "70f": "usual.",
        "710": "Enter the 'type' number.",
        "714": "Rejoin the other pathways.",
        "716": "Is the present code the token 'LINE'?",
        "718": "Jump if it is.",
        "71a": "Move on to the next statement if checking syntax.",
        "71d": "When there are no further parameters, &80 is entered.",
        "721": "Jump forward.",
        "723": "However only allow 'SAVE name LINE number'",
        "726": "(=&00).",
        "72a": "Advance .",
        "72b": "Pass the number to the calculator stack.",
        "72e": "Move on to the next statement if checking syntax.",
        "731": "Compress the 'line number' into the #REGbc register",
        "734": "pair and store it.",
        "73a": "Enter the 'type' number.",
        "73e": "The pointer to the end of the variables area",
        "741": "The pointer to the start of the BASIC program",
        "745": "Now perform the subtraction to find the length of the",
        "746": "'program + variables'; store the result.",
        "74e": "Repeat the operation but this time storing the length",
        "751": "of the 'program' only (-).",
        "759": "Transfer the 'pointer' to the #REGhl register pair as",
        "75a": "Jump forward when handling a SAVE command",
        "75d": "(=&00).",
        "761": "Save the 'destination' pointer.",
        "762": "Form in the #REGix register pair the base address of",
        "765": "the 'second header area'.",
        "767": "Make a copy of the base address.",
        "769": "LOAD seventeen bytes.",
        "76c": "Signal 'header'.",
        "76d": "Signal 'LOAD'.",
        "76e": "Now look for a header.",
        "771": "Retrieve the base address.",
        "773": "Go round the loop until successful.",
        "775": "Ensure that channel 'S' is open.",
        "77a": "Set the scroll counter ().",
        "77e": "Signal 'names do not match'.",
        "780": "Compare the 'new' type against the 'old' type.",
        "786": "Jump if the 'types' do not match.",
        "788": "But if they do, signal 'ten characters are to match'.",
        "78a": "Clearly the 'header' is nonsense if 'type 4 or more'.",
        "78e": "The base address of the #R$09C1(message block).",
        "791": "Save the #REGc register whilst the appropriate",
        "792": "message is printed.",
        "796": "Make the #REGde register pair point to the 'new name'",
        "798": "and the #REGhl register pair to the 'old name'.",
        "79d": "Ten characters are to be considered.",
        "79f": "Jump forward if the match is to be against an actual",
        "7a0": "name.",
        "7a3": "But if the 'old name' is 'null' then signal 'ten",
        "7a4": "characters already match'.",
        "7a6": "Consider each character of the 'new name' in turn.",
        "7a8": "Match it against the appropriate character of the",
        "7a9": "'old name'.",
        "7aa": "Do not count it if it does not does not match.",
        "7ad": "Print the 'new' character.",
        "7ae": "Loop for ten characters.",
        "7b0": "Accept the name only if the counter has reached zero.",
        "7b4": "Follow the 'new name' with a 'carriage return'.",
        "7b7": "Fetch the pointer.",
        "7b8": "'SCREEN$' and 'CODE' are handled with VERIFY.",
        "7bf": "Jump forward if using a LOAD command",
        "7c2": "(=&01).",
        "7c6": "Jump forward if using a MERGE command; continue into",
        "7c8": "#R$07CB with a VERIFY command.",
        "7cb": "Save the 'pointer'.",
        "7cc": "Fetch the 'number of bytes' as described in the 'old'",
        "7cf": "header.",
        "7d2": "Fetch also the number from the 'new' header.",
        "7d8": "Jump forward if the 'length' is unspecified, e.g. 'LOAD",
        "7d9": "name CODE' only.",
        "7dc": "Give report R if attempting to load a larger block than",
        "7de": "has been requested.",
        "7e0": "Accept equal 'lengths'.",
        "7e2": "Also give report R if trying to verify blocks that are",
        "7e5": "of unequal size. ('Old length' greater than 'new",
        "7e7": "length'.)",
        "7e9": "Fetch the 'pointer', i.e. the 'start'.",
        "7ea": "This 'pointer' will be used unless it is zero, in which",
        "7eb": "case the 'start' found in the 'new' header will be used",
        "7ec": "instead.",
        "7f4": "Move the 'pointer' to the #REGix register pair.",
        "7f7": "Jump forward unless using the VERIFY command",
        "7fa": "(=&02), with the carry flag signalling",
        "7fc": "'LOAD'.",
        "7ff": "Signal 'VERIFY'.",
        "800": "Signal 'accept data block only' before loading the",
        "802": "Load/verify a data block.",
        "805": "Return unless an error.",
        "806": "Call the error handling routine.",
        "808": "Fetch the 'number of bytes' as given in the 'new",
        "80b": "header'.",
        "80e": "Save the 'destination pointer'.",
        "80f": "Jump forward unless trying to LOAD a previously",
        "810": "undeclared array.",
        "813": "Add three bytes to the length - for the name, the low",
        "814": "length and the high length of a new variable.",
        "817": "Jump forward.",
        "819": "Fetch the size of the existing 'program+variables or",
        "81c": "array'.",
        "820": "Jump forward if no extra room will be required",
        "821": "(taking into account the reclaiming of the presently",
        "823": "used memory).",
        "825": "Allow an overhead of five bytes.",
        "829": "Move the result to the #REGbc register pair and make",
        "82a": "the test.",
        "82e": "Fetch the 'pointer' anew.",
        "82f": "Jump forward if LOADing a BASIC program.",
        "835": "Jump forward if LOADing a new array.",
        "839": "Fetch the 'length' of the existing array by",
        "83a": "collecting the length bytes from the variables area.",
        "83d": "Point to its old name.",
        "83e": "Add three bytes to the length - one for the name and",
        "83f": "two for the 'length'.",
        "841": "Save the #REGix register pair temporarily (in",
        "845": ") whilst the old array is reclaimed.",
        "84c": "Find the pointer to the end-marker of the variables",
        "84f": "area - the '&80-byte' ().",
        "850": "Fetch the 'length' of the new array.",
        "856": "Save this 'length'.",
        "857": "Add three bytes - one for the name and two for the",
        "858": "'length'.",
        "85a": "'#REGix+0E' of the old header gives the name of the",
        "85d": "The name is saved whilst the appropriate amount of",
        "85e": "room is made available. In effect #REGbc spaces before",
        "861": "the 'new &80-byte'.",
        "863": "The name is entered.",
        "864": "The 'length' is fetched and its two bytes are also",
        "865": "entered.",
        "869": "#REGhl now points to the first location that is to be",
        "86a": "This address is moved to the #REGix register pair;",
        "86b": "the carry flag set; 'data block' is signalled; and the",
        "86d": "block LOADed.",
        "873": "Save the 'destination pointer'.",
        "874": "Find the address of the end marker of the current",
        "877": "variables area - the '&80-byte' ().",
        "878": "Save #REGix temporarily (in ).",
        "87c": "Fetch the 'length' of the new data block.",
        "882": "Keep a copy of the 'length' whilst the present",
        "883": "program and variables areas are reclaimed.",
        "887": "Save the pointer to the program area and the length",
        "888": "of the new data block.",
        "889": "Make sufficient room available for the new program and",
        "88c": "Restore the #REGix register pair from .",
        "890": "The system variable  has also to be set",
        "891": "for the new program.",
        "89b": "If a line number was specified then it too has to be",
        "89e": "considered.",
        "8a1": "Jump if 'no number'; otherwise set ",
        "8a3": "and .",
        "8ad": "Fetch the 'length'.",
        "8ae": "Fetch the 'start'.",
        "8b0": "Signal 'LOAD'.",
        "8b1": "Signal 'data block' only.",
        "8b3": "Now LOAD it.",
        "8b6": "Fetch the 'length' of the data block.",
        "8bc": "Save a copy of the 'length'.",
        "8bd": "Now make 'length+1' locations available in the work",
        "8be": "space.",
        "8bf": "Place an end marker in the extra location.",
        "8c1": "Move the 'start' pointer to the #REGhl register pair.",
        "8c2": "Fetch the original 'length'.",
        "8c3": "Save a copy of the 'start'.",
        "8c4": "Now set the #REGix register pair for the actual load.",
        "8c7": "Signal 'LOAD'.",
        "8c8": "Signal 'data block only'.",
        "8ca": "Load the data block.",
        "8cd": "Fetch the 'start' of the new program.",
        "8ce": "Initialise #REGde to the 'start' of the old program",
        "8d2": "Fetch a line number and test it.",
        "8d5": "Jump when finished with all the lines.",
        "8d7": "Fetch the high line number byte and compare it. Jump",
        "8d8": "forward if it does not match but in any case advance",
        "8d9": "both pointers.",
        "8dd": "Repeat the comparison for the low line number bytes.",
        "8df": "Now retreat the pointers.",
        "8e1": "Jump forward if the correct place has been found for a",
        "8e3": "Otherwise find the address of the start of the next old",
        "8e4": "line.",
        "8e9": "Go round the loop for each of the 'old lines'.",
        "8eb": "Enter the 'new line' and go round the outer loop again.",
        "8f0": "Fetch each variable name in turn and test it.",
        "8f2": "Return when all the variables have been considered.",
        "8f5": "Save the current new pointer.",
        "8f6": "Fetch  (for the old program).",
        "8f9": "Fetch each variable name and test it.",
        "8fc": "Jump forward once the end marker is found. (Make an",
        "8fe": "Compare the names (first bytes).",
        "8ff": "Jump forward to consider it further, returning here if",
        "901": "Save the new variable's name whilst the next 'old",
        "902": "variable' is located.",
        "906": "Restore the pointer to the #REGde register pair and go",
        "907": "round the loop again.",
        "909": "Consider bits 7, 6 and 5 only.",
        "90b": "Accept all the variable types except 'long named",
        "90d": "variables'.",
        "90f": "Make #REGde point to the first character of the 'new",
        "910": "name'.",
        "911": "Save the pointer to the 'old name'.",
        "912": "Update both the 'old' and the 'new' pointers.",
        "914": "Compare the two letters.",
        "916": "Jump forward if the match fails.",
        "918": "Go round the loop until the 'last character' is found.",
        "91b": "Fetch the pointer to the start of the 'old' name and",
        "91c": "jump forward - successful.",
        "91e": "Fetch the pointer and jump back - unsuccessful.",
        "921": "Signal 'replace' variable.",
        "923": "Fetch pointer to 'new' name.",
        "924": "Switch over the registers.",
        "925": "The zero flag is to be set if there is to be a",
        "926": "Signal 'handling variables'.",
        "927": "Now make the entry.",
        "92a": "Go round the loop to consider the next new variable.",
        "92c": "Jump if handling an 'addition'.",
        "92e": "Save the flags.",
        "92f": "Save the 'new' pointer (in ) whilst the",
        "932": "'old' line or variable is reclaimed.",
        "93d": "Restore the flags.",
        "93e": "Save the flags.",
        "93f": "Make a copy of the 'destination' pointer.",
        "940": "Find the length of the 'new' variable/line.",
        "943": "Save the pointer to the 'new' variable/line (in",
        "946": "Fetch  - to avoid corruption.",
        "949": "Save  on the stack and fetch the 'new'",
        "94a": "Save the length.",
        "94b": "Retrieve the flags.",
        "94c": "Jump forward if adding a new variable.",
        "94e": "A new line is added before the 'destination' location.",
        "94f": "Make the room for the new line.",
        "953": "Jump forward.",
        "955": "Make the room for the new variable.",
        "958": "Point to the first new location.",
        "959": "Retrieve the length.",
        "95a": "Retrieve  and store it in its correct",
        "95b": "place.",
        "95f": "Also fetch the 'new' pointer (from ).",
        "963": "Again save the length and the 'new' pointer.",
        "965": "Switch the pointers and copy the 'new' variable/line",
        "966": "into the room made for it.",
        "968": "Fetch the 'new' pointer.",
        "969": "Fetch the length.",
        "96a": "Save the 'old' pointer. (Points to the location after",
        "96b": "Remove the variable/line from the work space.",
        "96e": "Return with the 'old' pointer in the #REGde register",
        "96f": "pair.",
        "970": "Save the 'pointer'.",
        "971": "Ensure that channel 'K' is open.",
        "976": "Signal 'first message'.",
        "977": "Print the message 'Start tape, then press any key.'",
        "97a": "(see #R$09A1).",
        "97d": "Signal 'screen will require to be cleared' (set bit 5",
        "981": "Wait for a key to be pressed.",
        "984": "Save the base address of the 'header' on the machine",
        "986": "Seventeen bytes are to be saved.",
        "989": "Signal 'it is a header'.",
        "98a": "Send the 'header', with a leading 'type' byte and a",
        "98d": "Retrieve the pointer to the 'header'.",
        "98f": "The delay is for fifty interrupts, i.e. one second.",
        "994": "Fetch the length of the data block that is to be",
        "997": "saved.",
        "99a": "Signal 'data block'.",
        "99c": "Fetch the 'start of block pointer' and save the block.",
        "9a1": "Initial byte is stepped",
        "9a2": "'Start tape, then press",
        "9c1": "Carriage return +",
        "9cb": "Carriage return +",
        "9da": "Carriage return +",
        "9ec": "Carriage return +",
        "9f4": "The current print position.",
        "9f7": "If the code represents a printable character then jump.",
        "9fc": "Print a question mark for codes in the range &00 to",
        "9fe": "&05.",
        "a00": "And also for codes &18 to &1F.",
        "a04": "Base of the #R$0A11(control character table).",
        "a07": "Move the code to the #REGde register pair.",
        "a0a": "Index into the table and fetch the offset.",
        "a0c": "Add the offset and make an indirect jump to the",
        "a0d": "appropriate subroutine.",
        "a11": "&06: PRINT comma (#R$0A5F)",
        "a12": "&07: EDIT (#R$0A69)",
        "a13": "&08: Cursor left (#R$0A23)",
        "a14": "&09: Cursor right (#R$0A3D)",
        "a15": "&0A: Cursor down (#R$0A69)",
        "a16": "&0B: Cursor up (#R$0A69)",
        "a17": "&0C: DELETE (#R$0A69)",
        "a18": "&0D: ENTER (#R$0A4F)",
        "a19": "&0E: Not used (#R$0A69)",
        "a1a": "&0F: Not used (#R$0A69)",
        "a1b": "&10: INK control (#R$0A7A)",
        "a1c": "&11: PAPER control (#R$0A7A)",
        "a1d": "&12: FLASH control (#R$0A7A)",
        "a1e": "&13: BRIGHT control (#R$0A7A)",
        "a1f": "&14: INVERSE control (#R$0A7A)",
        "a20": "&15: OVER control (#R$0A7A)",
        "a21": "&16: AT control (#R$0A75)",
        "a22": "&17: TAB control (#R$0A75)",
        "a23": "Move leftwards by one column.",
        "a24": "Accept the change unless up against the lefthand side.",
        "a29": "If dealing with the printer (bit 1 of ",
        "a2d": "set) jump forward.",
        "a2f": "Go up one line.",
        "a30": "Set column value.",
        "a32": "Test against top line. Note: (this",
        "a34": "ought to be &19).",
        "a35": "Accept the change unless at the top of the screen.",
        "a37": "Unacceptable so down a line.",
        "a38": "Set to lefthand column.",
        "a3a": "Make an indirect return via #R$0DD9 and #R$0ADC.",
        "a3d": "Fetch  and save it on the machine",
        "a40": "stack.",
        "a41": "Set  to OVER 1.",
        "a45": "A 'space'.",
        "a47": "Print the character.",
        "a4a": "Fetch the old value of .",
        "a4e": "Finished. Note: the programmer has forgotten to exit",
        "a4f": "Jump if handling the printer (bit 1 of ",
        "a53": "set).",
        "a56": "Set to lefthand column.",
        "a58": "Scroll if necessary.",
        "a5b": "Now down a line.",
        "a5c": "Make an indirect return via #R$0DD9 and #R$0ADC.",
        "a5f": "Why again?",
        "a62": "Current column number.",
        "a63": "Move rightwards by two columns and then test.",
        "a65": "The #REGa register will be &00 or &10.",
        "a67": "Exit via #R$0AC3.",
        "a69": "The character '?'.",
        "a6b": "Now print this character instead.",
        "a6d": "Save the first operand in  and",
        "a70": "change the address of the 'output' routine to #R$0A87.",
        "a75": "The character code will be saved in ",
        "a78": "and the address of the 'output' routine changed to",
        "a7a": "The 'output' routine is to be changed to #R$0A87.",
        "a7d": "Save the control character code in .",
        "a80": "#REGhl will point to the 'output' routine address",
        "a83": "Enter the new 'output' routine address and thereby",
        "a84": "force the next character code to be considered as an",
        "a85": "operand.",
        "a87": "Restore the original address for #R$09F4.",
        "a8d": "Fetch the control code and the first operand from",
        "a90": "The 'last' operand and the control code are moved.",
        "a92": "Jump forward if handling INK to OVER.",
        "a97": "Jump forward if handling TAB.",
        "a99": "The line number.",
        "a9a": "The column number.",
        "a9b": "Reverse the column number, i.e. &00 to &1F becomes &1F",
        "a9d": "to &00.",
        "a9e": "Must be in range.",
        "aa0": "Add in the offset to give #REGc holding &21 to &02.",
        "aa3": "Jump forward if handling the printer (bit 1 of",
        "aa7": " set).",
        "aa9": "Reverse the line number, i.e. &00 to &15 becomes &16",
        "aab": "to &01.",
        "aac": "If appropriate jump forward.",
        "aaf": "The range &16 to &01 becomes &17 to &02.",
        "ab1": "And now &18 to &03.",
        "ab2": "If printing in the lower part of the screen (bit 0 of",
        "ab6": " set) then consider whether scrolling",
        "ab9": "Give report 5 - Out of screen, if required",
        "abc": "(>#REGa).",
        "abf": "Return via #R$0DD9 and #R$0ADC.",
        "ac2": "Fetch the first operand.",
        "ac3": "The current print position.",
        "ac6": "Add the current column value.",
        "ac7": "Find how many spaces, modulo 32, are required and",
        "ac8": "return if the result is zero.",
        "acb": "Use #REGd as the counter.",
        "acc": "Suppress 'leading space' (set bit 0 of ).",
        "ad0": "Print #REGd number of spaces.",
        "ad8": "Now finished.",
        "ad9": "Print the character(s) and continue into #R$0ADC.",
        "adc": "Jump forward if handling the printer (bit 1 of",
        "ae0": " set).",
        "ae2": "Jump forward if handling the lower part of the screen",
        "ae6": "(bit 0 of  set).",
        "ae8": "Save the values that relate to the main part of the",
        "aec": "screen at  and .",
        "aef": "Then return.",
        "af0": "Save the values that relate to the lower part of the",
        "af4": "screen at ,  and",
        "af8": ".",
        "afb": "Then return.",
        "afc": "Save the values that relate to the printer buffer at",
        "aff": " and .",
        "b02": "Then return.",
        "b03": "Jump forward if handling the printer (bit 1 of",
        "b07": " set).",
        "b09": "Fetch the values relating to the main part of the",
        "b0d": "screen from  and  and",
        "b10": "return if this was the intention (bit 0 of",
        "b14": " set).",
        "b15": "Otherwise fetch the values relating to the lower part",
        "b19": "of the screen from  and",
        "b1d": "Fetch the values relating to the printer buffer from",
        "b20": " and .",
        "b24": "Jump forward with ordinary character codes.",
        "b28": "Jump forward with token codes and UDG codes.",
        "b2c": "Move the graphic code.",
        "b2d": "Construct the graphic form.",
        "b30": "#REGhl has been disturbed so 'fetch' again.",
        "b33": "Make #REGde point to the start of the graphic form,",
        "b36": "Jump forward to print the graphic character.",
        "b38": "This is .",
        "b3b": "In effect call the following subroutine twice.",
        "b3e": "Determine bit 0 (and later bit 2) of the graphic code.",
        "b41": "The #REGa register will hold &00 or &0F depending on",
        "b43": "Save the result in #REGc.",
        "b44": "Determine bit 1 (and later bit 3) of the graphic code.",
        "b47": "The #REGa register will hold &00 or &F0.",
        "b49": "The two results are combined.",
        "b4a": "The #REGa register holds half the character form and",
        "b4c": "has to be used four times. This is done for the upper",
        "b4d": "half of the character form and then the lower.",
        "b52": "Jump forward with token codes.",
        "b56": "UDG codes are now &00 to &0F.",
        "b58": "Save the current position values on the machine stack.",
        "b59": "Fetch the base address of the UDG area (from",
        "b5d": ") and jump forward.",
        "b5f": "Now print the token and return via #R$0B03.",
        "b65": "The current position is saved.",
        "b66": "The base address of the character area is fetched",
        "b6a": "The print address is saved.",
        "b6b": "This is .",
        "b6e": "Allow for a leading space.",
        "b70": "Jump forward if the character is not a 'space'.",
        "b74": "But 'suppress' if it is.",
        "b76": "Now pass the character code to the #REGhl register",
        "b78": "pair.",
        "b79": "The character code is in effect multiplied by 8.",
        "b7c": "The base address of the character form is found.",
        "b7d": "The current position is fetched and the base address",
        "b7e": "passed to the #REGde register pair.",
        "b7f": "Fetch the column number.",
        "b80": "Move one column rightwards.",
        "b81": "Jump forward unless a new line is indicated.",
        "b85": "Move down one line.",
        "b86": "Column number is &21.",
        "b87": "Jump forward if handling the screen (bit 1 of",
        "b8b": " reset).",
        "b8d": "Save the base address whilst the printer buffer is",
        "b8e": "emptied.",
        "b92": "Copy the new column number.",
        "b93": "Test whether a new line is being used. If it is see if",
        "b94": "the display requires to be scrolled.",
        "b99": "Save the position values and the destination address",
        "b9a": "on the machine stack.",
        "b9b": "Fetch  and read bit 0.",
        "b9e": "Prepare the 'OVER mask' in the #REGb register, i.e.",
        "ba0": "OVER 0=&00 and OVER 1=&FF.",
        "ba4": "Read bit 2 of  and prepare the 'INVERSE",
        "ba5": "mask' in the #REGc register, i.e. INVERSE 0=&00 and",
        "ba6": "INVERSE 1=&FF.",
        "ba8": "Set the #REGa register to hold the 'pixel-line'",
        "baa": "counter and clear the carry flag.",
        "bab": "Jump forward if handling the screen (bit 1 of",
        "baf": " reset).",
        "bb1": "Signal 'printer buffer no longer empty' (set bit 1 of",
        "bb5": "Set the carry flag to show that the printer is being",
        "bb6": "Exchange the destination address with the base address",
        "bb7": "The carry flag is set when using the printer. Save this",
        "bb8": "Fetch the existing 'pixel-line'.",
        "bb9": "Use the 'OVER mask' and then '#S/XOR/' the result with",
        "bba": "the 'pixel-line' of the character form.",
        "bbb": "Finally consider the 'INVERSE mask'.",
        "bbc": "Enter the result.",
        "bbd": "Fetch the printer flag and jump forward if required.",
        "bc0": "Update the destination address.",
        "bc1": "Update the 'pixel-line' address of the character form.",
        "bc2": "Decrease the counter and loop back unless it is zero.",
        "bc5": "Make the #REGh register hold a correct high-address",
        "bc6": "for the character area.",
        "bc7": "Set the attribute byte only if handling the screen",
        "bcb": "(bit 1 of  reset).",
        "bce": "Restore the original destination address and the",
        "bcf": "position values.",
        "bd0": "Decrease the column number and increase the",
        "bd1": "destination address before returning.",
        "bd3": "Save the printer flag again.",
        "bd4": "The required increment value.",
        "bd6": "Add the value and pass the result back to the #REGe",
        "bd7": "register.",
        "bd8": "Fetch the flag.",
        "bd9": "Jump back into the loop.",
        "bdb": "The high byte of the destination address is divided by",
        "bdc": "eight and #S/AND/ed with &03 to determine which third",
        "bdd": "of the screen is being addressed, i.e. &00, &01 or &02.",
        "be1": "The high byte for the attribute area is then formed.",
        "be4": "#REGe holds , and #REGd holds",
        "be8": "The old attribute value.",
        "be9": "The values of  and  are",
        "bea": "taken into account.",
        "bec": "Jump forward unless dealing with PAPER 9 (bit 6 of",
        "bf0": " set).",
        "bf2": "The old paper colour is ignored and depending on",
        "bf4": "whether the ink colour is light or dark the new paper",
        "bf6": "colour will be black (000) or white (111).",
        "bfa": "Jump forward unless dealing with INK 9 (bit 4 of",
        "bfe": " set).",
        "c00": "The old ink colour is ignored and depending on whether",
        "c02": "the paper colour is light or dark the new ink colour",
        "c04": "will be black (000) or white (111).",
        "c08": "Enter the new attribute value and return.",
        "c0a": "The high byte of the last entry on the machine stack",
        "c0b": "is made zero so as to suppress trailing spaces (see",
        "c0d": "below).",
        "c0e": "Jump forward.",
        "c10": "The base address of the #R$0095(token table).",
        "c13": "Save the code on the stack. (Range &00 to &5A, RND to",
        "c14": "Locate the required entry.",
        "c17": "Print the message/token.",
        "c19": "A 'space' will be printed before the message/token if",
        "c1b": "required (bit 0 of  reset).",
        "c22": "Collect a code.",
        "c23": "Cancel any 'inverted bit'.",
        "c25": "Print the character.",
        "c28": "Collect the code again.",
        "c29": "Advance the pointer.",
        "c2a": "The 'inverted bit' goes to the carry flag and signals",
        "c2b": "the end of the message/token; otherwise jump back.",
        "c2d": "For messages, #REGd holds &00; for tokens, #REGd holds",
        "c2e": "Jump forward if the last character was a '$'.",
        "c32": "Return if the last character was any other before 'A'.",
        "c35": "Examine the value in #REGd and return if it indicates",
        "c36": "a message, RND, INKEY$ or PI.",
        "c39": "All other cases will require a 'trailing space'.",
        "c3b": "Save the #REGde register pair.",
        "c3c": "Save #REGhl and #REGbc.",
        "c3d": "Print the single character.",
        "c3e": "Restore #REGhl and #REGbc.",
        "c3f": "Restore #REGde.",
        "c40": "Finished.",
        "c41": "Save the 'entry number'.",
        "c42": "#REGhl now holds the base address.",
        "c43": "Compensate for the '#S/DEC A/' below.",
        "c44": "Wait for an 'inverted character'.",
        "c49": "Count through the entries until the correct one is",
        "c4a": "found.",
        "c4c": "#REGde points to the initial character.",
        "c4d": "Fetch the 'entry number' and return with carry set for",
        "c4e": "the first thirty two entries.",
        "c51": "However if the initial character is a letter then a",
        "c52": "leading space may be needed.",
        "c55": "Return immediately if the printer is being used (bit 1",
        "c59": "of  set).",
        "c5a": "Pre-load the machine stack with the address of",
        "c5d": "#R$0DD9.",
        "c5e": "Transfer the line number.",
        "c5f": "Jump forward if considering 'INPUT ... AT ...' (bit 0",
        "c63": "of  set).",
        "c66": "Return, via #R$0DD9, if the line number is greater",
        "c69": "than the value of ; give report 5 if it",
        "c6b": "is less; otherwise continue.",
        "c6c": "Jump forward unless dealing with an 'automatic",
        "c70": "listing' (bit 4 of  set).",
        "c72": "Fetch the line counter from .",
        "c75": "Decrease this counter.",
        "c76": "Jump forward if the listing is to be scrolled.",
        "c78": "Otherwise open channel 'K', restore the stack pointer,",
        "c7a": "flag that the automatic listing has finished (reset bit",
        "c7d": "4 of ) and return via #R$0DD9.",
        "c86": "Call the error handling routine.",
        "c88": "Decrease the scroll counter () and",
        "c8b": "proceed to give the prompt only if it becomes zero.",
        "c8d": "The scroll counter () is reset.",
        "c93": "The current values of  and",
        "c96": " are saved.",
        "c97": "The current value of  is saved.",
        "c9b": "Channel 'K' is opened.",
        "ca0": "The message 'scroll?' is message '0'. This message is",
        "ca1": "now printed.",
        "ca7": "Signal 'clear the lower screen after a keystroke' (set",
        "cab": "This is .",
        "cae": "Signal 'L mode'.",
        "cb0": "Signal 'no key yet'.",
        "cb2": "Note: #REGde (should be pushed",
        "cb3": "Fetch a single key code.",
        "cb6": "Restore the registers.",
        "cb7": "There is a jump forward to #R$0D00 - 'BREAK - CONT",
        "cb9": "repeats' - if the keystroke was 'BREAK', 'STOP', 'N' or",
        "cbb": "'n'; otherwise accept the keystroke as indicating the",
        "cbd": "need to scroll the display.",
        "cc5": "Open channel 'S'.",
        "cca": "Restore the value of .",
        "cce": "Restore the values of  and",
        "ccf": ".",
        "cd2": "The whole display is scrolled.",
        "cd5": "The line () and column numbers for the",
        "cd8": "start of the line above the lower part of the display",
        "cd9": "are found and saved.",
        "cdc": "The corresponding attribute byte for this character",
        "cdf": "area is then found. The #REGhl register pair holds the",
        "ce0": "address of the byte.",
        "ce8": "#REGde points to the first attribute byte of the bottom",
        "ceb": "The value is fetched.",
        "cec": "The 'lower part' value.",
        "ced": "There are thirty two bytes.",
        "cef": "Exchange the pointers.",
        "cf0": "Make the first exchange and then proceed to use the",
        "cf1": "same values for the thirty two attribute bytes of the",
        "cf2": "two lines being handled.",
        "cf6": "The line and column numbers of the bottom line of the",
        "cf7": "'upper part' are fetched before returning.",
        "cf8": "Initial marker - stepped over.",
        "cff": "The '?' is inverted.",
        "d00": "Call the error handling routine.",
        "d02": "The 'out of screen' error is given if the lower part",
        "d04": "is going to be 'too large' (see ) and a",
        "d06": "return made if scrolling is unnecessary.",
        "d0c": "The #REGa register will now hold 'the number of scrolls",
        "d0e": "The line and column numbers are now saved.",
        "d0f": "The 'scroll number', , ",
        "d10": "and  are all saved.",
        "d18": "The 'permanent' colour items are to be used.",
        "d1b": "The 'scroll number' is fetched.",
        "d1c": "Save the 'number'.",
        "d1d": "This is .",
        "d20": "The value in  is incremented; the #REGb",
        "d21": "register set to hold the former value and the #REGa",
        "d22": "register the new value.",
        "d24": "This is .",
        "d27": "The jump is taken if only the lower part of the",
        "d28": "display is to be scrolled (#REGb=old ).",
        "d2a": "Otherwise  is incremented and the",
        "d2b": "whole display scrolled (#REGb=&18).",
        "d2d": "Scroll #REGb lines.",
        "d30": "Fetch and decrement the 'scroll number'.",
        "d32": "Jump back until finished.",
        "d34": "Restore the value of .",
        "d38": "Restore the values of  and",
        "d39": ".",
        "d3c": "In case  has been changed #R$0DD9 is",
        "d40": "called to give a matching value to ",
        "d44": "(after resetting bit 0 of ).",
        "d47": "Set bit 0 of  to indicate that the",
        "d4b": "lower screen is being handled, fetch the line and",
        "d4c": "column numbers, and then return.",
        "d4d": "#REGa is set to hold &00.",
        "d4e": "The current values of  and",
        "d51": "Jump forward if handing the main part of the screen",
        "d55": "(bit 0 of  reset).",
        "d57": "Otherwise use &00 and the value in ",
        "d58": "instead.",
        "d5b": "Now set  and .",
        "d5e": "This is .",
        "d61": "Jump forward if dealing with the lower part of the",
        "d63": "Otherwise fetch the value of  and move",
        "d64": "the odd bits to the even bits.",
        "d65": "Proceed to copy the even bits of #REGa to",
        "d66": ".",
        "d6b": "The whole of the display is 'cleared'.",
        "d6e": "This is .",
        "d71": "Signal 'do not clear the lower screen after",
        "d73": "Signal 'lower part'.",
        "d75": "Use the permanent values, i.e.  is",
        "d78": "The lower part of the screen is now 'cleared' with",
        "d7b": "these values (#REGb=).",
        "d7e": "Attribute byte at start of line 22.",
        "d81": "Fetch .",
        "d84": "The line counter.",
        "d85": "Jump forward into the loop.",
        "d87": "&20 characters per line.",
        "d89": "Go back along the line setting the attribute bytes.",
        "d8e": "Loop back until finished.",
        "d90": "It will be two lines in size ().",
        "d94": "Open channel 'K'.",
        "d99": "Fetch the address of the current channel",
        "d9c": "() and make the output address #R$09F4",
        "d9f": "and the input address #R$10A8.",
        "da7": "First the output address then the input address.",
        "daa": "As the lower part of the display is being handled the",
        "dad": "Return via #R$0DD9.",
        "daf": "The system variable  is reset to zero.",
        "db5": "Signal 'the screen is clear' (reset bit 0 of",
        "db9": "Perform the 'house keeping' tasks.",
        "dbc": "Open channel 'S'.",
        "dc1": "Use the 'permanent' values.",
        "dc4": "Now 'clear' the 24 lines of the display.",
        "dc9": "Ensure that the current output address (at",
        "dcc": "()) is #R$09F4.",
        "dd2": "Reset the scroll counter ().",
        "dd6": "As the upper part of the display is being handled the",
        "dd9": "The start of the printer buffer.",
        "ddc": "Jump forward if handling the printer buffer (bit 1 of",
        "de0": " set).",
        "de2": "Transfer the line number.",
        "de3": "Jump forward if handling the main part of the display",
        "de7": "(bit 0 of  reset).",
        "de9": "The top line of the lower part of the display is",
        "dec": "called 'line &18' and this has to be converted (see",
        "dee": "The line and column numbers are saved.",
        "def": "The line number is moved.",
        "df0": "The address for the start of the line is formed in",
        "df3": "The line and column numbers are fetched back.",
        "df4": "The column number is now reversed and transferred to",
        "df6": "the #REGde register pair.",
        "dfa": "The required address is now formed, and the address",
        "dfb": "and the line and column numbers are stored by jumping",
        "dfe": "The entry point after 'scroll?'",
        "e00": "Find the starting address of the line.",
        "e03": "There are eight pixel lines to a complete line.",
        "e05": "Save both counters.",
        "e06": "Save the starting address.",
        "e07": "Jump forward unless dealing at the present moment with",
        "e08": "a 'third' of the display.",
        "e0d": "The result of this manipulation is to leave #REGhl",
        "e0e": "unchanged and #REGde pointing to the required",
        "e11": "destination.",
        "e13": "There are &20 characters.",
        "e16": "Decrease the counter as one line is being dealt with.",
        "e17": "Now move the thirty two bytes.",
        "e19": "Again #REGde is made to point to the required",
        "e1a": "destination, this time only thirty two locations away.",
        "e1f": "Save the line number in #REGb.",
        "e20": "Now find how many characters there are remaining in the",
        "e22": "'third'.",
        "e25": "Pass the 'character total' to the #REGc register.",
        "e26": "Fetch the line number.",
        "e27": "#REGbc holds the 'character total' and a pixel line",
        "e29": "from each of the characters is 'scrolled'.",
        "e2b": "Now prepare to increment the address to jump across a",
        "e2d": "Increase #REGhl by &0700.",
        "e2e": "Jump back if there are any 'thirds' left to consider.",
        "e32": "Fetch the original address.",
        "e33": "Address the next pixel line.",
        "e34": "Fetch the counters.",
        "e35": "Decrease the pixel line counter and jump back unless",
        "e36": "eight lines have been moved.",
        "e38": "The required address in the attribute area and the",
        "e3b": "The displacement for all the attribute bytes is thirty",
        "e3e": "two locations away.",
        "e40": "The attribute bytes are 'scrolled'.",
        "e42": "The #REGb register is loaded with &01 and #R$0E44 is",
        "e44": "The line number is saved for the duration of the",
        "e45": "The starting address for the line is formed in #REGhl.",
        "e48": "Again there are eight pixel lines to be considered.",
        "e4a": "Save the line number and the pixel line counter.",
        "e4b": "Save the address.",
        "e4c": "Save the line number in #REGa.",
        "e4d": "Find how many characters are involved in '#REGb mod 8'",
        "e4f": "lines. Pass the result to the #REGc register. (#REGc",
        "e50": "will hold &00, i.e. 256, for a 'third'.)",
        "e53": "Fetch the line number.",
        "e54": "Make the #REGbc register pair hold one less than the",
        "e56": "number of characters.",
        "e57": "Make #REGde point to the first character.",
        "e59": "Clear the pixel-byte of the first character.",
        "e5b": "Make #REGde point to the second character and then",
        "e5c": "clear the pixel-bytes of all the other characters.",
        "e5e": "For each 'third' of the display #REGhl has to be",
        "e61": "increased by &0701.",
        "e62": "Now decrease the line number.",
        "e63": "Discard any extra lines and pass the 'third' count to",
        "e65": "#REGb.",
        "e66": "Jump back if there are still 'thirds' to be dealt with.",
        "e68": "Update the address for each pixel line.",
        "e6a": "Fetch the counters.",
        "e6b": "Decrease the pixel line counter and jump back unless",
        "e6c": "finished.",
        "e6e": "The address of the first attribute byte and the number",
        "e71": "#REGhl will point to the first attribute byte and",
        "e72": "#REGde the second.",
        "e74": "Fetch the value in .",
        "e77": "Jump forward if handling the main part of the screen",
        "e7b": "(bit 0 of  reset).",
        "e7d": "Otherwise use  instead.",
        "e80": "Set the attribute byte.",
        "e81": "One byte has been done.",
        "e82": "Now copy the value to all the attribute bytes.",
        "e84": "Restore the line number.",
        "e85": "Set the column number to the lefthand column and",
        "e87": "return.",
        "e88": "Fetch the high byte.",
        "e89": "Multiply this value by thirty two.",
        "e8c": "Go back to the 'eight' line.",
        "e8d": "Address the attribute area.",
        "e8f": "Restore to the high byte and transfer the address to",
        "e90": "#REGde.",
        "e91": "This is always zero.",
        "e92": "The line number.",
        "e93": "Multiply by thirty two.",
        "e98": "Move the result to the #REGbc register pair before",
        "e99": "returning.",
        "e9b": "The line number has to be reversed.",
        "e9e": "The result is saved in #REGd.",
        "e9f": "In effect '(#REGa mod 8)*32'. In a 'third' of the",
        "ea0": "display the low byte for the first line is &00, for the",
        "ea1": "second line &20, etc.",
        "ea4": "The low byte goes into #REGl.",
        "ea5": "The true line number is fetched.",
        "ea6": "In effect '64+8*INT (#REGa/8)'. For the upper 'third'",
        "ea8": "of the display the high byte is &40, for the middle",
        "eaa": "The high byte goes to #REGh.",
        "eab": "Finished.",
        "eac": "The maskable interrupt is disabled during COPY.",
        "ead": "The 176 lines.",
        "eaf": "The base address of the display.",
        "eb2": "Save the base address and the number of the line.",
        "eb4": "It is called 176 times.",
        "eb7": "Fetch the line number and the base address.",
        "eb9": "The base address is updated by 256 locations for each",
        "eba": "Jump forward and hence round the loop again directly",
        "ebb": "for the eight pixel lines of a character line.",
        "ebf": "Fetch the low byte.",
        "ec0": "Update it by &20 bytes.",
        "ec2": "The carry flag will be reset when 'within thirds' of the",
        "ec3": "Change the carry flag.",
        "ec4": "The #REGa register will hold &F8 when within a 'third'",
        "ec5": "but &00 when a new 'third' is reached.",
        "ec7": "The high byte of the address is now updated.",
        "ec9": "Jump back until 176 lines have been printed.",
        "ecb": "Jump forward to the end routine.",
        "ecd": "Disable the maskable interrupt.",
        "ece": "The base address of the printer buffer.",
        "ed1": "There are eight pixel lines.",
        "ed3": "Save the line number.",
        "ed4": "Print the line.",
        "ed7": "Fetch the line number.",
        "ed8": "Jump back until 8 lines have been printed.",
        "eda": "Stop the printer motor.",
        "ede": "Enable the maskable interrupt and continue into #R$0EDF.",
        "edf": "The base address of the printer buffer.",
        "ee2": "Reset the printer 'column' at .",
        "ee5": "Clear the #REGa register.",
        "ee6": "Also clear the #REGb register (in effect #REGb holds",
        "ee7": "The 256 bytes of the printer buffer are all cleared in",
        "ee8": "turn.",
        "eeb": "Signal 'the buffer is empty' (reset bit 1 of",
        "eef": "Set the printer position and return via #R$0DD9 and",
        "ef1": "#R$0ADC.",
        "ef4": "Copy the pixel-line number.",
        "ef5": "The #REGa register will hold &00 until the last two",
        "ef7": "lines are being handled.",
        "efa": "Slow the motor for the last two pixel lines only.",
        "efc": "The #REGd register will hold either &00 or &02.",
        "efd": "Jump forward unless the BREAK key is being pressed.",
        "f02": "But if it is then stop the motor, enable the maskable",
        "f04": "interrupt, clear the printer buffer and exit via the",
        "f06": "error handling routine - 'BREAK-CONT repeats'.",
        "f0c": "Fetch the status of the printer.",
        "f0f": "Make an immediate return if the printer is not present.",
        "f10": "Wait for the stylus.",
        "f12": "There are thirty two bytes.",
        "f14": "Fetch a byte.",
        "f15": "Update the pointer.",
        "f16": "Eight bits per byte.",
        "f18": "Move #REGd left.",
        "f1a": "Move each bit into the carry.",
        "f1c": "Move #REGd back again, picking up the carry from #REGe.",
        "f1e": "Again fetch the status of the printer and wait for the",
        "f20": "signal from the encoder.",
        "f23": "Now go ahead and pass the 'bit' to the printer. Note:",
        "f24": "bit 2 low starts the motor, bit 1 high slows the motor,",
        "f26": "'Print' each bit.",
        "f28": "Decrease the byte counter.",
        "f29": "Jump back whilst there are still bytes; otherwise",
        "f2b": "return.",
        "f2c": "The current value of  is saved on the",
        "f2f": "machine stack.",
        "f30": "This is #R$107F.",
        "f33": "Any event that leads to the error handling routine",
        "f34": "(see ) being used will come back to",
        "f38": "Return once a key has been pressed.",
        "f3b": "Save the code temporarily.",
        "f3c": "Fetch the duration of the keyboard click",
        "f3e": "().",
        "f41": "And the pitch.",
        "f44": "Now make the 'pip'.",
        "f47": "Restore the code.",
        "f48": "Pre-load the machine stack with the address of",
        "f4b": "#R$0F38.",
        "f4c": "Accept all character codes, graphic codes and tokens.",
        "f50": "Also accept ','.",
        "f54": "Jump forward if the code represents an editing key.",
        "f58": "INK and PAPER will require two locations.",
        "f5b": "Copy the code to #REGd.",
        "f5c": "Jump forward with INK and PAPER.",
        "f60": "Three locations required.",
        "f61": "Jump forward unless dealing with 'INPUT LINE...' (bit",
        "f65": "7 of  set).",
        "f68": "Get the second code and put it in #REGe.",
        "f6c": "Get another code.",
        "f6f": "Save the previous codes.",
        "f70": "Fetch .",
        "f73": "Signal 'K mode' (reset bit 0 of ).",
        "f77": "Make two or three spaces.",
        "f7a": "Restore the previous codes.",
        "f7b": "Point to the first location.",
        "f7c": "Enter first code.",
        "f7d": "Then enter the second code which will be overwritten",
        "f7e": "if there are only two codes - i.e. with INK and PAPER.",
        "f7f": "Jump forward.",
        "f81": "Signal 'K mode' (reset bit 0 of ).",
        "f85": "Fetch the cursor position ().",
        "f88": "Make a single space.",
        "f8b": "Enter the code into the space and set ",
        "f8c": "to signal that the cursor is to occur at the location",
        "f8d": "after. Then return indirectly to #R$0F38.",
        "f92": "The code is transferred to the #REGde register pair.",
        "f95": "The base address of the #R$0FA0(editing keys table).",
        "f98": "The entry is addressed and then fetched into #REGe.",
        "f9a": "The address of the handling routine is saved on the",
        "f9b": "machine stack.",
        "f9c": "The #REGhl register pair is set to  and",
        "f9f": "an indirect jump made to the required routine.",
        "fa0": "EDIT (#R$0FA9)",
        "fa1": "Cursor left (#R$1007)",
        "fa2": "Cursor right (#R$100C)",
        "fa3": "Cursor down (#R$0FF3)",
        "fa4": "Cursor up (#R$1059)",
        "fa5": "DELETE (#R$1015)",
        "fa6": "ENTER (#R$1024)",
        "fa7": "SYMBOL SHIFT (#R$1076)",
        "fa8": "GRAPHICS (#R$107C)",
        "fa9": "Fetch the current line number ().",
        "fac": "But jump forward if in 'INPUT mode' (bit 5 of",
        "fb0": " set).",
        "fb3": "Find the address of the start of the current line and",
        "fb6": "hence its number.",
        "fb9": "If the line number returned is zero then simply clear",
        "fba": "the editing area.",
        "fbe": "Save the address of the line.",
        "fbf": "Move on to collect the length of the line.",
        "fc3": "Add &0A to the length and test that there is",
        "fc6": "sufficient room for a copy of the line.",
        "fcc": "Now clear the editing area.",
        "fcf": "Fetch the current channel address ()",
        "fd2": "and exchange it for the address of the line.",
        "fd3": "Save it temporarily.",
        "fd4": "Open channel 'R' so that the line will be copied to",
        "fd6": "the editing area.",
        "fd9": "Fetch the address of the line.",
        "fda": "Go to before the line.",
        "fdb": "Decrement the current line number () so",
        "fde": "Print the BASIC line.",
        "fe1": "Increment the current line number ().",
        "fe4": "Fetch the start of the line in the editing area",
        "fe7": "() and step past the line number and the",
        "fe8": "length to find the address for .",
        "fee": "Fetch the former channel address and set the",
        "fef": "appropriate flags before returning to #R$0F38.",
        "ff3": "Jump forward if in 'INPUT mode' (bit 5 of",
        "ff7": " set).",
        "ff9": "This is .",
        "ffc": "The next line number is found and a new automatic",
        "fff": "listing produced.",
        "1001": "'STOP in INPUT' report ().",
        "1005": "Jump forward.",
        "1007": "The cursor is moved.",
        "100a": "Jump forward.",
        "100c": "The current character is tested and if it is 'carriage",
        "100d": "return' then return.",
        "1010": "Otherwise make the cursor come after the character.",
        "1011": "Set the system variable .",
        "1015": "Move the cursor leftwards.",
        "1018": "Reclaim the current character.",
        "101e": "The next two codes from the key-input routine are",
        "1021": "ignored.",
        "1024": "The addresses of #R$0F38 and #R$107F are discarded.",
        "1026": "The old value of  is restored.",
        "102a": "Now return if there were no errors ( is",
        "102e": "&FF).",
        "102f": "Otherwise make an indirect jump to the error routine.",
        "1031": "#REGde will hold either  (for editing)",
        "1032": "or  (for INPUTing).",
        "1035": "The carry flag will become set if the cursor is already",
        "1037": "to be at the start of the line.",
        "1038": "Correct for the subtraction.",
        "1039": "Drop the return address.",
        "103a": "Return via #R$0F38 if the carry flag is set.",
        "103b": "Restore the return address.",
        "103c": "Move the current address of the cursor to #REGbc.",
        "103e": "#REGhl will point to the character in the line after",
        "103f": "that addressed by #REGde.",
        "1041": "Fetch a character code.",
        "1042": "Jump forward if the code does not represent INK to TAB.",
        "1048": "Allow for one parameter.",
        "1049": "Fetch the code anew.",
        "104a": "Carry is reset for TAB.",
        "104c": "Note: this splits off AT and TAB but AT and TAB in this",
        "104e": "Jump forward unless dealing with AT and TAB which would",
        "1050": "have two parameters, if used.",
        "1051": "Prepare for true subtraction.",
        "1052": "The carry flag will be reset when the 'updated pointer'",
        "1054": "reaches .",
        "1055": "For the next loop use the 'updated pointer', but if",
        "1056": "exiting use the 'present pointer' for .",
        "1058": "Note: it is the control character that is deleted when",
        "1059": "Return if in 'INPUT mode' (bit 5 of ",
        "105d": "set).",
        "105e": "Fetch the current line number () and its",
        "1061": "start address.",
        "1064": "#REGhl now points to the previous line.",
        "1065": "This line's number is fetched.",
        "1068": "This is .",
        "106b": "The line number is stored.",
        "106e": "A new automatic listing is now produced and channel",
        "1071": "'K' re-opened before returning to #R$0F38.",
        "1076": "Jump back unless dealing with INPUT LINE (bit 7 of",
        "107a": " set).",
        "107c": "Jump back.",
        "107f": "Jump back if using other than channel 'K' (bit 4 of",
        "1083": "#R$5C6A(FLAGS2) reset).",
        "1085": "Cancel the error number () and give a",
        "1089": "'rasp' (see ) before going around the",
        "108b": "editor again.",
        "1097": "Save the pointer to the space.",
        "1098": "#REGde will point to the first character and #REGhl",
        "109b": "the last.",
        "109c": "The correct amount is now reclaimed.",
        "109f": "The system variables  and ",
        "10a2": "('K mode') are initialised before fetching the pointer",
        "10a6": "and returning.",
        "10a8": "Copy the edit-line or the INPUT-line to the screen if",
        "10ac": "the mode has changed (bit 3 of  set).",
        "10af": "Return with both carry and zero flags reset if no new",
        "10b0": "key has been pressed (bit 5 of  reset).",
        "10b5": "Otherwise fetch the code () and signal",
        "10b8": "that it has been taken (reset bit 5 of ).",
        "10bc": "Save the code temporarily.",
        "10bd": "Clear the lower part of the display if necessary (bit",
        "10c1": "5 of  set), e.g. after 'scroll?'.",
        "10c4": "Fetch the code.",
        "10c5": "Accept all characters and token codes.",
        "10c9": "Jump forward with most of the control character codes.",
        "10cd": "Jump forward with the 'mode' codes and the CAPS LOCK",
        "10cf": "code.",
        "10d1": "Save the code.",
        "10d2": "Keep only bit 0.",
        "10d4": "#REGc holds &00 (=OFF) or &01 (=ON).",
        "10d5": "Fetch the code.",
        "10d6": "Rotate it once (losing bit 0).",
        "10d7": "Increase it by &12 giving &12 for FLASH, &13 for",
        "10d9": "BRIGHT, and &14 for INVERSE.",
        "10db": "Jump forward with 'mode' codes.",
        "10dd": "This is #R$5C6A(FLAGS2).",
        "10e0": "Flip bit 3 of #R$5C6A(FLAGS2). This is the CAPS LOCK",
        "10e2": "flag.",
        "10e4": "Jump forward.",
        "10e6": "Check the lower limit.",
        "10e9": "Reduce the range.",
        "10eb": "This is .",
        "10ee": "Has it been changed?",
        "10ef": "Enter the new 'mode' code.",
        "10f0": "Jump if it has changed; otherwise make it 'L mode'.",
        "10f4": "Signal 'the mode might have changed' (set bit 3 of",
        "10f8": "Reset the carry flag and return.",
        "10fa": "Save the code.",
        "10fb": "Make the #REGc register hold the parameter (&00 to",
        "10fd": "&07).",
        "10fe": "#REGa now holds the INK code.",
        "1100": "But if the code was an 'unshifted' code then make",
        "1102": "#REGa hold the PAPER code.",
        "1105": "Save the parameter at .",
        "1108": "This is #R$110D.",
        "110b": "Jump forward.",
        "110d": "Fetch the parameter ().",
        "1110": "This is #R$10A8.",
        "1113": "Fetch the channel address ().",
        "1118": "Now set the input address.",
        "111b": "Show a code has been found and return.",
        "111d": "Use the permanent colours.",
        "1120": "Signal that the 'mode is to be considered unchanged'",
        "1124": "(reset bit 3 of ) and the 'lower",
        "1128": "Save the current value of .",
        "112c": "Keep the current value of .",
        "1130": "This is #R$1167.",
        "1133": "Push this address on to the machine stack to make",
        "1134": "#R$1167 the entry point following an error (see",
        "1138": "Push the value of  on to the stack.",
        "113c": "Make #REGhl point to the start of the space and",
        "113d": "#REGde the end.",
        "1141": "Now print the line.",
        "1144": "Exchange the pointers and print the cursor.",
        "1148": "Next fetch the current value of  and",
        "114b": "exchange it with .",
        "114c": "Pass  to #REGde.",
        "114d": "Again fetch the permanent colours.",
        "1150": "Fetch the current line number from ",
        "1153": "and subtract the old line number.",
        "1154": "Jump forward if no 'blanking' of lines required.",
        "1156": "Jump forward if not on the same line.",
        "1158": "Fetch the old column number and subtract the new",
        "1159": "column number (at ).",
        "115c": "Jump if no spaces required.",
        "115e": "A 'space'.",
        "1160": "Save the old values.",
        "1161": "Print it.",
        "1164": "Fetch the old values.",
        "1165": "Back again.",
        "1167": "Give out a 'rasp' (see ).",
        "1172": "Cancel the error number ().",
        "1176": "Fetch the current value of  and jump",
        "117a": "forward.",
        "117c": "The new position value.",
        "117d": "The 'error address'.",
        "117e": "The old value of  is restored.",
        "1182": "Fetch the old value of .",
        "1183": "Save the new position values.",
        "1184": "Set the system variables.",
        "1187": "The old value of  goes into",
        "1188": ".",
        "118b": " is cleared in a suitable manner and",
        "118f": "the return made.",
        "1190": "Point to the last location of the editing area",
        "1193": "(-1).",
        "1194": "Clear the carry flag.",
        "1195": "Point to the start of the editing area",
        "1199": "() and return if in 'editing mode' (bit",
        "119d": "5 of  reset).",
        "119e": "Otherwise point #REGde at the start of the work space",
        "11a2": "Return if now intended.",
        "11a3": "Fetch  and then return.",
        "11a7": "Each character in turn is examined.",
        "11a8": "Is it a number marker?",
        "11aa": "It will occupy six locations.",
        "11ad": "Reclaim the floating point number.",
        "11b0": "Fetch the code again.",
        "11b1": "Update the pointer.",
        "11b2": "Is it a carriage return?",
        "11b4": "Back if not. But make a simple return if it is.",
        "11b7": "Disable the maskable interrupt.",
        "11b8": "The NEW flag.",
        "11ba": "The existing value of  is preserved.",
        "11be": "Load the alternate registers with the following",
        "11bf": "system variables (, ,",
        "11c3": ", ). All of which will also be",
        "11c7": "preserved.",
        "11cb": "Save the flag for later.",
        "11cc": "Make the border white in colour.",
        "11d0": "Set the I register to hold the value of &3F.",
        "11d4": "Wait 24 T states.",
        "11da": "Transfer the value in #REGde (#R$0000=&FFFF,",
        "11db": "#R$11B7=).",
        "11dc": "Enter the value of &02 into every location above",
        "11de": "&3FFF.",
        "11e2": "Prepare for true subtraction.",
        "11e3": "The carry flag will become reset when the top is",
        "11e5": "reached.",
        "11e6": "Update the pointer.",
        "11e7": "Jump when at top.",
        "11e9": "&02 goes to &01.",
        "11ea": "But if zero then RAM is faulty. Use current #REGhl as",
        "11ec": "&01 goes to &00.",
        "11ed": "Step to the next test unless it fails.",
        "11ef": "#REGhl points to the last actual location in working",
        "11f0": "Restore , , ",
        "11f1": "and .",
        "11fd": "Test the #R$0000/#R$11B7 flag.",
        "11fe": "Jump forward if coming from the #R$11B7 command",
        "1200": "Top of physical RAM ().",
        "1203": "Last byte of 'U' in character set.",
        "1206": "There are this number of bytes in twenty one letters.",
        "1209": "Switch the pointers.",
        "120a": "Now copy the character forms of the letters 'A' to",
        "120c": "Switch the pointers back.",
        "120d": "Point to the first byte.",
        "120e": "Now set .",
        "1211": "Down one location.",
        "1212": "Set the system variables  and",
        "1215": ".",
        "1219": "Set .",
        "121c": "Initialise the system variable .",
        "1222": "The top location () is made to hold",
        "1225": "&3E.",
        "1227": "The next location is left holding zero.",
        "1228": "These two locations represent the 'last entry'.",
        "1229": "Step down two locations to find the correct value for",
        "122a": ".",
        "122e": "Interrupt mode 1 is used.",
        "1230": "#REGiy holds + always.",
        "1234": "The maskable interrupt can now be enabled. The",
        "1235": "The system variable  is set to the base",
        "1238": "address of the #R$5CB6(channel information area).",
        "123b": "The initial channel data is moved from the table",
        "123e": "(#R$15AF) to the channel information area.",
        "1244": "The system variable  is made to point",
        "1245": "to the last location of the channel data.",
        "1249": "And  and  to the the",
        "124a": "location after that.",
        "1250": "The end-marker of the variables area.",
        "1252": "Move on one location to find the value for",
        "1253": ".",
        "1256": "Make the edit-line be a single 'carriage return'",
        "1258": "character.",
        "1259": "Now enter an end marker.",
        "125b": "Move on one location to find the value for",
        "125c": ",  and .",
        "1265": "Initialise the colour system variables",
        "1267": "(, , ) to",
        "126a": "FLASH 0, BRIGHT 0, PAPER 7, INK 0, BORDER 7.",
        "1270": "Initialise the system variables  and",
        "1273": ".",
        "1276": "Make #R$5C00(KSTATE0) hold &FF.",
        "1279": "Make #R$5C04(KSTATE4) hold &FF.",
        "127c": "Next move the #R$15C6(initial stream data) from its",
        "127f": "table to the #R$5C10(streams area).",
        "1287": "Signal 'printer in use' (set bit 1 of )",
        "128b": "and clear the printer buffer.",
        "128e": "Set the size of the lower part of the display",
        "1292": "() and clear the whole display.",
        "1295": "Now print the message '#CHR169 1982 Sinclair Research",
        "1296": "Ltd' on the bottom line.",
        "129c": "Signal 'the lower part will required to be cleared'",
        "12a0": "Jump forward into the main execution loop.",
        "12a2": "The lower part of the screen is to be two lines in",
        "12a6": "Produce an automatic listing.",
        "12a9": "All the areas from  onwards are given",
        "12ac": "Channel 'K' is opened before calling the #R$0F2C.",
        "12b1": "The #R$0F2C is called to allow the user to build up a",
        "12b4": "The current line is scanned for correct syntax.",
        "12b7": "Jump forward if the syntax is correct",
        "12bb": "( is &FF).",
        "12bd": "Jump forward if other than channel 'K' is being used",
        "12c1": "(bit 4 of #R$5C6A(FLAGS2) is set).",
        "12c3": "Point to the start of the line with the error",
        "12c6": "Remove the floating-point forms from this line.",
        "12c9": "Reset  and jump back to #R$12AC",
        "12cd": "leaving the listing unchanged.",
        "12cf": "Point to the start of the line ().",
        "12d2": "Set  to the start also.",
        "12d5": "Fetch any line number into #REGbc.",
        "12d8": "Is the line number a valid one?",
        "12da": "Jump if it is so, and add the new line to the existing",
        "12dd": "Fetch the first character of the line and see if the",
        "12de": "line is 'carriage return only'.",
        "12e0": "If it is then jump back.",
        "12e2": "Clear the whole display unless the flag (bit 0 of",
        "12e6": "#R$5C6A(FLAGS2)) says it is unnecessary.",
        "12e9": "Clear the lower part anyway.",
        "12ec": "Set the appropriate value for the scroll counter",
        "12ee": "() by subtracting the second byte of",
        "12f1": " from &19).",
        "12f4": "Signal 'line execution' (set bit 7 of ).",
        "12f8": "Ensure  is correct.",
        "12fc": "Deal with the first statement in the line (set",
        "1300": "Now the line is interpreted. Note: the address #R$1303",
        "1303": "The maskable interrupt must be enabled.",
        "1304": "Signal 'ready for a new key' (reset bit 5 of",
        "1308": "Empty the printer buffer if it has been used (bit 1",
        "130c": "of #R$5C6A(FLAGS2) set).",
        "130f": "Fetch the error number () and",
        "1312": "increment it.",
        "1313": "Save the new value.",
        "1314": "The system variables ,",
        "1317": " and  are all set to",
        "131a": "zero.",
        "1320": "Ensure that stream &00 points to channel 'K' (see",
        "1323": ").",
        "1326": "Clear all the work areas and the calculator stack.",
        "1329": "Signal 'editing mode' (reset bit 5 of ).",
        "132d": "Clear the lower screen.",
        "1330": "Signal 'the lower screen will require clearing' (set",
        "1334": "Fetch the report value.",
        "1335": "Make a copy in #REGb.",
        "1336": "Jump forward with report numbers '0 to 9'.",
        "133a": "Add the ASCII letter offset value.",
        "133c": "Print the report code and follow it with a 'space'.",
        "1342": "Fetch the report value (used to identify the required",
        "1343": "Print the message.",
        "1349": "Follow it by a 'comma' and a 'space'.",
        "1350": "Now fetch the current line number () and",
        "1354": "print it as well.",
        "1357": "Follow it by a ':'.",
        "135a": "Fetch the current statement number ()",
        "135d": "into the #REGbc register pair and print it.",
        "1362": "Clear the editing area.",
        "1365": "Fetch the error number () again.",
        "1368": "Increment it as usual.",
        "1369": "If the program was completed successfully there cannot",
        "136b": "If the program halted with 'STOP statement' or 'BREAK",
        "136d": "into program' CONTinuing will be from the next",
        "136f": "statement; otherwise  is unchanged.",
        "1376": "The system variables  and",
        "1379": " have now to be made to hold the",
        "137c": "The values used will be those in  and",
        "137f": " unless  indicates that",
        "1381": "the 'break' occurred before a 'jump' (i.e. after a GO",
        "1383": "TO statement etc.).",
        "1386": " is reset to indicate 'no jump'.",
        "138a": "'K mode' is selected (reset bit 3 of ).",
        "138e": "And finally the jump back is made but no program",
        "1391": "Initial byte is stepped over.",
        "1392": "0 OK",
        "1394": "1 NEXT without FOR",
        "13a4": "2 Variable not found",
        "13b6": "3 Subscript wrong",
        "13c5": "4 Out of memory",
        "13d2": "5 Out of screen",
        "13df": "6 Number too big",
        "13ed": "7 RETURN without GOSUB",
        "1401": "8 End of file",
        "140c": "9 STOP statement",
        "141a": "A Invalid argument",
        "142a": "B Integer out of range",
        "143e": "C Nonsense in BASIC",
        "144f": "D BREAK - CONT repeats",
        "1463": "E Out of DATA",
        "146e": "F Invalid file name",
        "147f": "G No room for line",
        "148f": "H STOP in INPUT",
        "149c": "I FOR without NEXT",
        "14ac": "J Invalid I/O device",
        "14be": "K Invalid colour",
        "14cc": "L BREAK into program",
        "14de": "M RAMTOP no good",
        "14ec": "N Statement lost",
        "14fa": "O Invalid stream",
        "1508": "P FN without DEF",
        "1516": "Q Parameter error",
        "1525": "R Tape loading error",
        "1537": "', '",
        "1539": "#CHR169 1982 Sinclair",
        "1555": "'G' has the code &10 plus &37.",
        "1557": "Clear #REGbc.",
        "155a": "Jump back to give the report.",
        "155d": "Make the new line number the 'current line'",
        "1561": "Fetch  and save the address in #REGde.",
        "1565": "Push the address of #R$1555 on to the machine stack.",
        "1568": " will now point to #R$1555.",
        "1569": "Fetch .",
        "156c": "Find the length of the line from after the line number",
        "156d": "to the 'carriage return' character inclusively.",
        "156f": "Save the length.",
        "1570": "Move the line number to the #REGhl register pair.",
        "1572": "Is there an existing line with this number?",
        "1575": "Jump if there was not.",
        "1577": "Find the length of the 'old' line and reclaim it.",
        "157d": "Fetch the length of the 'new' line and jump forward if",
        "157e": "it is only a 'line number and a carriage return'.",
        "1583": "Save the length.",
        "1584": "Four extra locations will be needed, i.e. two for the",
        "1585": "number and two for the length.",
        "1588": "Make #REGhl point to the location before the",
        "1589": "Save the current value of  to avoid",
        "158d": "corruption when adding a first line.",
        "158e": "Space for the new line is created.",
        "1591": "The old value of  is fetched and restored.",
        "1595": "A copy of the line length (without parameters) is",
        "1596": "taken.",
        "1597": "Make #REGde point to the end location of the new area",
        "1598": "and #REGhl to the 'carriage return' character of the new",
        "159b": "line in the editing area (-2).",
        "159d": "Now copy over the line.",
        "159f": "Fetch the line's number (#R$5C49(E_PPC)).",
        "15a2": "Destination into #REGhl and number into #REGde.",
        "15a3": "Fetch the new line's length.",
        "15a4": "The high length byte.",
        "15a6": "The low length byte.",
        "15a8": "The low line number byte.",
        "15aa": "The high line number byte.",
        "15ab": "Drop the address of #R$1555.",
        "15ac": "Jump back and this time do produce an automatic listing.",
        "15af": "Keyboard.",
        "15b4": "Screen.",
        "15b9": "Work space.",
        "15be": "Printer.",
        "15c3": "End marker.",
        "15c4": "Call the error handling routine.",
        "15c6": "&FD: Leads to channel 'K' (keyboard)",
        "15c8": "&FE: Leads to channel 'S' (screen)",
        "15ca": "&FF: Leads to channel 'R' (work space)",
        "15cc": "&00: Leads to channel 'K' (keyboard)",
        "15ce": "&01: Leads to channel 'K' (keyboard)",
        "15d0": "&02: Leads to channel 'S' (screen)",
        "15d2": "&03: Leads to channel 'P' (printer)",
        "15d4": "Jump forward if the flag (bit 5 of )",
        "15d8": "indicates the lower screen does not require clearing.",
        "15da": "Otherwise signal 'consider the mode as having changed'",
        "15de": "Call the input subroutine indirectly via #R$15E6.",
        "15e1": "Return with acceptable codes.",
        "15e2": "Both the carry flag and the zero flag are reset if 'no",
        "15e4": "Call the error handling routine.",
        "15e6": "Save the registers.",
        "15e8": "Fetch the base address for the current channel",
        "15eb": "Step past the output address.",
        "15ed": "Jump forward.",
        "15ef": "Increase the value in the #REGa register by &30.",
        "15f2": "Save the registers.",
        "15f4": "Fetch the base address for the current channel",
        "15f7": "Fetch the low byte.",
        "15f8": "Fetch the high byte.",
        "15fa": "Move the address to the #REGhl register pair.",
        "15fb": "Call the actual subroutine.",
        "15fe": "Restore the registers.",
        "1600": "Return will be from here unless an error occurred.",
        "1601": "The value in the #REGa register is doubled and then",
        "1602": "increased by &16.",
        "1604": "The result is moved to #REGl.",
        "1605": "The address #R$5C16 is the base address for stream &00.",
        "1607": "Fetch the first two bytes of the required stream's",
        "1608": "data.",
        "160a": "Give an error if both bytes are zero; otherwise jump",
        "160b": "forward.",
        "160e": "Call the error handling routine.",
        "1610": "Reduce the stream data.",
        "1611": "The base address of the whole channel information area",
        "1614": "Form the required address in this area.",
        "1615": "The #REGhl register pair holds the base address for a",
        "1618": "Signal 'using other than channel 'K'' (reset bit 4 of",
        "161c": "Step past the output and the input addresses and make",
        "161d": "#REGhl point to the channel code.",
        "1620": "Fetch the code.",
        "1621": "The base address of the #R$162D(channel code look-up",
        "1624": "Index into this table and locate the required offset,",
        "1627": "but return if there is not a matching channel code.",
        "1628": "Pass the offset to the #REGde register pair.",
        "162b": "Point #REGhl at the appropriate flag setting routine.",
        "162c": "Jump to the routine.",
        "162d": "Channel 'K', offset &06 (#R$1634).",
        "162f": "Channel 'S', offset &12 (#R$1642).",
        "1631": "Channel 'P', offset &1B (#R$164D).",
        "1633": "End marker.",
        "1634": "Signal 'using lower screen' (set bit 0 of",
        "1638": "Signal 'ready for a key' (reset bit 5 of",
        "163c": "Signal 'using channel 'K'' (set bit 4 of",
        "1640": "Jump forward.",
        "1642": "Signal 'using main screen' (reset bit 0 of",
        "1646": "Signal 'printer not being used' (reset bit 1 of",
        "164a": "Exit via #R$0D4D so as to set the colour system",
        "164d": "Signal 'printer in use' (set bit 1 of ).",
        "1652": "Just the single extra location is required.",
        "1655": "Save the pointer.",
        "1656": "Make sure that there is sufficient memory available for",
        "1659": "Restore the pointer.",
        "165a": "Alter all the pointers before making the 'room'.",
        "165d": "Make #REGhl hold the new .",
        "1660": "Switch 'old' and 'new'.",
        "1661": "Now make the 'room' and return.",
        "1664": "These registers are saved.",
        "1665": "Copy the address of the 'position'.",
        "1666": "This is , the first of the fourteen system",
        "1669": "pointers.",
        "166b": "Fetch the two bytes of the current pointer.",
        "166e": "Exchange the system variable with the address of the",
        "166f": "The carry flag will become set if the system variable's",
        "1670": "address is to be updated.",
        "1673": "Restore the 'position'.",
        "1674": "Jump forward if the pointer is to be left; otherwise",
        "1676": "Save the old value.",
        "1677": "Now add the value in #REGbc to the old value.",
        "167a": "Enter the new value into the system variable - high",
        "167b": "byte before low byte.",
        "167d": "Point again to the high byte.",
        "167e": "Fetch the old value.",
        "167f": "Point to the next system variable and jump back until",
        "1680": "all fourteen have been considered.",
        "1683": "Put the old value of  in #REGhl and",
        "1684": "restore the other registers.",
        "1686": "Now find the difference between the old value of",
        "1687": " and the 'position'.",
        "1689": "Transfer the result to #REGbc and add 1 for the",
        "168a": "inclusive byte.",
        "168c": "Reform the old value of  and pass it to",
        "168d": "#REGde before returning.",
        "168f": "Line number zero.",
        "1691": "Consider the other pointer.",
        "1692": "Use line number zero.",
        "1695": "Fetch the high byte and test it.",
        "1698": "Jump if not suitable.",
        "169a": "Fetch the high byte and low byte and return.",
        "169e": "Fetch the current value of  and",
        "16a1": "decrement it to get the last location of the work space.",
        "16a2": "Now make '#REGbc spaces'.",
        "16a5": "Point to the first new space and then the second.",
        "16a7": "Fetch the old value of  and restore it.",
        "16ac": "Restore #REGbc - number of spaces.",
        "16ad": "Switch the pointers.",
        "16ae": "Make #REGhl point to the first of the displaced bytes.",
        "16af": "Now return.",
        "16b0": "Fetch .",
        "16b3": "Make the editing area hold only the 'carriage return'",
        "16b5": "character and the end marker, and set ",
        "16b8": "accordingly",
        "16bb": "Reset  and move on to clear the work",
        "16bc": "space.",
        "16bf": "Fetch the start address of the work space",
        "16c2": "Clear the work space by setting  equal to",
        "16c5": "Fetch .",
        "16c8": "Clear the stack by setting  equal to",
        "16cb": "Save .",
        "16cc": "The base of the memory area ().",
        "16cf": "Set  to this address.",
        "16d2": "Restore  to the #REGhl register pair",
        "16d3": "before returning.",
        "16d4": "Fetch .",
        "16d8": "Reclaim the memory.",
        "16db": "Move on to consider the next pair of entries.",
        "16dc": "Fetch the first of a pair of entries but return if it",
        "16dd": "is zero - the end marker.",
        "16df": "Compare it to the supplied code.",
        "16e0": "Point to the second entry.",
        "16e1": "Jump back if the correct entry has not been found.",
        "16e3": "The carry flag is set upon a successful search.",
        "16e5": "The existing data for the stream is fetched.",
        "16e8": "Check the code in that stream's channel.",
        "16eb": "Prepare to make the stream's data zero.",
        "16ee": "Prepare to identify the use of streams &00 to &03.",
        "16f2": "The carry flag will be set with streams &04 to &0F.",
        "16f3": "Jump forward with these streams; otherwise find the",
        "16f5": "correct entry in the #R$15C6(initial stream data table).",
        "16f9": "Fetch the initial data for streams &00 to &03.",
        "16fc": "Now enter the data: either zero and zero, or the",
        "16fd": "initial values.",
        "1701": "Save the address of the stream's data.",
        "1702": "Fetch the base address of the channel information area",
        "1705": "() and find the channel data for the",
        "1706": "Step past the subroutine addresses and pick up the code",
        "1707": "for that channel.",
        "170a": "Save the pointer.",
        "170b": "The base address of the #R$1716(CLOSE stream look-up",
        "170e": "Index into this table and locate the required offset.",
        "1711": "Pass the offset to the #REGbc register pair.",
        "1714": "Jump to the appropriate routine.",
        "1716": "Channel 'K', offset &05 (#R$171C)",
        "1718": "Channel 'S', offset &03 (#R$171C)",
        "171a": "Channel 'P', offset &01 (#R$171C)",
        "171c": "Fetch the channel information pointer and return.",
        "171e": "The given stream number is taken off the calculator",
        "1721": "Give an error if the stream number is greater than &0F.",
        "1725": "Call the error handling routine.",
        "1727": "Range now &03 to &12.",
        "1729": "And now &06 to &24.",
        "172a": "The base address of the #R$5C10(stream data area).",
        "172d": "Move the stream code to the #REGbc register pair.",
        "1730": "Index into the data area and fetch the the two data",
        "1731": "bytes into the #REGbc register pair.",
        "1734": "Make the pointer address the first of the data bytes",
        "1735": "before returning.",
        "1736": "Use the calculator to exchange the stream number and the",
        "1737": "#R$343C",
        "1738": "#R$369B",
        "1739": "Fetch the data for the stream.",
        "173c": "Jump forward if both bytes of the data are zero, i.e.",
        "173d": "the stream was in a closed state.",
        "1740": "Save #REGhl.",
        "1741": "Fetch  - the base address of the channel",
        "1744": "information and find the code of the channel associated",
        "1745": "with the stream being OPENed.",
        "1749": "Return #REGhl.",
        "174a": "The code fetched from the channel information area must",
        "174c": "be 'K', 'S' or 'P'; give an error if it is not.",
        "1756": "Collect the appropriate data in #REGde.",
        "1759": "Enter the data into the two bytes in the stream",
        "175a": "information area.",
        "175c": "Finally return.",
        "175d": "Save #REGhl.",
        "175e": "Fetch the parameters of the channel code.",
        "1761": "Give an error if the expression supplied is a null",
        "1762": "expression, e.g. OPEN #5,\"\".",
        "1765": "Call the error handling routine.",
        "1767": "The length of the expression is saved.",
        "1768": "Fetch the first character.",
        "1769": "Convert lower case codes to upper case ones.",
        "176b": "Move code to the #REGc register.",
        "176c": "The base address of the #R$177A(OPEN stream look-up",
        "176f": "Index into this table and locate the required offset.",
        "1772": "Jump back if not found.",
        "1774": "Pass the offset to the #REGbc register pair.",
        "1777": "Make #REGhl point to the start of the appropriate",
        "1778": "Fetch the length of the expression before jumping to",
        "1779": "the subroutine.",
        "177a": "Channel 'K', offset &06 (#R$1781)",
        "177c": "Channel 'S', offset &08 (#R$1785)",
        "177e": "Channel 'P', offset &0A (#R$1789)",
        "1780": "End marker.",
        "1781": "The data bytes will be &01 and &00.",
        "1785": "The data bytes will be &06 and &00.",
        "1789": "The data bytes will be &10 and &00.",
        "178b": "Decrease the length of the expression and give an error",
        "178c": "if it was not a single character.",
        "1790": "Otherwise clear the #REGd register, fetch #REGhl and",
        "1791": "return.",
        "1793": "Give this report.",
        "1795": "The stack pointer is saved at ",
        "1799": "Signal 'automatic listing in the main screen' (set bit",
        "179d": "Clear this part of the screen.",
        "17a0": "Switch to the editing area (set bit 0 of",
        "17a4": "Now clear the the lower part of the screen as well",
        "17a7": "(see ).",
        "17aa": "Then switch back (reset bit 0 of ).",
        "17ae": "Signal 'screen is clear' (set bit 0 of",
        "17b2": "Now fetch the the 'current' line number",
        "17b5": "() and the 'automatic' line number",
        "17b9": "If the 'current' number is less than the 'automatic'",
        "17ba": "number then jump forward to update the 'automatic'",
        "17bc": "number.",
        "17bf": "Save the 'automatic' number.",
        "17c0": "Find the address of the start of the 'current' line",
        "17c3": "and produce an address roughly a 'screen before it'",
        "17c6": "(negated).",
        "17c9": "Save the 'result' on the machine stack whilst the",
        "17ca": "'automatic' line address is also found (in #REGhl).",
        "17cd": "The 'result' goes to the #REGbc register pair.",
        "17ce": "Save the 'result'.",
        "17cf": "Find the address of the start of the line after the",
        "17d2": "Restore the 'result'.",
        "17d3": "Perform the computation and jump forward if finished.",
        "17d6": "Move the next line's address to the #REGhl register",
        "17d7": "pair and collect its line number.",
        "17db": "Now  can be updated and the test",
        "17df": "repeated with the new line.",
        "17e1": "When  is less than .",
        "17e4": "Fetch the top line's number () and",
        "17e7": "hence its address.",
        "17ea": "If the line cannot be found use #REGde instead.",
        "17ed": "The listing is produced.",
        "17f0": "The return will be to here unless scrolling was",
        "17f4": "needed to show the current line; reset bit 4 of",
        "17f5": "Use stream &03.",
        "17f7": "Jump forward.",
        "17f9": "Use stream &02.",
        "17fb": "Signal 'an ordinary listing in the main part of the",
        "17ff": "Open the channel unless checking syntax.",
        "1805": "With the present character in the #REGa register see",
        "1806": "if the stream is to be changed.",
        "1809": "Jump forward if unchanged.",
        "180b": "Is the present character a ';'?",
        "180c": "\"          ;",
        "180e": "Jump if it is.",
        "1810": "Is it a ','?",
        "1812": "Jump if it is not.",
        "1814": "A numeric expression must follow, e.g. LIST #5,20.",
        "1818": "Jump forward with it.",
        "181a": "Otherwise use zero and also jump forward.",
        "181f": "Fetch any line or use zero if none supplied.",
        "1822": "If checking the syntax of the edit-line move on to the",
        "1825": "Line number to #REGbc.",
        "1828": "High byte to #REGa.",
        "1829": "Limit the high byte to the correct range and pass the",
        "182b": "whole line number to #REGhl.",
        "182d": "Set  and find the address of the start",
        "1830": "of this line or the first line after it if the actual",
        "1833": "Flag 'before the current line'.",
        "1835": "Print the whole of a BASIC line.",
        "1838": "This will be a 'carriage return'.",
        "1839": "Jump back unless dealing with an automatic listing",
        "183d": "(bit 4 of  set).",
        "183f": "Also jump back if there is still part of the main",
        "1842": "screen that can be used ( <>",
        "1845": ").",
        "1847": "A return can be made at this point if the screen is",
        "1848": "full and the current line has been printed",
        "1849": "However if the current line is missing from the",
        "184a": "listing then  has to be updated and a",
        "184b": "further line printed (using scrolling).",
        "1855": "Fetch the 'current' line number from ",
        "1859": "and compare it.",
        "185c": "Pre-load the #REGd register with the current line",
        "185e": "Jump forward if printing the 'current' line.",
        "1860": "Load the #REGd register with zero (it is not the",
        "1863": "cursor) and set #REGe to hold &01 if the line is before",
        "1865": "Save the line marker in .",
        "1868": "Fetch the high byte of the line number and make a full",
        "1869": "return if the listing has been finished.",
        "186e": "The line number can now be printed - with leading",
        "1871": "Move the pointer on to address the first command code",
        "1872": "in the line.",
        "1874": "Signal 'leading space allowed' (reset bit 0 of",
        "1878": "Fetch the cursor code and jump forward unless the",
        "1879": "cursor is to be printed.",
        "187c": "So print the cursor now.",
        "187d": "Signal 'no leading space now' (set bit 0 of",
        "1881": "Save the registers.",
        "1882": "Move the pointer to #REGde.",
        "1883": "Signal 'not in quotes' (reset bit 2 of",
        "1887": "This is .",
        "188a": "Signal 'print in K-mode'.",
        "188c": "Jump forward unless in INPUT mode (bit 5 of",
        "1890": " set).",
        "1892": "Signal 'print in L-mode'.",
        "1894": "Fetch the syntax error pointer () and",
        "1897": "jump forward unless it is time to print the error",
        "1898": "marker.",
        "189c": "Print the error marker now. It is a flashing '?'.",
        "18a1": "Consider whether to print the cursor.",
        "18a4": "Move the pointer to #REGhl now.",
        "18a5": "Fetch each character in turn.",
        "18a6": "If the character is a 'number marker' then the hidden",
        "18a9": "Update the pointer for the next pass.",
        "18aa": "Is the character a 'carriage return'?",
        "18ac": "Jump if it is.",
        "18ae": "Switch the pointer to #REGde.",
        "18af": "Print the character.",
        "18b2": "Go around the loop for at least one further pass.",
        "18b4": "Restore the #REGde register pair and return.",
        "18b6": "Is the character a 'number marker'?",
        "18b8": "Return if not.",
        "18b9": "Advance the pointer six times so as to step past the",
        "18ba": "'number marker' and the five locations holding the",
        "18bb": "floating-point form.",
        "18bf": "Fetch the current code before returning.",
        "18c1": "Switch to the alternate registers.",
        "18c2": "Save the values of  and ",
        "18c5": "on the machine stack.",
        "18c6": "Ensure that FLASH is active.",
        "18ca": "Use these modified values for  and",
        "18cd": "This is .",
        "18d0": "Save  also on the machine stack.",
        "18d2": "Ensure INVERSE 0, OVER 0, and not PAPER 9 nor INK 9.",
        "18d4": "The character is printed.",
        "18d7": "The former value of  is restored.",
        "18db": "The former values of  and",
        "18dc": " are also restored before returning.",
        "18e1": "Fetch the address of the cursor () but",
        "18e4": "return if the correct place is not being considered.",
        "18e8": "The current value of  is fetched and",
        "18eb": "doubled.",
        "18ed": "Jump forward unless dealing with Extended mode or",
        "18ef": "Add the appropriate offset to give 'E' or 'G'.",
        "18f1": "Jump forward to print it.",
        "18f3": "This is .",
        "18f6": "Signal 'K-mode'.",
        "18f8": "The character 'K'.",
        "18fa": "Jump forward to print 'K' if 'the printing is to be in",
        "18fc": "K-mode'.",
        "18fe": "The 'printing is to be in L-mode' so signal 'L-MODE'.",
        "1900": "Form the character 'L'.",
        "1901": "Jump forward if not in 'C-mode' (bit 3 of",
        "1905": "#R$5C6A(FLAGS2) reset).",
        "1907": "The character 'C'.",
        "1909": "Save the #REGde register pair whilst the cursor is",
        "190a": "printed - FLASHing.",
        "190e": "Return once it has been done.",
        "190f": "The line number held by the system variable is",
        "1910": "collected.",
        "1912": "The pointer is saved.",
        "1913": "The line number is moved to the #REGhl register pair",
        "1914": "and incremented.",
        "1915": "The address of the start of this line is found, or the",
        "1918": "The number of that line is fetched.",
        "191b": "The pointer to the system variable is restored.",
        "191c": "Return if in 'INPUT mode' (bit 5 of ",
        "1920": "set).",
        "1921": "Otherwise proceed to enter the line number into the",
        "1922": "two locations of the system variable.",
        "1924": "Return when it has been done.",
        "1925": "The #REGa register will hold &20 for a space or &FF for",
        "1926": "Test the value and return if there is not to be a",
        "1927": "space.",
        "1928": "Jump forward to print a space.",
        "192a": "Clear the #REGa register.",
        "192b": "The 'trial subtraction'.",
        "192c": "Count each 'trial'.",
        "192d": "Jump back until exhausted.",
        "192f": "Restore last 'subtraction' and discount it.",
        "1932": "If no 'subtractions' were possible jump back to see if",
        "1934": "Otherwise print the digit.",
        "1937": "Return carry reset if handling a digit code.",
        "193a": "Jump forward to print the digit.",
        "193c": "Also print the control characters and 'space'.",
        "1940": "Signal 'print in K-mode' (reset bit 2 of",
        "1944": "Jump forward if dealing with the token 'THEN'.",
        "1948": "Jump forward unless dealing with ':'.",
        "194c": "Jump forward to print the ':' if in 'INPUT mode' (bit",
        "1950": "5 of  set).",
        "1952": "Jump forward if the ':' is 'not in quotes' (bit 2 of",
        "1956": "#R$5C6A(FLAGS2) reset), i.e. an inter-statement marker.",
        "1958": "The ':' is inside quotes and can now be printed.",
        "195a": "Accept for printing all characters except '\"'.",
        "195e": "Save the character code whilst changing the 'quote",
        "195f": "Fetch #R$5C6A(FLAGS2) and flip bit 2.",
        "1964": "Enter the amended value into #R$5C6A(FLAGS2) and",
        "1967": "restore the character code.",
        "1968": "Signal 'the next character is to be printed in L-mode'",
        "196c": "The present character is printed before returning.",
        "196e": "Save the given line number.",
        "196f": "Fetch the system variable  and transfer",
        "1972": "the address to the #REGde register pair.",
        "1974": "The given line number.",
        "1975": "Compare the given line number against the addressed line",
        "1978": "Return if carry reset; otherwise address the next",
        "1979": "line's number.",
        "197d": "Switch the pointers and jump back to consider the next",
        "197e": "line of the program.",
        "1980": "Fetch the high byte of the addressed line number and",
        "1981": "compare it.",
        "1982": "Return if they do not match.",
        "1983": "Next compare the low bytes.",
        "1987": "Return with the carry flag set if the addressed line",
        "198b": "Set  to the current byte.",
        "198e": "Set a 'quotes off' flag.",
        "1990": "Decrease #REGd and return if the required statement has",
        "1991": "been found.",
        "1992": "Fetch the next character code and jump if it does not",
        "1993": "match the given token code.",
        "1996": "But should it match then return with the carry and the",
        "1997": "zero flags both reset.",
        "1998": "Update the pointer and fetch the new code.",
        "199a": "Step over any number.",
        "199d": "Update .",
        "19a0": "Jump forward if the character is not a '\"'.",
        "19a4": "Otherwise set the 'quotes flag'.",
        "19a5": "Jump forward if the character is a ':'.",
        "19a9": "Jump forward unless the code is the token 'THEN'.",
        "19ad": "Read the 'quotes flag' and jump back at the end of each",
        "19af": "statement (including after 'THEN').",
        "19b1": "Jump back unless at the end of a BASIC line.",
        "19b5": "Decrease the statement counter and set the carry flag",
        "19b6": "before returning.",
        "19b8": "Save the address of the current line or variable.",
        "19b9": "Fetch the first byte.",
        "19ba": "Jump forward if searching for a 'next line'.",
        "19be": "Jump forward if searching for the next string or array",
        "19c0": "variable.",
        "19c2": "Jump forward with simple numeric and FOR-NEXT",
        "19c3": "variables.",
        "19c6": "Long name numeric variables only.",
        "19c7": "A numeric variable will occupy five locations but a",
        "19ca": "FOR-NEXT control variable will need eighteen locations.",
        "19ce": "The carry flag becomes reset for long named variables",
        "19cf": "Increment the pointer and fetch the new code.",
        "19d1": "Jump back unless the previous code was the last code of",
        "19d3": "Now jump forward (#REGbc=&0005 or &0012).",
        "19d5": "Step past the low byte of the line number.",
        "19d6": "Now point to the low byte of the length.",
        "19d7": "Fetch the length into the #REGbc register pair.",
        "19da": "Allow for the inclusive byte.",
        "19db": "Point to the first byte of the 'next' line or variable.",
        "19dc": "Fetch the address of the previous one and continue into",
        "19dd": "Prepare for a true subtraction.",
        "19de": "Find the length from one 'start' to the next and pass",
        "19e0": "it to the #REGbc register pair.",
        "19e2": "Reform the address and exchange them before returning.",
        "19e5": "Use the 'difference' subroutine to develop the",
        "19e8": "Save the number of bytes to be reclaimed.",
        "19e9": "All the system variable pointers above the area have to",
        "19ea": "be reduced by #REGbc, so this number is 2's complemented",
        "19eb": "before the pointers are altered.",
        "19f3": "Return the 'first location' address to the #REGde",
        "19f4": "register pair and form the address of the first location",
        "19f5": "to the left.",
        "19f6": "Save the 'first location' whilst the actual reclamation",
        "19f7": "occurs.",
        "19fa": "Now return.",
        "19fb": "Pick up the pointer to the edit-line ().",
        "19fe": "Set  to point to the location before any",
        "19ff": "number.",
        "1a02": "Pass the first code to the #REGa register.",
        "1a03": "However before considering the code make the",
        "1a06": "calculator's memory area a temporary calculator stack",
        "1a09": "Now read the digits of the line number. Return zero if",
        "1a0c": "Compress the line number into the #REGbc register pair.",
        "1a0f": "Jump forward if the number exceeds 65,536.",
        "1a11": "Otherwise test it against 10,000.",
        "1a15": "Give report C if over 9,999.",
        "1a18": "Return via #R$16C5 that restores the calculator stack to",
        "1a1b": "Save the other registers throughout the subroutine.",
        "1a1d": "Clear the #REGa register.",
        "1a1e": "Jump forward to print a zero rather than '-2' when",
        "1a20": "reporting on the edit-line.",
        "1a22": "Move the number to the #REGhl register pair.",
        "1a24": "Flag 'no leading spaces'.",
        "1a26": "Jump forward to print the number.",
        "1a28": "Save the #REGde register pair.",
        "1a29": "Fetch the number into the #REGde register pair and save",
        "1a2a": "the pointer (updated).",
        "1a2d": "Move the number to the #REGhl register pair and flag",
        "1a2e": "'leading spaces are to be printed'.",
        "1a30": "This is '-1,000'.",
        "1a33": "Print a first digit.",
        "1a36": "This is '-100'.",
        "1a39": "Print the second digit.",
        "1a3c": "This is '-10'.",
        "1a3e": "Print the third digit.",
        "1a41": "Move any remaining part of the number to the #REGa",
        "1a42": "Print the digit.",
        "1a45": "Restore the registers before returning.",
        "1a48": "#R$1AF9",
        "1a49": "#R$1B14",
        "1a4a": "#R$1B06",
        "1a4b": "#R$1B0A",
        "1a4c": "#R$1B10",
        "1a4d": "#R$1AFC",
        "1a4e": "#R$1B02",
        "1a4f": "#R$1AE2",
        "1a50": "#R$1AE1",
        "1a51": "#R$1AE3",
        "1a52": "#R$1AE7",
        "1a53": "#R$1AEB",
        "1a54": "#R$1AEC",
        "1a55": "#R$1AED",
        "1a56": "#R$1AEE",
        "1a57": "#R$1AEF",
        "1a58": "#R$1AF0",
        "1a59": "#R$1AF1",
        "1a5a": "#R$1AD9",
        "1a5b": "#R$1ADC",
        "1a5c": "#R$1A8A",
        "1a5d": "#R$1AC9",
        "1a5e": "#R$1ACC",
        "1a5f": "#R$1ACF",
        "1a60": "#R$1AA8",
        "1a61": "#R$1AF5",
        "1a62": "#R$1AB8",
        "1a63": "#R$1AA2",
        "1a64": "#R$1AA5",
        "1a65": "#R$1A90",
        "1a66": "#R$1A7D",
        "1a67": "#R$1A86",
        "1a68": "#R$1A9F",
        "1a69": "#R$1AE0",
        "1a6a": "#R$1AAE",
        "1a6b": "#R$1A7A",
        "1a6c": "#R$1AC5",
        "1a6d": "#R$1A98",
        "1a6e": "#R$1AB1",
        "1a6f": "#R$1A9C",
        "1a70": "#R$1AC1",
        "1a71": "#R$1AAB",
        "1a72": "#R$1ADF",
        "1a73": "#R$1AB5",
        "1a74": "#R$1A81",
        "1a75": "#R$1ABE",
        "1a76": "#R$1AD2",
        "1a77": "#R$1ABB",
        "1a78": "#R$1A8D",
        "1a79": "#R$1AD6",
        "1a7a": "#R$1C1F",
        "1a7c": "#R$1C4E",
        "1a7d": "#R$1C82",
        "1a7e": "#R$1C10",
        "1a81": "#R$1C82",
        "1a82": "THEN",
        "1a83": "#R$1C11",
        "1a86": "#R$1C82",
        "1a87": "#R$1C10",
        "1a8a": "#R$1C10",
        "1a8d": "#R$1C10",
        "1a90": "#R$1C6C",
        "1a92": "#R$1C82",
        "1a93": "TO",
        "1a94": "#R$1C82",
        "1a95": "#R$1C11",
        "1a98": "#R$1C6C",
        "1a99": "#R$1C10",
        "1a9c": "#R$1C11",
        "1a9f": "#R$1C11",
        "1aa2": "#R$1C11",
        "1aa5": "#R$1C11",
        "1aa8": "#R$1C10",
        "1aab": "#R$1C0D",
        "1aae": "#R$1C11",
        "1ab1": "#R$1C7A",
        "1ab2": "#R$1C10",
        "1ab5": "#R$1C0D",
        "1ab8": "#R$1C10",
        "1abb": "#R$1C0D",
        "1abe": "#R$1C10",
        "1ac1": "#R$1CBE",
        "1ac2": "#R$1C10",
        "1ac5": "#R$1C82",
        "1ac6": "#R$1C10",
        "1ac9": "#R$1C11",
        "1acc": "#R$1C11",
        "1acf": "#R$1C0D",
        "1ad2": "#R$1CBE",
        "1ad3": "#R$1C11",
        "1ad6": "#R$1C10",
        "1ad9": "#R$1C11",
        "1adc": "#R$1C11",
        "1adf": "#R$1CDB",
        "1ae0": "#R$1CDB",
        "1ae1": "#R$1CDB",
        "1ae2": "#R$1CDB",
        "1ae3": "#R$1C7A",
        "1ae4": "#R$1C10",
        "1ae7": "#R$1CBE",
        "1ae8": "#R$1C11",
        "1aeb": "#R$1C96",
        "1aec": "#R$1C96",
        "1aed": "#R$1C96",
        "1aee": "#R$1C96",
        "1aef": "#R$1C96",
        "1af0": "#R$1C96",
        "1af1": "#R$1C7A",
        "1af2": "#R$1C10",
        "1af5": "#R$1C82",
        "1af6": "#R$1C10",
        "1af9": "#R$1C11",
        "1afc": "#R$1C82",
        "1afe": "#R$1C8C",
        "1aff": "#R$1C10",
        "1b02": "#R$1C82",
        "1b03": "#R$1C10",
        "1b06": "#R$1C8C",
        "1b07": "#R$1C10",
        "1b0a": "#R$1C8C",
        "1b0c": "#R$1C8C",
        "1b0d": "#R$1C10",
        "1b10": "#R$1C8C",
        "1b11": "#R$1C10",
        "1b14": "#R$1C10",
        "1b17": "Signal 'syntax checking' (reset bit 7 of",
        "1b1b": " is made to point to the first code",
        "1b1e": "The system variable  is initialised to",
        "1b1f": "&00 and  to &FF.",
        "1b26": "Jump forward to consider the first statement of the",
        "1b28": "Advance  along the line.",
        "1b29": "The work space is cleared.",
        "1b2c": "Increase  on each passage around the",
        "1b2f": "But only '127' statements are allowed in a single line.",
        "1b32": "Fetch a character.",
        "1b33": "Clear the #REGb register for later.",
        "1b35": "Is the character a 'carriage return'?",
        "1b37": "Jump if it is.",
        "1b39": "Go around the loop again if it is a ':'.",
        "1b3d": "Pre-load the machine stack with the return address",
        "1b40": "#R$1B76.",
        "1b41": "Save the command temporarily in the #REGc register",
        "1b42": "whilst  is advanced again.",
        "1b44": "Reduce the command's code by &CE, giving the range &00",
        "1b46": "Give the appropriate error if not a command code.",
        "1b49": "Move the command code to the #REGbc register pair (#REGb",
        "1b4a": "The base address of the #R$1A48(syntax offset table).",
        "1b4d": "The required offset is passed to the #REGc register and",
        "1b4e": "used to compute the base address for the command's",
        "1b4f": "entries in the #R$1A7A(parameter table).",
        "1b50": "Jump forward into the scanning loop with this address.",
        "1b52": "The temporary pointer to the entries in the",
        "1b55": "Fetch each entry in turn.",
        "1b56": "Update the pointer to the entries () for",
        "1b57": "the next pass.",
        "1b5a": "Pre-load the machine stack with the return address",
        "1b5d": "#R$1B52.",
        "1b5e": "Copy the entry to the #REGc register for later.",
        "1b5f": "Jump forward if the entry is a 'separator'.",
        "1b63": "The base address of the #R$1C01(command class table).",
        "1b66": "Clear the #REGb register and index into the table.",
        "1b69": "Fetch the offset and compute the starting address of",
        "1b6a": "the required command class routine.",
        "1b6b": "Push the address on to the machine stack.",
        "1b6c": "Before making an indirect jump to the command class",
        "1b6d": "routine pass the command code to the #REGa register and",
        "1b6e": "set the #REGb register to &FF.",
        "1b6f": "The current character is fetched and compared to the",
        "1b70": "entry in the parameter table.",
        "1b71": "Give the error report if there is not a match.",
        "1b74": "Step past a correct character and return.",
        "1b76": "The BREAK key is tested after every statement.",
        "1b79": "Jump forward unless it has been pressed.",
        "1b7b": "Call the error handling routine.",
        "1b7d": "Jump forward if there is not a 'jump' to be made",
        "1b81": "( is &FF).",
        "1b83": "Fetch the 'new line' number () and jump",
        "1b86": "forward unless dealing with a further statement in the",
        "1b88": "editing area.",
        "1b8a": "A line in the editing area is considered as line '-2';",
        "1b8d": "set  accordingly",
        "1b90": "Make #REGhl point to the end marker of the editing area",
        "1b93": "(-1) and #REGde to the location before",
        "1b94": "the start of that area (-1).",
        "1b99": "Fetch the number of the next statement to be handled",
        "1b9c": "() before jumping forward.",
        "1b9e": "The starting address of the line, or the 'first line",
        "1ba1": "Collect the statement number ().",
        "1ba4": "Jump forward if the required line was found; otherwise",
        "1ba6": "check the validity of the statement number - must be",
        "1ba7": "zero.",
        "1ba9": "Also check that the 'first line after' is not after the",
        "1baa": "actual 'end of program'.",
        "1bae": "Jump forward with valid addresses; otherwise signal the",
        "1bb0": "Use the error handling routine.",
        "1bb2": "Drop the address - #R$1B76.",
        "1bb3": "Return if syntax is being checked; otherwise fetch the",
        "1bb6": "address in .",
        "1bba": "Return also if the address is after the end of the",
        "1bbc": "program - the 'run' is finished.",
        "1bbe": "Signal 'statement zero' before proceeding.",
        "1bbf": "Statement zero becomes statement '1'.",
        "1bc3": "The line number of the line to be used is collected and",
        "1bc4": "passed to .",
        "1bca": "Now find the 'length' of the line.",
        "1bce": "Switch over the values.",
        "1bcf": "Form the address of the start of the line after in",
        "1bd0": "#REGhl and the location before the 'next' line's first",
        "1bd1": "Set  for use once the current line has",
        "1bd4": "As usual  points to the location",
        "1bd5": "before the first character to be considered.",
        "1bd8": "The statement number is fetched.",
        "1bd9": "The #REGe register is cleared in case #R$198B is used.",
        "1bdb": "Signal 'no jump' by setting  to &FF.",
        "1bdf": "The statement number minus one goes into",
        "1be0": ".",
        "1be3": "A first statement can now be considered.",
        "1be6": "However for later statements the 'starting address'",
        "1be7": "has to be found.",
        "1bea": "Jump forward unless the statement does not exist.",
        "1bec": "Call the error handling routine.",
        "1bee": "Do not proceed unless checking syntax.",
        "1bf2": "Drop the addresses of #R$1B52 and #R$1B76 before",
        "1bf3": "continuing into #R$1BF4.",
        "1bf4": "Fetch the present character.",
        "1bf5": "Consider the 'next line' if it is a 'carriage return'.",
        "1bf9": "Consider the 'next statement' if it is a ':'.",
        "1bfe": "Otherwise there has been a syntax error.",
        "1c01": "#R$1C10",
        "1c02": "#R$1C1F",
        "1c03": "#R$1C4E",
        "1c04": "#R$1C0D",
        "1c05": "#R$1C6C",
        "1c06": "#R$1C11",
        "1c07": "#R$1C82",
        "1c08": "#R$1C96",
        "1c09": "#R$1C7A",
        "1c0a": "#R$1CBE",
        "1c0b": "#R$1C8C",
        "1c0c": "#R$1CDB",
        "1c0d": "A number is fetched but zero is used in cases of",
        "1c10": "Set the zero flag for later.",
        "1c11": "In all cases drop the address - #R$1B52.",
        "1c12": "If handling commands of classes &00 and &03 and syntax",
        "1c15": "Save the line pointer in the #REGde register pair.",
        "1c16": "Fetch the pointer to the entries in the",
        "1c19": "#R$1A7A(parameter table) from  and fetch",
        "1c1a": "the address of the required command routine.",
        "1c1c": "Exchange the pointers back and make an indirect jump to",
        "1c1d": "the command routine.",
        "1c1f": "Look in the variables area to determine whether or not",
        "1c22": "Initialise  to &00.",
        "1c26": "Jump forward if the variable has been used before.",
        "1c28": "Signal 'a new variable' (set bit 1 of ).",
        "1c2c": "Give an error if trying to use an 'undimensioned",
        "1c2e": "Call the error handling routine.",
        "1c30": "The parameters of simple string variables and all",
        "1c33": "Jump forward if handling a numeric variable (bit 6 of",
        "1c37": " set).",
        "1c39": "Clear the #REGa register.",
        "1c3a": "The parameters of the string or string array variable",
        "1c3d": "are fetched unless syntax is being checked.",
        "1c40": "This is .",
        "1c43": "Bit 0 is set only when handling complete 'simple",
        "1c44": "strings' thereby signalling 'old copy to be deleted'.",
        "1c45": "#REGhl now points to the string or the element of the",
        "1c46": "Set  as required.",
        "1c4a": "Set  as required and return.",
        "1c4e": "The address #R$1B52 is dropped.",
        "1c4f": "The assignment is made.",
        "1c52": "Move on to the next statement either via #R$1BEE if",
        "1c55": "checking syntax, or #R$1B76 if in 'run-time'.",
        "1c56": "Use .",
        "1c59": "Save  or .",
        "1c5a": "Evaluate the next expression.",
        "1c5d": "Fetch the old  or .",
        "1c5e": "Fetch the new .",
        "1c61": "The nature - numeric or string - of the variable and",
        "1c62": "the expression must match.",
        "1c64": "Give report C if they do not.",
        "1c66": "Jump forward to make the actual assignment unless",
        "1c68": "checking syntax (in which case simply return).",
        "1c6c": "Look in the variables area for the variable being used.",
        "1c6f": "Save the #REGaf register pair whilst the discriminator",
        "1c70": "byte is tested to ensure that the variable is a FOR-NEXT",
        "1c71": "control variable.",
        "1c76": "Restore the flags register and jump to make the",
        "1c77": "variable that has been found the 'variable in",
        "1c79": "Advance .",
        "1c7a": "Evaluate each expression in turn - so evaluate the",
        "1c7d": "Give an error report if the separator is not a comma.",
        "1c81": "Advance .",
        "1c82": "Evaluate the next expression.",
        "1c85": "Return as long as the result was numeric (bit 6 of",
        "1c89": " set); otherwise it is an error.",
        "1c8a": "Call the error handling routine.",
        "1c8c": "Evaluate the next expression.",
        "1c8f": "This time return if the result indicates a string (bit",
        "1c93": "6 of  reset); otherwise give an error",
        "1c94": "report.",
        "1c96": "The syntax/run flag (bit 7 of ) is read.",
        "1c9a": "Signal 'main screen' (reset bit 0 of ).",
        "1c9e": "Only during a 'run' call #R$0D4D to ensure the",
        "1ca1": "Drop the return address #R$1B52.",
        "1ca2": "Fetch the low byte of  and subtract &13",
        "1ca5": "to give the range &D9 to &DE which are the token codes",
        "1ca7": "Change the temporary colours as directed by the BASIC",
        "1caa": "Move on to the next statement if checking syntax.",
        "1cad": "Now the temporary colour values ( and",
        "1cb0": ") are made permanent (",
        "1cb3": "This is , and that too has to be",
        "1cb6": "considered.",
        "1cb7": "Move the mask leftwards.",
        "1cb8": "Impress onto the mask only the even bits of the other",
        "1cb9": "byte.",
        "1cbc": "Restore the result.",
        "1cbe": "Jump forward if checking syntax.",
        "1cc3": "Signal 'main screen' (reset bit 0 of ).",
        "1cc7": "Set the temporary colours for the main screen.",
        "1cca": "This is .",
        "1ccd": "Fetch its present value but keep only its INK part",
        "1cce": "'unmasked'.",
        "1cd0": "Restore the value which now indicates 'FLASH 8; BRIGHT",
        "1cd1": "Also ensure NOT 'PAPER 9' (reset bit 6 of",
        "1cd5": "Fetch the present character before continuing to deal",
        "1cd6": "Deal with the locally dominant colour items.",
        "1cd9": "Now get the first two operands for PLOT, DRAW or",
        "1cdb": "Jump to the cassette handling routine.",
        "1cde": "Jump forward if at the end of a line.",
        "1ce2": "But jump to #R$1C82 unless at the end of a statement.",
        "1ce6": "Do not perform the operation if syntax is being",
        "1ce9": "checked.",
        "1cea": "Use the calculator.",
        "1ceb": "#R$341B(stk_zero)",
        "1cec": "#R$369B",
        "1ced": "Return with zero added to the stack.",
        "1cee": "Call the error handling routine.",
        "1cf0": "Drop the return address - #R$1B76.",
        "1cf1": "Jump forward if checking syntax.",
        "1cf6": "Use the calculator.",
        "1cf7": "#R$33A1",
        "1cf8": "#R$369B",
        "1cf9": "Make #REGhl point to the first byte and call #R$34E9.",
        "1cfd": "If the value was 'FALSE' jump to the next line.",
        "1d00": "But if 'TRUE' jump to the next statement (after the",
        "1d03": "Jump forward unless a 'STEP' is given.",
        "1d07": "Advance  and fetch the value of the",
        "1d08": "STEP.",
        "1d0b": "Move on to the next statement if checking syntax;",
        "1d0e": "otherwise jump forward.",
        "1d10": "Move on to the next statement if checking syntax.",
        "1d13": "Otherwise use the calculator to place a '1' on the",
        "1d14": "#R$341B(stk_one)",
        "1d15": "#R$369B",
        "1d16": "v, l, s",
        "1d17": "#R$342D(st_mem_0): v, l, s (mem-0=s)",
        "1d18": "#R$33A1: v, l",
        "1d19": "#R$343C: l, v",
        "1d1a": "#R$340F(get_mem_0): l, v, s",
        "1d1b": "#R$343C: l, s, v",
        "1d1c": "#R$369B",
        "1d1d": "The variable is found, or created if needed (v is used).",
        "1d20": "Make it a 'memory area' by setting .",
        "1d23": "Fetch the variable's single character name.",
        "1d25": "Ensure bit 7 of the name is set.",
        "1d27": "It will have six locations at least.",
        "1d2a": "Make #REGhl point after them.",
        "1d2b": "Rotate the name and jump if it was already a FOR",
        "1d2c": "variable.",
        "1d2e": "Otherwise create thirteen more locations.",
        "1d33": "Again make #REGhl point to the LIMIT position.",
        "1d34": "The pointer is saved.",
        "1d35": "l, s",
        "1d36": "#R$33A1: l",
        "1d37": "#R$33A1: -",
        "1d38": "#R$369B: #REGde still points to 'l'",
        "1d39": "The pointer is restored and both pointers exchanged.",
        "1d3b": "The ten bytes of the LIMIT and the STEP are moved.",
        "1d3f": "The current line number ().",
        "1d42": "Exchange the registers before adding the line number to",
        "1d43": "the FOR control variable.",
        "1d46": "The looping statement is always the next statement",
        "1d49": "whether it exists or not (increment ).",
        "1d4c": "Is a 'pass' possible?",
        "1d4f": "Return now if it is.",
        "1d50": "Fetch the variable's name from .",
        "1d53": "Copy the present line number () to",
        "1d56": ".",
        "1d59": "Fetch the current statement number ()",
        "1d5c": "and two's complement it.",
        "1d5e": "Transfer the result to the #REGd register.",
        "1d5f": "Fetch the current value of .",
        "1d62": "The search will be for 'NEXT'.",
        "1d64": "Save the variable's name.",
        "1d65": "Fetch the current value of .",
        "1d69": "The program area is now searched and #REGbc will change",
        "1d6c": "Upon return save the pointer at .",
        "1d70": "Restore the variable's name.",
        "1d71": "If there are no further NEXTs then give an error.",
        "1d73": "Advance past the NEXT that was found.",
        "1d74": "Allow for upper and lower case letters before the new",
        "1d76": "variable name is tested.",
        "1d77": "Jump forward if it matches.",
        "1d79": "Advance  again and jump back if not the",
        "1d7a": "correct variable.",
        "1d7c": "Advance .",
        "1d7d": "The statement counter in the #REGd register counted",
        "1d7f": "statements back from zero so it has to be subtracted",
        "1d80": "The result is stored in .",
        "1d83": "Now return - to #R$1B76.",
        "1d84": "Call the error handling routine.",
        "1d86": "Fetch the present character.",
        "1d87": "Jump forward if it is a ':', which will indicate there",
        "1d89": "are more statements in the present line.",
        "1d8b": "Fetch the high byte of the line number and return with",
        "1d8c": "carry set if there are no further lines in the program.",
        "1d91": "The line number is fetched and passed to",
        "1d92": ".",
        "1d98": "Then the length is collected.",
        "1d9c": "The pointer is saved whilst the address of the end of",
        "1d9d": "the line is formed in the #REGbc register pair.",
        "1da0": "The pointer is restored.",
        "1da1": "Set the statement counter to zero.",
        "1da3": "The end-of-line pointer is saved whilst the statements",
        "1da4": "of the line are examined.",
        "1da8": "Make a return if there was an 'occurrence'; otherwise",
        "1da9": "consider the next line.",
        "1dab": "Jump to give the error report if the variable was not",
        "1daf": "found (bit 1 of  set).",
        "1db2": "The address of the variable is fetched from",
        "1db5": " and the name tested further.",
        "1db9": "Step past the name.",
        "1dba": "Make the variable a temporary 'memory area' by setting",
        "1dbd": "-",
        "1dbe": "#R$340F(get_mem_0): v",
        "1dbf": "#R$340F(get_mem_2): v, s",
        "1dc0": "#R$3014: v+s",
        "1dc1": "#R$342D(st_mem_0): v+s (v is replaced by v+s in mem-0)",
        "1dc2": "#R$33A1: -",
        "1dc3": "#R$369B: -",
        "1dc4": "Test the new VALUE against the LIMIT.",
        "1dc7": "Return now if the FOR-NEXT loop has been completed.",
        "1dc8": "Find the address of the low byte of the looping line",
        "1dcb": "number (+#h0F).",
        "1dcf": "Now fetch this line number.",
        "1dd3": "Followed by the statement number.",
        "1dd4": "Exchange the numbers before jumping forward to treat",
        "1dd5": "them as the destination line of a GO TO command.",
        "1dd8": "Call the error handling routine.",
        "1dda": "-",
        "1ddb": "#R$340F(get_mem_1): l",
        "1ddc": "#R$340F(get_mem_0): l, v",
        "1ddd": "#R$340F(get_mem_2): l, v, s",
        "1dde": "#R$3506: l, v,( 1/0)",
        "1ddf": "#R$368F to #R$1DE2: l, v, (1/0)",
        "1de1": "#R$343C: v, l",
        "1de2": "#R$300F: v-l or l-v",
        "1de3": "#R$34F9: (1/0)",
        "1de4": "#R$368F to #R$1DE9: (1/0)",
        "1de6": "#R$369B: -",
        "1de7": "Clear the carry flag and return - loop is possible.",
        "1de9": "#R$369B: -",
        "1dea": "Set the carry flag and return.",
        "1dec": "Come here on each pass, after the first, to move along",
        "1ded": "Consider whether the variable has been used before;",
        "1df0": "Jump forward if checking syntax.",
        "1df5": "Save the current pointer  in",
        "1df6": ".",
        "1df9": "Fetch the current DATA list pointer ()",
        "1dfc": "and jump forward unless a new DATA statement has to be",
        "1dfd": "found.",
        "1e01": "The search is for 'DATA'.",
        "1e03": "Jump forward if the search is successful.",
        "1e08": "Call the error handling routine.",
        "1e0a": "Advance the pointer along the DATA list and set",
        "1e0d": "Fetch the value and assign it to the variable.",
        "1e10": "Fetch the current value of  and store",
        "1e11": "it in .",
        "1e14": "Fetch the pointer to the READ statement from",
        "1e17": " and clear it.",
        "1e1b": "Make  once again point to the READ",
        "1e1e": "Get the present character and see if it is a ','.",
        "1e21": "If it is then jump back as there are further items;",
        "1e23": "otherwise return via either #R$1BEE (if checking",
        "1e26": "syntax) or the '#S/RET/' instruction (to #R$1B76).",
        "1e27": "Jump forward unless checking syntax.",
        "1e2c": "Scan the next expression.",
        "1e2f": "Check for a comma separator.",
        "1e31": "Move on to the next statement if not matched.",
        "1e34": "Whilst there are still expressions to be checked go",
        "1e35": "around the loop.",
        "1e37": "It is a 'DATA' statement that is to be passed by.",
        "1e39": "Make the #REGbc register pair hold a very high number.",
        "1e3a": "Look back along the statement for the token.",
        "1e3c": "Now look along the line for the statement after (the",
        "1e3f": "'#REGd-1'th statement from the current position).",
        "1e42": "Compress the operand into the #REGbc register pair.",
        "1e45": "Transfer the result to the #REGhl register pair.",
        "1e47": "Now find the address of that line or the 'first line",
        "1e4a": "Make  point to the location before.",
        "1e4e": "Return once it is done.",
        "1e4f": "Fetch the operand.",
        "1e52": "Jump forward unless the value of the operand is zero.",
        "1e56": "Fetch the two low order bytes of ",
        "1e5a": "Now enter the result into the system variable",
        "1e5e": " before returning.",
        "1e5f": "The line number ().",
        "1e62": "The statement number ().",
        "1e65": "Jump forward.",
        "1e67": "Fetch the operand and transfer it to the #REGhl",
        "1e6a": "register pair.",
        "1e6c": "Set the statement number to zero.",
        "1e6e": "Give the error message 'Integer out of range' with line",
        "1e6f": "numbers over 61439.",
        "1e73": "Enter the line number () and then the",
        "1e76": "statement number ().",
        "1e79": "Return - to #R$1B76.",
        "1e7a": "The operands are fetched.",
        "1e7d": "The actual '#S/OUT/' instruction.",
        "1e7f": "Return - to #R$1B76.",
        "1e80": "The operands are fetched.",
        "1e83": "The actual POKE operation.",
        "1e84": "Return - to #R$1B76.",
        "1e85": "The parameter is fetched.",
        "1e88": "Give an error if it is too high a number.",
        "1e8a": "Jump forward with positive numbers but two's complement",
        "1e8c": "negative numbers.",
        "1e8e": "Save the first parameter whilst the second is fetched.",
        "1e92": "The first parameter is restored before returning.",
        "1e94": "Fetch the 'last value'.",
        "1e97": "Jump forward.",
        "1e99": "Fetch the 'last value'.",
        "1e9c": "In both cases overflow is indicated by a set carry flag.",
        "1e9e": "Return with all positive numbers that are in range.",
        "1e9f": "Call the error handling routine.",
        "1ea1": "Set  as required.",
        "1ea4": "Now perform a 'RESTORE 0'.",
        "1eaa": "Exit via the #R$1EAC command routine.",
        "1eac": "Fetch the operand - using zero by default.",
        "1eaf": "Jump forward if the operand is other than zero. When",
        "1eb0": "called from #R$1EA1 there is no jump.",
        "1eb3": "If zero use the existing value in .",
        "1eb7": "Save the value.",
        "1eb8": "Next reclaim all the bytes of the present variables",
        "1ebc": "area ( to -1).",
        "1ec3": "Clear the display area.",
        "1ec6": "The current value of  is increased by 50",
        "1ec9": "before being tested. This forms the lower limit.",
        "1ed0": " will be too low.",
        "1ed2": "For the upper test the value for  is",
        "1ed5": "tested against .",
        "1ed8": "Jump forward if acceptable.",
        "1eda": "Call the error handling routine.",
        "1edc": "Now the value can actually be passed to",
        "1edd": ".",
        "1ee0": "Fetch the address of #R$1B76.",
        "1ee1": "Fetch the 'error address'.",
        "1ee2": "Enter a GO SUB stack end marker.",
        "1ee4": "Leave one location.",
        "1ee5": "Make the stack pointer point to an empty GO SUB stack.",
        "1ee6": "Next pass the 'error address' to the stack and save its",
        "1ee7": "address in .",
        "1eeb": "An indirect return is now made to #R$1B76.",
        "1eed": "Save the address - #R$1B76.",
        "1eee": "Fetch the statement number () and",
        "1ef1": "increment it.",
        "1ef2": "Exchange the 'error address' with the statement number.",
        "1ef3": "Reclaim the use of a location.",
        "1ef4": "Next save the present line number ().",
        "1ef9": "Return the 'error address' to the machine stack and",
        "1efa": "reset  to point to it.",
        "1efe": "Return the address #R$1B76.",
        "1eff": "Now set  and  to the",
        "1f02": "But before making the jump make a test for room.",
        "1f05": "Increase the value taken from  by the",
        "1f08": "value carried into the routine by the #REGbc register",
        "1f09": "Jump forward if the result is over &FFFF.",
        "1f0b": "Try it again allowing for a further eighty bytes.",
        "1f12": "Finally test the value against the address of the",
        "1f14": "Return if satisfactory.",
        "1f15": "This is a 'run-time' error and the error marker is not",
        "1f17": "to be used.",
        "1f1a": "Do not allow any overhead.",
        "1f1d": "Make the test and pass the result to the #REGbc",
        "1f20": "register before returning.",
        "1f23": "Fetch the address - #R$1B76.",
        "1f24": "Fetch the 'error address'.",
        "1f25": "Fetch the last entry on the GO SUB stack.",
        "1f26": "The entry is tested to see if it is the GO SUB stack",
        "1f27": "end marker.",
        "1f29": "Jump if it is.",
        "1f2b": "The full entry uses three locations only.",
        "1f2c": "Exchange the statement number with the 'error address'.",
        "1f2d": "Move the statement number.",
        "1f2e": "Reset the error pointer ().",
        "1f32": "Replace the address #R$1B76.",
        "1f33": "Jump back to change  and .",
        "1f36": "Replace the end marker and the 'error address'.",
        "1f38": "Call the error handling routine.",
        "1f3a": "Fetch the operand.",
        "1f3d": "Wait for a maskable interrupt.",
        "1f3e": "Decrease the counter.",
        "1f3f": "If the counter is thereby reduced to zero the pause",
        "1f40": "has come to an end.",
        "1f43": "If the operand was zero #REGbc will now hold &FFFF and",
        "1f44": "this value will be returned to zero. Jump with all",
        "1f45": "other operand values.",
        "1f49": "Jump back unless a key has been pressed (bit 5 of",
        "1f4d": " set).",
        "1f4f": "Signal 'no key pressed' (reset bit 5 of",
        "1f53": "Now return - to #R$1B76.",
        "1f54": "Form the port address &7FFE and read in a byte.",
        "1f58": "Examine only bit 0 by shifting it into the carry",
        "1f59": "Return if the BREAK key is not being pressed.",
        "1f5a": "Form the port address &FEFE and read in a byte.",
        "1f5e": "Again examine bit 0.",
        "1f5f": "Return with carry reset if both keys are being pressed.",
        "1f60": "Jump forward if checking syntax.",
        "1f65": "Otherwise pass by the 'DEF FN' statement.",
        "1f6a": "Signal 'a numeric variable' (set bit 6 of",
        "1f6e": "Check that the present code is a letter.",
        "1f71": "Jump forward if not.",
        "1f73": "Fetch the next character.",
        "1f74": "Jump forward unless it is a '$'.",
        "1f78": "Reset bit 6 of  as it is a string",
        "1f7c": "Fetch the next character.",
        "1f7d": "A '(' must follow the variable's name.",
        "1f81": "Fetch the next character.",
        "1f82": "Jump forward if it is a ')' as there are no parameters",
        "1f84": "of the function.",
        "1f86": "The present code must be a letter.",
        "1f8c": "Save the pointer in #REGde.",
        "1f8d": "Fetch the next character.",
        "1f8e": "Jump forward unless it is a '$'.",
        "1f92": "Otherwise save the new pointer in #REGde instead.",
        "1f93": "Fetch the next character.",
        "1f94": "Move the pointer to the last character of the name to",
        "1f95": "Now make six locations after that last character and",
        "1f98": "enter a 'number marker' into the first of the new",
        "1f9b": "locations.",
        "1f9f": "If the present character is a ',' then jump back as",
        "1fa1": "there should be a further parameter; otherwise jump out",
        "1fa3": "of the loop.",
        "1fa6": "Check that the ')' does exist.",
        "1faa": "The next character is fetched.",
        "1fab": "It must be an '='.",
        "1faf": "Fetch the next character.",
        "1fb0": "Save the nature - numeric or string - of the variable",
        "1fb3": "(bit 6 of ).",
        "1fb4": "Now consider the definition as an expression.",
        "1fb7": "Fetch the nature of the variable and check that it is",
        "1fb8": "of the same type as found for the definition (specified",
        "1fbb": "by bit 6 of ).",
        "1fbd": "Give an error report if it is required.",
        "1fc0": "Exit via #R$1BEE (thereby moving on to consider the",
        "1fc3": "Is syntax being checked?",
        "1fc6": "Fetch the return address but ignore it in",
        "1fc7": "'syntax-time'.",
        "1fc8": "In 'run-time' make a simple return to the calling",
        "1fc9": "Prepare to open channel 'P'.",
        "1fcb": "Jump forward.",
        "1fcd": "Prepare to open channel 'S'.",
        "1fcf": "Unless syntax is being checked open a channel.",
        "1fd5": "Set the temporary colour system variables.",
        "1fd8": "Call the print controlling subroutine.",
        "1fdb": "Move on to consider the next statement (via #R$1BEE if",
        "1fde": "checking syntax).",
        "1fdf": "Get the first character.",
        "1fe0": "Jump forward if already at the end of the item list.",
        "1fe5": "Deal with any consecutive position controllers.",
        "1fea": "Deal with a single print item.",
        "1fed": "Check for further position controllers and print items",
        "1ff0": "until there are none left.",
        "1ff2": "Return now if the present character is a ')'; otherwise",
        "1ff4": "consider performing a 'carriage return'.",
        "1ff5": "Return if checking syntax.",
        "1ff8": "Print a carriage return character and then return.",
        "1ffc": "The first character is fetched.",
        "1ffd": "Jump forward unless it is an 'AT'.",
        "2001": "The two parameters are transferred to the calculator",
        "2004": "Return now if checking syntax.",
        "2007": "The parameters are compressed into the #REGbc register",
        "200a": "The #REGa register is loaded with the AT control",
        "200c": "character before the jump is taken.",
        "200e": "Jump forward unless it is a 'TAB'.",
        "2012": "Get the next character.",
        "2013": "Transfer one parameter to the calculator stack.",
        "2016": "Return now if checking syntax.",
        "2019": "The value is compressed into the #REGbc register pair.",
        "201c": "The #REGa register is loaded with the TAB control",
        "201e": "Print the control character.",
        "201f": "Follow it with the first value.",
        "2021": "Finally print the second value, then return.",
        "2024": "Return with carry reset if colour items were found.",
        "2027": "Continue if none were found.",
        "2028": "Next consider if the stream is to be changed.",
        "202b": "Continue unless it was altered.",
        "202c": "Evaluate the expression but return now if checking",
        "202f": "syntax.",
        "2032": "Test for the nature of the expression (bit 6 of",
        "2036": "If it is a string then fetch the necessary parameters;",
        "2039": "but if it is numeric then exit via #R$2DE3.",
        "203c": "Return now if there are no characters remaining in the",
        "203d": "string; otherwise decrease the counter.",
        "2040": "Fetch the code and increment the pointer.",
        "2042": "The code is printed and a jump taken to consider any",
        "2043": "further characters.",
        "2045": "Return now if the character is a ')'.",
        "2048": "Return now if the character is a 'carriage return'.",
        "204b": "Make a final test against ':' before returning.",
        "204e": "Get the present character.",
        "204f": "\"        ; {Jump forward if it is a ';'.",
        "2053": "Also jump forward with a character other than a ',',",
        "2055": "but do not actually print the character if checking",
        "2057": "syntax.",
        "205c": "Load the #REGa register with the 'comma' control code",
        "205e": "and print it, then jump forward.",
        "2061": "Is it a '''?",
        "2063": "Return now (with the zero flag reset) if not any of the",
        "2064": "Print 'carriage return' unless checking syntax.",
        "2067": "Fetch the next character.",
        "2068": "If not at the end of a print statement then jump",
        "206b": "forward.",
        "206d": "Otherwise drop the return address from the stack.",
        "206e": "Set the zero flag and return.",
        "2070": "Unless the present character is a '#' return with the",
        "2072": "carry flag set.",
        "2074": "Advance .",
        "2075": "Pass the parameter to the calculator stack.",
        "2078": "Clear the carry flag.",
        "2079": "Return now if checking syntax.",
        "207c": "The value is passed to the #REGa register.",
        "207f": "Give report O if the value is over &0F.",
        "2084": "Use the channel for the stream in question.",
        "2087": "Clear the carry flag and return.",
        "2089": "Jump forward if syntax is being checked.",
        "208e": "Open channel 'K'.",
        "2093": "The lower part of the display is cleared.",
        "2096": "Signal that the lower screen is being handled (set bit",
        "209a": "Call the subroutine to deal with the INPUT items.",
        "209d": "Move on to the next statement if checking syntax.",
        "20a0": "Fetch the current print position ().",
        "20a4": "Jump forward if the current position is above the",
        "20a7": "lower screen (see ).",
        "20aa": "Otherwise set the print position to the top of the",
        "20ac": "lower screen.",
        "20ad": "Reset .",
        "20b1": "Now set the scroll counter ().",
        "20b7": "Signal 'main screen' (reset bit 0 of",
        "20bb": "Set the system variables and exit via #R$0D6E.",
        "20c1": "Consider first any position control characters.",
        "20c6": "Jump forward if the present character is not a '('.",
        "20ca": "Fetch the next character.",
        "20cb": "Now call the PRINT command routine to handle the items",
        "20ce": "Fetch the present character.",
        "20cf": "Give report C unless the character is a ')'.",
        "20d4": "Fetch the next character and jump forward to see if",
        "20d5": "there are any further INPUT items.",
        "20d8": "Jump forward if it is not 'LINE'.",
        "20dc": "Advance .",
        "20dd": "Determine the destination address for the variable.",
        "20e0": "Signal 'using INPUT LINE' (set bit 7 of",
        "20e4": "Give report C unless using a string variable (bit 6",
        "20e8": "of  reset).",
        "20eb": "Jump forward to issue the prompt message.",
        "20ed": "Jump to consider going round the loop again if the",
        "20f0": "present character is not a letter.",
        "20f3": "Determine the destination address for the variable.",
        "20f6": "Signal 'not INPUT LINE' (reset bit 7 of",
        "20fa": "Jump forward if only checking syntax.",
        "2100": "The work space is set to null.",
        "2103": "This is .",
        "2106": "Signal 'string result'.",
        "2108": "Signal 'INPUT mode'.",
        "210a": "Allow the prompt message only a single location.",
        "210d": "Jump forward if using 'LINE'.",
        "2111": "Jump forward if awaiting a numeric entry (bit 6 of",
        "2114": " set).",
        "2118": "A string entry will need three locations.",
        "211a": "Bit 6 of  will become set for a numeric",
        "211b": "entry.",
        "211c": "The required number of locations is made available.",
        "211d": "A 'carriage return' goes into the last location.",
        "211f": "Test bit 6 of the #REGc register and jump forward if",
        "2120": "only one location was required.",
        "2124": "A 'double quotes' character goes into the first and",
        "2126": "second locations.",
        "2129": "The position of the cursor () can now be",
        "212c": "Jump forward with 'INPUT LINE' (bit 7 of",
        "2130": " set).",
        "2132": "Save the current values of  and",
        "2135": " on the machine stack.",
        "213a": "This will be the 'return point' in case of errors.",
        "213e": "Only change the error stack pointer ()",
        "2142": "if using channel 'K' (bit 4 of #R$5C6A(FLAGS2) set).",
        "2148": "Set #REGhl to the start of the INPUT line",
        "214b": "() and remove any floating-point forms.",
        "214e": "Signal 'no error yet' by resetting .",
        "2152": "Now get the INPUT and with the syntax/run flag (bit 7",
        "2155": "of ) indicating syntax, check the INPUT",
        "2159": "for errors; jump if in order; return to #R$213A if",
        "215c": "not.",
        "215e": "Get a 'LINE'.",
        "2161": "The cursor address () is reset.",
        "2165": "The jump is taken if using other than channel 'K'.",
        "216a": "The input-line is copied to the display and the",
        "216d": "position in  made the current position",
        "2171": "in the lower screen.",
        "2174": "This is .",
        "2177": "Signal 'edit mode'.",
        "2179": "Jump forward if handling an INPUT LINE.",
        "217f": "Drop the address IN-VAR-1.",
        "2180": "Reset the  to its original address.",
        "2184": "Save the original  address in",
        "2185": ".",
        "2188": "Now with the syntax/run flag (bit 7 of",
        "218c": ") indicating 'run' make the assignment.",
        "218f": "Restore the original address to  and",
        "2192": "clear .",
        "2199": "Jump forward to see if there are further INPUT items.",
        "219b": "The length of the 'LINE' in the work space is found",
        "219e": "(--1).",
        "21a5": "#REGde points to the start and #REGbc holds the",
        "21a6": "length.",
        "21a7": "These parameters are stacked and the actual",
        "21aa": "assignment made.",
        "21ad": "Also jump forward to consider further items.",
        "21af": "Handle any print items.",
        "21b2": "Handle any position controllers.",
        "21b5": "Go around the loop again if there are further items;",
        "21b8": "otherwise return.",
        "21b9": "Set  to point to the first location of",
        "21bc": "the work space () and fetch the",
        "21bf": "character.",
        "21c0": "Is it a 'STOP'?",
        "21c2": "Jump if it is.",
        "21c4": "Otherwise pick up  and make the",
        "21c7": "assignment of the 'value' to the variable.",
        "21ca": "Get the present character and check it is a 'carriage",
        "21cb": "return'.",
        "21cd": "Return if it is.",
        "21ce": "Call the error handling routine.",
        "21d0": "But do not give the error report on the syntax-pass.",
        "21d4": "Call the error handling routine.",
        "21d6": "The base address of the channel information for the",
        "21d9": "current channel () is fetched and the",
        "21da": "channel code compared to the character 'K'.",
        "21e0": "Return afterwards.",
        "21e1": "Consider the next character in the BASIC statement.",
        "21e2": "Jump forward to see if the present code represents an",
        "21e5": "embedded 'temporary' colour item. Return carry set if",
        "21e6": "Fetch the present character.",
        "21e7": "Jump back if it is either a ',' or a ';'; otherwise",
        "21e9": "there has been an error.",
        "21eb": "\"        ;",
        "21ef": "Exit via 'report C'.",
        "21f2": "Return with the carry flag set if the code is not in",
        "21f4": "the range &D9 to &DE (INK to OVER).",
        "21f9": "The colour item code is preserved whilst",
        "21fa": " is advanced to address the parameter",
        "21fb": "that follows it.",
        "21fc": "The token range (&D9 to &DE) is reduced to the control",
        "21fe": "The control character code is preserved whilst the",
        "21ff": "parameter is moved to the calculator stack.",
        "2203": "A return is made at this point if syntax is being",
        "2204": "checked.",
        "2207": "The control character code is preserved whilst the",
        "2208": "parameter is moved to the #REGd register.",
        "220d": "The control character is sent out.",
        "220e": "Then the parameter is fetched and sent out before",
        "220f": "returning.",
        "2211": "Reduce the range and jump forward with INK and PAPER.",
        "2217": "Reduce the range once again and jump forward with FLASH",
        "2219": "and BRIGHT.",
        "221d": "Prepare to jump with OVER.",
        "221f": "Fetch the parameter.",
        "2220": "Prepare the mask for OVER.",
        "2222": "Now jump.",
        "2224": "Bit 2 of the #REGa register is to be reset for INVERSE",
        "2225": "0 and set for INVERSE 1; the mask is to have bit 2 set.",
        "2228": "Save the #REGa register whilst the range is tested.",
        "2229": "The correct range for INVERSE and OVER is only '0-1'.",
        "222e": "Restore the #REGa register.",
        "222f": "It is  that is to be changed.",
        "2232": "Exit via #R$226C and alter  using #REGb",
        "2234": "Fetch the parameter.",
        "2235": "Prepare the mask for INK.",
        "2237": "Jump forward with INK.",
        "2239": "Multiply the parameter for PAPER by eight.",
        "223c": "Prepare the mask for PAPER.",
        "223e": "Save the parameter in the #REGc register whilst the",
        "223f": "Fetch the original value.",
        "2240": "Only allow PAPER/INK a range of '0' to '9'.",
        "2244": "Call the error handling routine.",
        "2246": "Prepare to alter ,  and",
        "2249": "Jump forward with PAPER/INK '0' to '7'.",
        "224d": "Fetch the current value of  and use it",
        "224e": "unchanged, by jumping forward, with PAPER/INK '8'.",
        "2250": "But for PAPER/INK '9' the PAPER and INK colours have to",
        "2251": "be black and white.",
        "2254": "Jump for black INK/PAPER, but continue for white",
        "2256": "INK/PAPER.",
        "2257": "Move the value to the #REGc register.",
        "2258": "Move the value.",
        "2259": "Now change  as needed.",
        "225c": "The bits of  are set only when using",
        "225e": "PAPER/INK '8' or '9'.",
        "2260": "Now change  as needed.",
        "2263": "The appropriate mask is built up in the #REGb register",
        "2264": "in order to change bits 4 and 6 as necessary.",
        "2268": "The bits of  are set only when using",
        "226a": "PAPER/INK '9'. Continue into #R$226C to manipulate",
        "226b": ".",
        "226c": "The bits, specified by the mask in the #REGb register,",
        "226d": "are changed in the value and the result goes to form the",
        "226e": "system variable.",
        "2270": "Move on to address the next system variable.",
        "2271": "Return with the mask in the #REGa register.",
        "2273": "The zero flag will be set for BRIGHT.",
        "2274": "The parameter is fetched and rotated.",
        "2276": "Prepare the mask for FLASH.",
        "2278": "Jump forward with FLASH.",
        "227a": "Rotate an extra time and prepare the mask for BRIGHT.",
        "227d": "Save the value in the #REGc register.",
        "227e": "Fetch the parameter and test its range; only '0', '1'",
        "227f": "and '8' are allowable.",
        "2287": "Fetch the value.",
        "2288": "This is .",
        "228b": "Now change the system variable.",
        "228e": "The value is fetched anew.",
        "228f": "The set bit of FLASH/BRIGHT '8' (bit 3) is moved to bit",
        "2290": "7 (for FLASH) or bit 6 (for BRIGHT).",
        "2292": "Exit via #R$226C.",
        "2294": "The parameter is fetched and its range is tested.",
        "229b": "The '#S/OUT/' instruction is then used to set the border",
        "229d": "The parameter is then multiplied by eight.",
        "22a0": "Is the border colour a 'light' colour?",
        "22a2": "Jump if so (the INK colour will be black).",
        "22a4": "Change the INK colour to white.",
        "22a6": "Set the system variable () as required",
        "22a9": "and return.",
        "22aa": "Test that the y co-ordinate (in #REGb) is not greater",
        "22ac": "than 175.",
        "22b0": "#REGb now contains 175 minus y.",
        "22b1": "#REGa holds b7b6b5b4b3b2b1b0, the bits of #REGb.",
        "22b2": "And now 0b7b6b5b4b3b2b1.",
        "22b3": "Now 10b7b6b5b4b3b2.",
        "22b5": "Now 010b7b6b5b4b3.",
        "22b7": "Finally 010b7b6b2b1b0, so that #REGh becomes",
        "22b8": "64+8*INT(#REGb/64)+(#REGb mod 8), the high byte of the",
        "22ba": "pixel address.",
        "22bc": "#REGc contains x.",
        "22bd": "#REGa starts as c7c6c5c4c3c2c1c0 and becomes",
        "22be": "c4c3c2c1c0c7c6c5.",
        "22c0": "Now c4c3b5b4b3c7c6c5.",
        "22c4": "Finally b5b4b3c7c6c5c4c3, so that #REGl becomes",
        "22c5": "32*INT((#REGb mod 64)/8)+INT(x/8), the low byte.",
        "22c7": "#REGa holds x mod 8, so the pixel is bit (7-#REGa)",
        "22c8": "within the byte.",
        "22cb": "y-coordinate to #REGb, x to #REGc.",
        "22ce": "Pixel address to #REGhl.",
        "22d1": "#REGb will count #REGa+1 loops to get the wanted bit of",
        "22d2": "(#REGhl) to location 0.",
        "22d4": "The shifts.",
        "22d7": "The bit is 1 for ink, 0 for paper.",
        "22d9": "It is put on the calculator stack.",
        "22dc": "y-coordinate to #REGb, x to #REGc.",
        "22df": "The subroutine is called.",
        "22e2": "Exit, setting temporary colours.",
        "22e5": "The system variable  is set.",
        "22e9": "Pixel address to #REGhl.",
        "22ec": "#REGb will count #REGa+1 loops to get a zero to the",
        "22ed": "correct place in #REGa.",
        "22ee": "The zero is entered.",
        "22f0": "Then lined up with the pixel bit position in the byte.",
        "22f3": "Then copied to #REGb.",
        "22f4": "The pixel-byte is obtained in #REGa.",
        "22f5": " is obtained and first tested for OVER.",
        "22fa": "Jump if OVER 1.",
        "22fc": "OVER 0 first makes the pixel zero.",
        "22fd": "Test for INVERSE.",
        "22ff": "INVERSE 1 just leaves the pixel as it was (OVER 1) or",
        "2301": "INVERSE 0 leaves the pixel complemented (OVER 1) or 1",
        "2302": "(OVER 0).",
        "2303": "The byte is entered. Its other bits are unchanged in",
        "2304": "Exit, setting attribute byte.",
        "2307": "First number to #REGa.",
        "230a": "Hence to #REGb.",
        "230b": "Save it briefly.",
        "230c": "Second number to #REGa.",
        "230f": "Its sign indicator to #REGe.",
        "2310": "Restore first number.",
        "2311": "Its sign indicator to #REGd.",
        "2312": "Second number to #REGc.",
        "2313": "#REGbc, #REGde are now as required.",
        "2314": "Modulus of rounded last value to #REGa if possible;",
        "2317": "else, report error.",
        "231a": "One to #REGc for positive last value.",
        "231c": "Return if value was positive.",
        "231d": "Else change #REGc to &FF (i.e. minus one).",
        "231f": "Finished.",
        "2320": "Get the present character.",
        "2321": "Test for comma.",
        "2323": "If not so, report the error.",
        "2326": "Get next character (the radius).",
        "2327": "Radius to calculator stack.",
        "232a": "Move to consider next statement if checking syntax.",
        "232d": "Use calculator.",
        "232e": "#R$346A: X, Y, Z",
        "232f": "#R$3297: Z is re-stacked; its exponent is therefore",
        "2330": "#R$369B",
        "2331": "Get exponent of radius.",
        "2332": "Test whether radius less than 1.",
        "2334": "If not, jump.",
        "2336": "If less, delete it from the stack.",
        "2337": "#R$33A1: X, Y",
        "2338": "#R$369B",
        "2339": "Just plot the point X, Y.",
        "233c": "#R$341B(stk_pi_2): X, Y, Z, #pi/2",
        "233d": "#R$369B",
        "233e": "Now increase exponent to &83, changing #pi/2 into 2#pi.",
        "2340": "X, Y, Z, 2#pi.",
        "2341": "#R$342D(st_mem_5): (2#pi is copied to mem-5)",
        "2342": "#R$33A1: X, Y, Z",
        "2343": "#R$369B",
        "2344": "Set the initial parameters.",
        "2347": "Save the arc-count in #REGb.",
        "2348": "X, Y, Z",
        "2349": "#R$33C0: X, Y, Z, Z",
        "234a": "#R$340F(get_mem_1): X, Y, Z, Z, SIN (#pi/A)",
        "234b": "#R$30CA: X, Y, Z, Z*SIN (#pi/A)",
        "234c": "#R$369B",
        "234d": "Z*SIN (#pi/A) is half the initial 'arc' length; it is",
        "234e": "tested to see whether it is less than 0.5.",
        "2350": "If not, the jump is made.",
        "2353": "#R$33A1: X, Y, Z",
        "2354": "#R$33A1: X, Y",
        "2355": "#R$369B",
        "2356": "Clear the machine stack.",
        "2357": "Jump to plot X, Y.",
        "235a": "X, Y, Z, Z*SIN (#pi/A)",
        "235b": "#R$342D(st_mem_2): (Z*SIN (#pi/A) to mem-2 for now)",
        "235c": "#R$343C: X, Y, Z*SIN (#pi/A), Z",
        "235d": "#R$342D(st_mem_0): X, Y, Z*SIN (#pi/A), Z (Z is copied",
        "235e": "#R$33A1: X, Y, Z*SIN (#pi/A)",
        "235f": "#R$300F: X, Y-Z*SIN (#pi/A)",
        "2360": "#R$343C: Y-Z*SIN (#pi/A), X",
        "2361": "#R$340F(get_mem_0): Y-Z*SIN (#pi/A), X, Z",
        "2362": "#R$3014: Y-Z*SIN (#pi/A), X+Z",
        "2363": "#R$342D(st_mem_0): (X+Z is copied to mem-0)",
        "2364": "#R$343C: X+Z, Y-Z*SIN (#pi/A)",
        "2365": "#R$33C0: X+Z, Y-Z*SIN (#pi/A), Y-Z*SIN (#pi/A)",
        "2366": "#R$340F(get_mem_0): sa, sb, sb, sa",
        "2367": "#R$343C: sa, sb, sa, sb",
        "2368": "#R$33C0: sa, sb, sa, sb, sb",
        "2369": "#R$340F(get_mem_0): sa, sb, sa, sb, sb, sa",
        "236a": "#R$341B(stk_zero): sa, sb, sa, sb, sb, sa, 0",
        "236b": "#R$342D(st_mem_1): (mem-1 is set to zero)",
        "236c": "#R$33A1: sa, sb, sa, sb, sb, sa",
        "236d": "#R$369B",
        "236e": "Incrementing the exponent byte of #R$5C9C(mem-2) sets",
        "2371": "The last value X+Z is moved from the stack to #REGa and",
        "2374": "copied to #REGl.",
        "2375": "It is saved in #REGhl.",
        "2376": "Y-Z*SIN (#pi/A) goes from the stack to #REGa and is",
        "2379": "copied to #REGh. #REGhl now holds the initial point.",
        "237b": "It is copied to .",
        "237e": "The arc-count is restored.",
        "237f": "The jump is made to #R$2420.",
        "2382": "Get the current character.",
        "2383": "If it is a comma, then jump.",
        "2387": "Move on to next statement if checking syntax.",
        "238a": "Jump to just draw the line.",
        "238d": "Get next character (the angle).",
        "238e": "Angle to calculator stack.",
        "2391": "Move on to next statement if checking syntax.",
        "2394": "X, Y, G are on the stack.",
        "2395": "#R$342D(st_mem_5): (G is copied to mem-5)",
        "2396": "#R$341B(stk_half): X, Y, G, 0.5",
        "2397": "#R$30CA: X, Y, G/2",
        "2398": "#R$37B5: X, Y, SIN (G/2)",
        "2399": "#R$33C0: X, Y, SIN (G/2), SIN (G/2)",
        "239a": "#R$3501: X, Y, SIN (G/2), (0/1)",
        "239b": "#R$3501: X, Y, SIN (G/2), (1/0)",
        "239c": "#R$368F: X, Y, SIN (G/2)",
        "239d": "to #R$23A3 (if SIN (G/2)=0 i.e. G=2#piN just draw a",
        "239e": "#R$33A1: X, Y",
        "239f": "#R$369B",
        "23a0": "Line X0, Y0 to X0+X, Y0+Y.",
        "23a3": "#R$342D(st_mem_0): (SIN (G/2) is copied to mem-0)",
        "23a4": "#R$33A1: X, Y are now on the stack.",
        "23a5": "#R$342D(st_mem_1): (Y is copied to mem-1).",
        "23a6": "#R$33A1: X",
        "23a7": "#R$33C0: X, X",
        "23a8": "#R$346A: X, X' (X'=ABS X)",
        "23a9": "#R$340F(get_mem_1): X, X', Y",
        "23aa": "#R$343C: X, Y, X'",
        "23ab": "#R$340F(get_mem_1): X, Y, X', Y",
        "23ac": "#R$346A: X, Y, X', Y' (Y'=ABS Y)",
        "23ad": "#R$3014: X, Y, X'+Y'",
        "23ae": "#R$340F(get_mem_0): X, Y, X'+Y', SIN (G/2)",
        "23af": "#R$31AF: X, Y, (X'+Y')/SIN (G/2)=Z', say",
        "23b0": "#R$346A: X, Y, Z (Z=ABS Z')",
        "23b1": "#R$340F(get_mem_0): X, Y, Z, SIN (G/2)",
        "23b2": "#R$343C: X, Y, SIN (G/2), Z",
        "23b3": "#R$3297: (Z is re-stacked to make sure that its exponent",
        "23b4": "#R$369B",
        "23b5": "Get exponent of Z.",
        "23b6": "If Z is greater than or equal to 1, jump.",
        "23ba": "X, Y, SIN (G/2), Z",
        "23bb": "#R$33A1: X, Y, SIN (G/2)",
        "23bc": "#R$33A1: X, Y",
        "23bd": "#R$369B",
        "23be": "Just draw the line from X0, Y0 to X0+X, Y0+Y.",
        "23c1": "The subroutine is called.",
        "23c4": "Save the arc-counter in #REGb.",
        "23c5": "X, Y, SIN(G/2), Z",
        "23c6": "#R$33A1: X, Y, SIN(G/2)",
        "23c7": "#R$340F(get_mem_1): X, Y, SIN(G/2), SIN(G/2*A)",
        "23c8": "#R$343C: X, Y, SIN(G/2*A), SIN(G/2)",
        "23c9": "#R$31AF: X, Y, SIN(G/2*A)/SIN(G/2)=W",
        "23ca": "#R$342D(st_mem_1): (W is copied to mem-1).",
        "23cb": "#R$33A1: X, Y",
        "23cc": "#R$343C: Y, X",
        "23cd": "#R$33C0: Y, X, X",
        "23ce": "#R$340F(get_mem_1): Y, X, X, W",
        "23cf": "#R$30CA: Y, X, X*W",
        "23d0": "#R$342D(st_mem_2): (X*W is copied to mem-2).",
        "23d1": "#R$33A1: Y, X",
        "23d2": "#R$343C: X, Y",
        "23d3": "#R$33C0: X, Y, Y",
        "23d4": "#R$340F(get_mem_1): X, Y, Y, W",
        "23d5": "#R$30CA: X, Y, Y*W",
        "23d6": "#R$340F(get_mem_2): X, Y, Y*W, X*W",
        "23d7": "#R$340F(get_mem_5): X, Y, Y*W, X*W,G",
        "23d8": "#R$340F(get_mem_0): X, Y, Y*W, X*W, G, G/A",
        "23d9": "#R$300F: X, Y, Y*W, X*W, G-G/A",
        "23da": "#R$341B(stk_half): X, Y, Y*W, X*W, G-G/A, 1/2",
        "23db": "#R$30CA: X, Y, Y*W, X*W, G/2-G/2*A=F",
        "23dc": "#R$33C0: X, Y, Y*W, X*W, F, F",
        "23dd": "#R$37B5: X, Y, Y*W, X*W, F, SIN F",
        "23de": "#R$342D(st_mem_5): (SIN F is copied to mem-5).",
        "23df": "#R$33A1: X, Y, Y*W, X*W,F",
        "23e0": "#R$37AA: X, Y, Y*W, X*W, COS F",
        "23e1": "#R$342D(st_mem_0): (COS F is copied to mem-0).",
        "23e2": "#R$33A1: X, Y, Y*W, X*W",
        "23e3": "#R$342D(st_mem_2): (X*W is copied to mem-2).",
        "23e4": "#R$33A1: X, Y, Y*W",
        "23e5": "#R$342D(st_mem_1): (Y*W is copied to mem-1).",
        "23e6": "#R$340F(get_mem_5): X, Y, Y*W, SIN F",
        "23e7": "#R$30CA: X, Y, Y*W*SIN F",
        "23e8": "#R$340F(get_mem_0): X, Y, Y*W*SIN F, X*W",
        "23e9": "#R$340F(get_mem_2): X, Y, Y*W*SIN F, X*W, COS F",
        "23ea": "#R$30CA: X, Y, Y*W*SIN F, X*W*COS F",
        "23eb": "#R$3014: X, Y, Y*W*SIN F+X*W*COS F=U",
        "23ec": "#R$340F(get_mem_1): X, Y, U, Y*W",
        "23ed": "#R$343C: X, Y, Y*W, U",
        "23ee": "#R$342D(st_mem_1): (U is copied to mem-1)",
        "23ef": "#R$33A1: X, Y, Y*W",
        "23f0": "#R$340F(get_mem_0): X, Y, Y*W, COS F",
        "23f1": "#R$30CA: X, Y, Y*W*COS F",
        "23f2": "#R$340F(get_mem_2): X, Y, Y*W*COS F, X*W",
        "23f3": "#R$340F(get_mem_5): X, Y, Y*W*COS F, X*W, SIN F",
        "23f4": "#R$30CA: X, Y, Y*W*COS F, X*W*SIN F",
        "23f5": "#R$300F: X, Y, Y*W*COS F-X*W*SIN F=V",
        "23f6": "#R$342D(st_mem_2): (V is copied to mem-2).",
        "23f7": "#R$346A: X, Y, V' (V'=ABS V)",
        "23f8": "#R$340F(get_mem_1): X, Y, V', U",
        "23f9": "#R$346A: X, Y, V', U' (U'=ABS U)",
        "23fa": "#R$3014: X, Y, U'+V'",
        "23fb": "#R$33A1: X, Y",
        "23fc": "#R$369B: (#REGde now points to U'+V').",
        "23fd": "Get exponent of U'+V'.",
        "23fe": "If U'+V' is less than 1, just tidy the stack and draw",
        "2400": "the line from X0, Y0 to X0+X, Y0+Y.",
        "2404": "Otherwise, continue with the parameters: X, Y, on the",
        "2405": "stack.",
        "2406": "#R$343C: Y, X",
        "2407": "#R$369B",
        "2408": "Get X0 from  into #REGa and so on to the",
        "240b": "stack.",
        "240e": "Y, X, X0",
        "240f": "#R$342D(st_mem_0): (X0 is copied to mem-0).",
        "2410": "#R$3014: Y, X0+X",
        "2411": "#R$343C: X0+X, Y",
        "2412": "#R$369B",
        "2413": "Get Y0 from  into #REGa and so on to the",
        "2416": "stack.",
        "2419": "X0+X, Y, Y0",
        "241a": "#R$342D(st_mem_5): (Y0 is copied to mem-5).",
        "241b": "#R$3014: X0+X, Y0+Y",
        "241c": "#R$340F(get_mem_0): X0+X, Y0+Y, X0",
        "241d": "#R$340F(get_mem_5): X0+X, Y0+Y, X0, Y0",
        "241e": "#R$369B",
        "241f": "Restore the arc-counter in #REGb.",
        "2420": "#REGb counts the passes through the loop.",
        "2421": "Jump when #REGb has reached zero.",
        "2423": "Jump into the loop to start.",
        "2425": "(See text above for the stack).",
        "2426": "#R$340F(get_mem_1): Un-1",
        "2427": "#R$33C0: Un-1, Un-1",
        "2428": "#R$340F(get_mem_3): Un-1, Un-1, COS(G/A)",
        "2429": "#R$30CA: Un-1, Un-1*COS(G/A)",
        "242a": "#R$340F(get_mem_2): Un-1, Un-1*COS(G/A), Vn-1",
        "242b": "#R$340F(get_mem_4): Un-1, Un-1*COS(G/A), Vn-1, SIN(G/A)",
        "242c": "#R$30CA: Un-1, Un-1*COS(G/A), Vn-1*SIN(G/A)",
        "242d": "#R$300F: Un-1, Un-1*COS(G/A)-Vn-1*SIN(G/A)=Un",
        "242e": "#R$342D(st_mem_1): (Un is copied to mem-1).",
        "242f": "#R$33A1: Un-1",
        "2430": "#R$340F(get_mem_4): Un-1, SIN(G/A)",
        "2431": "#R$30CA: Un-1*SIN(G/A)",
        "2432": "#R$340F(get_mem_2): Un-1*SIN(G/A), Vn-1",
        "2433": "#R$340F(get_mem_3): Un-1*SIN(G/A), Vn-1, COS(G/A)",
        "2434": "#R$30CA: Un-1*SIN(G/A), Vn-1*COS(G/A)",
        "2435": "#R$3014: Un-1*SIN(G/A)+Vn-1*COS(G/A)=Vn",
        "2436": "#R$342D(st_mem_2): (Vn is copied to mem-2).",
        "2437": "#R$33A1: (As noted in the text, the stack in fact holds",
        "2438": "#R$369B",
        "2439": "Save the arc-counter.",
        "243a": "X0+X, Y0+y, Xn, Yn",
        "243b": "#R$342D(st_mem_0): (Yn is copied to mem-0).",
        "243c": "#R$33A1: X0+X, Y0+Y, Xn",
        "243d": "#R$340F(get_mem_1): X0+X, Y0+Y, Xn, Un",
        "243e": "#R$3014: X0+X, Y0+Y, Xn+Un=Xn+1",
        "243f": "#R$33C0: X0+X, Y0+Y, Xn+1, Xn+1",
        "2440": "#R$369B",
        "2441": "Next Xn', the approximate value of Xn reached by the",
        "2444": "line-drawing subroutine is copied from ",
        "2447": "X0+X, Y0+Y, Xn+1, Xn'",
        "2448": "#R$300F: X0+X, Y0+Y, Xn+1, Xn+1, Xn'-Xn'=Un'",
        "2449": "#R$340F(get_mem_0): X0+X, Y0+Y, Xn+1, Un', Yn",
        "244a": "#R$340F(get_mem_2): X0+X, Y0+Y, Xn+1, Un', Yn, Vn",
        "244b": "#R$3014: X0+X, Y0+Y, Xn+1, Un', Yn+Vn=Yn+1",
        "244c": "#R$342D(st_mem_0): (Yn+1 is copied to mem-0).",
        "244d": "#R$343C: X0+X, Y0+Y, Xn+1, Yn+1, Un'",
        "244e": "#R$340F(get_mem_0): X0+X, Y0+Y, Xn+1, Yn+1, Un', Yn+1",
        "244f": "#R$369B",
        "2450": "Yn', approximate like Xn', is copied from",
        "2453": " to #REGa and hence to the stack.",
        "2456": "X0+X, Y0+Y, Xn+1, Yn+1, Un', Yn+1, Yn'",
        "2457": "#R$300F: X0+X, Y0+Y, Xn+1, Yn+1, Un', Vn'",
        "2458": "#R$369B",
        "2459": "The next 'arc' is drawn.",
        "245c": "The arc-counter is restored.",
        "245d": "Jump if more arcs to draw.",
        "2460": "#R$33A1: The co-ordinates of the end of the last arc",
        "2461": "that was drawn are now deleted from the stack.",
        "2462": "#R$343C: Y0+Y, X0+X",
        "2463": "#R$369B",
        "2464": "The X-co-ordinate of the end of the last arc that was",
        "2467": "drawn, say Xz', is copied from  to the",
        "246b": "#R$300F: Y0+Y, X0+X-Xz'",
        "246c": "#R$343C: X0+X-Xz', Y0+Y",
        "246d": "#R$369B",
        "246e": "The Y-co-ordinate is obtained from  and",
        "2471": "stacked.",
        "2474": "X0+X-Xz', Y0+Y, Yz'",
        "2475": "#R$300F: X0+X-Xz', Y0+Y-Yz'",
        "2476": "#R$369B",
        "2477": "The final arc is drawn to reach X0+X, Y0+Y (or close the",
        "247a": "Exit, setting temporary colours.",
        "247d": "Z",
        "247e": "#R$33C0: Z, Z",
        "247f": "#R$384A: Z, SQR Z",
        "2480": "#R$33C6: Z, SQR Z, 2",
        "2483": "#R$343C: Z, 2, SQR Z",
        "2484": "#R$31AF: Z, 2/SQR Z",
        "2485": "#R$340F(get_mem_5): Z, 2/SQR Z, G",
        "2486": "#R$343C: Z, G, 2/SQR Z",
        "2487": "#R$31AF: Z, G*SQR Z/2",
        "2488": "#R$346A: Z, G'*SQR Z/2 (G'=ABS G)",
        "2489": "#R$369B: Z, G'*SQR Z/2=A1, say",
        "248a": "A1 to #REGa from the stack, if possible.",
        "248d": "If A1 rounds to 256 or more, use 252.",
        "248f": "4*INT (A1/4) to #REGa.",
        "2491": "Add 4, giving the arc-count A.",
        "2493": "Jump if still under 256.",
        "2495": "Here, just use 252.",
        "2497": "Now save the arc-count.",
        "2498": "Copy it to calculator stack too.",
        "249b": "Z, A",
        "249c": "#R$340F(get_mem_5): Z, A, G",
        "249d": "#R$343C: Z, G, A",
        "249e": "#R$31AF: Z, G/A",
        "249f": "#R$33C0: Z, G/A, G/A",
        "24a0": "#R$37B5: Z, G/A, SIN (G/A)",
        "24a1": "#R$342D(st_mem_4): (SIN (G/A) is copied to mem-4)",
        "24a2": "#R$33A1: Z, G/A",
        "24a3": "#R$33C0: Z, G/A, G/A",
        "24a4": "#R$341B(stk_half): Z, G/A, G/A, 0.5",
        "24a5": "#R$30CA: Z, G/A, G/2*A",
        "24a6": "#R$37B5: Z, G/A, SIN (G/2*A)",
        "24a7": "#R$342D(st_mem_1): (SIN (G/2*A) is copied to mem-1)",
        "24a8": "#R$343C: Z, SIN (G/2*A), G/A",
        "24a9": "#R$342D(st_mem_0): (G/A is copied to mem-0)",
        "24aa": "#R$33A1: Z, SIN (G/2*A)=S",
        "24ab": "#R$33C0: Z, S, S",
        "24ac": "#R$30CA: Z, S*S",
        "24ad": "#R$33C0: Z, S*S, S*S",
        "24ae": "#R$3014: Z, 2*S*S",
        "24af": "#R$341B(stk_one): Z, 2*S*S, 1",
        "24b0": "#R$300F: Z, 2*S*S-1",
        "24b1": "#R$346E: Z, 1-2*S*S=COS (G/A)",
        "24b2": "#R$342D(st_mem_3): (COS (G/A) is copied to mem-3)",
        "24b3": "#R$33A1: Z",
        "24b4": "#R$369B",
        "24b5": "Restore the arc-count to #REGb.",
        "24b6": "Finished.",
        "24b7": "ABS Y to #REGb; ABS X to #REGc; SGN Y to #REGd; SGN X to",
        "24ba": "Jump if ABS X is greater than or equal to ABS Y, so",
        "24bb": "that the smaller goes to #REGl, and the larger (later)",
        "24bc": "goes to #REGh.",
        "24bf": "Save diagonal step (+/-1,+/-1) in #REGde.",
        "24c0": "Insert a vertical step (+/-1,0) into #REGde (#REGd",
        "24c1": "holds SGN Y).",
        "24c2": "Now jump to set #REGh.",
        "24c4": "Return if ABS X and ABS Y are both zero.",
        "24c6": "The smaller (ABS Y here) goes to #REGl.",
        "24c7": "ABS X to #REGb here, for #REGh.",
        "24c8": "Save the diagonal step here too.",
        "24c9": "Horizontal step (0,+/-1) to #REGde here.",
        "24cb": "Larger of ABS X, ABS Y to #REGh now.",
        "24cc": "#REGb to #REGa as well as to #REGh.",
        "24cd": "#REGa starts at INT (#REGh/2).",
        "24ce": "#REGl is added to #REGa.",
        "24cf": "If 256 or more, jump - diagonal step.",
        "24d1": "If #REGa is less than #REGh, jump for horizontal or",
        "24d2": "vertical step.",
        "24d4": "Reduce #REGa by #REGh.",
        "24d5": "Restore it to #REGc.",
        "24d6": "Now use the exchange resisters.",
        "24d7": "Diagonal step to #REGbc'.",
        "24d8": "Save it too.",
        "24d9": "Jump to take the step.",
        "24db": "Save #REGa (unreduced) in #REGc.",
        "24dc": "Step to stack briefly.",
        "24dd": "Get exchange registers.",
        "24de": "Step to #REGbc' now.",
        "24df": "Now take the step: first,  to #REGhl' as",
        "24e2": "Y-step from #REGb' to #REGa.",
        "24e3": "Add in #REGh'.",
        "24e4": "Result to #REGb'.",
        "24e5": "Now the X-step; it will be tested for range (Y will be",
        "24e6": "tested in #R$22DC).",
        "24e7": "Add #REGl' to #REGc' in #REGa, jump on carry for",
        "24e8": "further test.",
        "24ea": "Zero after no carry denotes X-position -1, out of range.",
        "24ec": "Restore true value to #REGa.",
        "24ed": "Value to #REGc' for plotting.",
        "24ee": "Plot the step.",
        "24f1": "Restore main registers.",
        "24f2": "#REGc back to #REGa to continue algorithm.",
        "24f3": "Loop back for #REGb steps (i.e. #REGh steps).",
        "24f5": "Clear machine stack.",
        "24f6": "Finished.",
        "24f7": "Zero after carry denotes X-position 255, in range.",
        "24f9": "Call the error handling routine.",
        "24fb": "The first character is fetched.",
        "24fc": "The starting priority marker.",
        "24fe": "It is stacked.",
        "24ff": "The main re-entry point.",
        "2500": "Index into the #R$2596(scanning function table) with",
        "2503": "the code in #REGc.",
        "2506": "Restore the code to #REGa.",
        "2507": "Jump if code not found in table.",
        "250a": "Use the entry found in the table to build up the",
        "250c": "required address in #REGhl, and jump to it.",
        "250f": "Point to the next character.",
        "2512": "Increase the length count by one.",
        "2513": "Is it a carriage return?",
        "2515": "Report the error if so.",
        "2518": "Is it another '\"'?",
        "251a": "Loop back if it is not.",
        "251c": "Point to next character.",
        "251f": "Set zero flag if it is another '\"'.",
        "2521": "Finished.",
        "2522": "Fetch the next character.",
        "2523": "Is it a '('?",
        "2525": "Report the error if it is not.",
        "2527": "Co-ordinates to calculator stack.",
        "252a": "Fetch the current character.",
        "252b": "Is it a ')'?",
        "252d": "Report the error if it is not.",
        "2530": "Test bit 7 of .",
        "2534": "Finished.",
        "2535": "x to #REGc, y to #REGb; 0<=x<=23; 0<=y<=31.",
        "2538": " plus &0100 gives #REGhl pointing to the",
        "253b": "character set.",
        "253f": "x is copied to #REGa.",
        "2540": "The number 32*(x mod 8)+y is formed in #REGa and copied",
        "2541": "to #REGe. This is the low byte of the required screen",
        "2542": "address.",
        "2547": "x is copied to #REGa again.",
        "2548": "Now the number 64+8*INT (x/8) is inserted into #REGd.",
        "254a": "#REGde now holds the screen address.",
        "254d": "#REGb counts the 96 characters.",
        "254f": "Save the count.",
        "2550": "And the screen pointer.",
        "2551": "And the character set pointer.",
        "2552": "Get first row of screen character.",
        "2553": "Match with row from character set.",
        "2554": "Jump if direct match found.",
        "2556": "Now test for match with inverse character (get &00 in",
        "2557": "Jump if neither match found.",
        "2559": "Restore &FF to #REGa.",
        "255a": "Inverse status (&00 or &FF) to #REGc.",
        "255b": "#REGb counts through the other 7 rows.",
        "255d": "Move #REGde to next row (add &0100).",
        "255e": "Move #REGhl to next row (i.e. next byte).",
        "255f": "Get the screen row.",
        "2560": "Match with row from the ROM.",
        "2561": "Include the inverse status.",
        "2562": "Jump if row fails to match.",
        "2564": "Jump back till all rows done.",
        "2566": "Discard character set pointer.",
        "2567": "And screen pointer.",
        "2568": "Final count to #REGbc.",
        "2569": "Last character code in set plus one.",
        "256b": "#REGa now holds required code.",
        "256c": "One space is now needed in the work space.",
        "256f": "Make the space.",
        "2570": "Put the character into it.",
        "2571": "Jump to stack the character.",
        "2573": "Restore character set pointer.",
        "2574": "Move it on 8 bytes, to the next character in the set.",
        "2578": "Restore the screen pointer.",
        "2579": "And the counter.",
        "257a": "Loop back for the 96 characters.",
        "257c": "Stack the empty string (length zero).",
        "257d": "Jump to stack the matching character, or the null string",
        "2580": "x to #REGc, y to #REGb. Again, 0<=x<=23; 0<=y<=31.",
        "2583": "x is copied to #REGa and the number 32*(x mod 8)+y is",
        "2584": "formed in #REGa. 32*(x mod 8)+INT (x/8) is also copied",
        "2585": "to #REGc.",
        "258b": "#REGl holds low byte of attribute address.",
        "258c": "32*(x mod 8)+INT (x/8) is copied to #REGa.",
        "258d": "88+INT (x/8) is formed in #REGa.",
        "2591": "#REGh holds high byte of attribute address.",
        "2592": "The attribute byte is copied to #REGa.",
        "2593": "Exit, stacking the required byte.",
        "2596": "#R$25B3",
        "2598": "#R$25E8",
        "259a": "#R$268D",
        "259c": "#R$25AF",
        "259e": "#R$25F5",
        "25a0": "#R$25F8",
        "25a2": "#R$2627",
        "25a4": "#R$2634",
        "25a6": "#R$268D",
        "25a8": "#R$2668",
        "25aa": "#R$2672",
        "25ac": "#R$267B",
        "25ae": "End marker.",
        "25af": "For unary plus, simply move on to the next character",
        "25b0": "and jump back to the main re-entry of #R$24FB.",
        "25b3": "Fetch the current character.",
        "25b4": "Point to the start of the string.",
        "25b5": "Save the start address.",
        "25b6": "Set the length to zero.",
        "25b9": "Call the \"matching\" subroutine.",
        "25bc": "Jump if zero reset - no more quotes.",
        "25be": "Call it again for a third quote.",
        "25c1": "And again for the fifth, seventh etc.",
        "25c3": "If testing syntax, jump to reset bit 6 of",
        "25c6": " and to continue scanning.",
        "25c8": "Make space in the work space for the string and the",
        "25c9": "Get the pointer to the start.",
        "25ca": "Save the pointer to the first space.",
        "25cb": "Get a character from the string.",
        "25cc": "Point to the next one.",
        "25cd": "Copy last one to work space.",
        "25ce": "Point to the next space.",
        "25cf": "Is last character a '\"'?",
        "25d1": "If not, jump to copy next one.",
        "25d3": "But if it was, do not copy next one; if next one is a",
        "25d4": "'\"', jump to copy the one after it; otherwise, finished",
        "25d5": "with copying.",
        "25d9": "Get true length to #REGbc.",
        "25da": "Restore start of copied string.",
        "25db": "This is ; this entry point is used",
        "25de": "whenever bit 6 is to be reset and a string stacked if",
        "25e0": "executing a line. This is done now.",
        "25e5": "Jump to continue scanning the line.",
        "25e8": "This routine simply gets the character and calls",
        "25e9": "#R$24FB recursively.",
        "25ec": "Report the error if no matching bracket.",
        "25f1": "Continue scanning.",
        "25f8": "Unless syntax is being checked, jump to",
        "25fb": "calculate a random number.",
        "25fd": "Fetch the current value of .",
        "2601": "Put it on the calculator stack.",
        "2604": "Now use the calculator.",
        "2605": "#R$341B(stk_one)",
        "2606": "#R$3014: The 'last value' is now",
        "2607": "#R$33C6: Put the number 75 on the calculator",
        "2608": "stack.",
        "260a": "#R$30CA: 'last value' (+1)*75.",
        "260b": "#R$33C6: Put the number 65537 on the",
        "260c": "calculator stack.",
        "2611": "#R$36A0: Divide (+1)*75 by 65537",
        "2612": "#R$33A1: Discard the 'answer'.",
        "2613": "#R$341B(stk_one)",
        "2614": "#R$300F: The 'last value' is now 'remainder'",
        "2615": "#R$33C0: Make a copy of the 'last value'.",
        "2616": "#R$369B: The calculation is finished.",
        "2617": "Use the 'last value' to give the new value",
        "261a": "for .",
        "261e": "Fetch the exponent of 'last value'.",
        "261f": "Jump forward if the exponent is zero.",
        "2622": "Reduce the exponent, i.e. divide 'last",
        "2624": "value' by 65536 to give the required 'last",
        "2625": "Jump past the #R$2627 routine.",
        "2627": "Test for syntax checking.",
        "262a": "Jump if required.",
        "262c": "Now use the calculator.",
        "262d": "#R$341B(stk_pi_2): The value of #pi/2 is put on the",
        "262e": "#R$369B",
        "262f": "The exponent is incremented thereby doubling the 'last",
        "2630": "Move on to the next character.",
        "2631": "Jump forward.",
        "2634": "Priority &10, operation code &5A for the 'read-in'",
        "2637": "subroutine.",
        "2638": "If next char. is '#', jump. There will be a numerical",
        "263a": "argument.",
        "263d": "This is .",
        "2640": "Reset bit 6 for a string result.",
        "2642": "Test for syntax checking.",
        "2644": "Jump if required.",
        "2646": "Fetch a key-value in #REGde.",
        "2649": "Prepare empty string; stack it if too many keys",
        "264b": "pressed.",
        "264d": "Test the key value; stack empty string if",
        "2650": "unsatisfactory.",
        "2652": "&FF to #REGd for 'L' mode (bit 3 set).",
        "2653": "Key-value to #REGe for decoding.",
        "2654": "Decode the key-value.",
        "2657": "Save the ASCII value briefly.",
        "2658": "One space is needed in the work space.",
        "265b": "Make it now.",
        "265c": "Restore the ASCII value.",
        "265d": "Prepare to stack it as a string.",
        "265e": "Its length is one.",
        "2660": "Complete the length parameter.",
        "2662": "Stack the required string.",
        "2665": "Jump forward.",
        "2668": "Check that 2 co-ordinates are given.",
        "266b": "Call the subroutine unless checking syntax.",
        "266e": "Then get the next character and jump back.",
        "2672": "Check that 2 co-ordinates are given.",
        "2675": "Call the subroutine unless checking syntax.",
        "2678": "Then get the next character and jump forward.",
        "267b": "Check that 2 co-ordinates are given.",
        "267e": "Call the subroutine unless checking syntax.",
        "2681": "Then get the next character and jump forward.",
        "2684": "Is the character alphanumeric?",
        "2687": "Jump if not a letter or a digit.",
        "2689": "Now jump if it is a letter; otherwise continue on into",
        "268b": "#R$268D.",
        "268d": "Jump forward if a line is being executed.",
        "2692": "The floating-point form is found.",
        "2695": "Set #REGhl to point one past the last digit.",
        "2696": "Six locations are required.",
        "2699": "Make the room in the BASIC line.",
        "269c": "Point to the first free space.",
        "269d": "Enter the number marker code.",
        "269f": "Point to the second location.",
        "26a0": "This pointer is wanted in #REGde.",
        "26a1": "Fetch the 'old' .",
        "26a4": "There are 5 bytes to move.",
        "26a6": "Clear the carry flag.",
        "26a7": "The 'new' ='old'  minus",
        "26a9": "5.",
        "26ac": "Move the floating-point number from the calculator",
        "26ae": "Put the line pointer in #REGhl.",
        "26af": "Point to the last byte added.",
        "26b0": "This sets .",
        "26b3": "Jump forward.",
        "26b5": "Get the current character.",
        "26b6": "Now move on to the next character in turn until the",
        "26b7": "number marker code (&0E) is found.",
        "26bc": "Point to the first byte of the number.",
        "26bd": "Move the floating-point number.",
        "26c0": "Set .",
        "26c3": "Set the numeric marker flag (bit 6 of ).",
        "26c7": "Jump forward.",
        "26c9": "Look in the existing variables for the matching entry.",
        "26cc": "An error is reported if there is no existing entry.",
        "26cf": "Stack the parameters of the string entry/return numeric",
        "26d2": "Fetch .",
        "26d5": "Test bits 6 and 7 together.",
        "26d7": "Jump if one or both bits are reset.",
        "26d9": "A numeric value is to be stacked.",
        "26da": "Move the number.",
        "26dd": "Jump forward.",
        "26df": "Priority &09, operation code &DB.",
        "26e2": "Is it a '-'?",
        "26e4": "Jump forward if it is 'unary minus'.",
        "26e6": "Priority &10, operation code &18.",
        "26e9": "Is it 'VAL$'?",
        "26eb": "Jump forward if it is 'VAL$'.",
        "26ed": "The range of the functions is changed from &AF to &C3",
        "26ef": "Report an error if out of range.",
        "26f2": "Priority &04, operation code &F0.",
        "26f5": "Is it the function 'NOT'?",
        "26f7": "Jump if it is so.",
        "26f9": "Check the range again.",
        "26fc": "Priority &10.",
        "26fe": "The function range is now &DC to &EF.",
        "2700": "Transfer the operation code.",
        "2701": "Separate CODE, VAL and LEN which operate on strings to",
        "2703": "give numerical results.",
        "2707": "Separate STR$ and CHR$ which operate on numbers to",
        "2709": "give string results.",
        "270b": "Mark the operation codes. The other operation codes",
        "270d": "Stack the priority and operation codes before moving",
        "270e": "on to consider the next part of the expression.",
        "2712": "Fetch the present character.",
        "2713": "Jump forward if it is not a '(', which indicates a",
        "2715": "parenthesised expression.",
        "2717": "Jump forward if dealing with a numeric parenthesised",
        "271b": "expression (bit 6 of  set).",
        "271d": "Modify the parameters of the 'last value'.",
        "2720": "Move on to consider the next character.",
        "2723": "Original code to #REGbc to index into the",
        "2725": "#R$2795(table of operators).",
        "2726": "The pointer to the table.",
        "2729": "Index into the table.",
        "272c": "Jump forward if no operation found.",
        "272e": "Get required code from the table.",
        "272f": "The pointer to the priority table (#h26ED+#hC3 gives",
        "2732": "Index into the table.",
        "2733": "Fetch the appropriate priority.",
        "2734": "Get the 'last' operation and priority.",
        "2735": "The priority goes to the #REGa register.",
        "2736": "Compare 'last' against 'present'.",
        "2737": "Exit to wait for the argument.",
        "2739": "Are both priorities zero?",
        "273a": "Exit via #R$0018 thereby making 'last value' the",
        "273d": "Stack the 'present' values.",
        "273e": "This is .",
        "2741": "The 'last' operation is compared with the code for",
        "2742": "USR, which will give 'USR number' unless modified; jump",
        "2744": "if not 'USR'.",
        "2746": "Test bit 6 of .",
        "2748": "Jump if it is set ('USR number').",
        "274a": "Modify the 'last' operation code: 'offset' &19, plus",
        "274c": "Stack the 'last' values briefly.",
        "274d": "Do not perform the actual operation if syntax is being",
        "2750": "checked.",
        "2752": "The 'last' operation code.",
        "2753": "Strip off bits 6 and 7 to convert the operation code",
        "2755": "to a calculator offset.",
        "2756": "Now use the calculator.",
        "2757": "#R$33A2: (perform the actual operation)",
        "2758": "#R$369B",
        "2759": "Jump forward.",
        "275b": "Get the 'last' operation code.",
        "275c": "This tests the nature of the 'last value' (bit 6 of",
        "275f": ") against the requirement of the",
        "2761": "Jump if syntax fails.",
        "2764": "Get the 'last' operation code.",
        "2765": "This is .",
        "2768": "Assume result to be numeric.",
        "276a": "Jump forward if the nature of 'last value' is numeric.",
        "276e": "It is a string.",
        "2770": "Get the 'present' values into #REGbc.",
        "2771": "Jump back.",
        "2773": "The 'last' values go on the stack.",
        "2774": "Get the 'present' operation code.",
        "2775": "Do not modify the operation code if dealing with a",
        "2779": "numeric operand (bit 6 of  set).",
        "277b": "Clear bits 6 and 7.",
        "277d": "Increase the code by &08.",
        "277f": "Return the code to the #REGc register.",
        "2780": "Is the operation 'AND'?",
        "2782": "Jump if it is not so.",
        "2784": "'AND' requires a numeric operand.",
        "2786": "Jump forward.",
        "2788": "The operations -, *, /, #power and OR are not possible",
        "278a": "Is the operation a '+'?",
        "278c": "Jump if it is so.",
        "278e": "The other operations yield a numeric result.",
        "2790": "The 'present' values go on the machine stack.",
        "2791": "Consider the next character.",
        "2792": "Go around the loop again.",
        "2795": "+",
        "2797": "-",
        "2799": "*",
        "279b": "/",
        "279d": "#power",
        "279f": "=",
        "27a1": ">",
        "27a3": "<",
        "27a5": "<=",
        "27a7": ">=",
        "27a9": "<>",
        "27ab": "OR",
        "27ad": "AND",
        "27af": "End marker.",
        "27b0": "-",
        "27b1": "*",
        "27b2": "/",
        "27b3": "#power",
        "27b4": "OR",
        "27b5": "AND",
        "27b6": "<=",
        "27b7": ">=",
        "27b8": "<>",
        "27b9": ">",
        "27ba": "<",
        "27bb": "=",
        "27bc": "+",
        "27bd": "Unless syntax is being checked, a jump is made to",
        "27c0": "#R$27F7.",
        "27c2": "Get the first character of the name.",
        "27c3": "If it is not alphabetic, then report the error.",
        "27c9": "Get the next character.",
        "27ca": "Is it a '$'?",
        "27cc": "Save the zero flag on the stack.",
        "27cd": "Jump if it was not a '$'.",
        "27cf": "But get the next character if it was.",
        "27d0": "If the character is not a '(', then report the error.",
        "27d4": "Get the next character.",
        "27d5": "Is it a ')'?",
        "27d7": "Jump if it is; there are no arguments.",
        "27d9": "Within the loop, call #R$24FB to check the syntax of",
        "27dc": "Get the character which follows the argument; if it is",
        "27dd": "not a ',' then jump - no more arguments.",
        "27e1": "Get the first character in the next argument.",
        "27e2": "Loop back to consider this argument.",
        "27e4": "Is the current character a ')'?",
        "27e6": "Report the error if it is not.",
        "27e9": "Point to the next character in the BASIC line.",
        "27ea": "Assume a string-valued function and reset bit 6 of",
        "27ed": ".",
        "27ef": "Restore the zero flag, jump if the FN is indeed",
        "27f0": "string-valued.",
        "27f2": "Otherwise, set bit 6 of .",
        "27f4": "Jump back to continue scanning the line.",
        "27f7": "Get the first character of the name.",
        "27f8": "Reset bit 5 for upper case.",
        "27fa": "Copy the name to #REGb.",
        "27fb": "Get the next character.",
        "27fc": "Subtract &24, the code for '$'.",
        "27fe": "Copy the result to #REGc (zero for a string, non-zero",
        "27ff": "Jump if non-zero: numerical function.",
        "2801": "Get the next character, the '('.",
        "2802": "Get 1st character of 1st argument.",
        "2803": "Save the pointer to it on the stack.",
        "2804": "Point to the start of the program ().",
        "2807": "Go back one location.",
        "2808": "The search will be for 'DEF FN'.",
        "280b": "Save the name and 'string status'.",
        "280c": "Search the program now.",
        "280f": "Restore the name and status.",
        "2810": "Jump if a DEF FN statement found.",
        "2812": "Call the error handling routine.",
        "2814": "Save the pointer to the DEF FN character in case the",
        "2815": "Get the name of the DEF FN function.",
        "2818": "Reset bit 5 for upper case.",
        "281a": "Does it match the FN name?",
        "281b": "Jump if it does not match.",
        "281d": "Get the next character in the DEF FN.",
        "2820": "Subtract &24, the code for '$'.",
        "2822": "Compare the status with that of FN.",
        "2823": "Jump if complete match now found.",
        "2825": "Restore the pointer to the 'DEF FN'.",
        "2826": "Step back one location.",
        "2827": "Use the search routine to find the end of the DEF FN",
        "282a": "statement, preparing for the next search; save the name",
        "282b": "and status meanwhile.",
        "282f": "Jump back for a further search.",
        "2831": "If #REGhl is now pointing to a '$', move on to the '('.",
        "2835": "Discard the pointer to 'DEF FN'.",
        "2836": "Get the pointer to the first argument of FN, and copy",
        "2837": "it to .",
        "283b": "Move past the '(' now.",
        "283e": "Save this pointer on the stack.",
        "283f": "Is it pointing to a ')'?",
        "2841": "If so, jump: FN has no arguments.",
        "2843": "Point to the next code.",
        "2844": "Put the code into #REGa.",
        "2845": "Is it the 'number marker' code, &0E?",
        "2847": "Set bit 6 of #REGd for a numerical argument.",
        "2849": "Jump on zero: numerical argument.",
        "284b": "Now ensure that #REGhl is pointing to the '$' character",
        "284c": "(not e.g. to a control code).",
        "284f": "#REGhl now points to the 'number marker'.",
        "2850": "Bit 6 of #REGd is reset: string argument.",
        "2852": "Point to the 1st of the 5 bytes in DEF FN.",
        "2853": "Save this pointer on the stack.",
        "2854": "Save the 'string status' of the argument.",
        "2855": "Now evaluate the argument.",
        "2858": "Get the no./string flag into #REGa.",
        "2859": "Test bit 6 of it against the result of #R$24FB (bit 6",
        "285c": "of ).",
        "285e": "Give report Q if they did not match.",
        "2860": "Get the pointer to the first of the 5 spaces in DEF FN",
        "2861": "into #REGde.",
        "2862": "Point #REGhl at .",
        "2865": "#REGbc will count 5 bytes to be moved.",
        "2868": "First, decrease  by 5, so deleting the",
        "286a": "'last value' from the stack.",
        "286d": "Copy the 5 bytes into the spaces in DEF FN.",
        "286f": "Point #REGhl at the next code.",
        "2870": "Ensure that #REGhl points to the character after the 5",
        "2871": "bytes.",
        "2874": "Is it a ')'?",
        "2876": "Jump if it is: no more arguments in the DEF FN",
        "2878": "It is a ',': save the pointer to it.",
        "2879": "Get the character after the last argument that was",
        "287a": "If it is not a ',' jump: mismatched arguments of FN and",
        "287c": "DEF FN.",
        "287e": "Point  to the next argument of FN.",
        "287f": "Point #REGhl to the ',' in DEF FN again.",
        "2880": "Move #REGhl on to the next argument in DEF FN.",
        "2883": "Jump back to consider this argument.",
        "2885": "Save the pointer to the ')' in DEF FN.",
        "2886": "Get the character after the last argument in FN.",
        "2887": "Is it a ')'?",
        "2889": "If so, jump to evaluate the function; but if not, give",
        "288b": "Call the error handling routine.",
        "288d": "Restore pointer to ')' in DEF FN.",
        "288e": "Get this pointer into #REGhl.",
        "288f": "Insert it into .",
        "2892": "Get the old value of .",
        "2895": "Stack it, and get the start address of the arguments",
        "2896": "area of DEF FN into .",
        "2899": "Save address of ')' in FN.",
        "289a": "Move  on past ')' and '=' to the start",
        "289b": "of the expression for the function in DEF FN.",
        "289c": "Now evaluate the function.",
        "289f": "Restore the address of ')' in FN.",
        "28a0": "Store it in .",
        "28a3": "Restore original value of .",
        "28a4": "Put it back into .",
        "28a7": "Get the next character in the BASIC line.",
        "28a8": "Jump back to continue scanning.",
        "28ab": "Point to the next code in the statement.",
        "28ac": "Copy the code to #REGa.",
        "28ad": "Jump back to skip over it if it is a control code or a",
        "28af": "space.",
        "28b1": "Finished.",
        "28b2": "Presume a numeric variable (set bit 6 of",
        "28b6": "Get the first character into #REGa.",
        "28b7": "Is it alphabetic?",
        "28ba": "Give an error report if it is not so.",
        "28bd": "Save the pointer to the first letter.",
        "28be": "Transfer bits 0 to 4 of the letter to the #REGc",
        "28c0": "register; bits 5 and 7 are always reset.",
        "28c1": "Get the second character into #REGa.",
        "28c2": "Save this pointer also.",
        "28c3": "Is the second character a '('?",
        "28c5": "Separate arrays of numbers.",
        "28c7": "Now set bit 6.",
        "28c9": "Is the second character a '$'?",
        "28cb": "Separate all the strings.",
        "28cd": "Now set bit 5.",
        "28cf": "If the variable's name has only one character then",
        "28d2": "jump forward.",
        "28d4": "Is the character alphanumeric?",
        "28d7": "Jump out of the loop when the end of the name is found.",
        "28d9": "Mark the discriminator byte.",
        "28db": "Get the next character.",
        "28dc": "Go back to test it.",
        "28de": "Step  past the '$'.",
        "28df": "Reset bit 6 of  to indicate a string.",
        "28e3": "Is  zero?",
        "28e7": "If so, jump forward.",
        "28e9": "In 'run-time'?",
        "28ec": "If so, jump forward to search the DEF FN statement.",
        "28ef": "Copy the discriminator byte to the #REGb register.",
        "28f0": "Jump forward if in 'run-time'.",
        "28f5": "Move the discriminator to #REGa.",
        "28f6": "Drop the character code part.",
        "28f8": "Indicate syntax by setting bit 7.",
        "28fa": "Restore the discriminator.",
        "28fb": "Jump forward to continue.",
        "28fd": "Pick up the  pointer.",
        "2900": "The first letter of each existing variable.",
        "2901": "Match on bits 0 to 6.",
        "2903": "Jump when the '&80-byte' is reached.",
        "2905": "The actual comparison.",
        "2906": "Jump forward if the first characters do not match.",
        "2908": "Rotate #REGa leftwards and then double it to test bits",
        "2909": "5 and 6.",
        "290a": "Strings and array variables.",
        "290d": "Simple numeric and FOR-NEXT variables.",
        "290f": "Take a copy of the pointer to the second character.",
        "2911": "Save the first letter pointer.",
        "2912": "Consider the next character.",
        "2913": "Fetch each character in turn.",
        "2914": "Point to the next character.",
        "2915": "Is the character a 'space'?",
        "2917": "Ignore the spaces.",
        "2919": "Set bit 5 so as to match lower and upper case letters.",
        "291b": "Make the comparison.",
        "291c": "Back for another character if it does match.",
        "291e": "Will it match with bit 7 set?",
        "2920": "Try it.",
        "2921": "Jump forward if the 'last characters' do not match.",
        "2923": "Check that the end of the name has been reached before",
        "2924": "jumping forward.",
        "2929": "Fetch the pointer.",
        "292a": "Save #REGb and #REGc briefly.",
        "292b": "#REGde is made to point to the next variable.",
        "292e": "Switch the two pointers.",
        "292f": "Get #REGb and #REGc back.",
        "2930": "Go around the loop again.",
        "2932": "Signal 'variable not found'.",
        "2934": "Drop the pointer to the second character.",
        "2935": "Fetch the present character.",
        "2936": "Is it a '('?",
        "2938": "Jump forward if so.",
        "293a": "Indicate not dealing with an array and jump forward.",
        "293e": "Drop the saved variable pointer.",
        "293f": "Drop the second character pointer.",
        "2940": "Drop the first letter pointer.",
        "2941": "Save the 'last' letter pointer.",
        "2942": "Fetch the current character.",
        "2943": "Is it alphanumeric?",
        "2946": "Jump when the end of the name has been found.",
        "2948": "Fetch the next character.",
        "2949": "Go back and test it.",
        "294b": "#REGhl holds the pointer to the letter of a short name",
        "294c": "Rotate the whole register.",
        "294e": "Specify the state of bit 6.",
        "2950": "Finished.",
        "2951": "Point to the first character in the arguments area",
        "2954": "() and put it into #REGa.",
        "2955": "Is it a ')'?",
        "2957": "Jump to search the variables area.",
        "295a": "Get the next argument in the loop.",
        "295b": "Set bits 5 and 6, assuming a simple numeric variable;",
        "295d": "copy it to #REGb.",
        "295e": "Point to the next code.",
        "295f": "Put it into the #REGa register.",
        "2960": "Is it the 'number marker' code, &0E?",
        "2962": "Jump if so: numeric variable.",
        "2964": "Ensure that #REGhl points to the character, not to a",
        "2965": "space or control code.",
        "2968": "#REGhl now points to the 'number marker'.",
        "2969": "Reset bit 5 of #REGb: string variable.",
        "296b": "Get the variable name into #REGa.",
        "296c": "Is it the one we are looking for?",
        "296d": "Jump if it matches.",
        "296f": "Now pass over the 5 bytes of the floating-point number",
        "2970": "or string parameters to get to the next argument.",
        "2974": "Pass on to the next character.",
        "2977": "Is it a ')'?",
        "2979": "If so, jump to search the variables area.",
        "297c": "Point to the next argument.",
        "297f": "Jump back to consider it.",
        "2981": "Test for a numeric variable.",
        "2983": "Jump if the variable is numeric; #R$24FB will stack it.",
        "2985": "Point to the first of the 5 bytes to be stacked.",
        "2986": "Point #REGde to .",
        "298a": "Stack the 5 bytes.",
        "298d": "Point #REGhl to the new position of ,",
        "298e": "and reset the system variable.",
        "2991": "Discard the #R$28B2 pointers (second and first",
        "2992": "character pointers).",
        "2993": "Return from the search with both the carry and zero",
        "2994": "flags reset - signalling that a call #R$2996 is not",
        "2995": "Finished.",
        "2996": "Clear the array flag.",
        "2997": "Clear the #REGb register for later.",
        "2998": "Jump forward if syntax is being checked.",
        "299c": "Jump forward if dealing with an array variable.",
        "29a0": "Signal 'a simple string'.",
        "29a1": "Move along the entry.",
        "29a2": "Pick up the low length counter.",
        "29a3": "Advance the pointer.",
        "29a4": "Pick up the high length pointer.",
        "29a5": "Advance the pointer.",
        "29a6": "Transfer the pointer to the actual string.",
        "29a7": "Pass these parameters to the calculator stack.",
        "29aa": "Fetch the present character and jump forward to see if",
        "29ab": "a 'slice' is required.",
        "29ae": "Step past the length bytes.",
        "29b1": "Collect the 'number of dimensions'.",
        "29b2": "Jump forward if handling an array of numbers.",
        "29b6": "Decrease the 'number of dimensions' and jump if the",
        "29b7": "number is now zero.",
        "29b9": "Save the pointer in #REGde.",
        "29ba": "Get the present character.",
        "29bb": "Is it a '('?",
        "29bd": "Report the error if it is not so.",
        "29bf": "Restore the pointer.",
        "29c0": "Pass the pointer to #REGde.",
        "29c1": "Jump forward.",
        "29c3": "Save the counter.",
        "29c4": "Get the present character.",
        "29c5": "Restore the counter.",
        "29c6": "Is the present character a ','?",
        "29c8": "Jump forward to consider another subscript.",
        "29ca": "If a line is being executed then there is an error.",
        "29ce": "Jump forward if dealing with an array of strings.",
        "29d2": "Is the present character a ')'?",
        "29d4": "Report an error if not so.",
        "29d6": "Advance .",
        "29d7": "Return as the syntax is correct.",
        "29d8": "Is the present character a ')'?",
        "29da": "Jump forward and check whether there is another",
        "29dc": "Is the present character a 'TO'?",
        "29de": "It must not be otherwise.",
        "29e0": "Get the present character.",
        "29e1": "Point to the preceding character and set",
        "29e2": ".",
        "29e5": "Evaluate the 'slice'.",
        "29e7": "Set the counter to zero.",
        "29ea": "Save the counter briefly.",
        "29eb": "Advance .",
        "29ec": "Restore the counter.",
        "29ed": "Fetch the discriminator byte.",
        "29ee": "Jump unless checking the syntax for an array of",
        "29f0": "strings.",
        "29f2": "Get the present character.",
        "29f3": "Is it a ')'?",
        "29f5": "Jump forward as finished counting elements.",
        "29f7": "Is to 'TO'?",
        "29f9": "Jump back if dealing with a 'slice'.",
        "29fb": "Save the dimension-number counter and the discriminator",
        "29fc": "Save the element-counter.",
        "29fd": "Get a dimension-size into #REGde.",
        "2a00": "The counter moves to #REGhl and the variable pointer is",
        "2a01": "The counter moves to #REGde and the dimension-size to",
        "2a02": "Evaluate the next subscript.",
        "2a05": "Give an error if out of range.",
        "2a07": "The result of the evaluation is decremented as the",
        "2a08": "Multiply the counter by the dimension-size.",
        "2a0b": "Add the result of #R$2ACC to the present counter.",
        "2a0c": "Fetch the variable pointer.",
        "2a0d": "Fetch the dimension-number and the discriminator byte.",
        "2a0e": "Keep going round the loop until #REGb equals zero.",
        "2a10": "Report an error if checking syntax at this point.",
        "2a14": "Save the counter.",
        "2a15": "Jump forward if handling an array of strings.",
        "2a19": "Transfer the variable pointer to the #REGbc register",
        "2a1a": "pair.",
        "2a1b": "Fetch the present character.",
        "2a1c": "Is it a ')'?",
        "2a1e": "Jump past the error report unless it is needed.",
        "2a20": "Call the error handling routine.",
        "2a22": "Advance .",
        "2a23": "Fetch the counter.",
        "2a24": "There are 5 bytes to each element in an array of",
        "2a27": "Compute the total number of bytes before the required",
        "2a2a": "Make #REGhl point to the location before the required",
        "2a2b": "Return with this address.",
        "2a2c": "Fetch the last dimension-size.",
        "2a2f": "The variable pointer goes on the stack and the counter",
        "2a30": "Multiply 'counter' by 'dimension-size'.",
        "2a33": "Fetch the variable pointer.",
        "2a34": "This gives #REGhl pointing to the location before the",
        "2a35": "So point to the actual 'start'.",
        "2a36": "Transfer the last dimension-size to #REGbc to form the",
        "2a37": "'length'.",
        "2a38": "Move the 'start' to #REGde.",
        "2a39": "Pass these parameters to the calculator stack. Note:",
        "2a3c": "Get the present character.",
        "2a3d": "Is it a ')'?",
        "2a3f": "Jump if it is so.",
        "2a41": "Is it a ','?",
        "2a43": "Report the error if not so.",
        "2a45": "Use #R$2A52 to modify the set of parameters.",
        "2a48": "Fetch the next character.",
        "2a49": "Is It a '('?",
        "2a4b": "Jump back if there is a 'slice' to be considered.",
        "2a4d": "Signal - string result (reset bit 6 of ).",
        "2a51": "Return with the parameters of the required string",
        "2a52": "Check the flag.",
        "2a55": "Take the parameters off the stack in 'run-time'.",
        "2a58": "Get the next character.",
        "2a59": "Is it a ')'?",
        "2a5b": "Jump forward if it is so.",
        "2a5d": "The 'start' goes on the machine stack.",
        "2a5e": "The #REGa register is cleared and saved.",
        "2a60": "The 'length' is saved briefly.",
        "2a61": "Presume that the 'slice' is to begin with the first",
        "2a64": "Get the first character.",
        "2a65": "Pass the 'length' to #REGhl.",
        "2a66": "Is the present character a 'TO'?",
        "2a68": "The first parameter, by default, will be '1' if the",
        "2a6a": "At this stage #REGa is zero.",
        "2a6b": "#REGbc is made to hold the first parameter. #REGa will",
        "2a6e": "Save the value anyway.",
        "2a6f": "Transfer the first parameter to #REGde.",
        "2a71": "Save the 'length' briefly.",
        "2a72": "Get the present character.",
        "2a73": "Restore the 'length'.",
        "2a74": "Is the present character a 'TO'?",
        "2a76": "Jump forward to consider the second parameter if it is",
        "2a78": "so; otherwise show that there is a closing bracket.",
        "2a7d": "The last character of the 'slice' is also the first",
        "2a7e": "character.",
        "2a7f": "Jump forward.",
        "2a81": "Save the 'length' briefly.",
        "2a82": "Get the next character.",
        "2a83": "Restore the 'length'.",
        "2a84": "Is the present character a ')'?",
        "2a86": "Jump if there is not a second parameter.",
        "2a88": "If the first parameter was in range #REGa will hold",
        "2a89": "Make #REGbc hold the second parameter.",
        "2a8c": "Save the 'error register'.",
        "2a8d": "Get the present character.",
        "2a8e": "Pass the result obtained from #R$2ACD to the #REGhl",
        "2a8f": "register pair.",
        "2a90": "Check that there is a closing bracket now.",
        "2a94": "Fetch the 'error register'.",
        "2a95": "The second parameter goes on the stack and the 'start'",
        "2a96": "The first parameter is added to the 'start'.",
        "2a97": "Go back a location to get it correct.",
        "2a98": "The 'new start' goes on the stack and the second",
        "2a99": "Subtract the first parameters from the second to find",
        "2a9a": "the length of the 'slice'.",
        "2a9c": "Initialise the 'new length'.",
        "2a9f": "A negative 'slice' is a 'null string' rather than an",
        "2aa1": "Allow for the inclusive byte.",
        "2aa2": "Only now test the 'error register'.",
        "2aa3": "Jump if either parameter was out of range for the",
        "2aa6": "Transfer the 'new length' to #REGbc.",
        "2aa8": "Get the 'new start'.",
        "2aa9": "Ensure that a string is still indicated (reset bit 6 of",
        "2aad": "Return at this point if checking syntax; otherwise",
        "2ab0": "continue into #R$2AB1.",
        "2ab1": "Signal - a string from an array of strings or a",
        "2ab2": "Ensure the flag indicates a string result (reset bit 6",
        "2ab6": "Save #REGb and #REGc briefly.",
        "2ab7": "Is there room for 5 bytes? Do not return here unless",
        "2aba": "Restore #REGb and #REGc.",
        "2abb": "Fetch the address of the first location above the",
        "2abe": "Transfer the first byte.",
        "2abf": "Step on.",
        "2ac0": "Transfer the second and third bytes; for a string",
        "2ac1": "these will be the 'start'.",
        "2ac3": "Step on.",
        "2ac4": "Transfer the fourth and fifth bytes; for a string",
        "2ac5": "these will be the 'length'.",
        "2ac7": "Step on so as to point to the location above the stack.",
        "2ac8": "Save this address in  and return.",
        "2acc": "Clear the 'error register'.",
        "2acd": "Save both the #REGde and #REGhl register pairs",
        "2ace": "throughout.",
        "2acf": "Save the 'error register' briefly.",
        "2ad0": "The 'next expression' is evaluated to give a 'last",
        "2ad3": "Restore the 'error register'.",
        "2ad4": "Jump forward if checking syntax.",
        "2ad9": "Save the error register again.",
        "2ada": "The 'last value' is compressed Into #REGbc.",
        "2add": "Error register to #REGd.",
        "2ade": "A 'next expression' that gives zero is always in error",
        "2adf": "so jump forward if it is so.",
        "2ae3": "Take a copy of the limit-value. This will be a",
        "2ae4": "'dimension-size', a 'DIM-limit' or a 'string length'.",
        "2ae5": "Now compare the result of evaluating the expression",
        "2ae6": "against the limit.",
        "2ae8": "Fetch the 'old error value'.",
        "2ae9": "Form the 'new error value': &00 if no error at any time,",
        "2aeb": "Restore #REGhl and #REGde.",
        "2aed": "Return; 'error register' is the #REGa register.",
        "2aee": "Use #REGhl for the construction.",
        "2aef": "Point to '#REGde+1'.",
        "2af0": "In effect - #S/LD E,(DE+1)/.",
        "2af1": "Point to '#REGde+2'.",
        "2af2": "In effect - #S/LD D,(DE+2)/.",
        "2af3": "Finished.",
        "2af4": "Return directly if syntax is being checked.",
        "2af8": "Perform the multiplication.",
        "2afb": "Report 'Out of memory'.",
        "2afe": "Finished.",
        "2aff": "Fetch the present address in .",
        "2b02": "Jump if handling a variable that 'exists already' (bit",
        "2b06": "1 of  reset).",
        "2b08": "Presume dealing with a numeric variable - 5 bytes.",
        "2b0b": "Add '1' to the counter for each character of a name.",
        "2b0c": "Move along the variable's name.",
        "2b0d": "Fetch the 'present code'.",
        "2b0e": "Jump back if it is a 'space', thereby ignoring spaces.",
        "2b12": "Jump forward if the code is &21 to &FF.",
        "2b14": "Accept, as a final code, those in the range &00 to",
        "2b16": "&0F.",
        "2b18": "Also accept the range &16 to &1F.",
        "2b1c": "Step past the control code after any of INK to OVER.",
        "2b1d": "Jump back as these control codes are treated as spaces.",
        "2b1f": "Is the code alphanumeric?",
        "2b22": "If It is so then accept it as a character of a 'long'",
        "2b24": "Is the present code a '$'?",
        "2b26": "Jump forward as handling a 'newly declared' simple",
        "2b29": "Copy the 'length' to #REGa.",
        "2b2a": "Make #REGhl point to the '&80-byte' at the end of the",
        "2b2d": "variables area (-1).",
        "2b2e": "Now open up the variables area. Note: in effect #REGbc",
        "2b31": "Point to the first 'new' byte.",
        "2b32": "Make #REGde point to the second 'new' byte.",
        "2b34": "Save this pointer.",
        "2b35": "Fetch the pointer to the start of the name",
        "2b38": "Make #REGde point to the first 'new' byte.",
        "2b39": "Make #REGb hold the 'number of extra letters' that are",
        "2b3b": "found in a 'long name'.",
        "2b3c": "Jump forward if dealing with a variable with a 'short",
        "2b3e": "Point to each 'extra' code.",
        "2b3f": "Fetch the code.",
        "2b40": "Accept codes from &21 to &FF; ignore codes &00 to &20.",
        "2b44": "Set bit 5, as for lower case letters.",
        "2b46": "Transfer the codes in turn to the 2nd 'new' byte",
        "2b47": "onwards.",
        "2b48": "Go round the loop for all the 'extra' codes.",
        "2b4a": "Mark the code as required and overwrite the last code.",
        "2b4d": "Prepare to mark the letter of a 'long' name.",
        "2b4f": "Fetch the pointer to the letter ().",
        "2b52": "#REGa holds &00 for a 'short' name and &C0 for a 'long'",
        "2b53": "Set bit 5, as for lower case letters.",
        "2b55": "Drop the pointer now.",
        "2b56": "Enter the letter and return with #REGhl pointing to",
        "2b59": "Save the 'destination' pointer.",
        "2b5a": "Use the calculator to move  back five",
        "2b5b": "#R$33A1",
        "2b5c": "#R$369B",
        "2b5d": "Restore the pointer.",
        "2b5e": "Give the number a 'length' of five bytes.",
        "2b61": "Make #REGhl point to the first of the five locations",
        "2b62": "and jump forward to make the actual transfer.",
        "2b66": "Jump forward if handling any kind of string variable",
        "2b6a": "(bit 6 of  reset).",
        "2b6c": "The five bytes of a number + 1.",
        "2b6f": "#REGhl now points 'after'.",
        "2b70": "Jump back to make the actual transfer.",
        "2b72": "Fetch the 'start' (). Note: this line is",
        "2b75": "Fetch the 'length' ().",
        "2b79": "Jump if dealing with a complete simple string (bit 0",
        "2b7d": "of  set); the old string will need to be",
        "2b7f": "Return if the string is a null string.",
        "2b82": "Save the 'start' ().",
        "2b83": "Make the necessary amount of room in the work space.",
        "2b84": "Save the pointer to the first location.",
        "2b85": "Save the 'length' for use later on.",
        "2b86": "Make #REGde point to the last location.",
        "2b88": "Make #REGhl point 'one past' the new locations.",
        "2b89": "Enter a 'space' character.",
        "2b8b": "Copy this character into all the new locations. Finish",
        "2b8d": "Save the pointer briefly.",
        "2b8e": "Fetch the 'new' parameters.",
        "2b91": "Restore the pointer.",
        "2b92": "'Length' of new area to #REGhl. 'Pointer' to new area",
        "2b93": "Compare the two 'lengths' and jump forward if the",
        "2b94": "'new' string will fit into the room, i.e. no shortening",
        "2b96": "required.",
        "2b99": "However modify the 'new' length if it is too long.",
        "2b9b": "'Length' of new area to stack. 'Pointer' to new area to",
        "2b9c": "'Start' of new string to #REGhl. 'Pointer' to new area",
        "2b9d": "Jump forward if the 'new' string is a 'null' string.",
        "2ba1": "Otherwise move the 'new' string to the work space.",
        "2ba3": "'Length' of new area.",
        "2ba4": "'Pointer' to new area.",
        "2ba5": "The start - the pointer to the 'variable in assignment'",
        "2ba6": "Change the pointers over.",
        "2ba7": "Check once again that the length is not zero.",
        "2baa": "Save the destination pointer.",
        "2bab": "Move the numeric value or the string.",
        "2bad": "Return with the #REGhl register pair pointing to the",
        "2bae": "first byte of the numeric value or the string.",
        "2baf": "Make #REGhl point to the letter of the variable's",
        "2bb0": "name, i.e. -3.",
        "2bb2": "Pick up the letter.",
        "2bb3": "Save the pointer to the 'existing version'.",
        "2bb4": "Save the 'length' of the 'existing string'.",
        "2bb5": "Use #R$2BC6 to add the new string to the variables",
        "2bb8": "Restore the 'length'.",
        "2bb9": "Restore the pointer.",
        "2bba": "Allow one byte for the letter and two bytes for the",
        "2bbb": "length.",
        "2bbd": "Exit by jumping to #R$19E8 which will reclaim the whole",
        "2bc0": "Prepare for the marking of the variable's letter.",
        "2bc2": "Fetch the pointer to the letter ().",
        "2bc5": "Mark the letter as required. #R$2BC6 is now used to add",
        "2bc6": "Save the variable's letter.",
        "2bc7": "Fetch the 'start' and the 'length' of the 'new' string.",
        "2bca": "Move the 'start' to #REGhl.",
        "2bcb": "Make #REGhl point one past the string.",
        "2bcc": "Save the 'length'.",
        "2bcd": "Make #REGhl point to the end of the string.",
        "2bce": "Save the pointer briefly in .",
        "2bd1": "Allow one byte for the letter and two bytes for the",
        "2bd2": "length.",
        "2bd4": "Make #REGhl point to the '&80-byte' at the end of the",
        "2bd7": "variables area (-1).",
        "2bd8": "Now open up the variables area. Note: in effect #REGbc",
        "2bdb": "Restore the pointer to the end of the 'new' string from",
        "2bde": "Make a copy of the length of the 'new' string.",
        "2be0": "Add one to the length in case the 'new' string is a",
        "2be1": "Now copy the 'new' string + one byte.",
        "2be3": "Make #REGhl point to the byte that is to hold the",
        "2be4": "high-length.",
        "2be5": "Fetch the 'length'.",
        "2be6": "Enter the high-length.",
        "2be7": "Back one.",
        "2be8": "Enter the low-length.",
        "2be9": "Fetch the variable's letter.",
        "2bea": "Make #REGhl point to the 'old &80-byte'.",
        "2beb": "It is overwritten with the letter of the variable.",
        "2bec": "Make #REGhl point to the 'new &80-byte'",
        "2bef": "(-1).",
        "2bf0": "Finished with all the 'newly declared variables'.",
        "2bf1": "Get .",
        "2bf4": "Back one.",
        "2bf5": "The fifth value.",
        "2bf6": "Back one.",
        "2bf7": "The fourth value.",
        "2bf8": "Back one.",
        "2bf9": "The third value.",
        "2bfa": "Back one.",
        "2bfb": "The second value.",
        "2bfc": "Back one.",
        "2bfd": "The first value.",
        "2bfe": "Reset  to its new position.",
        "2c01": "Finished.",
        "2c02": "Search the variables area.",
        "2c05": "Give report C as there has been an error.",
        "2c08": "Jump forward if in 'run time'.",
        "2c0d": "Test the syntax for string arrays as if they were",
        "2c0f": "Check the syntax of the parenthesised expression.",
        "2c12": "Move on to consider the next statement as the syntax was",
        "2c15": "Jump forward if there is no 'existing array'.",
        "2c17": "Save the discriminator byte.",
        "2c18": "Find the start of the next variable.",
        "2c1b": "Reclaim the 'existing array'.",
        "2c1e": "Restore the discriminator byte.",
        "2c1f": "Set bit 7 in the discriminator byte.",
        "2c21": "Make the dimension counter zero.",
        "2c23": "Save the counter and the discriminator byte.",
        "2c24": "The #REGhl register pair is to hold the size of the",
        "2c27": "elements in the array: '1' for a string array, '5' for a",
        "2c29": "numeric array.",
        "2c2d": "Element size to #REGde.",
        "2c2e": "Advance  on each pass.",
        "2c2f": "Set a 'limit value'.",
        "2c31": "Evaluate a parameter.",
        "2c34": "Give an error if 'out of range'.",
        "2c37": "Fetch the dimension counter and the discriminator byte.",
        "2c38": "Save the parameter on each pass through the loop.",
        "2c39": "Increase the dimension counter on each pass also.",
        "2c3a": "Restack the dimension counter and the discriminator",
        "2c3b": "The parameter is moved to the #REGhl register pair.",
        "2c3d": "The byte total is built up in #REGhl and then",
        "2c40": "transferred to #REGde.",
        "2c41": "Get the present character and go around the loop again",
        "2c42": "if there is another dimension.",
        "2c46": "Is it a ')'?",
        "2c48": "Jump back if not so.",
        "2c4a": "Advance  past it.",
        "2c4b": "Fetch the dimension counter and the discriminator byte.",
        "2c4c": "Pass the discriminator byte to the #REGa register for",
        "2c4d": "Move the counter to #REGl.",
        "2c4e": "Clear the #REGh register.",
        "2c50": "Increase the dimension counter by two and double the",
        "2c51": "result and form the correct overall length for the",
        "2c52": "variable by adding the element byte total.",
        "2c54": "Give the report 'Out of memory' if required.",
        "2c57": "Save the element byte total.",
        "2c58": "Save the dimension counter and the discriminator byte.",
        "2c59": "Save the overall length also.",
        "2c5a": "Move the overall length to #REGbc.",
        "2c5c": "Make the #REGhl register pair point to the '&80-byte'",
        "2c5f": "(-1).",
        "2c60": "The room is made available.",
        "2c63": "#REGhl is made to point to the first new location.",
        "2c64": "The letter, suitably marked, is entered first.",
        "2c65": "The overall length is fetched and decreased by '3'.",
        "2c69": "Advance #REGhl.",
        "2c6a": "Enter the low length.",
        "2c6b": "Advance #REGhl.",
        "2c6c": "Enter the high length.",
        "2c6d": "Fetch the dimension counter.",
        "2c6e": "Move it to the #REGa register.",
        "2c6f": "Advance #REGhl.",
        "2c70": "Enter the dimension count.",
        "2c71": "#REGhl is made to point to the last location of the",
        "2c72": "array and #REGde to the location before that one.",
        "2c74": "Enter a zero into the last location but overwrite it",
        "2c76": "with 'space' if dealing with an array of strings.",
        "2c7c": "Fetch the element byte total.",
        "2c7d": "Clear the array + one extra location.",
        "2c7f": "Get a dimension size.",
        "2c80": "Enter the high byte.",
        "2c81": "Back one.",
        "2c82": "Enter the low byte.",
        "2c83": "Back one.",
        "2c84": "Decrease the dimension counter.",
        "2c85": "Repeat the operation until all the dimensions have been",
        "2c87": "considered; then return.",
        "2c88": "Test for a digit; carry will be reset for a digit.",
        "2c8b": "Complement the carry flag.",
        "2c8c": "Return if a digit; otherwise continue on into #R$2C8D.",
        "2c8d": "Test against &41, the code for 'A'.",
        "2c8f": "Complement the carry flag.",
        "2c90": "Return if not a valid character code.",
        "2c91": "Test against &5B, 1 more than the code for 'Z'.",
        "2c93": "Return if an upper case letter.",
        "2c94": "Test against &61, the code for 'a'.",
        "2c96": "Complement the carry flag.",
        "2c97": "Return if not a valid character code.",
        "2c98": "Test against &7B, 1 more than the code for 'z'.",
        "2c9a": "Finished.",
        "2c9b": "Is the character a 'BIN'?",
        "2c9d": "Jump if it is not 'BIN'.",
        "2c9f": "Initialise result to zero in #REGde.",
        "2ca2": "Get the next character.",
        "2ca3": "Subtract the character code for '1'.",
        "2ca5": "0 now gives 0 with carry set; 1 gives 0 with carry",
        "2ca7": "Any other character causes a jump to #R$2CB3 and will be",
        "2ca9": "Result so far to #REGhl now.",
        "2caa": "Complement the carry flag.",
        "2cab": "Shift the result left, with the carry going to bit 0.",
        "2cad": "Report overflow if more than 65535.",
        "2cb0": "Return the result so far to #REGde.",
        "2cb1": "Jump back for next 0 or 1.",
        "2cb3": "Copy result to #REGbc for stacking.",
        "2cb5": "Jump forward to stack the result.",
        "2cb8": "Is the first character a '.'?",
        "2cba": "If so, jump forward.",
        "2cbc": "Otherwise, form a 'last value' of the integer.",
        "2cbf": "Is the next character a '.'?",
        "2cc1": "Jump forward to see if it is an 'E'.",
        "2cc3": "Get the next character.",
        "2cc4": "Is it a digit?",
        "2cc7": "Jump if not (e.g. 1.E4 is allowed).",
        "2cc9": "Jump forward to deal with the digits after the decimal",
        "2ccb": "If the number started with a decimal, see if the next",
        "2ccc": "character is a digit.",
        "2ccf": "Report the error if it is not.",
        "2cd2": "Use the calculator to stack zero as the integer part of",
        "2cd3": "#R$341B(stk_zero)",
        "2cd4": "#R$369B",
        "2cd5": "Use the calculator to copy the number 1 to mem-0.",
        "2cd6": "#R$341B(stk_one)",
        "2cd7": "#R$342D(st_mem_0)",
        "2cd8": "#R$33A1",
        "2cd9": "#R$369B",
        "2cda": "Get the present character.",
        "2cdb": "If it is a digit (D) then stack it.",
        "2cde": "If not jump forward.",
        "2ce0": "Now use the calculator.",
        "2ce1": "#R$340F(get_mem_0): V, D, N",
        "2ce2": "#R$341B(stk_ten): V, D, N, 10",
        "2ce3": "#R$31AF: V, D, N/10",
        "2ce4": "#R$342D(st_mem_0): V, D, N/10 (N/10 is copied to mem-0)",
        "2ce5": "#R$30CA: V, D*N/10",
        "2ce6": "#R$3014: V+D*N/10",
        "2ce7": "#R$369B",
        "2ce8": "Get the next character.",
        "2ce9": "Jump back (one more byte than needed) to consider it.",
        "2ceb": "Is the present character an 'E'?",
        "2ced": "Jump forward if it is.",
        "2cef": "Is it an 'e'?",
        "2cf1": "Finished unless it is so.",
        "2cf2": "Use #REGb as a sign flag, &FF for '+'.",
        "2cf4": "Get the next character.",
        "2cf5": "Is it a '+'?",
        "2cf7": "Jump forward.",
        "2cf9": "Is it a '-'?",
        "2cfb": "Jump if neither '+' nor '-'.",
        "2cfd": "Change the sign of the flag.",
        "2cfe": "Point to the first digit.",
        "2cff": "Is it indeed a digit?",
        "2d02": "Report the error if not.",
        "2d04": "Save the flag in #REGb briefly.",
        "2d05": "Stack ABS m, where m is the exponent.",
        "2d08": "Transfer ABS m to #REGa.",
        "2d0b": "Restore the sign flag to #REGb.",
        "2d0c": "Report the overflow now if ABS m is greater than 255 or",
        "2d0f": "indeed greater than 127 (other values greater than about",
        "2d10": "39 will be detected later).",
        "2d13": "Test the sign flag in #REGb; '+' (i.e. &FF) will now set",
        "2d14": "Jump if sign of m is '+'.",
        "2d16": "Negate m if sign is '-'.",
        "2d18": "Jump to assign to the 'last value' the result of",
        "2d1b": "Test against &30, the code for '0'.",
        "2d1d": "Return if not a valid character code.",
        "2d1e": "Test against the upper limit.",
        "2d20": "Complement the carry flag.",
        "2d21": "Finished.",
        "2d22": "Is the character a digit?",
        "2d25": "Return if not.",
        "2d26": "Replace the code by the actual digit.",
        "2d28": "Transfer the value to the #REGc register.",
        "2d29": "Clear the #REGb register.",
        "2d2b": "Re-initialise #REGiy to .",
        "2d2f": "Clear the #REGa register.",
        "2d30": "And the #REGe register, to indicate '+'.",
        "2d31": "Copy the less significant byte to #REGd.",
        "2d32": "And the more significant byte to #REGc.",
        "2d33": "Clear the #REGb register.",
        "2d34": "Now stack the number.",
        "2d37": "Use the calculator to make #REGhl point to",
        "2d38": "#R$369B",
        "2d39": "Clear the carry flag.",
        "2d3a": "Finished.",
        "2d3b": "Save the first digit - in #REGa.",
        "2d3c": "Use the calculator.",
        "2d3d": "#R$341B(stk_zero): (the 'last value' is now zero)",
        "2d3e": "#R$369B",
        "2d3f": "Restore the first digit.",
        "2d40": "If the code represents a digit (D) then stack the",
        "2d43": "floating-point form; otherwise return.",
        "2d44": "Use the calculator.",
        "2d45": "#R$343C: D, V",
        "2d46": "#R$341B(stk_ten): D, V, 10",
        "2d47": "#R$30CA: D, 10*V",
        "2d48": "#R$3014: D+10*V",
        "2d49": "#R$369B: D+10*V (this is 'V' for the next pass through",
        "2d4a": "The next code goes into #REGa.",
        "2d4d": "Loop back with this code.",
        "2d4f": "Test the sign of m by rotating bit 7 of #REGa into the",
        "2d50": "carry without changing #REGa.",
        "2d51": "Jump if m is positive.",
        "2d53": "Negate m in #REGa without disturbing the carry flag.",
        "2d55": "Save m in #REGa briefly.",
        "2d56": "This is ; a sign flag is now stored in",
        "2d59": "the first byte of mem-0, i.e. 0 for '+' and 1 for '-'.",
        "2d5c": "The stack holds x.",
        "2d5d": "#R$341B(stk_ten): x, 10",
        "2d5e": "#R$369B: x, 10",
        "2d5f": "Restore m in #REGa.",
        "2d60": "In the loop, shift out the next bit of m, modifying the",
        "2d62": "carry and zero flags appropriately; jump if carry reset.",
        "2d64": "Save the rest of m and the flags.",
        "2d65": "The stack holds x' and 10#power(2#powern), where x' is",
        "2d66": "#R$342D(st_mem_1): (10#power(2#powern) is copied to",
        "2d67": "#R$340F(get_mem_0): x', 10#power(2#powern), (1/0)",
        "2d68": "#R$368F to #R$2D6D: x', 10#power(2#powern)",
        "2d6a": "#R$30CA: x'*10#power(2#powern)=x\"",
        "2d6b": "#R$3686 to #R$2D6E: x''",
        "2d6d": "#R$31AF: x/10#power(2#powern)=x'' (x'' is",
        "2d6e": "#R$340F(get_mem_1): x'', 10#power(2#powern)",
        "2d6f": "#R$369B: x'', 10#power(2#powern)",
        "2d70": "Restore the rest of m in #REGa, and the flags.",
        "2d71": "Jump if m has been reduced to zero.",
        "2d73": "Save the rest of m in #REGa.",
        "2d74": "x'', 10#power(2#powern)",
        "2d75": "#R$33C0: x'', 10#power(2#powern), 10#power(2#powern)",
        "2d76": "#R$30CA: x'', 10#power(2#power(n+1))",
        "2d77": "#R$369B: x'', 10#power(2#power(n+1))",
        "2d78": "Restore the rest of m in #REGa.",
        "2d79": "Jump back for all bits of m.",
        "2d7b": "Use the calculator to delete the final power of 10",
        "2d7c": "#R$33A1",
        "2d7d": "#R$369B",
        "2d7f": "Point to the sign byte of the number.",
        "2d80": "Copy the sign byte to #REGc.",
        "2d81": "Point to the less significant byte.",
        "2d82": "Collect the byte in #REGa.",
        "2d83": "One's complement it if negative.",
        "2d84": "This adds 1 for negative numbers; it sets the carry",
        "2d85": "Less significant byte to #REGe now.",
        "2d86": "Point to the more significant byte.",
        "2d87": "Collect it in #REGa.",
        "2d88": "Finish two's complementing in the case of a negative",
        "2d89": "number; note that the carry is always left reset.",
        "2d8a": "More significant byte to #REGd now.",
        "2d8b": "Finished.",
        "2d8c": "This (unused) entry point would store a number known to",
        "2d8e": "The pointer to the first location is saved.",
        "2d8f": "The first byte is set to zero.",
        "2d91": "Point to the second location.",
        "2d92": "Enter the second byte.",
        "2d93": "Point to the third location.",
        "2d94": "Collect the less significant byte.",
        "2d95": "Two's complement it if the number is negative.",
        "2d97": "Store the byte.",
        "2d98": "Point to the fourth location.",
        "2d99": "Collect the more significant byte.",
        "2d9a": "Two's complement it if the number is negative.",
        "2d9c": "Store the byte.",
        "2d9d": "Point to the fifth location.",
        "2d9e": "The fifth byte is set to zero.",
        "2da0": "Return with #REGhl pointing to the first byte of n on",
        "2da1": "the stack.",
        "2da2": "Use the calculator to make #REGhl point to",
        "2da3": "#R$369B",
        "2da4": "Collect the exponent byte of the 'last value'; jump if",
        "2da5": "it is zero, indicating a 'small integer'.",
        "2da8": "Now use the calculator to round the 'last value' (V) to",
        "2da9": "#R$341B(stk_half): V, 0.5",
        "2daa": "#R$3014: V+0.5",
        "2dab": "#R$36AF: INT (V+0.5)",
        "2dac": "#R$369B",
        "2dad": "Use the calculator to delete the integer from the stack;",
        "2dae": "#R$33A1",
        "2daf": "#R$369B",
        "2db0": "Save both stack pointers.",
        "2db2": "#REGhl now points to the number.",
        "2db3": "Copy the first byte to #REGb.",
        "2db4": "Copy bytes 2, 3 and 4 to #REGc, #REGe and #REGd.",
        "2db7": "Clear the #REGa register.",
        "2db8": "This sets the carry unless #REGb is zero.",
        "2db9": "This sets the zero flag if the number is positive (NZ",
        "2dbb": "Copy the high byte to #REGb.",
        "2dbc": "And the low byte to #REGc.",
        "2dbd": "Copy the low byte to #REGa too.",
        "2dbe": "Restore the stack pointers.",
        "2dc0": "Finished.",
        "2dc1": "The integer #REGa is stacked, either as 00",
        "2dc2": "00 #REGa 00 00 (for positive #REGa) or as 00",
        "2dc3": "#S/FF/ #REGa #S/FF/ 00 (for negative #REGa).",
        "2dc4": "These bytes are first loaded into #REGa,",
        "2dc5": "#REGe, #REGd, #REGc, #REGb and then #R$2AB6",
        "2dc6": "is called to put the number on the calculator",
        "2dc7": "stack.",
        "2dcb": "The calculator is used.",
        "2dcc": "#R$33C6: log 2 to the base 10 is now stacked",
        "2dd2": "#R$30CA: #REGa*log 2 i.e. log (2#power#REGa)",
        "2dd3": "#R$36AF: INT log (2#power#REGa)",
        "2dd4": "#R$369B",
        "2dd5": "Compress the 'last value' into #REGbc.",
        "2dd8": "Return if out of range already.",
        "2dd9": "Save the result and the flags.",
        "2dda": "Again it will be out of range if the #REGb register",
        "2ddb": "does not hold zero.",
        "2ddc": "Jump if in range.",
        "2dde": "Fetch the result and the flags.",
        "2ddf": "Signal the result is out of range.",
        "2de0": "Finished - unsuccessful.",
        "2de1": "Fetch the result and the flags.",
        "2de2": "Finished - successful.",
        "2de3": "Use the calculator.",
        "2de4": "#R$33C0: x, x",
        "2de5": "#R$3506: x, (1/0) Logical value of x.",
        "2de6": "#R$368F to #R$2DF2: x",
        "2de8": "#R$33C0: x, x",
        "2de9": "#R$34F9: x, (1/0) Logical value of x.",
        "2dea": "#R$368F to #R$2DF8: x Hereafter x'=ABS x.",
        "2dec": "#R$33A1: -",
        "2ded": "#R$369B: -",
        "2dee": "Enter the character code for '0'.",
        "2df0": "Print the '0'.",
        "2df1": "Finished as the 'last value' is zero.",
        "2df2": "#R$346A: x' x'=ABS x.",
        "2df3": "#R$369B: x'",
        "2df4": "Enter the character code for '-'.",
        "2df6": "Print the '-'.",
        "2df7": "Use the calculator again.",
        "2df8": "#R$341B(stk_zero): The 15 bytes of mem-3, mem-4 and",
        "2df9": "mem-5 are now initialised to zero to be used for a",
        "2dfc": "#R$33A1: The stack is cleared, except for x'.",
        "2dfd": "#R$369B: x'",
        "2dfe": "#REGhl', which is used to hold calculator offsets",
        "2dff": "(e.g. for 'STR$'), is saved on the machine stack.",
        "2e01": "Use the calculator again.",
        "2e02": "#R$33C0: x', x'",
        "2e03": "#R$36AF: x', INT (x')=i",
        "2e04": "#R$342D(st_mem_2): (i is stored in mem-2).",
        "2e05": "#R$300F: x'-i=f",
        "2e06": "#R$340F(get_mem_2): f, i",
        "2e07": "#R$343C: i, f",
        "2e08": "#R$342D(st_mem_2): (f is stored in mem-2).",
        "2e09": "#R$33A1: i",
        "2e0a": "#R$369B: i",
        "2e0b": "Is i a small integer (first byte zero) i.e. is ABS",
        "2e0c": "i<=65535?",
        "2e0d": "Jump if it is not.",
        "2e0f": "i is copied to #REGde (i, like x', >=0).",
        "2e12": "#REGb is set to count 16 bits.",
        "2e14": "#REGd is copied to #REGa for testing: is it zero?",
        "2e16": "Jump if it is not zero.",
        "2e18": "Now test #REGe.",
        "2e19": "Jump if #REGde is zero: x is a pure fraction.",
        "2e1b": "Move #REGe to #REGd and set #REGb for 8 bits: #REGd",
        "2e1c": "was zero and #REGe was not.",
        "2e1e": "Transfer #REGde to #REGde', via the machine stack,",
        "2e1f": "to be moved into the print buffer at #R$2E7B.",
        "2e22": "Jump forward.",
        "2e24": "i (i=zero here)",
        "2e25": "#R$340F(get_mem_2): i, f",
        "2e26": "#R$369B: i, f",
        "2e27": "The exponent byte e of f is copied to #REGa.",
        "2e28": "#REGa becomes e minus &7E, i.e. e'+2, where e' is the",
        "2e2a": "The construction #REGa=ABS INT (LOG (2#power#REGa))",
        "2e2d": "is performed (LOG is to base 10); i.e. #REGa=n, say:",
        "2e2e": "The current count is collected from the second byte",
        "2e31": "of #R$5CAB(mem-5) and n is subtracted from it.",
        "2e35": "n is copied from #REGd to #REGa.",
        "2e36": "y=f*10#powern is formed and stacked.",
        "2e39": "i, y",
        "2e3a": "#R$33C0: i, y, y",
        "2e3b": "#R$36AF: i, y, INT (y)=i2",
        "2e3c": "#R$342D(st_mem_1): (i2 is copied to mem-1).",
        "2e3d": "#R$300F: i, y-i2",
        "2e3e": "#R$340F(get_mem_1): i, y-i2, i2",
        "2e3f": "#R$369B: i, f2, i2 (f2=y-i2)",
        "2e40": "i2 is transferred from the stack to #REGa.",
        "2e43": "The pointer to f2 is saved.",
        "2e44": "i2 is stored in the first byte of #R$5CA1(mem-3): a",
        "2e47": "i2 will not count as a digit for printing if it is",
        "2e48": "zero; #REGa is manipulated so that zero will produce",
        "2e49": "zero but a non-zero digit will produce 1.",
        "2e4b": "The zero or one is inserted into the first byte of",
        "2e4e": "#R$5CAB(mem-5) (the number of digits for printing)",
        "2e4f": "and added to the second byte of mem-5 (the number of",
        "2e50": "digits before the decimal).",
        "2e52": "The pointer to f2 is restored.",
        "2e53": "Jump to store f2 in buffer (#REGhl now points to f2,",
        "2e56": "e minus &80 is e', the true exponent of i.",
        "2e58": "Is e' less than 28?",
        "2e5a": "Jump if it is less.",
        "2e5c": "n is formed in #REGa.",
        "2e5f": "And reduced to n-7.",
        "2e61": "Then copied to #REGb.",
        "2e62": "n-7 is added in to the second byte of",
        "2e65": "#R$5CAB(mem-5), the number of digits required before",
        "2e66": "the decimal in x.",
        "2e67": "Then i is multiplied by 10#power(-n+7). This will",
        "2e68": "bring it into medium range for printing.",
        "2e6d": "Round the loop again to deal with the now",
        "2e6f": "#REGde now points to i, #REGhl to f.",
        "2e70": "The mantissa of i is now in #REGd', #REGe', #REGd,",
        "2e73": "Get the exchange registers.",
        "2e74": "True numerical bit 7 to #REGd'.",
        "2e76": "Exponent byte e of i to #REGa.",
        "2e77": "Back to the main registers.",
        "2e78": "True exponent e'=e minus &80 to #REGa.",
        "2e7a": "This gives the required bit count.",
        "2e7b": "The mantissa of i is now rotated left and all the",
        "2e7d": "bits of i are thus shifted into mem-4 and each byte",
        "2e7f": "of mem-4 is decimal adjusted at each shift.",
        "2e84": "Back to the main registers.",
        "2e85": "Address of fifth byte of #R$5CA6(mem-4) to #REGhl;",
        "2e88": "count of 5 bytes to #REGc.",
        "2e8a": "Get the byte of mem-4.",
        "2e8b": "Shift it left, taking in the new bit.",
        "2e8c": "Decimal adjust the byte.",
        "2e8d": "Restore it to mem-4.",
        "2e8e": "Point to next byte of mem-4.",
        "2e8f": "Decrease the byte count by one.",
        "2e90": "Jump for each byte of mem-4.",
        "2e92": "Jump for each bit of INT (x).",
        "2e94": "#REGa is cleared to receive the digits.",
        "2e95": "Source address: first byte of #R$5CA6(mem-4).",
        "2e98": "Destination: first byte of #R$5CA1(mem-3).",
        "2e9b": "There are at most 9 digits.",
        "2e9d": "The left nibble of mem-4 is discarded.",
        "2e9f": "&FF in #REGc will signal a leading zero, &00 will",
        "2ea1": "Left nibble of (#REGhl) to #REGa, right nibble of",
        "2ea3": "Jump if digit in #REGa is not zero.",
        "2ea5": "Test for a leading zero: it will now give zero",
        "2ea6": "reset.",
        "2ea7": "Jump if it was a leading zero.",
        "2ea9": "Insert the digit now.",
        "2eaa": "Point to next destination.",
        "2eab": "One more digit for printing, and one more before the",
        "2eae": "decimal.",
        "2eb1": "Change the flag from leading zero to other zero.",
        "2eb3": "The source pointer needs to be incremented on every",
        "2eb5": "second passage through the loop, when #REGb is odd.",
        "2eb8": "Jump back for all 9 digits.",
        "2eba": "Get counter from the first byte of #R$5CAB(mem-5):",
        "2ebd": "were there 9 digits excluding leading zeros?",
        "2ebf": "If not, jump to get more digits.",
        "2ec1": "Prepare to round: reduce count to 8.",
        "2ec4": "Compare 9th digit, byte 4 of #R$5CA6(mem-4), with 4",
        "2ec6": "to set carry for rounding up.",
        "2ec9": "Jump forward to round up.",
        "2ecb": "Use the calculator again.",
        "2ecc": "#R$33A1: - (i is now deleted).",
        "2ecd": "#R$340F(get_mem_2): f",
        "2ece": "#R$369B: f",
        "2ecf": "#REGde now points to f.",
        "2ed0": "The mantissa of f is now in #REGd', #REGe', #REGd,",
        "2ed3": "Get the exchange registers.",
        "2ed4": "The exponent of f is reduced to zero, by shifting",
        "2ed6": "the bits of f &80 minus e places right, where #REGl'",
        "2ed7": "contained e.",
        "2ed9": "True numerical bit to bit 7 of #REGd'.",
        "2edb": "Restore the main registers.",
        "2edc": "Now make the shift.",
        "2edf": "Get the digit count.",
        "2ee2": "Are there already 8 digits?",
        "2ee4": "If not, jump forward.",
        "2ee6": "If 8 digits, just use f to round i up, rotating",
        "2ee7": "#REGd' left to set the carry.",
        "2ee9": "Restore main registers and jump forward to round up.",
        "2eec": "Initial zero to #REGc, count of 2 to #REGb.",
        "2eef": " is multiplied by 10 in 2 stages, first",
        "2ef0": "#REGde then #REGde', each byte by byte in 2 steps,",
        "2ef3": "and the integer part of the result is obtained in",
        "2ef4": "#REGc to be passed into the print buffer.",
        "2ef9": "The count and the result alternate between #REGbc",
        "2efa": "and #REGbc'.",
        "2efc": "Loop back once through the exchange registers.",
        "2efe": "The start - 1st byte of #R$5CA1(mem-3).",
        "2f01": "Result to #REGa for storing.",
        "2f02": "Count of digits so far in number to #REGc.",
        "2f05": "Address the first empty byte.",
        "2f06": "Store the next digit.",
        "2f07": "Step up the count of digits.",
        "2f0a": "Loop back until there are 8 digits.",
        "2f0c": "Save the carry flag for the rounding.",
        "2f0d": "Base address of number: #R$5CA1(mem-3), byte 1.",
        "2f10": "Offset (number of digits in number) to #REGbc.",
        "2f15": "Address the last byte of the number.",
        "2f16": "Copy #REGc to #REGb as the counter.",
        "2f17": "Restore the carry flag.",
        "2f18": "This is the last byte of the number.",
        "2f19": "Get the byte into #REGa.",
        "2f1a": "Add in the carry i.e. round up.",
        "2f1c": "Store the rounded byte in the buffer.",
        "2f1d": "If the byte is 0 or 10, #REGb will be decremented",
        "2f1e": "and the final zero (or the 10) will not be counted",
        "2f20": "for printing.",
        "2f22": "Reset the carry for a valid digit.",
        "2f23": "Jump if carry reset.",
        "2f25": "Jump back for more rounding or more final zeros.",
        "2f27": "There is overflow to the left; an extra 1 is needed",
        "2f29": "here.",
        "2f2a": "It is also an extra digit before the decimal.",
        "2f2d": "#REGb now sets the count of the digits to be printed",
        "2f30": "f is to be deleted.",
        "2f31": "#R$33A1: -",
        "2f32": "#R$369B: -",
        "2f33": "The calculator offset saved on the stack is restored",
        "2f34": "to #REGhl'.",
        "2f36": "The counters are set (first two bytes of",
        "2f3a": "The start of the digits (first byte of",
        "2f3d": "If more than 9, or fewer than minus 4, digits are",
        "2f3e": "required before the decimal, then E-format will be",
        "2f40": "needed.",
        "2f42": "Fewer than 4 means more than 4 leading zeros after",
        "2f44": "the decimal.",
        "2f46": "Are there no digits before the decimal? If so, print",
        "2f47": "an initial zero.",
        "2f4a": "Start by setting #REGa to zero.",
        "2f4b": "Subtract #REGb: minus will mean there are digits",
        "2f4c": "before the decimal; jump forward to print them.",
        "2f4f": "#REGa is now required as a counter.",
        "2f50": "Jump forward to print the decimal part.",
        "2f52": "Copy the number of digits to be printed to #REGa. If",
        "2f53": "#REGa is 0, there are still final zeros to print",
        "2f54": "(#REGb is non-zero), so jump.",
        "2f56": "Get a digit from the print buffer.",
        "2f57": "Point to the next digit.",
        "2f58": "Decrease the count by one.",
        "2f59": "Print the appropriate digit.",
        "2f5c": "Loop back until #REGb is zero.",
        "2f5e": "It is time to print the decimal, unless #REGc is now",
        "2f5f": "zero; in that case, return - finished.",
        "2f61": "Add 1 to #REGb - include the decimal.",
        "2f62": "Put the code for '.' into #REGa.",
        "2f64": "Print the '.'.",
        "2f65": "Enter the character code for '0'.",
        "2f67": "Loop back to print all needed zeros.",
        "2f69": "Set the count for all remaining digits.",
        "2f6a": "Jump back to print them.",
        "2f6c": "The count of digits is copied to #REGd.",
        "2f6d": "It is decremented to give the exponent.",
        "2f6e": "One digit is required before the decimal in E-format.",
        "2f70": "All the part of the number before the 'E' is now",
        "2f73": "Enter the character code for 'E'.",
        "2f75": "Print the 'E'.",
        "2f76": "Exponent to #REGc now for printing.",
        "2f77": "And to #REGa for testing.",
        "2f78": "Its sign is tested.",
        "2f79": "Jump if it is positive.",
        "2f7c": "Otherwise, negate it in #REGa.",
        "2f7e": "Then copy it back to #REGc for printing.",
        "2f7f": "Enter the character code for '-'.",
        "2f81": "Jump to print the sign.",
        "2f83": "Enter the character code for '+'.",
        "2f85": "Now print the sign: '+' or '-'.",
        "2f86": "#REGbc holds the exponent for printing.",
        "2f88": "Jump back to print it and finish.",
        "2f8b": "Save whichever #REGde pair is in use.",
        "2f8c": "Copy the multiplicand from #REGa to #REGhl.",
        "2f8f": "Copy it to #REGde too.",
        "2f91": "Double #REGhl.",
        "2f92": "Double it again.",
        "2f93": "Add in #REGde to give #REGhl=5*#REGa.",
        "2f94": "Double again: now #REGhl=10*#REGa.",
        "2f95": "Copy #REGc to #REGde (#REGd is zero) for addition.",
        "2f96": "Now #REGhl=10*#REGa+#REGc.",
        "2f97": "#REGh is copied to #REGc.",
        "2f98": "#REGl is copied to #REGa, completing the task.",
        "2f99": "The #REGde register pair is restored.",
        "2f9a": "Finished.",
        "2f9b": "Transfer the exponent to #REGa.",
        "2f9c": "Presume a positive number.",
        "2f9e": "If the number is zero then the preparation is already",
        "2f9f": "finished.",
        "2fa0": "Now point to the sign byte.",
        "2fa1": "Set the zero flag for positive number.",
        "2fa3": "Restore the true numeric bit.",
        "2fa5": "Point to the first byte again.",
        "2fa6": "Positive numbers have been prepared, but negative",
        "2fa7": "Save any earlier exponent.",
        "2fa8": "There are 5 bytes to be handled.",
        "2fab": "Point one past the last byte.",
        "2fac": "Transfer the 5 to #REGb.",
        "2fad": "Save the exponent in #REGc.",
        "2fae": "Set carry flag for negation.",
        "2faf": "Point to each byte in turn.",
        "2fb0": "Get each byte.",
        "2fb1": "One's complement the byte.",
        "2fb2": "Add in carry for negation.",
        "2fb4": "Restore the byte.",
        "2fb5": "Loop 5 times.",
        "2fb7": "Restore the exponent to #REGa.",
        "2fb8": "Restore any earlier exponent.",
        "2fb9": "Finished.",
        "2fba": "#REGhl is preserved.",
        "2fbb": "#REGaf is preserved.",
        "2fbc": "M1 to #REGc.",
        "2fbd": "Next.",
        "2fbe": "M2 to #REGb.",
        "2fbf": "Copy the sign of the result to bit 7 of (#REGhl).",
        "2fc0": "Next.",
        "2fc1": "M1 to #REGa.",
        "2fc2": "M3 to #REGc.",
        "2fc3": "Save M2 and M3 on the machine stack.",
        "2fc4": "Next.",
        "2fc5": "M4 to #REGc.",
        "2fc6": "Next.",
        "2fc7": "M5 to #REGb.",
        "2fc8": "#REGhl now points to N1.",
        "2fc9": "M1 to #REGd.",
        "2fca": "N1 to #REGe.",
        "2fcb": "Save M1 and N1 on the machine stack.",
        "2fcc": "Next.",
        "2fcd": "N2 to #REGd.",
        "2fce": "Next.",
        "2fcf": "N3 to #REGe.",
        "2fd0": "Save N2 and N3 on the machine stack.",
        "2fd1": "Get the exchange registers.",
        "2fd2": "N2 to #REGd' and N3 to #REGe'.",
        "2fd3": "M1 to #REGh' and N1 to #REGl'.",
        "2fd4": "M2 to #REGb' and M3 to #REGc'.",
        "2fd5": "Get the original set of registers.",
        "2fd6": "Next.",
        "2fd7": "N4 to #REGd.",
        "2fd8": "Next.",
        "2fd9": "N5 to #REGe.",
        "2fda": "Restore the original #REGaf.",
        "2fdb": "Restore the original #REGhl.",
        "2fdc": "Finished.",
        "2fdd": "If the exponent difference is zero, the subroutine",
        "2fde": "returns at once.",
        "2fdf": "If the difference is greater than &20, jump forward.",
        "2fe3": "Save #REGbc briefly.",
        "2fe4": "Transfer the exponent difference to #REGb to count the",
        "2fe5": "Arithmetic shift right for #REGl', preserving the sign",
        "2fe6": "marker bits.",
        "2fe8": "Rotate right with carry #REGd', #REGe', #REGd and",
        "2fea": "#REGe, thereby shifting the whole five bytes of the",
        "2fec": "number to the right as many times as #REGb counts.",
        "2ff1": "Loop back until #REGb reaches zero.",
        "2ff3": "Restore the original #REGbc.",
        "2ff4": "Done if no carry to retrieve.",
        "2ff5": "Retrieve carry.",
        "2ff8": "Return unless the carry rippled right back. (In this",
        "2ff9": "Fetch #REGl', #REGd' and #REGe'.",
        "2ffa": "Clear the #REGa register.",
        "2ffb": "Set the addend to zero in #REGd', #REGe', #REGd and",
        "2ffd": "#REGe, together with its marker byte (sign indicator)",
        "2ffe": "#REGl', which was &00 for a positive number and &FF for",
        "2fff": "a negative number. This produces only 4 zero bytes when",
        "3000": "called for near underflow by #R$30CA.",
        "3003": "Finished.",
        "3004": "Add carry to rightmost byte.",
        "3005": "Return if no overflow to left.",
        "3006": "Continue to the next byte.",
        "3007": "Return if no overflow to left.",
        "3008": "Get the next byte.",
        "3009": "Increment it too.",
        "300a": "Jump if no overflow.",
        "300c": "Increment the last byte.",
        "300d": "Restore the original registers.",
        "300e": "Finished.",
        "300f": "Exchange the pointers.",
        "3010": "Change the sign of the subtrahend.",
        "3013": "Exchange the pointers back and continue into #R$3014.",
        "3014": "Test whether the first bytes of both numbers are zero.",
        "3016": "If not, jump for full addition.",
        "3018": "Save the pointer to the second number.",
        "3019": "Point to the second byte of the first number and save",
        "301a": "that pointer too.",
        "301b": "Point to the less significant byte.",
        "301c": "Fetch it in #REGe.",
        "301d": "Point to the more significant byte.",
        "301e": "Fetch it in #REGd.",
        "301f": "Move on to the second byte of the second number.",
        "3022": "Fetch it in #REGa (this is the sign byte).",
        "3023": "Point to the less significant byte.",
        "3024": "Fetch it in #REGc.",
        "3025": "Point to the more significant byte.",
        "3026": "Fetch it in #REGb.",
        "3027": "Fetch the pointer to the sign byte of the first number;",
        "3028": "put it in #REGde, and the number in #REGhl.",
        "3029": "Perform the addition: result in #REGhl.",
        "302a": "Result to #REGde, sign byte to #REGhl.",
        "302b": "Add the sign bytes and the carry into #REGa; this will",
        "302c": "detect any overflow.",
        "302d": "A non-zero #REGa now indicates overflow.",
        "302f": "Jump to reset the pointers and to do full addition.",
        "3031": "Define the correct sign byte for the result.",
        "3032": "Store it on the stack.",
        "3033": "Point to the next location.",
        "3034": "Store the low byte of the result.",
        "3035": "Point to the next location.",
        "3036": "Store the high byte of the result.",
        "3037": "Move the pointer back to address the first byte of the",
        "3038": "result.",
        "303a": "Restore  to #REGde.",
        "303b": "Finished.",
        "303c": "Restore the pointer to the first number.",
        "303d": "Restore the pointer to the second number.",
        "303e": "Re-stack both numbers in full five-byte floating-point",
        "3041": "Exchange the registers.",
        "3042": "Save the next literal address.",
        "3043": "Exchange the registers.",
        "3044": "Save pointer to the addend.",
        "3045": "Save pointer to the augend.",
        "3046": "Prepare the augend.",
        "3049": "Save its exponent in #REGb.",
        "304a": "Exchange the pointers.",
        "304b": "Prepare the addend.",
        "304e": "Save its exponent in #REGc.",
        "304f": "If the first exponent is smaller, keep the first number",
        "3050": "in the addend position; otherwise change the exponents",
        "3052": "and the pointers back again.",
        "3055": "Save the larger exponent in #REGa.",
        "3056": "The difference between the exponents is the length of",
        "3057": "Get the two numbers from the stack.",
        "305a": "Shift the addend right.",
        "305d": "Restore the larger exponent.",
        "305e": "#REGhl is to point to the result.",
        "305f": "Store the exponent of the result.",
        "3060": "Save the pointer again.",
        "3061": "M4 to #REGh and M5 to #REGl (see #R$2FBA).",
        "3063": "Add the two right bytes.",
        "3064": "N2 to #REGh' and N3 to #REGl' (see #R$2FBA).",
        "3066": "Add left bytes with carry.",
        "3068": "Result back in .",
        "3069": "Add #REGh', #REGl' and the carry; the resulting",
        "306a": "mechanisms will ensure that a single shift right is",
        "306b": "called if the sum of 2 positive numbers has overflowed",
        "306c": "left, or the sum of 2 negative numbers has not",
        "306d": "overflowed left.",
        "306f": "The result is now in .",
        "3070": "Get the pointer to the exponent.",
        "3071": "The test for shift (#REGh', #REGl' were &00 for",
        "3072": "positive numbers and &FF for negative numbers).",
        "3074": "#REGa counts a single shift right.",
        "3076": "The shift is called.",
        "3079": "Add 1 to the exponent; this may lead to arithmetic",
        "307a": "overflow.",
        "307c": "Test for negative result: get sign bit of #REGl' into",
        "307d": "#REGa (this now correctly indicates the sign of the",
        "307e": "result).",
        "3081": "Store it in the second byte position of the result on",
        "3082": "the calculator stack.",
        "3084": "If it is zero, then do not two's complement the result.",
        "3086": "Get the first byte.",
        "3087": "Negate it.",
        "3089": "Complement the carry for continued negation, and store",
        "308a": "byte.",
        "308b": "Get the next byte.",
        "308c": "One's complement it.",
        "308d": "Add in the carry for negation.",
        "308f": "Store the byte.",
        "3090": "Proceed to get next byte into the #REGa register.",
        "3092": "One's complement it.",
        "3093": "Add in the carry for negation.",
        "3095": "Store the byte.",
        "3096": "Get the last byte.",
        "3097": "One's complement it.",
        "3098": "Add in the carry for negation.",
        "309a": "Done if no carry.",
        "309c": "Else, get .5 into mantissa and add 1 to the exponent;",
        "309d": "this will be needed when two negative numbers add to",
        "309e": "give an exact power of 2, and it may lead to arithmetic",
        "309f": "Give the error if required.",
        "30a3": "Store the last byte.",
        "30a5": "Clear #REGa and the carry flag.",
        "30a6": "Exit via #R$3155.",
        "30a9": "#REGbc is saved.",
        "30aa": "It is to be a 16-bit multiplication.",
        "30ac": "#REGa holds the high byte.",
        "30ad": "#REGc holds the low byte.",
        "30ae": "Initialise the result to zero.",
        "30b1": "Double the result.",
        "30b2": "Jump if overflow.",
        "30b4": "Rotate bit 7 of #REGc into the carry.",
        "30b6": "Rotate the carry bit into bit 0 and bit 7 into the carry",
        "30b7": "Jump if the carry flag is reset.",
        "30b9": "Otherwise add #REGde in once.",
        "30ba": "Jump if overflow.",
        "30bc": "Repeat until 16 passes have been made.",
        "30be": "Restore #REGbc.",
        "30bf": "Finished.",
        "30c0": "If the number is zero, return with the carry flag set.",
        "30c4": "Point to the sign byte.",
        "30c5": "Get sign for result into #REGa (like signs give plus,",
        "30c6": "Set the true numeric bit.",
        "30c8": "Point to the exponent again.",
        "30c9": "Return with carry flag reset.",
        "30ca": "Test whether the first bytes of both numbers are zero.",
        "30cc": "If not, jump for 'long' multiplication.",
        "30ce": "Save the pointers to the second number.",
        "30cf": "And to the first number.",
        "30d0": "And to the second number yet again.",
        "30d1": "Fetch sign in #REGc, number in #REGde.",
        "30d4": "Number to #REGhl now.",
        "30d5": "Number to stack, second pointer to #REGhl.",
        "30d6": "Save first sign in #REGb.",
        "30d7": "Fetch second sign in #REGc, number in #REGde.",
        "30da": "Form sign of result in #REGa: like signs give plus",
        "30db": "(&00), unlike give minus (&FF).",
        "30dc": "Store sign of result in #REGc.",
        "30dd": "Restore the first number to #REGhl.",
        "30de": "Perform the actual multiplication.",
        "30e1": "Store the result in #REGde.",
        "30e2": "Restore the pointer to the first number.",
        "30e3": "Jump on overflow to 'full' multiplication.",
        "30e5": "These 5 bytes ensure that 00 #S/FF/ 00 00 00 is",
        "30e6": "replaced by zero; that they should not be needed if this",
        "30e7": "number were excluded from the system is noted at",
        "30e9": "#R$303C.",
        "30ea": "Now store the result on the stack.",
        "30ed": "Restore  to #REGde.",
        "30ee": "Finished.",
        "30ef": "Restore the pointer to the second number.",
        "30f0": "Re-stack both numbers in full five byte floating-point",
        "30f3": "#REGa is set to zero so that the sign of the first",
        "30f4": "Prepare the first number, and return if zero. (Result",
        "30f7": "already zero.)",
        "30f8": "Exchange the registers.",
        "30f9": "Save the next literal address.",
        "30fa": "Exchange the registers.",
        "30fb": "Save the pointer to the multiplicand.",
        "30fc": "Exchange the pointers.",
        "30fd": "Prepare the 2nd number.",
        "3100": "Exchange the pointers again.",
        "3101": "Jump forward if 2nd number is zero.",
        "3103": "Save the pointer to the result.",
        "3104": "Get the two numbers from the stack.",
        "3107": "M5 to #REGa (see #R$2FBA).",
        "3108": "Prepare for a subtraction.",
        "3109": "Initialise #REGhl to zero for the result.",
        "310b": "Exchange the registers.",
        "310c": "Save M1 and N1 (see #R$2FBA).",
        "310d": "Also initialise #REGhl' for the result.",
        "310f": "Exchange the registers.",
        "3110": "#REGb counts thirty three shifts.",
        "3112": "Jump forward into the loop.",
        "3114": "Jump forward to #R$311B if no carry, i.e. the multiplier",
        "3116": "Else, add the multiplicand in  (see",
        "3117": "#R$2FBA) into the result being built up in .",
        "311b": "Whether multiplicand was added or not, shift result",
        "311c": "right in ; the shift is done by rotating",
        "311e": "each byte with carry, so that any bit that drops into",
        "3120": "the carry is picked up by the next byte, and the shift",
        "3121": "continued into .",
        "3125": "Shift right the multiplier in  (see #R$2FBA",
        "3126": "and above). A final bit dropping into the carry will",
        "3128": "trigger another add of the multiplicand to the result.",
        "312e": "Loop 33 times to get all the bits.",
        "3130": "Move the result from  to .",
        "3134": "Restore the exponents - M1 and N1.",
        "3135": "Restore the pointer to the exponent byte.",
        "3136": "Get the sum of the two exponent bytes in #REGa, and the",
        "3137": "correct carry.",
        "3138": "If the sum equals zero then clear the carry; else leave",
        "313a": "it unchanged.",
        "313b": "Prepare to increase the exponent by &80.",
        "313d": "These few bytes very cleverly make the correct exponent",
        "313e": "byte. Rotating left then right gets the exponent byte",
        "313f": "(true exponent plus &80) into #REGa.",
        "3140": "If the sign flag is reset, no report of arithmetic",
        "3143": "Report the overflow if carry reset.",
        "3145": "Clear the carry now.",
        "3146": "The exponent byte is now complete; but if #REGa is zero",
        "3147": "a further check for overflow is needed.",
        "314b": "If there is no carry set and the result is already in",
        "314c": "normal form (bit 7 of #REGd' set) then there is overflow",
        "314e": "to report; but if bit 7 of #REGd' is reset, the result",
        "314f": "in just in range, i.e. just under 2**127.",
        "3151": "Store the exponent byte, at last.",
        "3152": "Pass the fifth result byte to #REGa for the",
        "3153": "normalisation sequence, i.e. the overflow from #REGl",
        "3154": "into #REGb'.",
        "3155": "If no carry then normalise now.",
        "3157": "Else, deal with underflow (zero result) or near",
        "3158": "underflow (result 2**-128): return exponent to #REGa,",
        "3159": "test if #REGa is zero (case 2**-128) and if so produce",
        "315b": "2**-128 if number is normal; otherwise produce zero. The",
        "315d": "exponent must then be set to zero (for zero) or 1 (for",
        "315e": "2**-128).",
        "3164": "Restore the exponent byte.",
        "3165": "Jump if case 2**-128.",
        "3167": "Otherwise, put zero into second byte of result on the",
        "3168": "calculator stack.",
        "316a": "Jump forward to transfer the result.",
        "316c": "Normalise the result by up to 32 shifts left of",
        "316e": " (with #REGa adjoined) until bit 7 of #REGd'",
        "316f": "is set. #REGa holds zero after addition so no precision",
        "3171": "is gained or lost; #REGa holds the fifth byte from",
        "3172": "#REGb' after multiplication or division; but as only",
        "3174": "about 32 bits can be correct, no precision is lost. Note",
        "3175": "that #REGa is rotated circularly, with branch at",
        "3177": "carry...eventually a random process.",
        "317f": "The exponent is decremented on each shift.",
        "3180": "If the exponent becomes zero, then numbers from 2**-129",
        "3182": "Loop back, up to 32 times.",
        "3184": "If bit 7 never became 1 then the whole result is to be",
        "3186": "After normalisation add back any final carry that went",
        "3187": "into #REGa. Jump forward if the carry does not ripple",
        "3189": "right back.",
        "318e": "If it should ripple right back then set mantissa to 0.5",
        "318f": "and increment the exponent. This action may lead to",
        "3191": "arithmetic overflow (final case).",
        "3195": "Save the result pointer.",
        "3196": "Point to the sign byte in the result.",
        "3197": "The result is moved from  to ,",
        "3198": "and then to .",
        "319c": "The sign bit is retrieved from its temporary store and",
        "319d": "transferred to its correct position of bit 7 of the",
        "319f": "first byte of the mantissa.",
        "31a0": "The first byte is stored.",
        "31a1": "Next.",
        "31a2": "The second byte is stored.",
        "31a3": "Next.",
        "31a4": "The third byte is stored.",
        "31a5": "Next.",
        "31a6": "The fourth byte is stored.",
        "31a7": "Restore the pointer to the result.",
        "31a8": "Restore the pointer to second number.",
        "31a9": "Exchange the register.",
        "31aa": "Restore the next literal address.",
        "31ab": "Exchange the registers.",
        "31ac": "Finished.",
        "31ad": "Call the error handling routine.",
        "31af": "Use full floating-point forms.",
        "31b2": "Exchange the pointers.",
        "31b3": "#REGa is set to 0, so that the sign of the first number",
        "31b4": "Prepare the divisor and give the report for arithmetic",
        "31b7": "overflow if it is zero.",
        "31b9": "Exchange the pointers.",
        "31ba": "Prepare the dividend and return if it is zero (result",
        "31bd": "already zero).",
        "31be": "Exchange the pointers.",
        "31bf": "Save the next literal address.",
        "31c0": "Exchange the registers.",
        "31c1": "Save pointer to divisor.",
        "31c2": "Save pointer to dividend.",
        "31c3": "Get the two numbers from the stack.",
        "31c6": "Exchange the registers.",
        "31c7": "Save M1 and N1 (the exponent bytes) on the machine",
        "31c8": "Copy the four bytes of the dividend from registers",
        "31c9": " (i.e. M2, M3, M4 and M5; see #R$2FBA) to",
        "31ca": "the registers .",
        "31cd": "Clear #REGa and reset the carry flag.",
        "31ce": "#REGb will count upwards from -33 to -1 (&DF to &FF),",
        "31d0": "Jump forward into the division loop for the first trial",
        "31d2": "Shift the result left into , shifting out",
        "31d3": "the bits already there, picking up 1 from the carry",
        "31d5": "whenever it is set, and rotating left each byte with",
        "31d6": "carry to achieve the 32-bit shift.",
        "31db": "Move what remains of the dividend left in ",
        "31dc": "before the next trial subtraction; if a bit drops into",
        "31dd": "the carry, force no restore and a bit for the quotient,",
        "31df": "thus retrieving the lost bit and allowing a full 32-bit",
        "31e0": "divisor.",
        "31e2": "Trial subtract divisor in  from rest of",
        "31e4": "dividend in ; there is no initial carry (see",
        "31e5": "previous step).",
        "31e8": "Jump forward if there is no carry.",
        "31ea": "Otherwise restore, i.e. add back the divisor. Then",
        "31eb": "clear the carry so that there will be no bit for the",
        "31ec": "quotient (the divisor 'did not go').",
        "31f0": "Jump forward to the counter.",
        "31f2": "Just subtract with no restore and go on to set the",
        "31f3": "carry flag because the lost bit of the dividend is to be",
        "31f5": "retrieved and used for the quotient.",
        "31f9": "One for the quotient in .",
        "31fa": "Step the loop count up by one.",
        "31fb": "Loop 32 times for all bits.",
        "31fe": "Save any 33rd bit for extra precision (the present",
        "31ff": "Trial subtract yet again for any 34th bit; the '#S/PUSH",
        "3201": "Now move the four bytes that form the mantissa of the",
        "3202": "result from  to .",
        "3206": "Then put the 34th and 33rd bits into #REGb' to be",
        "3207": "picked up on normalisation.",
        "320d": "Restore the exponent bytes M1 and N1.",
        "320e": "Restore the pointer to the result.",
        "320f": "Get the difference between the two exponent bytes into",
        "3210": "#REGa and set the carry flag if required.",
        "3211": "Exit via #R$313D.",
        "3214": "Get the exponent byte of x into #REGa.",
        "3215": "If #REGa is zero, return since x is already a small",
        "3216": "integer.",
        "3217": "Compare e, the exponent, to &81.",
        "3219": "Jump if e is greater than &80.",
        "321b": "Else, set the exponent to zero; enter &20 into #REGa",
        "321d": "and jump forward to #R$3272 to make all the bits of x be",
        "321f": "zero.",
        "3221": "Compare e to &91.",
        "3223": "Jump if e not &91.",
        "3225": "#REGhl is pointed at the fourth byte of x, where the 17",
        "3226": "bits of the integer part of x end after the first bit.",
        "3228": "The first bit is obtained in #REGa, using &80 as a",
        "322a": "mask.",
        "322b": "That bit and the previous 8 bits are tested together",
        "322c": "for zero.",
        "322d": "#REGhl is pointed at the second byte of x.",
        "322e": "If already non-zero, the test can end.",
        "3230": "Otherwise, the test for -65536 is now completed: 91 80",
        "3232": "00 00 00 will leave the zero flag set now.",
        "3233": "#REGhl is pointed at the first byte of x.",
        "3234": "If zero reset, the jump is made.",
        "3236": "The first byte is set to zero.",
        "3237": "#REGhl points to the second byte.",
        "3238": "The second byte is set to &FF.",
        "323a": "#REGhl again points to the first byte.",
        "323b": "The last 24 bits are to be zero.",
        "323d": "The jump to #R$3272 completes the number 00 #S/FF/ 00 00",
        "323f": "Jump with exponent byte &92 or more (it would be better",
        "3241": "Save  in #REGde.",
        "3242": "Range 129<=#REGa<=144 becomes 126>=#REGa>=111.",
        "3243": "Range is now 15>=#REGa>=0.",
        "3245": "Point #REGhl at second byte.",
        "3246": "Second byte to #REGd.",
        "3247": "Point #REGhl at third byte.",
        "3248": "Third byte to #REGe.",
        "3249": "Point #REGhl at first byte again.",
        "324b": "Assume a positive number.",
        "324d": "Now test for negative (bit 7 set).",
        "324f": "Jump if positive after all.",
        "3251": "Change the sign.",
        "3252": "Insert true numeric bit, 1, in #REGd.",
        "3254": "Now test whether #REGa>=8 (one byte only) or two bytes",
        "3256": "needed.",
        "3257": "Leave #REGa unchanged.",
        "3258": "Jump if two bytes needed.",
        "325a": "Put the one byte into #REGe.",
        "325b": "And set #REGd to zero.",
        "325d": "Now 1<=#REGa<=7 to count the shifts needed.",
        "325e": "Jump if no shift needed.",
        "3260": "#REGb will count the shifts.",
        "3261": "Shift #REGd and #REGe right #REGb times to produce the",
        "3263": "correct number.",
        "3265": "Loop until #REGb is zero.",
        "3267": "Store the result on the stack.",
        "326a": "Restore  to #REGde.",
        "326b": "Finished.",
        "326c": "Get the exponent byte of x into #REGa.",
        "326d": "Subtract &A0 from e.",
        "326f": "Return on plus - x has no significant non-integral part.",
        "3270": "Else, negate the remainder; this gives the number of",
        "3272": "Save the current value of #REGde ().",
        "3273": "Make #REGhl point one past the fifth byte.",
        "3274": "#REGhl now points to the fifth byte of x.",
        "3275": "Get the number of bits to be set to zero in #REGb and",
        "3276": "divide it by 8 to give the number of whole bytes",
        "3278": "implied.",
        "327c": "Jump forward if the result is zero.",
        "327e": "Else, set the bytes to zero; #REGb counts them.",
        "3283": "Get #REGa (mod 8); this is the number of bits still to",
        "3285": "Jump to the end if nothing more to do.",
        "3287": "#REGb will count the bits now.",
        "3288": "Prepare the mask.",
        "328a": "With each loop a zero enters the mask from the right",
        "328c": "and thereby a mask of the correct length is produced.",
        "328e": "The unwanted bits of (#REGhl) are lost as the masking",
        "328f": "is performed.",
        "3290": "Return the pointer to #REGhl.",
        "3291": "Return  to #REGde.",
        "3292": "Finished.",
        "3293": "Call the subroutine and then continue into it for the",
        "3296": "Exchange the pointers at each call.",
        "3297": "If the first byte is not zero, return - the number",
        "3298": "cannot be a 'small integer'.",
        "329a": "Save the 'other' pointer in #REGde.",
        "329b": "Fetch the sign in #REGc and the number in #REGde.",
        "329e": "Clear the #REGa register.",
        "329f": "Point to the fifth location.",
        "32a0": "Set the fifth byte to zero.",
        "32a1": "Point to the fourth location.",
        "32a2": "Set the fourth byte to zero; bytes 2 and 3 will hold the",
        "32a3": "Set #REGb to &91 for the exponent, i.e. for up to 16",
        "32a5": "Test whether #REGd is zero so that at most 8 bits would",
        "32a6": "be needed.",
        "32a7": "Jump if more than 8 bits needed.",
        "32a9": "Now test #REGe too.",
        "32aa": "Save the zero in #REGb (it will give zero exponent if",
        "32ab": "Jump if #REGe is indeed zero.",
        "32ad": "Move #REGe to #REGd (#REGd was zero, #REGe not).",
        "32ae": "Set #REGe to zero now.",
        "32af": "Set #REGb to &89 for the exponent - no more than 8 bits",
        "32b1": "Pointer to #REGde, number to #REGhl.",
        "32b2": "Decrement the exponent on each shift.",
        "32b3": "Shift the number right one position.",
        "32b4": "Until the carry is set.",
        "32b6": "Sign bit to carry flag now.",
        "32b8": "Insert it in place as the number is shifted back one",
        "32ba": "place normal now.",
        "32bc": "Pointer to byte 4 back to #REGhl.",
        "32bd": "Point to the third location.",
        "32be": "Store the third byte.",
        "32bf": "Point to the second location.",
        "32c0": "Store the second byte.",
        "32c1": "Point to the first location.",
        "32c2": "Store the exponent byte.",
        "32c3": "Restore the 'other' pointer to #REGde.",
        "32c4": "Finished.",
        "32c5": "zero (00 00 00 00 00)",
        "32c8": "one (00 00 01 00 00)",
        "32cc": "a half (80 00 00 00 00)",
        "32ce": "a half of pi (81 49 #S/0F DA A2/)",
        "32d3": "ten (00 00 #S/0A/ 00 00)",
        "32d7": "&00",
        "32d9": "&01",
        "32db": "&02",
        "32dd": "&03",
        "32df": "&04",
        "32e1": "&05",
        "32e3": "&06",
        "32e5": "&07",
        "32e7": "&08",
        "32e9": "&09: <= (numbers)",
        "32eb": "&0A: >= (numbers)",
        "32ed": "&0B: <> (numbers)",
        "32ef": "&0C: > (numbers)",
        "32f1": "&0D: < (numbers)",
        "32f3": "&0E: = (numbers)",
        "32f5": "&0F",
        "32f7": "&10",
        "32f9": "&11: <= (strings)",
        "32fb": "&12: >= (strings)",
        "32fd": "&13: <> (strings)",
        "32ff": "&14: > (strings)",
        "3301": "&15: < (strings)",
        "3303": "&16: = (strings)",
        "3305": "&17",
        "3307": "&18 (VAL$)",
        "3309": "&19",
        "330b": "&1A",
        "330d": "&1B",
        "330f": "&1C",
        "3311": "&1D (VAL)",
        "3313": "&1E",
        "3315": "&1F",
        "3317": "&20",
        "3319": "&21",
        "331b": "&22",
        "331d": "&23",
        "331f": "&24",
        "3321": "&25",
        "3323": "&26",
        "3325": "&27",
        "3327": "&28",
        "3329": "&29",
        "332b": "&2A",
        "332d": "&2B",
        "332f": "&2C",
        "3331": "&2D",
        "3333": "&2E",
        "3335": "&2F",
        "3337": "&30",
        "3339": "&31",
        "333b": "&32",
        "333d": "&33",
        "333f": "&34",
        "3341": "&35",
        "3343": "&36",
        "3345": "&37",
        "3347": "&38",
        "3349": "&39",
        "334b": "&3A",
        "334d": "&3B",
        "334f": "&3C",
        "3351": "&3D",
        "3353": "&3E",
        "3355": "&3F",
        "3357": "&40",
        "3359": "&41",
        "335b": "Presume a unary operation and therefore set #REGhl to",
        "335e": "Either transfer a single operation offset to",
        "335f": " temporarily, or, when using the subroutine",
        "3362": "The return address of the subroutine is stored in",
        "3363": "#REGhl'. This saves the pointer to the first literal.",
        "3364": "Entering the calculator here is done whenever",
        "3365": "A loop is now entered to handle each literal in the list",
        "3369": "Go to the alternate register set and fetch the literal",
        "336a": "for this loop.",
        "336b": "Make #REGhl' point to the next literal.",
        "336c": "This pointer is saved briefly on the machine stack.",
        "336d": "Test the #REGa register.",
        "336e": "Separate the simple literals from the multi-purpose",
        "3371": "Save the literal in #REGd.",
        "3372": "Continue only with bits 5 and 6.",
        "3374": "Four right shifts make them now bits 1 and 2.",
        "3378": "The offsets required are &3E to &41, and #REGl will now",
        "337a": "hold double the required offset.",
        "337b": "Now produce the parameter by taking bits 0, 1, 2, 3 and",
        "337c": "4 of the literal; keep the parameter in #REGa.",
        "337e": "Jump forward to find the address of the required",
        "3380": "Jump forward if performing a unary operation.",
        "3384": "All of the subroutines that perform binary operations",
        "3385": "require that #REGhl points to the first operand and",
        "3388": "#REGde points to the second operand (the 'last value')",
        "3389": "as they appear on the calculator stack.",
        "338c": "As each entry in the table of addresses takes up two",
        "338d": "bytes the offset produced is doubled.",
        "338e": "The base address of the #R$32D7(table).",
        "3391": "The address of the required table entry is formed in",
        "3393": "#REGhl, and the required subroutine address is loaded",
        "3394": "into the #REGde register pair.",
        "3397": "The address of #R$3365 is put on the machine stack",
        "339a": "underneath the subroutine address.",
        "339c": "Return to the main set of registers.",
        "339d": "The current value of  is transferred to the",
        "33a1": "An indirect jump to the required subroutine.",
        "33a2": "Discard the #R$3365 address.",
        "33a3": "Transfer the offset from  to #REGa.",
        "33a6": "Enter the alternate register set.",
        "33a7": "Jump back to find the required address; stack the",
        "33a9": "Save #REGde briefly.",
        "33aa": "Save #REGhl briefly.",
        "33ab": "Specify the test is for 5 bytes.",
        "33ae": "Make the test.",
        "33b1": "Restore #REGhl.",
        "33b2": "Restore #REGde.",
        "33b3": "Finished.",
        "33b4": "Copy  to #REGde as destination address.",
        "33b8": "Move the number.",
        "33bb": "Reset  from #REGde.",
        "33bf": "Finished.",
        "33c0": "A test is made for room.",
        "33c3": "Move the five bytes involved.",
        "33c5": "Finished.",
        "33c6": "This subroutine performs the manipulatory operation of",
        "33c7": "adding a 'last value' to the calculator stack; hence",
        "33c8": "Now test that there is indeed room.",
        "33cb": "Go to the alternate register set and stack the pointer",
        "33cc": "to the next literal.",
        "33ce": "Switch over the result pointer and the next literal",
        "33cf": "Save #REGbc briefly.",
        "33d0": "The first literal is put into #REGa and divided by &40",
        "33d1": "to give the integer values 0, 1, 2 or 3.",
        "33d5": "The integer value is transferred to #REGc and",
        "33d6": "incremented, thereby giving the range 1, 2, 3 or 4 for",
        "33d7": "The literal is fetched anew, reduced mod &40 and",
        "33d8": "discarded as inappropriate if the remainder if zero; in",
        "33da": "which case the next literal is fetched and used",
        "33dc": "unreduced.",
        "33de": "The exponent, e, is formed by the addition of &50 and",
        "33e0": "passed to the calculator stack as the first of the five",
        "33e1": "The number of literals specified in #REGc are taken",
        "33e3": "from the source and entered into the bytes of the",
        "33e4": "result.",
        "33ea": "Restore #REGbc.",
        "33eb": "Return the result pointer to #REGhl and the next",
        "33ec": "literal pointer to its usual position in #REGhl'.",
        "33ef": "The number of zero bytes required at this stage is",
        "33f0": "given by 5-#REGc-1, and this number of zeros is added to",
        "33f1": "the result to make up the required five bytes.",
        "33f7": "The subroutine returns if the parameter is zero, or",
        "33f8": "when the requested constant has been reached.",
        "33f9": "Save the parameter.",
        "33fa": "Save the result pointer.",
        "33fb": "The dummy address.",
        "33fe": "Perform imaginary stacking of an expanded constant.",
        "3401": "Restore the result pointer.",
        "3402": "Restore the parameter.",
        "3403": "Count the loops.",
        "3404": "Jump back to consider the value of the counter.",
        "3406": "Copy the parameter to #REGc.",
        "3407": "Double the parameter.",
        "3408": "Double the result.",
        "3409": "Add the value of the parameter to give five times the",
        "340a": "This result is wanted in the #REGbc register pair.",
        "340d": "Produce the new base address.",
        "340e": "Finished.",
        "340f": "Save the result pointer.",
        "3410": "Fetch the pointer to the current memory area",
        "3413": "The base address is found.",
        "3416": "The five bytes are moved.",
        "3419": "Set the result pointer.",
        "341a": "Finished.",
        "341b": "Set #REGhl to hold the result pointer.",
        "341d": "Go to the alternate register set and save the next",
        "341e": "literal pointer.",
        "341f": "The base address of the calculator's #R$32C5(table of",
        "3422": "Back to the main set of registers.",
        "3423": "Find the requested base address.",
        "3426": "Expand the constant.",
        "3429": "Restore the next literal pointer.",
        "342c": "Finished.",
        "342d": "Save the result pointer.",
        "342e": "Source to #REGde briefly.",
        "342f": "Fetch the pointer to the current memory area",
        "3432": "The base address is found.",
        "3435": "Exchange source and destination pointers.",
        "3436": "The five bytes are moved.",
        "3439": "'Last value'+5, i.e. , to #REGde.",
        "343a": "Result pointer to #REGhl.",
        "343b": "Finished.",
        "343c": "There are five bytes involved.",
        "343e": "Each byte of the second number.",
        "343f": "Each byte of the first number.",
        "3440": "Switch source and destination.",
        "3441": "Now to the first number.",
        "3442": "Now to the second number.",
        "3443": "Move to consider the next pair of bytes.",
        "3445": "Exchange the five bytes.",
        "3447": "Get the pointers correct as 5 is an odd number.",
        "3448": "Finished.",
        "3449": "Move the parameter to #REGb.",
        "344a": "In effect a RST #o28 instruction but sets the counter.",
        "344d": "#R$33C0: Z, Z",
        "344e": "#R$3014: 2*Z",
        "344f": "#R$342D(st_mem_0): 2*Z (mem-0 holds 2*Z)",
        "3450": "#R$33A1: -",
        "3451": "#R$341B(stk_zero): 0",
        "3452": "#R$342D(st_mem_2): 0 (mem-2 holds 0)",
        "3453": "#R$33C0: B(R), B(R)",
        "3454": "#R$340F(get_mem_0): B(R), B(R), 2*Z",
        "3455": "#R$30CA: B(R), 2*B(R)*Z",
        "3456": "#R$340F(get_mem_2): B(R),2*B(R)*Z, B(R-1)",
        "3457": "#R$342D(st_mem_1): mem-1 holds B(R-1)",
        "3458": "#R$300F: B(R), 2*B(R)*Z-B(R-1)",
        "3459": "#R$369B",
        "345a": "B(R), 2*B(R)*Z-B(R-1), A(R+1)",
        "3460": "#R$3014: B(R), 2*B(R)*Z-B(R-1)+A(R+1)",
        "3461": "#R$343C: 2*B(R)*Z-B(R-1)+A(R+1), B(R)",
        "3462": "#R$342D(st_mem_2): mem-2 holds B(R)",
        "3463": "#R$33A1: 2*B(R)*Z-B(R-1)+A(R+1)=B(R+1)",
        "3464": "#R$367A to #R$3453: B(R+1)",
        "3466": "#R$340F(get_mem_1): B(N), B(N-2)",
        "3467": "#R$300F: B(N)-B(N-2)",
        "3468": "#R$369B",
        "3469": "Finished.",
        "346a": "#REGb is set to &FF.",
        "346c": "The jump is made into 'unary minus'.",
        "346e": "If the number is zero, the subroutine returns leaving",
        "3471": "00 00 00 00 00 unchanged.",
        "3472": "#REGb is set to &00 for 'negate'.",
        "3474": "If the first byte is zero, the jump is made to deal",
        "3475": "with a 'small integer'.",
        "3478": "Point to the second byte.",
        "3479": "Get &FF for 'abs', &00 for 'negate'.",
        "347a": "Now &80 for 'abs', &00 for 'negate'.",
        "347c": "This sets bit 7 for 'abs', but changes nothing for",
        "347d": "Now bit 7 is changed, leading to bit 7 of byte 2 reset",
        "347e": "for 'abs', and simply changed for 'negate'.",
        "3480": "The new second byte is stored.",
        "3481": "#REGhl points to the first byte again.",
        "3482": "Finished.",
        "3483": "Save  in #REGde.",
        "3484": "Save pointer to the number in #REGhl.",
        "3485": "Fetch the sign in #REGc, the number in #REGde.",
        "3488": "Restore the pointer to the number in #REGhl.",
        "3489": "Get &FF for 'abs', &00 for 'negate'.",
        "348a": "Now &FF for 'abs', no change for 'negate'.",
        "348b": "Now &00 for 'abs', and a changed byte for 'negate';",
        "348c": "store it in #REGc.",
        "348d": "Store result on the stack.",
        "3490": "Return  to #REGde.",
        "3492": "If X is zero, just return with zero as the 'last",
        "3495": "value'.",
        "3496": "Save the pointer to .",
        "3497": "Store 1 in #REGde.",
        "349a": "Point to the second byte of X.",
        "349b": "Rotate bit 7 into the carry flag.",
        "349d": "Point to the destination again.",
        "349e": "Set #REGc to zero for positive X and to &FF for",
        "349f": "negative X.",
        "34a0": "Stack 1 or -1 as required.",
        "34a3": "Restore the pointer to .",
        "34a4": "Finished.",
        "34a5": "The 'last value', X, is compressed into #REGbc.",
        "34a8": "The signal is received.",
        "34aa": "Jump to stack the result.",
        "34ac": "Evaluate the 'last value', rounded to the nearest",
        "34af": "Fetch the required byte.",
        "34b0": "Exit by jumping to #R$2D28.",
        "34b3": "Evaluate the 'last value', rounded to the nearest",
        "34b6": "Make the return address be that of the subroutine",
        "34b9": "#R$2D2B.",
        "34ba": "Make an indirect jump to the required location.",
        "34bc": "Fetch the parameters of the string X$.",
        "34bf": "Decrease the length by 1 to test it.",
        "34c0": "If the length was not 1, then jump to give error report",
        "34c1": "A.",
        "34c4": "Fetch the single code of the string.",
        "34c5": "Does it denote a letter?",
        "34c8": "If so, jump to gets its address.",
        "34ca": "Reduce range for actual user-defined graphics to 0-20.",
        "34cc": "Give report A if out of range.",
        "34ce": "Test the range again.",
        "34d0": "Give report A if out of range.",
        "34d2": "Make range of user-defined graphics 1 to 21, as for 'a'",
        "34d3": "Now make the range 0 to 20 in each case.",
        "34d4": "Multiply by 8 to get an offset for the address.",
        "34d7": "Test the range of the offset.",
        "34d9": "Give report A if out of range.",
        "34db": "Fetch the address of the first user-defined graphic",
        "34df": "Add #REGc to the offset.",
        "34e0": "Store the result back in #REGc.",
        "34e1": "Jump if there is no carry.",
        "34e3": "Increment #REGb to complete the address.",
        "34e4": "Jump to stack the address.",
        "34e7": "Call the error handling routine.",
        "34e9": "Save #REGhl on the stack.",
        "34ea": "Save #REGbc on the stack.",
        "34eb": "Save the value of #REGa in #REGb.",
        "34ec": "Get the first byte.",
        "34ed": "Point to the second byte.",
        "34ee": "'#S/OR/' the first byte with the second.",
        "34ef": "Point to the third byte.",
        "34f0": "'#S/OR/' the result with the third byte.",
        "34f1": "Point to the fourth byte.",
        "34f2": "'#S/OR/' the result with the fourth byte.",
        "34f3": "Restore the original value of #REGa.",
        "34f4": "And of #REGbc.",
        "34f5": "Restore the pointer to the number to #REGhl.",
        "34f6": "Return with carry reset if any of the four bytes was",
        "34f7": "Set the carry flag to indicate that the number was",
        "34f8": "zero, and return.",
        "34f9": "Is the 'last-value' zero?",
        "34fc": "If so, return.",
        "34fd": "Jump forward to #R$3506 but signal the opposite action",
        "34ff": "is needed.",
        "3501": "The carry flag will be set only if the 'last value' is",
        "3504": "Jump forward.",
        "3506": "Clear the #REGa register.",
        "3507": "Point to the sign byte.",
        "3508": "The carry is reset for a positive number and set for a",
        "3509": "negative number; when entered from #R$34F9 the opposite",
        "350a": "sign goes to the carry.",
        "350b": "Save the result pointer.",
        "350c": "Clear #REGa without disturbing the carry.",
        "350e": "Set the first byte to zero.",
        "350f": "Point to the second byte.",
        "3510": "Set the second byte to zero.",
        "3511": "Point to the third byte.",
        "3512": "Rotate the carry into #REGa, making #REGa one if the",
        "3513": "Set the third byte to one or zero.",
        "3514": "Ensure that #REGa is zero again.",
        "3515": "Point to the fourth byte.",
        "3516": "Set the fourth byte to zero.",
        "3517": "Point to the fifth byte.",
        "3518": "Set the fifth byte to zero.",
        "3519": "Restore the result pointer.",
        "351b": "Point #REGhl at Y, the second number.",
        "351c": "Test whether Y is zero.",
        "351f": "Restore the pointers.",
        "3520": "Return if Y was zero; X is now the 'last value'.",
        "3521": "Set the carry flag and jump back to set the 'last",
        "3522": "value' to 1.",
        "3524": "Point #REGhl at Y, #REGde at X.",
        "3525": "Test whether Y is zero.",
        "3528": "Swap the pointers back.",
        "3529": "Return with X as the 'last value' if Y was non-zero.",
        "352a": "Reset the carry flag and jump back to set the 'last",
        "352b": "value' to zero.",
        "352d": "Point #REGhl at Y, #REGde at X$.",
        "352e": "Test whether Y is zero.",
        "3531": "Swap the pointers back.",
        "3532": "Return with X$ as the 'last value' if Y was non-zero.",
        "3533": "Save the pointer to the number.",
        "3534": "Point to the fifth byte of the string parameters, i.e.",
        "3535": "Clear the #REGa register.",
        "3536": "Length-high is now set to zero.",
        "3537": "Point to length-low.",
        "3538": "Length-low is now set to zero.",
        "3539": "Restore the pointer.",
        "353a": "Return with the string parameters being the 'last",
        "353b": "The single offset goes to the #REGa register.",
        "353c": "The range is now &01 to &06 and &09 to &0E.",
        "353e": "This range is changed to &00, &01, &02, &04, &05, &06,",
        "3540": "&08, &09, &0A, &0C, &0D, &0E.",
        "3543": "Then reduced to &00 to &07 with carry set for 'greater",
        "3544": "than or equal to' and 'less than'; the operations with",
        "3546": "carry set are then treated as their complementary",
        "3547": "operation once their values have been exchanged.",
        "354e": "The numerical comparisons are now separated from the",
        "3550": "string comparisons by testing bit 2.",
        "3552": "The numerical operations now have the range &00 to &01",
        "3553": "Save the offset.",
        "3554": "The numbers are subtracted for the final tests.",
        "3559": "The string comparisons now have the range &02 to &03",
        "355a": "Save the offset.",
        "355b": "The lengths and starting addresses of the strings are",
        "355e": "fetched from the calculator stack.",
        "3563": "The length of the second string.",
        "3568": "Jump unless the second string is null.",
        "356b": "Here the second string is either null or less than the",
        "356f": "The carry is complemented to give the correct test",
        "3570": "results.",
        "3572": "Here the carry is used as it stands.",
        "3576": "The first string is now null, the second not.",
        "3578": "Neither string is null, so their next bytes are",
        "3579": "compared.",
        "357a": "Jump if the first byte is less.",
        "357c": "Jump if the second byte is less.",
        "357e": "The bytes are equal; so the lengths are decremented and",
        "357f": "a jump is made to #R$3564 to compare the next bytes of",
        "3580": "the reduced strings.",
        "3587": "The carry is cleared here for the correct test results.",
        "3588": "For the string tests, a zero is put on to the",
        "3589": "calculator stack.",
        "358a": "#R$341B(stk_zero)",
        "358b": "#R$369B",
        "358c": "These three tests, called as needed, give the correct",
        "358d": "results for all twelve comparisons. The initial carry is",
        "358e": "set for 'not equal' and 'equal', and the final carry is",
        "3591": "set for 'greater than', 'less than' and 'equal'.",
        "359b": "Finished.",
        "359c": "The parameters of the second string are fetched and",
        "359f": "saved.",
        "35a1": "The parameters of the first string are fetched.",
        "35a4": "The lengths are now in #REGhl and #REGbc.",
        "35a6": "The parameters of the first string are saved.",
        "35a8": "The total length of the two strings is calculated and",
        "35a9": "passed to #REGbc.",
        "35ab": "Sufficient room is made available.",
        "35ac": "The parameters of the new string are passed to the",
        "35af": "The parameters of the first string are retrieved and",
        "35b0": "the string copied to the work space as long as it is not",
        "35b1": "a null string.",
        "35b7": "Exactly the same procedure is followed for the second",
        "35b8": "string thereby giving 'A$+B$'.",
        "35bf": "Fetch the current value of .",
        "35c2": "Set #REGde to -5, two's complement.",
        "35c5": "Stack the value for .",
        "35c6": "Calculate -5.",
        "35c7": "#REGde now holds  and #REGhl holds",
        "35c9": "The 'last value' is compressed into the #REGa register.",
        "35cc": "Give the error report if X is greater than 255, or X is",
        "35ce": "a negative number.",
        "35d0": "Save the compressed value of X.",
        "35d1": "Make one space available in the work space.",
        "35d5": "Fetch the value.",
        "35d6": "Copy the value to the work space.",
        "35d7": "Pass the parameters of the new string to the calculator",
        "35da": "Reset the pointers.",
        "35db": "Finished.",
        "35dc": "Call the error handling routine.",
        "35de": "The current value of  is preserved on",
        "35e1": "the machine stack.",
        "35e2": "The 'offset' for 'val' or 'val$' must be in the #REGb",
        "35e3": "Produce &00 and carry set for 'val', &FB and carry",
        "35e5": "Produce &FF (bit 6 therefore set) for 'val', but &00",
        "35e6": "Save this 'flag' on the machine stack.",
        "35e7": "The parameters of the string are fetched; the starting",
        "35ea": "address is saved; one byte is added to the length and",
        "35eb": "room made available for the string (+1) in the work",
        "35ec": "space.",
        "35ed": "The starting address of the string goes to #REGhl as a",
        "35ee": "The pointer to the first new space goes to",
        "35f2": " and to the machine stack.",
        "35f3": "The string is copied to the work space, together with",
        "35f5": "Switch the pointers.",
        "35f6": "The extra byte is replaced by a 'carriage return'",
        "35f7": "character.",
        "35f9": "The syntax flag (bit 7 of ) is reset and",
        "35fd": "the string is scanned for correct syntax.",
        "3600": "The character after the string is fetched.",
        "3601": "A check is made that the end of the expression has been",
        "3603": "If not, the error is reported.",
        "3605": "The starting address of the string is fetched.",
        "3606": "The 'flag' for 'val/val$' is fetched and bit 6 is",
        "3607": "compared with bit 6 of the result () of",
        "360a": "the syntax scan.",
        "360c": "Report the error if they do not match.",
        "360f": "Start address to  again.",
        "3612": "The flag (bit 7 of ) is set for line",
        "3616": "The string is treated as a 'next expression' and a",
        "3619": "The original value of  is restored.",
        "361d": "The subroutine exits via #R$35BF which resets the",
        "361f": "One space is made in the work space and its address is",
        "3622": "copied to , the address of the cursor.",
        "3626": "This address is saved on the stack too.",
        "3627": "The current channel address () is saved",
        "362a": "on the machine stack.",
        "362b": "Channel 'R' is opened, allowing the string to be",
        "362d": "'printed' out into the work space.",
        "3630": "The 'last value', X, is now printed out in the work",
        "3633": "Restore  to #REGhl and restore the flags",
        "3634": "that are appropriate to it.",
        "3637": "Restore the start address of the string.",
        "3638": "Now the cursor address is one past the end of the",
        "363b": "string and hence the difference is the length.",
        "363e": "Transfer the length to #REGbc.",
        "3640": "Pass the parameters of the new string to the calculator",
        "3643": "Reset the pointers.",
        "3644": "Finished.",
        "3645": "The numerical parameter is compressed into the #REGa",
        "3648": "Is it smaller than 16?",
        "364a": "If not, report the error.",
        "364d": "The current channel address () is saved",
        "3650": "on the machine stack.",
        "3651": "The channel specified by the parameter is opened.",
        "3654": "The signal is now accepted, like a 'key-value'.",
        "3657": "The default length of the resulting string is zero.",
        "365a": "Jump if there was no signal.",
        "365c": "Set the length to 1 now.",
        "365d": "Make a space in the work space.",
        "365e": "Put the string into it.",
        "365f": "Pass the parameters of the string to the calculator",
        "3662": "Restore  and the appropriate flags.",
        "3666": "Exit, setting the pointers.",
        "3669": "The parameters of the string are fetched.",
        "366c": "The length is tested and the #REGa register holding",
        "366d": "zero is carried forward if A$ is a null string.",
        "3670": "The code of the first character is put into #REGa",
        "3671": "The subroutine exits via #R$2D28 which gives the correct",
        "3674": "The parameters of the string are fetched.",
        "3677": "The subroutine exits via #R$2D2B which gives the correct",
        "367a": "Go to the alternative register set and save the next",
        "367b": "literal pointer on the machine stack.",
        "367c": "Make #REGhl point to .",
        "367f": "Decrease .",
        "3680": "Restore the next literal pointer.",
        "3681": "The jump is made on non-zero.",
        "3683": "The next literal is passed over.",
        "3684": "Return to the main register set.",
        "3685": "Finished.",
        "3686": "Go to the next alternate register set.",
        "3687": "The next literal (jump length) is put in the #REGe'",
        "3688": "The number &00 or &FF is formed in #REGa according as",
        "3689": "#REGe' is positive or negative, and is then copied to",
        "368a": "#REGd'.",
        "368c": "#REGhl' now holds the next literal pointer.",
        "368e": "Finished.",
        "368f": "Point to the third byte, which is zero or one.",
        "3691": "Collect this byte in the #REGa register.",
        "3692": "Point to the first byte once again.",
        "3694": "Test the third byte: is it zero?",
        "3695": "Make the jump if the byte is non-zero, i.e. if the",
        "3697": "Go to the alternate register set.",
        "3698": "Pass over the jump length.",
        "3699": "Back to the main set of registers.",
        "369a": "Finished.",
        "369b": "The return address to the calculator (#R$3365) is",
        "369c": "Instead, the address in #REGhl' is put on the machine",
        "369d": "stack and an indirect jump is made to it. #REGhl' will",
        "369e": "now hold any earlier address in the calculator chain of",
        "369f": "Finished.",
        "36a0": "N, M",
        "36a1": "#R$342D(st_mem_0): N, M (mem-0 holds M)",
        "36a2": "#R$33A1: N",
        "36a3": "#R$33C0: N, N",
        "36a4": "#R$340F(get_mem_0): N, N, M",
        "36a5": "#R$31AF: N, N/M",
        "36a6": "#R$36AF: N, INT (N/M)",
        "36a7": "#R$340F(get_mem_0): N, INT (N/M), M",
        "36a8": "#R$343C: N, M, INT (N/M)",
        "36a9": "#R$342D(st_mem_0): N, M, INT (N/M) (mem-0 holds INT",
        "36aa": "#R$30CA: N, M*INT (N/M)",
        "36ab": "#R$300F: N-M*INT (N/M)",
        "36ac": "#R$340F(get_mem_0): N-M*INT (N/M), INT (N/M)",
        "36ad": "#R$369B",
        "36ae": "Finished.",
        "36af": "X",
        "36b0": "#R$33C0: X, X",
        "36b1": "#R$3506: X, (1/0)",
        "36b2": "#R$368F to #R$36B7: X",
        "36b4": "#R$3214: I(X)",
        "36b5": "#R$369B",
        "36b6": "Finished.",
        "36b7": "#R$33C0: X, X",
        "36b8": "#R$3214: X, I(X)",
        "36b9": "#R$342D(st_mem_0): X, I(X) (mem-0 holds I(X))",
        "36ba": "#R$300F: X-I(X)",
        "36bb": "#R$340F(get_mem_0): X-I(X), I(X)",
        "36bc": "#R$343C: I(X), X-I(X)",
        "36bd": "#R$3501: I(X), (1/0)",
        "36be": "#R$368F to #R$36C2: I(X)",
        "36c0": "#R$341B(stk_one): I(X), 1",
        "36c1": "#R$300F: I(X)-1",
        "36c2": "#R$369B: I(X) or I(X)-1",
        "36c4": "X",
        "36c5": "#R$3297: X (in full floating-point form)",
        "36c6": "#R$33C6: X, 1/LN 2",
        "36cc": "#R$30CA: X/LN 2=Y",
        "36cd": "#R$33C0: Y, Y",
        "36ce": "#R$36AF: Y, INT Y=N",
        "36cf": "#R$342D(st_mem_3): Y, N (mem-3 holds N)",
        "36d0": "#R$300F: Y-N=W",
        "36d1": "#R$33C0: W, W",
        "36d2": "#R$3014: 2*W",
        "36d3": "#R$341B(stk_one): 2*W, 1",
        "36d4": "#R$300F: 2*W-1=Z",
        "36d5": "#R$3449(series_08): Z",
        "36f7": "#R$340F(get_mem_3): 2**W, N",
        "36f8": "#R$369B",
        "36f9": "The absolute value of N mod 256 is put into",
        "36fc": "Jump forward if N was negative.",
        "36fe": "Error if ABS N>&FF.",
        "3700": "Now add ABS N to the exponent.",
        "3701": "Jump unless e>&FF.",
        "3703": "Call the error handling routine.",
        "3705": "The result is to be zero if N<-255.",
        "3707": "Subtract ABS N from the exponent as N was",
        "3708": "Zero result if e less than zero.",
        "370a": "Minus e is changed to e.",
        "370c": "The exponent, e, is entered.",
        "370d": "Finished: 'last value' is EXP X.",
        "370e": "Use the calculator to make the 'last value'",
        "370f": "#R$33A1 (the stack is now empty)",
        "3710": "#R$341B(stk_zero): 0",
        "3711": "#R$369B",
        "3712": "Finished, with EXP X=0.",
        "3713": "X",
        "3714": "#R$3297: X (in full floating-point form)",
        "3715": "#R$33C0: X, X",
        "3716": "#R$34F9: X, (1/0)",
        "3717": "#R$368F to #R$371C: X",
        "3718": "#R$30CA: X",
        "3719": "#R$369B: X",
        "371a": "Call the error handling routine.",
        "371c": "#R$341B(stk_zero): X, 0 (the deleted 1 is",
        "371d": "#R$33A1: X",
        "371e": "#R$369B: X",
        "371f": "The exponent, e, goes into #REGa.",
        "3720": "X is reduced to X'.",
        "3722": "The stack holds: X', e.",
        "3725": "X', e",
        "3726": "#R$33C6: X', e, 128",
        "3729": "#R$300F: X', e'",
        "372a": "#R$343C: e', X'",
        "372b": "#R$33C0: e', X', X'",
        "372c": "#R$33C6: e', X', X', 0.8",
        "3732": "#R$300F: e', X', X'-0.8",
        "3733": "#R$34F9: e', X', (1/0)",
        "3734": "#R$368F to #R$373D: e', X'",
        "3736": "#R$343C: X', e'",
        "3737": "#R$341B(stk_one): X', e', 1",
        "3738": "#R$300F: X', e'-1",
        "3739": "#R$343C: e'-1, X'",
        "373a": "#R$369B",
        "373b": "Double X' to give 2*X'.",
        "373c": "e'-1, 2*X'",
        "373d": "#R$343C: X', e' (X'>0.8) or 2*X', e'-1",
        "373e": "#R$33C6: X', e', LN 2 or 2*X', e'-1, LN 2",
        "3744": "#R$30CA: X', e'*LN 2=Y1 or 2*X', (e'-1)*LN",
        "3745": "#R$343C: Y1, X' (X'>0.8) or Y2, 2*X'",
        "3746": "#R$341B(stk_half): Y1, X', .5 or Y2, 2*X', .5",
        "3747": "#R$300F: Y1, X'-.5 or Y2, 2*X'-.5",
        "3748": "#R$341B(stk_half): Y1, X'-.5, .5 or Y2,",
        "3749": "#R$300F: Y1, X'-1 or Y2, 2*X'-1",
        "374a": "#R$33C0: Y, X'-1, X'-1 or Y2, 2*X'-1, 2*X'-1",
        "374b": "#R$33C6: Y1, X'-1, X'-1, 2.5 or Y2, 2*X'-1,",
        "374c": "2*X'-1, 2.5",
        "374e": "#R$30CA: Y1, X'-1, 2.5*X'-2.5 or Y2, 2*X'-1,",
        "374f": "#R$341B(stk_half): Y1, X'-1, 2.5*X'-2.5, .5",
        "3750": "#R$300F: Y1, X'-1, 2.5*X'-3=Z or Y2, 2*X'-1,",
        "3751": "#R$3449(series_0C): Y1, X'-1, Z or Y2,",
        "377f": "#R$30CA: Y1=LN (2**e'), LN X' or Y2=LN",
        "3780": "#R$3014: LN (2**e')*X')=LN X or LN",
        "3781": "#R$369B: LN X",
        "3782": "Finished: 'last value' is LN X.",
        "3783": "X",
        "3784": "#R$3297: X (in full floating-point form)",
        "3785": "#R$33C6: X, 1/2#pi",
        "378b": "#R$30CA: X/2#pi",
        "378c": "#R$33C0: X/2#pi, X/2#pi",
        "378d": "#R$341B(stk_half): X/2#pi, X/2#pi, 0.5",
        "378e": "#R$3014: X/2#pi, X/2#pi+0.5",
        "378f": "#R$36AF: X/2#pi, INT (X/2#pi+0.5)",
        "3790": "#R$300F: X/2#pi-INT (X/2#pi+0.5)=Y",
        "3791": "#R$33C0: Y, Y",
        "3792": "#R$3014: 2*Y",
        "3793": "#R$33C0: 2*Y, 2*Y",
        "3794": "#R$3014: 4*Y",
        "3795": "#R$33C0: 4*Y, 4*Y",
        "3796": "#R$346A: 4*Y, ABS (4*Y)",
        "3797": "#R$341B(stk_one): 4*Y, ABS (4*Y), 1",
        "3798": "#R$300F: 4*Y, ABS (4*Y)-1=Z",
        "3799": "#R$33C0: 4*Y, Z, Z",
        "379a": "#R$34F9: 4*Y, Z, (1/0)",
        "379b": "#R$342D(st_mem_0): (mem-0 holds the result of",
        "379c": "#R$368F to #R$37A1: 4*Y, Z",
        "379e": "#R$33A1: 4*Y",
        "379f": "#R$369B: 4*Y=V (case i)",
        "37a0": "Finished.",
        "37a1": "#R$341B(stk_one): 4*Y, Z, 1",
        "37a2": "#R$300F: 4*Y, Z-1",
        "37a3": "#R$343C: Z-1, 4*Y",
        "37a4": "#R$3506: Z-1, (1/0)",
        "37a5": "#R$368F to #R$37A8: Z-1",
        "37a7": "#R$346E: 1-Z",
        "37a8": "#R$369B: 1-Z=V (case ii) or Z-1=V (case iii)",
        "37a9": "Finished.",
        "37aa": "X",
        "37ab": "#R$3783: V",
        "37ac": "#R$346A: ABS V",
        "37ad": "#R$341B(stk_one): ABS V, 1",
        "37ae": "#R$300F: ABS V-1",
        "37af": "#R$340F(get_mem_0): ABS V-1, (1/0)",
        "37b0": "#R$368F to #R$37B7: ABS V-1=W",
        "37b2": "#R$346E: 1-ABS V",
        "37b3": "#R$3686 to #R$37B7: 1-ABS V=W",
        "37b5": "X",
        "37b6": "#R$3783: W",
        "37b7": "#R$33C0: W, W",
        "37b8": "#R$33C0: W, W, W",
        "37b9": "#R$30CA: W, W*W",
        "37ba": "#R$33C0: W, W*W, W*W",
        "37bb": "#R$3014: W, 2*W*W",
        "37bc": "#R$341B(stk_one): W, 2*W*W, 1",
        "37bd": "#R$300F: W, 2*W*W-1=Z",
        "37be": "#R$3449(series_06): W, Z",
        "37d7": "#R$30CA: SIN (#pi*W/2)=SIN X (or COS X)",
        "37d8": "#R$369B",
        "37d9": "Finished: 'last value'=SIN X (or COS X).",
        "37da": "X",
        "37db": "#R$33C0: X, X",
        "37dc": "#R$37B5: X, SIN X",
        "37dd": "#R$343C: SIN X, X",
        "37de": "#R$37AA: SIN X, COS X",
        "37df": "#R$31AF: SIN X/COS X=TAN X (report arithmetic overflow",
        "37e0": "#R$369B: TAN X",
        "37e1": "Finished: 'last value'=TAN X.",
        "37e2": "Use the full floating-point form of X.",
        "37e5": "Fetch the exponent of X.",
        "37e6": "Jump forward for case i: Y=X.",
        "37ea": "X",
        "37eb": "#R$341B(stk_one): X, 1",
        "37ec": "#R$346E: X, -1",
        "37ed": "#R$343C: -1, X",
        "37ee": "#R$31AF: -1/X",
        "37ef": "#R$33C0: -1/X, -1/X",
        "37f0": "#R$3506: -1/X, (1/0)",
        "37f1": "#R$341B(stk_pi_2): -1/X, (1/0), #pi/2",
        "37f2": "#R$343C: -1/X, #pi/2, (1/0)",
        "37f3": "#R$368F to #R$37FA for case ii: -1/X, #pi/2",
        "37f5": "#R$346E: -1/X, -#pi/2",
        "37f6": "#R$3686 to #R$37FA for case iii: -1/X,",
        "37f7": "-#pi/2",
        "37f9": "#R$341B(stk_zero): Y, 0; continue for case i:",
        "37fa": "#R$343C: W, Y",
        "37fb": "#R$33C0: W, Y, Y",
        "37fc": "#R$33C0: W, Y, Y, Y",
        "37fd": "#R$30CA: W, Y, Y*Y",
        "37fe": "#R$33C0: W, Y, Y*Y, Y*Y",
        "37ff": "#R$3014: W, Y, 2*Y*Y",
        "3800": "#R$341B(stk_one): W, Y, 2*Y*Y, 1",
        "3801": "#R$300F: W, Y, 2*Y*Y-1=Z",
        "3802": "#R$3449(series_0C): W, Y, Z",
        "382f": "#R$30CA: W, ATN X (case i) or W, ATN (-1/X)",
        "3830": "#R$3014: ATN X (all cases now)",
        "3831": "#R$369B",
        "3832": "Finished: 'last value'=ATN X.",
        "3833": "X",
        "3834": "#R$33C0: X, X",
        "3835": "#R$33C0: X, X, X",
        "3836": "#R$30CA: X, X*X",
        "3837": "#R$341B(stk_one): X, X*X, 1",
        "3838": "#R$300F: X, X*X-1",
        "3839": "#R$346E: X, 1-X*X",
        "383a": "#R$384A: X, SQR (1-X*X)",
        "383b": "#R$341B(stk_one): X, SQR (1-X*X), 1",
        "383c": "#R$3014: X, 1+SQR (1-X*X)",
        "383d": "#R$31AF: X/(1+SQR (1-X*X))=TAN (Y/2)",
        "383e": "#R$37E2: Y/2",
        "383f": "#R$33C0: Y/2, Y/2",
        "3840": "#R$3014: Y=ASN X",
        "3841": "#R$369B",
        "3842": "Finished: 'last value'=ASN X.",
        "3843": "X",
        "3844": "#R$3833: ASN X",
        "3845": "#R$341B(stk_pi_2): ASN X, #pi/2",
        "3846": "#R$300F: ASN X-#pi/2",
        "3847": "#R$346E: #pi/2-ASN X=ACS X",
        "3848": "#R$369B",
        "3849": "Finished: 'last value'=ACS X.",
        "384a": "X",
        "384b": "#R$33C0: X, X",
        "384c": "#R$3501: X, (1/0)",
        "384d": "#R$368F to #R$386C: X",
        "384f": "#R$341B(stk_half): X, 0.5",
        "3850": "#R$369B",
        "3851": "X, Y",
        "3852": "#R$343C: Y, X",
        "3853": "#R$33C0: Y, X, X",
        "3854": "#R$3501: Y, X, (1/0)",
        "3855": "#R$368F to #R$385D: Y, X",
        "3857": "#R$3713: Y, LN X",
        "3858": "#R$30CA: Y*LN X",
        "3859": "#R$369B",
        "385a": "Exit via #R$36C4 to form EXP (Y*LN X).",
        "385d": "#R$33A1: Y",
        "385e": "#R$33C0: Y, Y",
        "385f": "#R$3501: Y, (1/0)",
        "3860": "#R$368F to #R$386A: Y",
        "3862": "#R$341B(stk_zero): Y, 0",
        "3863": "#R$343C: 0, Y",
        "3864": "#R$34F9: 0, (1/0)",
        "3865": "#R$368F to #R$386C: 0",
        "3867": "#R$341B(stk_one): 0, 1",
        "3868": "#R$343C: 1, 0",
        "3869": "#R$31AF: Exit via #R$31AF as dividing by zero gives",
        "386a": "#R$33A1: -",
        "386b": "#R$341B(stk_one): 1",
        "386c": "#R$369B: (1/0)",
        "386d": "Finished: 'last value' is 0 or 1.",
        "386e": "These locations are 'spare'. They all hold &FF.",
        "3d00": "#CHAR$3D00",
        "3d08": "#CHAR$3D08",
        "3d10": "#CHAR$3D10",
        "3d18": "#CHAR$3D18",
        "3d20": "#CHAR$3D20",
        "3d28": "#CHAR$3D28",
        "3d30": "#CHAR$3D30",
        "3d38": "#CHAR$3D38",
        "3d40": "#CHAR$3D40",
        "3d48": "#CHAR$3D48",
        "3d50": "#CHAR$3D50",
        "3d58": "#CHAR$3D58",
        "3d60": "#CHAR$3D60",
        "3d68": "#CHAR$3D68",
        "3d70": "#CHAR$3D70",
        "3d78": "#CHAR$3D78",
        "3d80": "#CHAR$3D80",
        "3d88": "#CHAR$3D88",
        "3d90": "#CHAR$3D90",
        "3d98": "#CHAR$3D98",
        "3da0": "#CHAR$3DA0",
        "3da8": "#CHAR$3DA8",
        "3db0": "#CHAR$3DB0",
        "3db8": "#CHAR$3DB8",
        "3dc0": "#CHAR$3DC0",
        "3dc8": "#CHAR$3DC8",
        "3dd0": "#CHAR$3DD0",
        "3dd8": "#CHAR$3DD8",
        "3de0": "#CHAR$3DE0",
        "3de8": "#CHAR$3DE8",
        "3df0": "#CHAR$3DF0",
        "3df8": "#CHAR$3DF8",
        "3e00": "#CHAR$3E00",
        "3e08": "#CHAR$3E08",
        "3e10": "#CHAR$3E10",
        "3e18": "#CHAR$3E18",
        "3e20": "#CHAR$3E20",
        "3e28": "#CHAR$3E28",
        "3e30": "#CHAR$3E30",
        "3e38": "#CHAR$3E38",
        "3e40": "#CHAR$3E40",
        "3e48": "#CHAR$3E48",
        "3e50": "#CHAR$3E50",
        "3e58": "#CHAR$3E58",
        "3e60": "#CHAR$3E60",
        "3e68": "#CHAR$3E68",
        "3e70": "#CHAR$3E70",
        "3e78": "#CHAR$3E78",
        "3e80": "#CHAR$3E80",
        "3e88": "#CHAR$3E88",
        "3e90": "#CHAR$3E90",
        "3e98": "#CHAR$3E98",
        "3ea0": "#CHAR$3EA0",
        "3ea8": "#CHAR$3EA8",
        "3eb0": "#CHAR$3EB0",
        "3eb8": "#CHAR$3EB8",
        "3ec0": "#CHAR$3EC0",
        "3ec8": "#CHAR$3EC8",
        "3ed0": "#CHAR$3ED0",
        "3ed8": "#CHAR$3ED8",
        "3ee0": "#CHAR$3EE0",
        "3ee8": "#CHAR$3EE8",
        "3ef0": "#CHAR$3EF0",
        "3ef8": "#CHAR$3EF8",
        "3f00": "#CHAR$3F00",
        "3f08": "#CHAR$3F08",
        "3f10": "#CHAR$3F10",
        "3f18": "#CHAR$3F18",
        "3f20": "#CHAR$3F20",
        "3f28": "#CHAR$3F28",
        "3f30": "#CHAR$3F30",
        "3f38": "#CHAR$3F38",
        "3f40": "#CHAR$3F40",
        "3f48": "#CHAR$3F48",
        "3f50": "#CHAR$3F50",
        "3f58": "#CHAR$3F58",
        "3f60": "#CHAR$3F60",
        "3f68": "#CHAR$3F68",
        "3f70": "#CHAR$3F70",
        "3f78": "#CHAR$3F78",
        "3f80": "#CHAR$3F80",
        "3f88": "#CHAR$3F88",
        "3f90": "#CHAR$3F90",
        "3f98": "#CHAR$3F98",
        "3fa0": "#CHAR$3FA0",
        "3fa8": "#CHAR$3FA8",
        "3fb0": "#CHAR$3FB0",
        "3fb8": "#CHAR$3FB8",
        "3fc0": "#CHAR$3FC0",
        "3fc8": "#CHAR$3FC8",
        "3fd0": "#CHAR$3FD0",
        "3fd8": "#CHAR$3FD8",
        "3fe0": "#CHAR$3FE0",
        "3fe8": "#CHAR$3FE8",
        "3ff0": "#CHAR$3FF0",
        "3ff8": "#CHAR$3FF8",
        "5c10": "Stream &FD (keyboard).",
        "5c12": "Stream &FE (screen).",
        "5c14": "Stream &FF (work space).",
        "5c16": "Stream &00 (keyboard).",
        "5c18": "Stream &01 (keyboard).",
        "5c1a": "Stream &02 (screen).",
        "5c1c": "Stream &03 (printer).",
        "5c1e": "Stream &04.",
        "5c20": "Stream &05.",
        "5c22": "Stream &06.",
        "5c24": "Stream &07.",
        "5c26": "Stream &08.",
        "5c28": "Stream &09.",
        "5c2a": "Stream &0A.",
        "5c2c": "Stream &0B.",
        "5c2e": "Stream &0C.",
        "5c30": "Stream &0D.",
        "5c32": "Stream &0E.",
        "5c34": "Stream &0F.",
        "5c7d": "x-coordinate",
        "5c7e": "y-coordinate",
        "5c8d": "FLASH 0: BRIGHT 0: PAPER 7: INK 0",
        "5c8f": "FLASH 0: BRIGHT 0: PAPER 7: INK 0",
        "5c92": "mem-0",
        "5c97": "mem-1",
        "5c9c": "mem-2",
        "5ca1": "mem-3",
        "5ca6": "mem-4",
        "5cab": "mem-5",
        "5cb6": "Keyboard.",
        "5cbb": "Screen.",
        "5cc0": "Work space.",
        "5cc5": "Printer.",
        "5cca": "End marker."
    },
    "stats": {
        "labels": 1172,
        "regions": 1081,
        "comments": 6997,
        "anchors": 0
    }
}