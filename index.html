<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ZX-M8XXX v0.6.3</title>
    <style>
        * { box-sizing: border-box; }
        
        /* Theme variables */
        :root {
            --bg-primary: #1a1a2e;
            --bg-secondary: #2a2a4a;
            --bg-button: #4a4a6a;
            --bg-button-hover: #5a5a7a;
            --bg-screen: #111;
            --text-primary: #eee;
            --text-secondary: #888;
            --accent: #ff6b6b;
            --accent-hover: #ff8080;
            --cyan: #4ecdc4;
        }
        
        body.light-theme {
            --bg-primary: #e8e8f0;
            --bg-secondary: #d0d0e0;
            --bg-button: #b0b0c0;
            --bg-button-hover: #9090a0;
            --bg-screen: #888;
            --text-primary: #222;
            --text-secondary: #555;
            --accent: #d04040;
            --accent-hover: #c03030;
            --cyan: #0a8a82;
        }
        body.light-theme .status {
            background: var(--bg-primary);
            border: 1px solid var(--bg-secondary);
        }
        body.light-theme .disasm-line.current {
            background: #ffe0b0;
        }
        body.light-theme .disasm-line.current.target {
            background: #d0d0d0;
        }
        body.light-theme .disasm-line.breakpoint.current {
            background: #ffc0a0;
        }
        body.light-theme .disasm-line.trace {
            background: #e8d0f0;
            border-left: 3px solid #a040a0;
        }
        body.light-theme .disasm-line.current.trace {
            background: #f0e0b8;
            border-left: 3px solid #a040a0;
        }
        body.light-theme .stack-entry.current {
            background: #c0f0c0;
            color: #060;
        }
        /* Light theme operand colors */
        body.light-theme .disasm-reg {
            color: #996600;
        }
        body.light-theme .disasm-num {
            color: #008800;
        }
        body.light-theme .disasm-char {
            color: #9933cc;
        }
        body.light-theme .disasm-bin {
            color: #336699;
        }
        body.light-theme .disasm-ptr {
            color: #666666;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            margin: 0;
            padding: 10px;
            min-height: 100vh;
            transition: background 0.3s, color 0.3s;
        }
        .container { max-width: 1090px; margin: 0 auto; }
        .main-layout { display: flex; flex-direction: column; }
        .emulator-section { flex-shrink: 0; }

        /* Landscape mode - side by side layout */
        @media (min-width: 1400px) {
            body { padding: 10px; }
            .container { max-width: none; margin: 0; position: relative; }
            .top-bar { margin-bottom: 10px; }
            .top-bar .theme-btn {
                position: absolute;
                top: 0px;
                right: -20px;
                left: auto;
                z-index: 10;
            }
            .top-bar #btnHelpFull {
                position: absolute;
                top: 0px;
                right: 60px;
                left: auto;
                z-index: 10;
            }
            .top-bar .app-name {
                position: absolute;
                top: 4px;
                right: 115px;
                left: auto;
                z-index: 10;
            }
            .main-layout {
                flex-direction: row;
                align-items: flex-start;
                gap: 20px;
            }
            .emulator-section {
                flex: 0 0 auto;
                position: relative;
            }
            .screen-container {
                margin-bottom: 4px;
            }
            .tab-container {
                flex: 1;
                min-width: 800px;
                position: relative;
                top: -40px;
                margin-bottom: -40px;
                margin-top: 0;
                margin-left: 60px;
            }
            .main-layout {
                gap: 10px;
            }
            .debugger-panel.open {
                max-height: calc(100vh - 50px);
                overflow-y: auto;
                overflow-x: hidden;
            }
            .main-debug-row {
                flex-wrap: nowrap;
            }
            .disasm-panel {
                height: 598px !important;
            }
            .memory-section.memory-panel {
                margin-top: 3px !important;
                flex: 1 !important;
                display: flex !important;
                flex-direction: column !important;
            }
            #memoryView {
                flex: 0 0 auto !important;
                height: 360px !important;
                max-height: 360px !important;
                min-height: 0 !important;
                overflow: hidden !important;
            }
            .right-column {
                height: 550px !important;
                flex: 0 0 auto !important;
                display: flex;
                flex-direction: column;
            }
            .breakpoint-list {
                max-height: 60px !important;
            }
            .labels-list {
                max-height: 80px !important;
            }
            .memory-search {
                border-top: none !important;
                margin-top: 0 !important;
                padding-top: 0 !important;
            }
            .memory-search.inline {
                margin-top: 10px !important;
            }
            .opcodes-container {
                height: calc(100vh - 80px) !important;
                min-height: 800px !important;
                max-height: none !important;
            }
            .graphics-container {
                max-height: calc(100vh - 100px) !important;
            }
            .graphics-dump-wrap {
                max-height: calc(100vh - 180px) !important;
            }
        }
        .top-bar {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 6px;
            flex-wrap: wrap;
        }
        .top-bar h1 { color: var(--accent); margin: 0; font-size: 1.3em; }
        .toolbar-select {
            padding: 6px 10px;
            font-size: 12px;
        }
        .toolbar-btn {
            padding: 6px 12px;
            font-size: 12px;
        }
        .top-bar .app-name {
            margin-left: auto;
            color: var(--text-secondary);
            font-size: 12px;
        }
        .version { color: var(--text-secondary); font-size: 0.9em; }
        .help-btn {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--bg-button);
            color: var(--text-secondary);
            border: none;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            padding: 0;
            line-height: 24px;
        }
        .help-btn:hover {
            background: var(--bg-button-hover);
            color: var(--text-primary);
        }
        .test-link {
            color: var(--text-secondary);
            font-size: 12px;
            text-decoration: none;
            padding: 4px 8px;
            background: var(--bg-button);
            border-radius: 3px;
        }
        .test-link:hover {
            background: var(--bg-button-hover);
            color: var(--text-primary);
        }
        .theme-btn {
            background: var(--bg-secondary);
            border: none;
            font-size: 16px;
            cursor: pointer;
            padding: 5px 10px;
            border-radius: 4px;
            margin-left: 10px;
            margin-right: 30px;
            color: inherit;
            outline: none;
            box-shadow: none;
            transition: none;
        }
        .theme-btn:hover {
            background: var(--bg-button-hover);
        }
        .screen-container {
            background: var(--bg-screen);
            padding: 6px;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            margin-bottom: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            overflow: auto;
            position: relative;
        }
        .screen-wrapper {
            position: relative;
            display: inline-block;
        }
        #screen {
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            cursor: crosshair;
            display: block;
        }
        #overlayCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 10;
        }
        .sprite-region-overlay {
            position: absolute;
            pointer-events: none;
            z-index: 20;
            border: 2px dashed #ff0000;
            background: rgba(255, 0, 0, 0.15);
            box-sizing: border-box;
            display: none;
        }
        .screen-info-popup {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 8px 12px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 11px;
            line-height: 1.5;
            z-index: 100;
            pointer-events: none;
            white-space: nowrap;
            border: 1px solid var(--cyan);
        }
        .screen-info-popup.hidden {
            display: none;
        }
        .screen-info-popup .info-label {
            color: var(--text-secondary);
        }
        .screen-info-popup .info-value {
            color: var(--cyan);
        }
        .screen-info-popup .info-dec {
            color: var(--text-secondary);
            font-size: 10px;
        }
        .controls {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 4px;
        }
        .controls button, .controls select {
            padding: 2px 10px;
            font-size: 13px;
            height: 26px;
        }
        button {
            background: var(--bg-button);
            color: var(--text-primary);
            border: none;
            padding: 4px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }
        button:hover { background: var(--bg-button-hover); }
        button:disabled { background: var(--bg-secondary); cursor: not-allowed; opacity: 0.5; }
        button.primary { background: var(--accent); }
        button.primary:hover { background: var(--accent-hover); }
        #btnRun { width: 90px; text-align: center; }
        .file-input { display: none; }
        select {
            background: var(--bg-button);
            color: var(--text-primary);
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
        }
        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 5px;
            background: var(--bg-button);
            padding: 2px 10px;
            border-radius: 4px;
            font-size: 13px;
            cursor: pointer;
            height: 26px;
        }
        .checkbox-label:hover { background: var(--bg-button-hover); }
        .checkbox-label input { cursor: pointer; }
        .zoom-btn {
            background: var(--bg-secondary);
            color: var(--text-secondary);
            border: none;
            padding: 2px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            margin-left: 3px;
            height: 26px;
        }
        .zoom-btn:hover { background: var(--bg-button); color: var(--text-primary); }
        .zoom-btn.active { background: var(--accent); color: #fff; }
        .zoom-group {
            margin-left: 10px;
            display: flex;
            align-items: center;
            gap: 3px;
            font-size: 12px;
        }
        #btnOverlay {
            min-width: 85px;  /* Fixed width for longest text "BeamScreen" */
            text-align: center;
        }
        .status {
            text-align: center;
            padding: 6px;
            background: var(--bg-secondary);
            border-radius: 4px;
            margin-bottom: 8px;
            font-family: monospace;
            border: none;
            box-shadow: none;
            outline: none;
            overflow: hidden;
        }
        .status-item { display: inline-block; margin: 0 15px; }
        .status-label { color: var(--text-secondary); }
        .status-value { color: var(--cyan); }
        .small-btn {
            padding: 2px 6px;
            font-size: 10px;
            margin-left: 5px;
            background: var(--bg-button);
            border: 1px solid var(--bg-button);
            color: var(--text-primary);
            border-radius: 3px;
            cursor: pointer;
        }
        .small-btn:hover { background: var(--accent); }

        /* Keyboard Help Modal */
        .help-modal {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }
        .help-modal.hidden { display: none; }
        .help-modal-content {
            background: var(--bg-secondary);
            padding: 20px 30px;
            border-radius: 8px;
            max-width: 450px;
            width: 90%;
        }
        .help-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .help-modal-header h3 { margin: 0; color: var(--cyan); }
        .help-modal-close {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        .help-modal-close:hover { color: var(--text-primary); }
        .help-modal table { width: 100%; border-collapse: collapse; }
        .help-modal td { padding: 5px 10px; border-bottom: 1px solid var(--bg-button); }
        .help-modal td:first-child { color: var(--accent); font-family: monospace; width: 120px; }
        .help-section-header { padding-top: 10px !important; color: var(--cyan) !important; font-weight: bold; }
        
        .message {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 25px;
            border-radius: 4px;
            animation: fadeIn 0.3s ease;
            z-index: 100;
        }
        .message.success { background: #2ecc71; }
        .message.error { background: #e74c3c; }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .drop-zone {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(78, 205, 196, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            font-size: 2em;
            z-index: 50;
        }
        .drop-zone.active { display: flex; }
        
        /* ROM Selection Modal */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }
        .modal-overlay.hidden { display: none; }
        .modal {
            background: var(--bg-secondary);
            padding: 30px;
            border-radius: 12px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }
        .modal h2 {
            margin-top: 0;
            color: var(--accent);
            text-align: center;
        }
        .modal p {
            color: var(--text-primary);
            line-height: 1.6;
        }
        .rom-section {
            margin: 20px 0;
            padding: 15px;
            background: var(--bg-primary);
            border-radius: 8px;
        }
        .rom-section h4 {
            margin: 0 0 10px 0;
            color: var(--cyan);
        }
        .rom-section .rom-status {
            font-size: 0.9em;
            color: var(--text-secondary);
            margin-top: 5px;
        }
        .rom-section .rom-status.loaded {
            color: #2ecc71;
        }
        .rom-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        .rom-buttons button {
            flex: 1;
        }
        .modal-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        .modal-actions button {
            flex: 1;
            padding: 12px;
        }
        .modal-actions button:disabled {
            opacity: 0.5;
        }
        .modal-hint {
            font-size: 0.85em;
            color: var(--text-secondary);
            margin-top: 15px;
            text-align: center;
        }

        /* Tab System */
        .tab-container {
            margin-top: 0;
        }
        .tab-container.collapsed .tab-content,
        .tab-container.collapsed .tab-content.active {
            display: none !important;
        }
        .tab-bar {
            display: flex;
            gap: 2px;
            background: var(--bg-primary);
            padding: 4px 4px 0 4px;
            border-radius: 6px 6px 0 0;
        }
        .tab-container.collapsed .tab-bar {
            border-radius: 6px;
            padding: 4px;
        }
        .tab-btn {
            padding: 8px 16px;
            background: var(--bg-button);
            border: none;
            border-radius: 6px 6px 0 0;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s;
        }
        .tab-container.collapsed .tab-btn {
            border-radius: 4px;
        }
        .tab-btn .arrow {
            margin-right: 6px;
            font-size: 10px;
            display: inline-block;
            transition: transform 0.2s;
        }
        .tab-btn.active .arrow {
            transform: rotate(90deg);
        }
        .tab-container.collapsed .tab-btn .arrow {
            transform: rotate(0deg);
        }
        .tab-btn:hover {
            background: var(--bg-button-hover);
            color: var(--text-primary);
        }
        .tab-btn.active {
            background: var(--bg-secondary);
            color: var(--cyan);
        }
        .tab-container.collapsed .tab-btn.active {
            background: var(--bg-button);
            color: var(--text-secondary);
        }
        .tab-content {
            display: none;
            background: var(--bg-secondary);
            border-radius: 0 6px 6px 6px;
            padding: 10px;
        }
        .tab-content.active {
            display: block;
        }

        /* Assembler Tab */
        .assembler-container {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 200px);
            min-height: 500px;
            max-height: 900px;
        }
        .assembler-header {
            display: flex;
            justify-content: flex-start;
            align-items: center;
            padding: 10px 15px;
            background: var(--bg-primary);
            border-radius: 4px;
            margin-bottom: 10px;
        }
        .assembler-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        .assembler-controls button {
            padding: 4px 10px;
            font-size: 11px;
        }
        .asm-option {
            font-size: 11px;
            color: var(--text-secondary);
            margin-left: 10px;
            cursor: pointer;
        }
        .asm-option input {
            margin-right: 4px;
        }
        .asm-option input[type="text"] {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: 2px 6px;
            font-family: monospace;
            font-size: 11px;
            width: 140px;
            margin-left: 4px;
        }
        .asm-option input[type="text"]::placeholder {
            color: var(--text-secondary);
            opacity: 0.6;
        }
        #asmDetectedDefines {
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            padding: 2px;
            font-family: monospace;
            font-size: 11px;
            margin-left: 6px;
            min-width: 100px;
            max-width: 200px;
            height: auto;
            max-height: 60px;
        }
        #asmDetectedDefines option {
            padding: 2px 4px;
            background-color: var(--bg-secondary);
            color: var(--text-primary);
        }
        #asmDetectedDefines option:checked {
            background-color: var(--accent);
            color: var(--bg-primary);
        }
        #asmDetectedDefines option:hover {
            background-color: var(--bg-button);
        }
        .assembler-body {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 6px;
            min-height: 0;
        }
        .asm-editor-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--bg-primary);
            border-radius: 4px;
            overflow: hidden;
            min-height: 0;
            transition: box-shadow 0.15s;
        }
        .asm-editor-container.drag-over {
            box-shadow: inset 0 0 0 3px var(--cyan);
        }
        .asm-line-numbers {
            padding: 10px 8px;
            background: var(--bg-button);
            color: var(--text-secondary);
            font-family: monospace;
            font-size: 12px;
            line-height: 1.4;
            text-align: right;
            user-select: none;
            min-width: 35px;
            overflow: hidden;
            white-space: pre;
        }
        .asm-editor-wrap {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        .asm-textarea {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 10px;
            margin: 0;
            border: none;
            resize: none;
            background: transparent;
            color: var(--text-primary);
            caret-color: var(--text-primary);
            font-family: monospace;
            font-size: 12px;
            line-height: 1.4;
            tab-size: 8;
            white-space: pre;
            overflow: auto;
            z-index: 2;
        }
        .asm-textarea.highlighting {
            color: transparent;
        }
        .asm-textarea::placeholder {
            color: var(--text-secondary);
        }
        .asm-highlight {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 10px;
            margin: 0;
            font-family: monospace;
            font-size: 12px;
            line-height: 1.4;
            tab-size: 8;
            white-space: pre;
            overflow: auto;
            pointer-events: none;
            z-index: 1;
            color: var(--text-primary);
            background: transparent;
        }
        .asm-output-container {
            flex: 0 0 auto;
            display: flex;
            flex-direction: column;
            background: var(--bg-primary);
            border-radius: 4px;
            min-height: 180px;
            max-height: 400px;
        }
        .asm-output-header {
            padding: 4px 10px;
            background: var(--bg-button);
            color: var(--cyan);
            font-size: 11px;
            font-weight: bold;
            border-radius: 4px 4px 0 0;
        }
        .asm-output {
            flex: 1;
            padding: 6px 10px;
            font-family: monospace;
            font-size: 11px;
            line-height: 1.4;
            overflow: auto;
            color: var(--text-primary);
        }
        .asm-output .asm-hint {
            color: var(--text-secondary);
            font-style: italic;
        }
        .asm-output .asm-status-line {
            font-weight: bold;
            margin-bottom: 6px;
            padding-bottom: 4px;
            border-bottom: 1px solid var(--bg-button);
        }
        .asm-output .asm-status-line.success {
            color: #80ff80;
        }
        .asm-output .asm-status-line.error {
            color: #ff8080;
        }
        .asm-output .asm-files-section {
            margin-top: 8px;
            padding: 6px 8px;
            background: var(--bg-secondary);
            border-radius: 4px;
        }
        .asm-output .asm-files-header {
            color: var(--cyan);
            font-weight: bold;
            margin-bottom: 4px;
        }
        .asm-output .asm-file-item {
            color: var(--text-primary);
            padding: 2px 0;
            font-family: monospace;
        }
        .asm-output .asm-file-item::before {
            content: '\2022 ';
            color: var(--text-secondary);
        }
        .asm-output .asm-file-details {
            color: var(--text-secondary);
        }
        .asm-output .asm-file-md5 {
            color: var(--cyan);
            font-size: 0.85em;
            opacity: 0.8;
        }
        .asm-output .asm-md5-pass {
            color: #80ff80;
            font-weight: bold;
        }
        .asm-output .asm-md5-fail {
            color: #ff8080;
            font-weight: bold;
        }
        .asm-output .asm-line {
            display: flex;
            gap: 10px;
        }
        .asm-output .asm-addr {
            color: var(--cyan);
            min-width: 40px;
        }
        .asm-output .asm-bytes {
            color: #80c0ff;
            min-width: 100px;
        }
        .asm-output .asm-source {
            color: var(--text-secondary);
        }
        .asm-output .asm-error {
            color: #ff8080;
        }
        .asm-output .asm-warning {
            color: #ffcc00;
        }
        .asm-output .asm-clickable {
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 2px;
        }
        .asm-output .asm-clickable:hover {
            background: rgba(255, 255, 255, 0.1);
            text-decoration: underline;
        }
        .asm-output .asm-label-def {
            color: var(--accent);
        }

        /* File tabs */
        .asm-file-tabs {
            display: flex;
            flex-wrap: nowrap;
            gap: 2px;
            padding: 4px 4px 0 4px;
            background: var(--bg-secondary);
            border-radius: 4px 4px 0 0;
            min-height: 28px;
            overflow-x: auto;
            overflow-y: hidden;
            scrollbar-width: thin;
        }
        .asm-file-tabs::-webkit-scrollbar {
            height: 4px;
        }
        .asm-file-tabs::-webkit-scrollbar-thumb {
            background: var(--bg-button);
            border-radius: 2px;
        }
        .asm-file-tabs:empty {
            display: none;
        }
        .asm-file-tab {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            background: var(--bg-button);
            border-radius: 4px 4px 0 0;
            font-size: 11px;
            cursor: pointer;
            max-width: 120px;
            min-width: 60px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex-shrink: 0;
        }
        .asm-file-tab .tab-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        /* Files dropdown */
        .asm-files-dropdown {
            position: relative;
            display: inline-block;
        }
        .asm-files-list {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: var(--bg-secondary);
            border: 1px solid var(--bg-button);
            border-radius: 4px;
            min-width: 375px;
            max-width: 600px;
            max-height: 400px;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        .asm-files-list.show {
            display: block;
        }
        .asm-files-list-item {
            padding: 6px 10px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
            border-bottom: 1px solid var(--bg-button);
        }
        .asm-files-list-item:last-child {
            border-bottom: none;
        }
        .asm-files-list-item:hover {
            background: var(--bg-button);
        }
        .asm-files-list-item.main {
            color: var(--accent);
        }
        .asm-files-list-item.binary {
            color: var(--text-secondary);
            font-style: italic;
        }
        .asm-files-list-item.open {
            background: var(--bg-button);
            color: var(--cyan);
        }
        .asm-files-list-item .file-icon {
            width: 14px;
            text-align: center;
        }
        .asm-files-list-item .file-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .asm-files-list-item .file-size {
            color: var(--text-secondary);
            font-size: 10px;
        }
        .asm-files-list-item .file-dir {
            color: var(--text-secondary);
            font-size: 11px;
        }
        /* Search/Replace bar */
        .asm-search-bar {
            background: var(--bg-secondary);
            padding: 6px 10px;
            border-bottom: 1px solid var(--bg-button);
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .asm-search-row, .asm-replace-row {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .asm-search-bar input[type="text"] {
            flex: 1;
            max-width: 250px;
            padding: 4px 8px;
            font-size: 12px;
            background: var(--bg-primary);
            border: 1px solid var(--bg-button);
            border-radius: 3px;
            color: var(--text-primary);
        }
        .asm-search-bar input[type="text"]:focus {
            outline: none;
            border-color: var(--accent);
        }
        .asm-search-bar button {
            padding: 4px 8px;
            font-size: 11px;
            background: var(--bg-button);
            border: none;
            border-radius: 3px;
            color: var(--text-primary);
            cursor: pointer;
        }
        .asm-search-bar button:hover {
            background: var(--bg-secondary);
        }
        #btnAsmSearchClose {
            font-size: 14px;
            padding: 2px 6px;
        }
        .asm-search-count {
            font-size: 11px;
            color: var(--text-secondary);
            min-width: 60px;
        }
        .asm-search-option {
            font-size: 11px;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 3px;
        }
        .asm-search-option input {
            margin: 0;
        }
        .asm-search-results {
            max-height: 200px;
            overflow-y: auto;
            background: var(--bg-secondary);
            border-top: 1px solid var(--bg-button);
            font-size: 12px;
        }
        .asm-search-result-item {
            padding: 4px 8px;
            cursor: pointer;
            border-bottom: 1px solid var(--bg-button);
            display: flex;
            gap: 8px;
        }
        .asm-search-result-item:hover {
            background: var(--bg-button);
        }
        .asm-search-result-file {
            color: var(--cyan);
            min-width: 100px;
            flex-shrink: 0;
        }
        .asm-search-result-line {
            color: var(--text-secondary);
            min-width: 40px;
            flex-shrink: 0;
        }
        .asm-search-result-text {
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .asm-search-result-match {
            background: rgba(255, 255, 0, 0.3);
            color: #ff0;
        }
        .asm-search-results-header {
            padding: 4px 8px;
            background: var(--bg-button);
            font-weight: bold;
            color: var(--text-secondary);
        }
        /* File selector dialog */
        .file-selector-dialog {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        .file-selector-dialog.hidden {
            display: none;
        }
        .file-selector-content {
            background: var(--bg-primary);
            border: 1px solid var(--bg-button);
            border-radius: 8px;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        }
        .file-selector-header {
            padding: 12px 16px;
            border-bottom: 1px solid var(--bg-button);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .file-selector-header h3 {
            margin: 0;
            font-size: 16px;
        }
        .file-selector-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 20px;
            cursor: pointer;
        }
        .file-selector-close:hover {
            color: var(--accent);
        }
        .file-selector-body {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }
        .file-selector-item {
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 4px;
            margin-bottom: 2px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .file-selector-item:hover {
            background: var(--bg-button);
        }
        .file-selector-item.detected {
            background: var(--bg-button);
            border: 1px solid var(--cyan);
        }
        .file-selector-item .item-icon {
            width: 16px;
            text-align: center;
            color: var(--text-secondary);
        }
        .file-selector-item .item-name {
            flex: 1;
        }
        .file-selector-item .item-hint {
            font-size: 10px;
            color: var(--cyan);
        }
        .asm-file-tab:hover {
            background: var(--bg-hover);
        }
        .asm-file-tab.active {
            background: var(--bg-primary);
            color: var(--cyan);
        }
        .asm-file-tab.main::before {
            content: "▶";
            font-size: 8px;
            color: var(--accent);
        }
        .asm-file-tab.modified::after {
            content: "●";
            font-size: 8px;
            color: var(--accent);
            margin-left: 2px;
        }
        .asm-file-tab .tab-close {
            font-size: 12px;
            color: var(--text-secondary);
            padding: 0 2px;
            margin-left: 4px;
        }
        .asm-file-tab .tab-close:hover {
            color: #ff8080;
        }
        .asm-file-tab.binary {
            color: var(--text-secondary);
            font-style: italic;
        }
        .asm-editor-area {
            display: flex;
            flex: 1;
            min-height: 0;
        }
        .asm-main-label {
            font-size: 10px;
            color: #ff6666;
            cursor: pointer;
            margin-left: 10px;
        }
        .asm-main-label:hover {
            color: #ff9999;
        }
        .asm-main-label::before {
            content: "Main: ";
            color: #ff6666;
        }

        /* Syntax highlighting colors */
        .asm-hl-instruction { color: var(--accent); font-weight: bold; }
        .asm-hl-directive { color: #c080ff; }
        .asm-hl-register { color: #ffd080; }
        .asm-hl-number { color: #80ff80; }
        .asm-hl-string { color: #ff80c0; }
        .asm-hl-label { color: var(--cyan); }
        .asm-hl-comment { color: var(--text-secondary); font-style: italic; }
        .asm-hl-operator { color: var(--text-primary); }
        .asm-hl-paren { color: #c0c0c0; }

        /* Opcodes Tab */
        .opcodes-container {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 500px);
            min-height: 400px;
            max-height: 700px;
        }
        .opcodes-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: var(--bg-primary);
            border-radius: 4px;
            margin-bottom: 10px;
        }
        .opcodes-header h3 {
            margin: 0;
            color: var(--cyan);
            font-size: 14px;
        }
        .opcodes-filter {
            display: flex;
            gap: 10px;
        }
        .opcode-search {
            padding: 5px 10px;
            background: var(--bg-secondary);
            border: 1px solid var(--bg-button);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 12px;
            width: 150px;
        }
        .opcodes-filter select {
            padding: 5px 10px;
            font-size: 12px;
        }
        .opcodes-body {
            flex: 1;
            overflow-y: auto;
            background: var(--bg-primary);
            border-radius: 4px;
        }
        .opcodes-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
            font-family: monospace;
        }
        .opcodes-table thead {
            position: sticky;
            top: 0;
            background: var(--bg-button);
            z-index: 1;
        }
        .opcodes-table th {
            padding: 8px 10px;
            text-align: left;
            color: var(--cyan);
            font-weight: bold;
            border-bottom: 2px solid var(--bg-secondary);
        }
        .opcodes-table td {
            padding: 5px 10px;
            border-bottom: 1px solid var(--bg-secondary);
            vertical-align: top;
        }
        .opcodes-table tr:hover {
            background: var(--bg-button);
        }
        .opcodes-table .op-mnemonic {
            color: var(--accent);
            font-weight: bold;
            white-space: nowrap;
        }
        .opcodes-table .op-mnemonic.undoc {
            color: #c080ff;
        }
        .opcodes-table .op-mnemonic.undoc::after {
            content: '*';
            color: #ff80ff;
            font-size: 10px;
            vertical-align: super;
        }
        .opcodes-table .op-opcode {
            color: #80c0ff;
            text-align: left;
            white-space: nowrap;
        }
        .opcodes-table .op-bytes {
            color: var(--text-secondary);
            text-align: center;
        }
        .opcodes-table .op-cycles {
            color: var(--cyan);
            text-align: center;
        }
        .opcodes-table .op-flags {
            font-size: 10px;
            letter-spacing: 1px;
        }
        .opcodes-table .op-desc {
            color: var(--text-primary);
        }
        .opcodes-footer {
            padding: 8px 15px;
            background: var(--bg-primary);
            border-radius: 4px;
            margin-top: 10px;
        }
        .flags-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            font-size: 10px;
            color: var(--text-secondary);
        }
        .flags-legend .flag-symbol {
            color: var(--cyan);
        }

        /* Graphics Viewer Tab */
        .graphics-container {
            padding: 10px;
            height: auto;
            display: flex;
            flex-direction: column;
        }
        .graphics-body {
            display: flex;
            gap: 10px;
            flex: 1;
            overflow: visible;
        }
        .graphics-dump-wrap {
            flex: 1;
            overflow: auto;
            background: #000;
            border: 1px solid var(--border-secondary);
            max-height: calc(100vh - 200px);
        }
        .graphics-dump-canvas {
            image-rendering: pixelated;
            display: block;
        }
        .graphics-sidebar {
            width: 160px;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .gfx-col-address,
        .gfx-col-actions {
            display: flex;
            flex-direction: column;
            gap: 6px;
            flex-shrink: 0;
        }
        .gfx-control-group {
            background: var(--bg-secondary);
            border: 1px solid var(--border-secondary);
            border-radius: 4px;
            padding: 8px;
        }
        .gfx-control-group label {
            display: block;
            font-size: 10px;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }
        .gfx-control-group input[type="text"] {
            width: 100%;
            padding: 4px 6px;
            background: var(--bg-primary);
            border: 1px solid var(--border-secondary);
            color: var(--text-primary);
            border-radius: 3px;
            font-family: monospace;
            font-size: 12px;
            box-sizing: border-box;
        }
        #gfxAddress {
            width: 50px;
        }
        .gfx-spinner {
            display: flex;
            gap: 2px;
        }
        .gfx-spinner input {
            width: 30px !important;
            max-width: 30px;
            flex: 0 0 30px;
            text-align: center;
        }
        .gfx-spinner button {
            width: 28px;
            padding: 4px;
            background: var(--bg-button);
            border: 1px solid var(--border-secondary);
            color: var(--text-primary);
            cursor: pointer;
            border-radius: 3px;
        }
        .gfx-spinner button:hover {
            background: var(--accent);
            color: var(--bg-primary);
        }
        .gfx-checkboxes label {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            margin-right: 10px;
            cursor: pointer;
        }
        .gfx-zoom-inline {
            display: flex;
            gap: 6px;
            margin-top: 4px;
        }
        .gfx-zoom-inline label {
            margin-right: 0;
        }
        .gfx-nav-buttons {
            display: flex;
            gap: 2px;
            margin-bottom: 2px;
            width: 160px;
        }
        .gfx-nav-buttons button {
            flex: 1;
            padding: 4px 6px;
            background: var(--bg-button);
            border: 1px solid var(--border-secondary);
            color: var(--text-primary);
            cursor: pointer;
            border-radius: 3px;
            font-size: 10px;
        }
        .gfx-nav-buttons button:hover {
            background: var(--accent);
            color: var(--bg-primary);
        }
        .gfx-preview-wrap {
            background: #000;
            border: 1px solid var(--border-secondary);
            padding: 4px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            overflow: hidden;
            max-width: 160px;
            min-height: 200px;
        }
        .gfx-preview-canvas {
            image-rendering: pixelated;
            max-width: 100%;
        }
        .gfx-info {
            font-size: 10px;
            color: var(--text-secondary);
            text-align: center;
            margin-top: 4px;
        }
        .gfx-actions {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .gfx-actions button {
            padding: 6px 8px;
            background: var(--bg-button);
            border: 1px solid var(--accent);
            color: var(--accent);
            cursor: pointer;
            border-radius: 3px;
            font-size: 11px;
        }
        .gfx-actions button:hover {
            background: var(--accent);
            color: var(--bg-primary);
        }

        /* Info Tab */
        #tab-info {
            overflow-y: auto;
            max-height: calc(100vh - 120px);
        }
        .info-tab-content {
            padding: 15px;
            max-width: 800px;
        }
        .info-tab-content h3 {
            margin: 0 0 15px 0;
            color: var(--accent);
            font-size: 16px;
        }
        .keyboard-image {
            margin-bottom: 15px;
            text-align: center;
        }
        .keyboard-image img {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
        }
        .info-section {
            margin-bottom: 20px;
        }
        .info-section h4 {
            margin: 0 0 8px 0;
            color: var(--cyan);
            font-size: 13px;
            border-bottom: 1px solid var(--border-secondary);
            padding-bottom: 4px;
        }
        .info-section p, .info-section li {
            font-size: 11px;
            color: var(--text-secondary);
            margin: 4px 0;
            line-height: 1.4;
        }
        .info-section ul {
            margin: 0;
            padding-left: 20px;
        }
        .info-section code {
            background: var(--bg-tertiary);
            padding: 2px 4px;
            border-radius: 2px;
            font-family: monospace;
            color: var(--text-primary);
        }
        .info-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
        }
        .info-table th, .info-table td {
            border: 1px solid var(--border-secondary);
            padding: 4px 8px;
            text-align: left;
        }
        .info-table th {
            background: var(--bg-tertiary);
            color: var(--cyan);
            font-weight: normal;
        }
        .info-table td {
            color: var(--text-secondary);
        }
        .info-table td.contended {
            color: var(--accent);
        }

        /* Settings Tab */
        #tab-settings {
            overflow-y: auto;
            max-height: calc(100vh - 120px);
        }
        .settings-tab-content {
            padding: 15px;
            max-width: 600px;
        }
        .settings-tab-content h3 {
            margin: 0 0 15px 0;
            color: var(--accent);
            font-size: 16px;
        }
        .settings-section {
            margin-bottom: 15px;
            padding: 12px;
            background: var(--bg-secondary);
            border: 1px solid var(--bg-button);
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }
        .settings-section h4 {
            margin: -12px -12px 12px -12px;
            padding: 8px 12px;
            color: var(--cyan);
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            background: var(--bg-button);
            border-radius: 3px 3px 0 0;
        }
        .settings-row {
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .settings-row label:not(.checkbox-label) {
            min-width: 100px;
            color: var(--text-secondary);
            font-size: 12px;
        }
        .settings-row select {
            flex: 1;
            max-width: 200px;
            padding: 5px 10px;
            font-size: 12px;
        }
        .settings-section select {
            padding: 5px 10px;
            font-size: 12px;
        }
        .palette-preview {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-top: 8px;
        }
        .palette-row {
            display: flex;
            gap: 4px;
            align-items: center;
        }
        .palette-row-label {
            font-size: 10px;
            color: var(--text-secondary);
            width: 42px;
            text-align: right;
            margin-right: 4px;
        }
        .palette-color {
            width: 28px;
            height: 28px;
            border: 1px solid var(--border-secondary);
            border-radius: 2px;
        }
        .frame-export-controls {
            gap: 5px;
        }
        .sprite-region-row {
            gap: 2px !important;
        }
        .sprite-input-group {
            display: inline-flex;
            align-items: center;
            gap: 2px;
            margin-right: 6px;
        }
        .sprite-input-group label {
            min-width: auto !important;
            font-size: 11px;
            color: var(--text-secondary);
        }
        .sprite-input-group input {
            font-size: 11px;
            padding: 2px 4px;
            width: 50px;
        }
        .settings-section.full-width {
            max-width: none;
        }
        .frame-grab-btn {
            padding: 4px 12px;
            font-size: 11px;
        }
        .frame-grab-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .frame-grab-status {
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 8px;
            min-height: 16px;
        }
        .frame-grab-status.recording {
            color: var(--accent);
        }

        /* Calculator Tab */
        .calc-wrapper {
            display: flex;
            gap: 15px;
            padding: 10px;
            align-items: stretch;
        }
        .calc-container {
            width: 340px;
            min-width: 340px;
            font-family: 'Consolas', 'Monaco', monospace;
        }
        .calc-log {
            width: 420px;
            background: var(--bg-primary);
            border: 1px solid var(--bg-button);
            border-radius: 6px;
            font-family: 'Consolas', 'Monaco', monospace;
            display: flex;
            flex-direction: column;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .calc-log-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            border-bottom: 1px solid var(--border-color);
            font-size: 11px;
            color: var(--text-secondary);
        }
        .calc-log-header button {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 14px;
            padding: 0 4px;
        }
        .calc-log-header button:hover {
            color: var(--accent);
        }
        .calc-log-content {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
            font-size: 11px;
        }
        .calc-log-entry {
            padding: 4px 6px;
            margin: 2px 0;
            border-radius: 3px;
            background: var(--bg-secondary);
            cursor: pointer;
        }
        .calc-log-entry:hover {
            background: var(--bg-button);
        }
        .calc-log-op {
            color: var(--text-secondary);
        }
        .calc-log-val {
            color: var(--cyan);
            margin-left: 4px;
        }
        .calc-log-result {
            color: var(--green);
            font-weight: bold;
        }
        .calc-display {
            background: var(--bg-primary);
            border: 1px solid var(--bg-button);
            border-radius: 6px;
            padding: 12px;
            min-height: 180px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .calc-input-row {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }
        .calc-base-select {
            background: var(--bg-button);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 4px 8px;
            font-family: inherit;
            font-size: 12px;
        }
        .calc-input {
            flex: 1;
            background: var(--bg-primary);
            color: var(--cyan);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 8px;
            font-family: inherit;
            font-size: 16px;
            text-align: right;
        }
        .calc-output-row {
            display: flex;
            align-items: center;
            padding: 4px 0;
            gap: 10px;
            min-height: 20px;
        }
        .calc-label {
            font-size: 11px;
            font-weight: bold;
            width: 35px;
        }
        .calc-label.dec { color: #4CAF50; }
        .calc-label.hex { color: var(--cyan); }
        .calc-label.oct { color: var(--text-secondary); }
        .calc-label.bin { color: var(--text-secondary); }
        .calc-label.ascii { color: var(--yellow); }
        .calc-output-row.ascii-row {
            height: 20px;
            min-height: 20px;
            max-height: 20px;
        }
        .calc-signed {
            color: #e74c3c;
            font-size: 12px;
            margin-left: 10px;
            min-width: 60px;
        }
        .calc-value {
            font-size: 13px;
            color: var(--text-primary);
            word-break: break-all;
            max-width: 280px;
        }
        .calc-value.bin-value {
            font-size: 11px;
            letter-spacing: -0.5px;
        }
        .calc-buttons {
            display: flex;
            flex-direction: column;
            gap: 4px;
            background: var(--bg-primary);
            border: 1px solid var(--bg-button);
            border-radius: 6px;
            padding: 10px;
            margin-top: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .calc-row {
            display: flex;
            gap: 4px;
        }
        .calc-btn {
            flex: 1;
            padding: 10px 4px;
            font-family: inherit;
            font-size: 12px;
            border: 1px solid var(--bg-button);
            border-radius: 4px;
            cursor: pointer;
            background: var(--bg-secondary);
            color: var(--text-primary);
            transition: background 0.1s;
        }
        .calc-btn:hover {
            background: var(--bg-button);
        }
        .calc-btn:active {
            background: var(--accent);
        }
        .calc-btn.digit {
            background: var(--bg-primary);
            font-size: 14px;
            font-weight: bold;
        }
        .calc-btn.hex-digit {
            background: var(--bg-secondary);
            color: var(--text-secondary);
            font-size: 13px;
        }
        .calc-btn-disabled,
        .calc-btn-disabled:hover {
            opacity: 0.35;
            cursor: not-allowed;
            background: var(--bg-tertiary) !important;
            color: var(--text-secondary);
        }
        .calc-btn.op {
            color: var(--text-secondary);
        }
        .calc-btn.func {
            color: var(--text-secondary);
            font-size: 11px;
        }
        .calc-btn.mode {
            background: var(--bg-button);
            color: var(--text-primary);
            font-size: 12px;
            font-weight: bold;
        }
        .calc-btn.special {
            color: var(--cyan);
            font-weight: bold;
        }
        .calc-btn.clear {
            background: #c0392b;
            color: white;
            font-weight: bold;
        }
        .calc-btn.clear:hover {
            background: #e74c3c;
        }
        .calc-btn.equals {
            background: var(--bg-button);
            color: var(--text-primary);
            font-size: 16px;
            font-weight: bold;
        }
        .calc-btn.paren {
            font-size: 14px;
        }
        .calc-bits-panel {
            background: var(--bg-primary);
            border: 1px solid var(--bg-button);
            border-radius: 6px;
            padding: 8px;
            margin-top: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .calc-bits-labels {
            display: flex;
            gap: 1px;
            margin-bottom: 2px;
            justify-content: flex-start;
        }
        .calc-bits-label {
            width: 9px;
            font-size: 8px;
            text-align: center;
            color: var(--text-secondary);
        }
        .calc-bits-label-sep {
            width: 3px;
        }
        .calc-bits-grid {
            display: flex;
            flex-wrap: nowrap;
            gap: 1px;
        }
        .calc-bit {
            width: 9px;
            height: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            background: var(--bg-secondary);
            border: 1px solid var(--bg-button);
            border-radius: 2px;
            cursor: pointer;
            color: var(--text-secondary);
        }
        .calc-bit.set {
            background: var(--cyan);
            color: var(--bg-primary);
        }
        .calc-bit-separator {
            width: 3px;
        }
        .calc-bit-label {
            font-size: 9px;
            color: var(--text-secondary);
            width: 100%;
            text-align: center;
            margin-top: 2px;
        }

        /* Debugger Panel */
        .debugger-container {
            margin-top: 0;
        }
        .debugger-panel {
            display: block;
            background: var(--bg-primary);
            border: 1px solid var(--bg-button);
            border-radius: 4px;
            padding: 10px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 11px;
        }
        .debugger-section {
            margin-bottom: 8px;
        }
        .debugger-section h4 {
            color: var(--cyan);
            margin: 0 0 4px 0;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .registers-row {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 4px;
            justify-content: flex-end;
        }
        .stack-pages-row {
            display: flex;
            gap: 8px;
        }
        .registers-grid.vertical {
            flex-direction: column;
        }
        .reg-group {
            background: var(--bg-secondary);
            padding: 5px 8px;
            border-radius: 3px;
        }
        .reg-group h4 {
            color: var(--cyan);
            margin: 0 0 3px 0;
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .registers-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 3px;
        }
        .registers-grid + .registers-grid {
            margin-top: 6px;
        }
        .register-item {
            background: var(--bg-primary);
            padding: 1px 4px;
            border-radius: 2px;
            font-size: 11px;
            white-space: nowrap;
        }
        .register-name {
            color: var(--text-secondary);
        }
        .register-value {
            color: var(--accent);
            font-weight: bold;
            margin-left: 2px;
            display: inline-block;
        }
        .register-value.editable {
            cursor: pointer;
            border-bottom: 1px dashed var(--text-secondary);
        }
        .register-value.editable:hover {
            color: var(--yellow);
            border-bottom-color: var(--yellow);
        }
        .register-value.editing {
            color: var(--yellow);
            border-bottom-color: var(--yellow);
        }
        .reg-swap-btn {
            height: 21px;
            padding: 0 6px;
            margin-left: 2px;
            font-size: 11px;
            background: var(--bg-button);
            color: var(--text-primary);
            border: none;
            border-radius: 3px;
            cursor: pointer;
            align-self: flex-end;
        }
        .reg-swap-btn:first-of-type {
            margin-left: 5px;
        }
        .reg-swap-btn:hover {
            background: var(--bg-button-hover);
        }
        .flags-label {
            font-size: 9px;
            color: var(--cyan);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 6px;
            margin-bottom: 2px;
        }
        .flags-display {
            display: flex;
            gap: 2px;
            flex-wrap: wrap;
        }
        .flag-item {
            background: var(--bg-primary);
            padding: 1px 4px;
            border-radius: 2px;
            color: var(--text-secondary);
            font-size: 10px;
            cursor: pointer;
            user-select: none;
        }
        .flag-item:hover {
            background: var(--bg-tertiary);
            border: 1px solid var(--accent);
            padding: 0 3px;
        }
        .flag-item.set {
            background: #4a6a4a;
            color: #8f8;
        }
        .flag-item.set:hover {
            background: #5a7a5a;
        }
        .flag-item:not(.editable) {
            cursor: default;
            opacity: 0.7;
        }
        .flag-item:not(.editable):hover {
            border: none;
            padding: 1px 4px;
            background: inherit;
        }
        .stack-view {
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 11px;
            background: var(--bg-secondary);
            border-radius: 3px;
            padding: 3px;
        }
        .stack-entry {
            display: flex;
            padding: 1px 3px;
            border-radius: 2px;
            cursor: context-menu;
        }
        .stack-entry:hover {
            background: var(--bg-button);
        }
        .stack-entry.current {
            background: #3a4a3a;
            color: #8f8;
        }
        .stack-entry.changed {
            color: var(--accent);
        }
        .stack-addr {
            color: var(--text-secondary);
            margin-right: 4px;
        }
        .stack-value {
            color: var(--text-primary);
        }
        .stack-pointer {
            color: #8f8;
            margin-left: 2px;
        }
        .stack-context-menu {
            position: fixed;
            background: var(--bg-secondary);
            border: 1px solid var(--bg-button);
            border-radius: 4px;
            padding: 4px 0;
            z-index: 1000;
            box-shadow: 2px 2px 8px rgba(0,0,0,0.5);
        }
        .stack-context-menu div {
            padding: 4px 12px;
            cursor: pointer;
        }
        .stack-context-menu div:hover {
            background: var(--bg-button);
        }
        .label-context-menu {
            position: fixed;
            background: var(--bg-secondary);
            border: 1px solid var(--bg-button);
            border-radius: 4px;
            padding: 4px 0;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        .label-context-menu div {
            padding: 4px 12px;
            cursor: pointer;
            font-size: 12px;
        }
        .label-context-menu div:hover {
            background: var(--bg-button);
        }
        .label-context-menu div.danger {
            color: var(--accent);
        }
        .label-context-menu div.selected {
            color: var(--accent);
        }
        .label-context-menu div.selected::before {
            content: '✓ ';
        }
        .label-context-menu .menu-separator {
            height: 1px;
            background: var(--bg-button);
            margin: 4px 0;
            padding: 0;
        }
        .label-context-menu .menu-separator:hover {
            background: var(--bg-button);
        }
        .label-context-menu .menu-submenu {
            position: relative;
        }
        .label-context-menu .menu-submenu-items {
            display: none;
            position: absolute;
            left: 100%;
            top: 0;
            background: var(--bg-secondary);
            border: 1px solid var(--bg-button);
            border-radius: 4px;
            padding: 4px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            white-space: nowrap;
        }
        .label-context-menu .menu-submenu:hover .menu-submenu-items {
            display: block;
        }
        .label-context-menu .menu-submenu.submenu-left .menu-submenu-items {
            left: auto;
            right: 100%;
        }
        .label-context-menu .menu-submenu.submenu-up .menu-submenu-items {
            top: auto;
            bottom: 0;
        }
        .label-context-menu .menu-submenu-items div {
            padding: 4px 12px;
        }
        .region-type-code { color: #8f8; }
        .region-type-db { color: #88f; }
        .region-type-dw { color: #8cf; }
        .region-type-text { color: #ff8; }
        .region-type-graphics { color: #f8f; }
        .region-type-smc { color: #f88; }
        .label-dialog {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1001;
        }
        .label-dialog.hidden {
            display: none;
        }
        .label-dialog-content {
            background: var(--bg-secondary);
            border: 1px solid var(--bg-button);
            border-radius: 6px;
            padding: 15px;
            min-width: 280px;
        }
        .label-dialog h4 {
            margin: 0 0 12px 0;
            color: var(--cyan);
        }
        .label-dialog-row {
            margin-bottom: 10px;
        }
        .label-dialog-row label {
            display: block;
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 3px;
        }
        .label-dialog-row input {
            width: 100%;
            padding: 6px 8px;
            background: var(--bg-primary);
            border: 1px solid var(--bg-button);
            border-radius: 3px;
            color: var(--text-primary);
            font-size: 12px;
            box-sizing: border-box;
        }
        .label-dialog-row input:focus {
            outline: none;
            border-color: var(--cyan);
        }
        .label-dialog-row textarea {
            width: 100%;
            padding: 5px 8px;
            background: var(--bg-primary);
            border: 1px solid var(--bg-button);
            border-radius: 3px;
            color: var(--text-primary);
            font-size: 12px;
            font-family: var(--font-mono);
            box-sizing: border-box;
            resize: vertical;
        }
        .label-dialog-row textarea:focus {
            outline: none;
            border-color: var(--cyan);
        }
        .label-dialog-buttons button.danger {
            background: #633;
        }
        .label-dialog-buttons button.danger:hover {
            background: #844;
        }
        .label-dialog-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            margin-top: 15px;
        }
        .label-dialog-buttons button {
            padding: 6px 14px;
            font-size: 12px;
        }
        .export-options {
            display: flex;
            flex-direction: column;
            gap: 5px;
            align-items: flex-start;
        }
        .export-options label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 12px;
            cursor: pointer;
            white-space: nowrap;
        }
        .disassembly-view {
            background: var(--bg-primary);
            border: none;
            border-radius: 3px;
            padding: 5px;
            flex: 1;
            overflow: hidden;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 11px;
        }
        .main-debug-row {
            display: flex;
            gap: 8px;
            margin-top: 0;
            align-items: stretch;
        }
        .right-column {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-width: 0;
        }
        .disasm-panel {
            flex: 0 0 480px;
            width: 480px;
            height: 643px;
            background: var(--bg-secondary);
            border: 1px solid var(--bg-button);
            border-radius: 3px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            margin-bottom: 0;
        }
        .memory-panel {
            width: 100%;
            min-width: 0;
            margin-top: 0;
            display: flex;
            flex-direction: column;
        }
        .tools-row .search-label {
            color: var(--text-secondary);
            font-size: 11px;
        }
        .disasm-line {
            display: flex;
            padding: 1px 3px;
            border-radius: 2px;
        }
        .disasm-line.flow-break {
            margin-bottom: 6px;
        }
        .disasm-line.data-line .disasm-mnemonic {
            color: #8cf;
            font-style: italic;
        }
        .disasm-line:hover {
            background: var(--bg-button);
        }
        .disasm-line.current {
            background: #4a3a2a;
            border-left: 3px solid var(--accent);
            margin-left: -3px;
        }
        .disasm-line.trace {
            background: #3a2a4a;
            border-left: 3px solid #c060c0;
            margin-left: -3px;
        }
        .disasm-line.current.trace {
            background: #4a3a4a;
            border-left: 3px solid #c060c0;
        }
        .disasm-line.target {
            background: #2a3a4a;
            border-right: 3px solid var(--cyan);
        }
        .disasm-line.current.target {
            background: #3a3a3a;
        }
        .disasm-addr {
            color: var(--text-secondary);
            width: 100px;
            flex-shrink: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            cursor: pointer;
        }
        .disasm-addr:hover {
            color: var(--cyan);
            text-decoration: underline;
        }
        .disasm-addr .label-name {
            color: var(--cyan);
            font-weight: bold;
        }
        .disasm-line.has-long-label {
            flex-wrap: wrap;
        }
        .disasm-line.has-long-label .disasm-label-row {
            width: 100%;
            padding-left: 16px;
            margin-bottom: 1px;
            color: var(--cyan);
        }
        .disasm-line.has-long-label .disasm-label-row .label-name {
            color: var(--cyan);
            font-weight: bold;
        }
        .disasm-label-operand {
            color: var(--cyan);
        }
        .disasm-operand-addr {
            cursor: pointer;
            color: #00aa00; /* Green for address operands */
        }
        .disasm-operand-addr:hover {
            text-decoration: underline;
        }
        .disasm-label-operand.disasm-operand-addr {
            color: var(--cyan); /* Cyan for labels */
        }
        body.light-theme .disasm-operand-addr {
            color: #008800;
        }
        body.light-theme .disasm-label-operand.disasm-operand-addr {
            color: #0066aa;
        }
        .xref-tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.95);
            color: #fff;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 11px;
            font-family: monospace;
            max-width: 300px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 10000;
            pointer-events: none;
            display: none;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
            border: 1px solid #444;
        }
        .xref-tooltip-header {
            font-weight: bold;
            margin-bottom: 4px;
            border-bottom: 1px solid #444;
            padding-bottom: 4px;
            color: #fff;
        }
        .xref-tooltip-item {
            padding: 2px 0;
            white-space: nowrap;
        }
        .xref-type-call { color: #ff8080; }
        .xref-type-jp { color: #80ff80; }
        .xref-type-jr { color: #80ffff; }
        .xref-type-djnz { color: #80ffff; }
        .xref-type-rst { color: #ff80ff; }
        .xref-type-ld { color: #ffff80; }
        .disasm-bytes {
            color: var(--text-secondary);
            width: 80px;
            flex-shrink: 0;
            opacity: 0.6;
        }
        .disasm-mnemonic {
            color: var(--cyan);
            flex-grow: 1;
        }
        .disasm-mnemonic .op {
            color: var(--accent);
        }
        /* Operand syntax colors */
        .disasm-reg {
            color: #daa520; /* Gold - registers */
        }
        .disasm-num {
            color: #00aa00; /* Green - hex/decimal numbers */
        }
        .disasm-char {
            color: #cc66cc; /* Purple - character literals */
        }
        .disasm-bin {
            color: #6699cc; /* Blue - binary numbers */
        }
        .disasm-ptr {
            color: #888888; /* Gray - parentheses for indirect */
        }
        .disasm-tstates {
            color: var(--text-secondary);
            font-size: 10px;
            width: 40px;
            flex-shrink: 0;
            text-align: right;
            margin-right: 8px;
        }
        .debugger-controls {
            display: flex;
            gap: 5px;
            margin-top: 10px;
            margin-bottom: -3px;
        }
        .debugger-controls button {
            padding: 4px 8px;
            font-size: 11px;
        }
        .debugger-controls button kbd {
            background: var(--bg-secondary);
            padding: 1px 4px;
            border-radius: 2px;
            margin-left: 4px;
            font-size: 10px;
        }
        .tstates-input {
            width: 55px;
            padding: 4px 6px;
            font-size: 11px;
            font-family: monospace;
            background: var(--bg-secondary);
            border: 1px solid var(--bg-button);
            border-radius: 3px;
            color: var(--text-primary);
        }
        .disasm-line.breakpoint {
            background: #4a2a2a;
        }
        .disasm-line.breakpoint.current {
            background: #5a3a2a;
        }
        .disasm-bp {
            width: 16px;
            flex-shrink: 0;
            text-align: center;
            cursor: pointer;
            user-select: none;
        }
        .disasm-bp::before {
            content: '○';
            color: var(--text-secondary);
        }
        .disasm-bp:hover::before {
            color: var(--accent);
        }
        .disasm-bp.active::before {
            content: '●';
            color: var(--accent);
        }
        /* Comment styling */
        .disasm-comment {
            color: #7a7;
            font-style: italic;
        }
        .disasm-comment-line {
            display: block;
            padding-left: 80px;
            color: #7a7;
            font-style: italic;
            white-space: pre-wrap;
        }
        .disasm-separator {
            display: block;
            padding-left: 80px;
            color: #666;
        }
        .disasm-inline-comment {
            color: #7a7;
            font-style: italic;
            margin-left: 8px;
        }
        .bp-add-form {
            display: flex;
            gap: 3px;
        }
        .bp-add-form input {
            width: 55px;
            padding: 2px 5px;
            background: var(--bg-primary);
            border: 1px solid var(--bg-button);
            border-radius: 3px;
            color: var(--text-primary);
            font-family: monospace;
            font-size: 11px;
        }
        #triggerCondInput {
            width: 80px;
        }
        .bp-add-form select {
            padding: 2px 3px;
            font-size: 10px;
        }
        .bp-add-form button {
            padding: 2px 6px;
            font-size: 10px;
        }
        .breakpoint-list {
            max-height: 80px;
            overflow-y: auto;
        }
        .breakpoint-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 2px 5px;
            background: var(--bg-primary);
            border-radius: 2px;
            margin-bottom: 2px;
            font-size: 11px;
        }
        .breakpoint-item:hover {
            background: var(--bg-button);
        }
        .bp-addr {
            color: var(--accent);
            font-family: monospace;
            cursor: pointer;
        }
        .bp-addr:hover {
            text-decoration: underline;
        }
        .bp-remove {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 2px 4px;
            font-size: 12px;
        }
        .bp-remove:hover {
            color: var(--accent);
        }
        /* Unified Trigger Styles */
        .trigger-item {
            display: flex;
            align-items: center;
            padding: 2px 5px;
            background: var(--bg-primary);
            border-radius: 2px;
            margin-bottom: 2px;
            font-size: 11px;
            gap: 4px;
        }
        .trigger-item:hover {
            background: var(--bg-button);
        }
        .trigger-item.disabled {
            opacity: 0.5;
        }
        .trigger-icon {
            color: var(--text-secondary);
            font-size: 10px;
            min-width: 16px;
            text-align: center;
        }
        .trigger-icon.exec { color: var(--accent); }
        .trigger-icon.read { color: var(--cyan); }
        .trigger-icon.write { color: var(--warning); }
        .trigger-icon.rw { color: #ff80ff; }
        .trigger-icon.port { color: var(--purple); }
        .trigger-desc {
            flex: 1;
            color: var(--accent);
            font-family: monospace;
            cursor: pointer;
        }
        .trigger-desc:hover {
            text-decoration: underline;
        }
        .trigger-skip {
            color: var(--yellow);
            font-size: 10px;
            margin-left: 3px;
        }
        .trigger-toggle {
            color: var(--text-secondary);
            cursor: pointer;
            padding: 0 3px;
            font-size: 10px;
        }
        .trigger-toggle:hover {
            color: var(--accent);
        }
        .trigger-remove {
            color: var(--text-secondary);
            cursor: pointer;
            padding: 0 3px;
            font-size: 12px;
        }
        .trigger-remove:hover {
            color: var(--accent);
        }
        .wp-type {
            color: var(--text-secondary);
            font-size: 10px;
            margin-left: 5px;
        }
        .no-breakpoints {
            color: var(--text-secondary);
            font-size: 10px;
            text-align: center;
            padding: 5px;
        }
        .label-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 2px 5px;
            background: var(--bg-primary);
            border-radius: 2px;
            margin-bottom: 2px;
            font-size: 11px;
            cursor: pointer;
        }
        .label-item:hover {
            background: var(--bg-button);
        }
        .label-info {
            display: flex;
            gap: 6px;
            overflow: hidden;
            flex: 1;
        }
        .label-addr {
            color: var(--accent);
            font-family: monospace;
            flex-shrink: 0;
        }
        .label-name {
            color: #8bd;
            font-family: monospace;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .label-comment {
            color: var(--text-secondary);
            font-size: 10px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .label-actions {
            display: flex;
            gap: 2px;
            flex-shrink: 0;
        }
        .label-btn {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 2px 4px;
            font-size: 11px;
        }
        .label-btn:hover {
            color: var(--accent);
        }
        .labels-list {
            max-height: 100px;
            overflow-y: auto;
        }
        .rom-labels-toggle {
            display: flex;
            align-items: center;
            gap: 0;
            font-size: 11px;
            cursor: pointer;
        }
        .rom-labels-toggle input {
            margin: 0 2px 0 0;
            width: 13px;
        }
        .label-item.rom-label {
            opacity: 0.7;
            font-style: italic;
        }
        .label-item.rom-label .label-item-name::before {
            content: "ROM: ";
            color: var(--text-secondary);
            font-style: normal;
        }

        /* Memory Hex View */
        .memory-section {
            margin-top: 4px;
            background: var(--bg-secondary);
            border: 1px solid var(--bg-button);
            border-radius: 3px;
            padding: 10px;
        }
        .memory-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .memory-header h4 {
            margin: 0;
            color: var(--cyan);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .memory-controls {
            display: flex;
            gap: 2px;
            align-items: center;
        }
        .memory-controls input {
            width: 60px;
            padding: 4px 8px;
            background: var(--bg-primary);
            border: 1px solid var(--bg-button);
            border-radius: 3px;
            color: var(--text-primary);
            font-family: monospace;
            font-size: 12px;
        }
        .memory-controls button {
            padding: 4px 10px;
            font-size: 11px;
        }
        .memory-option {
            margin-left: 5px;
            font-size: 11px;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 0;
            white-space: nowrap;
        }
        .memory-option input {
            margin: 0 2px 0 0;
            width: 13px;
        }
        .disasm-option {
            margin-left: 0;
            font-size: 10px;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 0;
            white-space: nowrap;
        }
        .disasm-option input[type="checkbox"] {
            margin: 0 2px 0 0;
            padding: 0;
            width: 12px;
            height: 12px;
        }
        .disasm-select {
            padding: 2px 4px;
            font-size: 10px;
            background: var(--bg-primary);
            color: var(--text-primary);
            border: 1px solid var(--bg-button);
            border-radius: 3px;
            margin-left: 3px;
        }
        .memory-view {
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 11px;
            flex: 1;
            overflow-y: auto;
            background: var(--bg-primary);
            border-radius: 2px;
            padding: 5px;
        }
        .memory-line {
            display: flex;
            padding: 1px 0;
            white-space: nowrap;
            line-height: 18px;
        }
        .memory-addr {
            color: var(--text-secondary);
            width: 36px;
            flex-shrink: 0;
        }
        .memory-hex {
            display: flex;
            gap: 0;
            margin-right: 8px;
        }
        .memory-byte {
            color: var(--text-primary);
            width: 18px;
            height: 16px;
            line-height: 16px;
            text-align: center;
            cursor: pointer;
            border-radius: 2px;
            display: inline-block;
        }
        .memory-byte:hover {
            background: var(--bg-button);
        }
        .memory-byte.modified {
            color: var(--accent);
        }
        .memory-byte.changed {
            background: #4a2a2a;
            color: #f88;
        }
        .memory-byte.has-bp {
            outline: 1px solid #f44;
        }
        .memory-byte.has-wp {
            outline: 1px solid #4af;
        }
        .memory-byte.has-wp-r {
            outline: 1px solid #4f4;
        }
        .memory-byte.has-wp-w {
            outline: 1px solid #fa4;
        }
        .memory-byte.region-db {
            color: #88f;
        }
        .memory-byte.region-dw {
            color: #8cf;
        }
        .memory-byte.region-text {
            color: #ff8;
        }
        .memory-byte.region-graphics {
            color: #f8f;
        }
        .memory-byte.region-smc {
            color: #f88;
        }
        .memory-byte.selected {
            background: #446;
            outline: 1px solid #88f;
        }
        .memory-ascii .changed {
            color: #f88;
        }
        .memory-ascii {
            color: var(--text-secondary);
            letter-spacing: 0;
        }
        .memory-ascii .printable {
            color: var(--cyan);
        }
        .memory-ascii .region-text {
            color: #ff8;
            font-weight: bold;
        }
        .memory-edit-input {
            width: 22px;
            height: 18px;
            padding: 0;
            margin: 0;
            text-align: center;
            font-family: inherit;
            font-size: inherit;
            background: var(--bg-secondary);
            border: 1px solid var(--cyan);
            border-radius: 2px;
            color: var(--text-primary);
            outline: none;
            box-sizing: border-box;
        }
        .memory-search {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid var(--bg-button);
        }
        .memory-search.inline {
            margin-top: 4px;
            padding-top: 4px;
            margin-bottom: -10px;
            border-top: none;
        }
        .memory-search.inline input[type="text"] {
            flex: 0 1 auto;
            width: 140px;
        }
        .memory-search.inline .search-options {
            gap: 6px;
            margin: 0;
        }
        .search-row {
            display: flex;
            gap: 5px;
            align-items: center;
        }
        .search-row input {
            flex: 1;
            padding: 4px 8px;
            background: var(--bg-primary);
            border: 1px solid var(--bg-button);
            border-radius: 3px;
            color: var(--text-primary);
            font-family: monospace;
            font-size: 12px;
        }
        .search-row select {
            padding: 4px;
            background: var(--bg-primary);
            border: 1px solid var(--bg-button);
            border-radius: 3px;
            color: var(--text-primary);
            font-size: 11px;
        }
        .search-row button {
            padding: 4px 10px;
            font-size: 11px;
        }
        .search-options {
            display: flex;
            gap: 15px;
            margin: 5px 0;
        }
        .search-option {
            font-size: 10px;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 3px;
        }
        .search-results {
            max-height: 80px;
            overflow-y: auto;
            margin-top: 5px;
            font-family: monospace;
            font-size: 11px;
        }
        .search-result {
            padding: 2px 5px;
            cursor: pointer;
            border-radius: 2px;
        }
        .search-result:hover {
            background: var(--bg-button);
        }
        .search-result .addr {
            color: var(--accent);
        }
        .search-result .preview {
            color: var(--text-secondary);
            margin-left: 10px;
        }
        .search-info {
            color: var(--text-secondary);
            font-style: italic;
        }
        /* Panel tabs (Breakpoints/Labels/Tools) */
        .panel-tabs {
            margin-top: 10px;
        }
        .panel-tab-bar {
            display: flex;
            gap: 2px;
            border-bottom: 1px solid var(--bg-button);
            margin-bottom: 0;
        }
        .panel-tab-btn {
            padding: 4px 12px;
            background: var(--bg-secondary);
            border: 1px solid var(--bg-button);
            border-bottom: none;
            border-radius: 3px 3px 0 0;
            color: var(--text-secondary);
            font-size: 11px;
            cursor: pointer;
            margin-bottom: -1px;
        }
        .panel-tab-btn:hover {
            background: var(--bg-button);
            color: var(--text-primary);
        }
        .panel-tab-btn.active {
            background: var(--bg-secondary);
            color: var(--cyan);
            border-bottom: 1px solid var(--bg-secondary);
        }
        .panel-tab-content {
            display: none;
            background: var(--bg-secondary);
            border: 1px solid var(--bg-button);
            border-top: none;
            border-radius: 0 0 3px 3px;
            padding: 8px;
        }
        .panel-tab-content.active {
            display: block;
        }
        .panel-tab-content .panel-row {
            display: flex;
            gap: 10px;
        }
        .panel-tab-content .panel-column {
            flex: 1;
        }
        .tools-row {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            align-items: center;
            margin-bottom: 5px;
        }
        .tools-row:last-child {
            margin-bottom: 0;
        }
        .tools-row button {
            padding: 2px 6px;
            font-size: 11px;
        }
        .tools-row select {
            font-size: 11px;
            padding: 2px 4px;
        }
        .poke-status {
            color: var(--text-secondary);
            font-size: 11px;
            margin-left: 5px;
        }
        .poke-results {
            max-height: 60px;
            overflow-y: auto;
            margin-top: 5px;
            font-family: monospace;
            font-size: 11px;
        }
        .poke-result {
            display: inline-block;
            padding: 2px 6px;
            margin: 1px;
            background: var(--bg-primary);
            border-radius: 2px;
            cursor: pointer;
        }
        .poke-result:hover {
            background: var(--bg-button);
        }
        .poke-result .addr {
            color: var(--accent);
        }
        .poke-result .val {
            color: var(--text-secondary);
            margin-left: 3px;
        }
        .text-scan-results {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 5px;
            font-family: monospace;
            font-size: 11px;
        }
        .text-scan-result {
            display: flex;
            padding: 2px 6px;
            margin: 1px 0;
            background: var(--bg-primary);
            border-radius: 2px;
            cursor: pointer;
            gap: 8px;
        }
        .text-scan-result:hover {
            background: var(--bg-button);
        }
        .text-scan-result .addr {
            color: var(--accent);
            min-width: 45px;
        }
        .text-scan-result .len {
            color: var(--text-secondary);
            min-width: 25px;
        }
        .text-scan-result .text {
            color: var(--cyan);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .text-scan-result .text .dict-match {
            color: var(--green);
            font-weight: bold;
        }
        .text-scan-result .bank {
            color: var(--magenta);
            font-size: 9px;
            margin-left: 2px;
        }
        .automap-stats {
            color: var(--text-secondary);
            font-size: 11px;
            margin-left: 5px;
        }
        .automap-stats.active {
            color: var(--accent);
        }

        /* Trace List */
        .trace-list {
            max-height: 120px;
            overflow-y: auto;
            margin-top: 5px;
            font-family: monospace;
            font-size: 11px;
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            display: none;
        }
        .trace-list.visible {
            display: block;
        }
        .trace-entry {
            padding: 1px 4px;
            cursor: pointer;
            white-space: nowrap;
            border-bottom: 1px solid var(--border-primary);
        }
        .trace-entry:hover {
            background: var(--bg-button);
        }
        .trace-entry.current {
            background: var(--bg-selected);
        }
        .trace-entry.viewing {
            background: var(--accent);
            color: var(--bg-primary);
        }
        .trace-entry .addr {
            color: var(--accent);
        }
        .trace-entry.viewing .addr {
            color: var(--bg-primary);
        }
        .trace-entry .instr {
            color: var(--text-primary);
            margin-left: 8px;
        }
        .trace-entry .regs {
            color: var(--text-secondary);
            margin-left: 8px;
        }
        .trace-entry .ports {
            color: var(--cyan);
            margin-left: 8px;
            font-weight: bold;
        }
        .trace-entry.viewing .ports {
            color: var(--bg-secondary);
        }
        .trace-entry .memops {
            color: var(--warning);
            margin-left: 8px;
        }
        .trace-entry.viewing .memops {
            color: var(--bg-secondary);
        }
        .trace-viewing-indicator {
            background: var(--warning);
            color: #000;
            padding: 2px 6px;
            font-size: 11px;
            margin-left: 5px;
            border-radius: 3px;
        }

        /* Watches Panel */
        .watches-controls {
            display: flex;
            align-items: center;
            gap: 3px;
            margin-bottom: 5px;
        }
        .watches-controls input {
            padding: 2px 5px;
            font-size: 11px;
            font-family: monospace;
            background: var(--bg-primary);
            border: 1px solid var(--bg-button);
            border-radius: 3px;
            color: var(--text-primary);
        }
        #watchAddrInput {
            width: 60px;
        }
        #watchNameInput {
            width: 80px;
        }
        .watches-controls button {
            padding: 2px 6px;
            font-size: 10px;
        }
        .watches-list {
            font-family: monospace;
            font-size: 11px;
            max-height: 150px;
            overflow-y: auto;
        }
        .watch-entry {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 2px 0;
            border-bottom: 1px solid var(--border-primary);
        }
        .watch-entry:last-child {
            border-bottom: none;
        }
        .watch-addr {
            color: var(--accent);
            min-width: 45px;
        }
        .watch-name {
            color: var(--text-secondary);
            min-width: 60px;
            max-width: 80px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .watch-name.label {
            color: var(--cyan);
        }
        .watch-bytes {
            color: var(--text-primary);
        }
        .watch-ascii {
            color: var(--text-secondary);
        }
        .watch-remove {
            padding: 0 4px;
            font-size: 10px;
            background: var(--bg-button);
            border: 1px solid var(--border-primary);
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 2px;
        }
        .watch-remove:hover {
            background: var(--warning);
            color: #000;
        }
        .watch-bytes .changed {
            color: var(--warning);
            font-weight: bold;
        }

        /* Memory Map Dialog */
        .memmap-dialog {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .memmap-dialog.hidden {
            display: none;
        }
        .memmap-content {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 10px 15px 15px 15px;
            max-width: 90vw;
            max-height: 90vh;
            overflow: auto;
            min-width: 750px;
            position: relative;
        }
        .memmap-header {
            position: absolute;
            top: 8px;
            right: 10px;
            z-index: 10;
        }
        .memmap-title {
            margin: 0;
            margin-top: auto;
            color: var(--text-secondary);
            font-size: 12px;
            font-weight: normal;
        }
        .memmap-scale {
            display: flex;
            flex-direction: column;
            width: 45px;
            flex-shrink: 0;
            font-size: 9px;
            color: var(--text-secondary);
            padding-right: 5px;
            position: relative;
        }
        .memmap-scale-tick {
            position: absolute;
            right: -10px;
            font-size: 9px;
        }
        .memmap-scale-tick::after {
            content: '';
            position: absolute;
            top: 0;
            right: -5px;
            width: 10px;
            height: 1px;
            background: var(--text-secondary);
        }
        .memmap-scale-item {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            padding-top: 2px;
            height: 128px;
            box-sizing: border-box;
            position: relative;
        }
        .memmap-scale-item::after {
            content: '';
            position: absolute;
            top: 0;
            right: -15px;
            width: 15px;
            height: 1px;
            background: var(--text-secondary);
        }
        .memmap-scale-addr {
            color: var(--cyan);
            font-family: monospace;
        }
        .memmap-scale-end {
            position: relative;
            font-size: 9px;
            margin-top: -2px;
        }
        .memmap-scale-end::after {
            content: '';
            position: absolute;
            top: 0;
            right: -15px;
            width: 15px;
            height: 1px;
            background: var(--text-secondary);
        }
        .memmap-close {
            background: var(--bg-button);
            border: none;
            color: var(--text-primary);
            padding: 5px 15px;
            border-radius: 4px;
            cursor: pointer;
        }
        .memmap-close:hover {
            background: var(--bg-button-hover);
        }
        .memmap-view-toggle {
            display: flex;
            gap: 2px;
        }
        .memmap-view-btn {
            background: var(--bg-button);
            border: 1px solid var(--border-secondary);
            color: var(--text-secondary);
            padding: 4px 12px;
            cursor: pointer;
            font-size: 11px;
        }
        .memmap-view-btn:first-child {
            border-radius: 4px 0 0 4px;
        }
        .memmap-view-btn:last-child {
            border-radius: 0 4px 4px 0;
        }
        .memmap-view-btn.active {
            background: var(--accent);
            color: var(--bg-primary);
            border-color: var(--accent);
        }
        .memmap-view-btn:hover:not(.active) {
            background: var(--bg-button-hover);
        }
        .memmap-heatmap-scale {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-top: 10px;
            font-size: 10px;
            color: var(--text-secondary);
        }
        .memmap-gradient {
            flex: 1;
            height: 12px;
            background: linear-gradient(to right, #000, #0066ff, #00ff66, #ff6600, #fff);
            border-radius: 2px;
        }
        .memmap-body {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: flex-start;
        }
        .memmap-canvas-container {
            position: relative;
            width: 512px;
            height: 512px;
            flex-shrink: 0;
        }
        #memmapCanvas {
            border: 1px solid var(--bg-button);
            cursor: crosshair;
            image-rendering: pixelated;
        }
        .memmap-tooltip {
            position: absolute;
            background: rgba(0,0,0,0.9);
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            pointer-events: none;
            white-space: nowrap;
            display: none;
        }
        .memmap-sidebar {
            width: 220px;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            min-height: 512px;
            padding-top: 5px;
        }
        .memmap-legend {
            margin-bottom: 15px;
        }
        .memmap-legend.hidden {
            display: none;
        }
        .memmap-legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 4px 0;
            font-size: 12px;
        }
        .memmap-legend-color {
            width: 16px;
            height: 16px;
            border-radius: 2px;
        }
        .memmap-stats {
            font-size: 12px;
        }
        .memmap-stats table {
            width: 100%;
            border-collapse: collapse;
        }
        .memmap-stats td {
            padding: 3px 5px;
        }
        .memmap-stats td:nth-child(2),
        .memmap-stats td:nth-child(3) {
            text-align: right;
            font-family: monospace;
        }
        .memmap-stats tr.total {
            border-top: 1px solid var(--bg-button);
            font-weight: bold;
        }
        .memmap-bar {
            height: 8px;
            background: var(--bg-button);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 10px;
        }
        .memmap-bar-fill {
            height: 100%;
            display: flex;
        }
        .memmap-addr-info {
            margin-top: 15px;
            padding: 8px;
            background: var(--bg-primary);
            border-radius: 4px;
            font-family: monospace;
            font-size: 11px;
            height: 80px;
            overflow: hidden;
            white-space: pre-wrap;
        }
        /* Full Help Dialog */
        .fullhelp-dialog {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .fullhelp-dialog.hidden {
            display: none;
        }
        .fullhelp-content {
            background: var(--bg-secondary);
            border-radius: 8px;
            width: 90vw;
            max-width: 900px;
            height: 90vh;
            max-height: 800px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .fullhelp-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            border-bottom: 1px solid var(--bg-button);
        }
        .fullhelp-header h3 {
            margin: 0;
            color: var(--cyan);
        }
        .help-version {
            color: var(--text-secondary);
            font-size: 0.8em;
        }
        .fullhelp-close {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 28px;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        .fullhelp-close:hover {
            color: var(--text-primary);
        }
        .fullhelp-body {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        .fullhelp-nav {
            display: flex;
            flex-direction: column;
            gap: 2px;
            padding: 10px;
            background: var(--bg-primary);
            min-width: 130px;
            overflow-y: auto;
        }
        .fullhelp-nav-btn {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            text-align: left;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }
        .fullhelp-nav-btn:hover {
            background: var(--bg-button);
            color: var(--text-primary);
        }
        .fullhelp-nav-btn.active {
            background: var(--accent);
            color: #fff;
        }
        .fullhelp-section {
            flex: 1;
            padding: 20px 25px;
            overflow-y: auto;
            line-height: 1.6;
        }
        .fullhelp-section.hidden {
            display: none;
        }
        .fullhelp-section h4 {
            margin: 0 0 15px 0;
            color: var(--cyan);
            font-size: 18px;
            border-bottom: 1px solid var(--bg-button);
            padding-bottom: 8px;
        }
        .fullhelp-section h5 {
            margin: 20px 0 10px 0;
            color: var(--accent);
            font-size: 14px;
        }
        .fullhelp-section p {
            margin: 0 0 10px 0;
            color: var(--text-primary);
        }
        .fullhelp-section ul, .fullhelp-section ol {
            margin: 0 0 15px 0;
            padding-left: 25px;
        }
        .fullhelp-section li {
            margin-bottom: 5px;
        }
        .fullhelp-section code {
            background: var(--bg-primary);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 12px;
            color: var(--cyan);
        }
        .fullhelp-section pre {
            background: var(--bg-primary);
            padding: 15px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 11px;
            overflow-x: auto;
            line-height: 1.4;
            color: var(--text-primary);
        }
        .fullhelp-section table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 15px;
        }
        .fullhelp-section th, .fullhelp-section td {
            padding: 8px 12px;
            text-align: left;
            border-bottom: 1px solid var(--bg-button);
        }
        .fullhelp-section th {
            color: var(--cyan);
            font-weight: bold;
        }
        .fullhelp-section td:first-child {
            font-family: monospace;
            color: var(--accent);
            white-space: nowrap;
        }
        /* Bookmarks bar */
        .bookmarks-bar {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 2px 6px;
            background: var(--bg-tertiary);
            border-top: 1px solid var(--border-color);
            font-size: 10px;
            margin-bottom: -6px;
        }
        .bookmarks-label {
            color: var(--text-secondary);
            margin-right: 4px;
        }
        .bookmark-btn {
            min-width: 40px;
            padding: 2px 6px;
            font-family: monospace;
            font-size: 10px;
            background: var(--bg-button);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            cursor: pointer;
        }
        .bookmark-btn:hover {
            background: var(--bg-hover);
        }
        .bookmark-btn.set {
            background: var(--accent);
            color: white;
        }
    </style>
</head>
<body>
    <!-- ROM Selection Modal (shown only if ROMs not found in roms/) -->
    <div class="modal-overlay hidden" id="romModal">
        <div class="modal">
            <h2>🖥️ ROM Files Required</h2>
            <p>No ROM files found in <code>roms/</code> directory. Please select ROM files manually, or place them in the <code>roms/</code> folder:</p>
            <ul style="color: var(--text-secondary); font-size: 0.9em; margin: 10px 0;">
                <li><code>roms/48.rom</code> - ZX Spectrum 48K</li>
                <li><code>roms/128.rom</code> - ZX Spectrum 128K</li>
                <li><code>roms/pentagon.rom</code> - Pentagon 128K</li>
                <li><code>roms/trdos.rom</code> - TR-DOS 5.03/5.04t (for TRD/SCL disk images)</li>
            </ul>
            
            <div class="rom-section">
                <h4>48K ROM (Required)</h4>
                <div class="rom-buttons">
                    <button id="btnSelect48Rom">Select 48.rom</button>
                </div>
                <div class="rom-status" id="status48Rom">Not loaded</div>
            </div>
            
            <div class="rom-section">
                <h4>128K ROM (Optional)</h4>
                <div class="rom-buttons">
                    <button id="btnSelect128Rom">Select 128.rom</button>
                </div>
                <div class="rom-status" id="status128Rom">Not loaded</div>
            </div>
            
            <div class="rom-section">
                <h4>Pentagon ROM (Optional)</h4>
                <div class="rom-buttons">
                    <button id="btnSelectPentagonRom">Select pentagon.rom</button>
                </div>
                <div class="rom-status" id="statusPentagonRom">Not loaded</div>
            </div>

            <div class="rom-section">
                <h4>TR-DOS ROM (Required for disk images)</h4>
                <div class="rom-buttons">
                    <button id="btnSelectTrdosRom">Select trdos.rom</button>
                </div>
                <div class="rom-status" id="statusTrdosRom">Not loaded (required for TRD/SCL disk images)</div>
            </div>

            <div class="modal-actions">
                <button id="btnStartEmulator" class="primary" disabled>Start Emulator</button>
            </div>
            
            <p class="modal-hint">
                You can also drag & drop ROM files onto this dialog.
            </p>
        </div>
    </div>

    <!-- ZIP File Selection Modal -->
    <div id="zipModal" class="modal-overlay hidden">
        <div class="modal">
            <h2>Select File to Load</h2>
            <p>The archive contains multiple files. Select one to load:</p>
            <div id="zipFileList" class="zip-file-list"></div>
            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                <button id="btnBootTrdos" class="secondary" style="display: none;">Boot TR-DOS</button>
                <button id="btnZipCancel" class="secondary">Cancel</button>
            </div>
        </div>
    </div>

    <style>
        .zip-file-list {
            max-height: 300px;
            overflow-y: auto;
            margin: 15px 0;
        }
        .zip-file-item {
            padding: 10px 15px;
            margin: 5px 0;
            background: #2a2a3a;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .zip-file-item:hover {
            background: #3a3a4a;
        }
        .zip-file-name {
            color: var(--cyan);
        }
        .zip-file-type {
            color: #888;
            font-size: 12px;
            text-transform: uppercase;
            min-width: 50px;
        }
        .zip-file-info {
            color: #666;
            font-size: 11px;
            font-family: monospace;
        }
    </style>

    <div class="container">
        <div class="top-bar">
            <select id="machineSelect" class="toolbar-select">
                <option value="48k">ZX Spectrum 48K</option>
                <option value="128k">ZX Spectrum 128K</option>
                <option value="pentagon">Pentagon 128K</option>
            </select>
            <button id="btnLoadFile" class="toolbar-btn">Load</button>
            <button id="btnSaveSnapshot" class="toolbar-btn">Save</button>
            <button id="btnSaveProject" class="toolbar-btn" title="Save project (state + debugger)">Project▼</button>
            <button id="btnLoadProject" class="toolbar-btn" title="Load project">Project▲</button>
            <input type="file" id="projectFileInput" class="file-input" accept=".zxproj,.json">
            <span class="app-name">ZX-M8XXX v0.6.3</span>
            <button id="btnHelpFull" class="test-link" title="Open help documentation">Help</button>
            <button id="themeToggle" class="theme-btn" title="Toggle light/dark theme">☀️</button>
        </div>
        
        <div class="main-layout">
        <div class="emulator-section">
        <div class="screen-container">
            <div class="screen-wrapper">
                <canvas id="screen" width="320" height="240"></canvas>
                <canvas id="overlayCanvas" width="320" height="240"></canvas>
                <div id="spriteRegionOverlay" class="sprite-region-overlay"></div>
            </div>
            <div id="screenInfoPopup" class="screen-info-popup hidden"></div>
            <div id="xrefTooltip" class="xref-tooltip"></div>
        </div>

        <div class="status">
            <span class="status-item">
                <span class="status-label">Status:</span>
                <span class="status-value" id="status">Stopped</span>
            </span>
            <span class="status-item">
                <span class="status-label">FPS:</span>
                <span class="status-value" id="fps">0</span>
            </span>
            <span class="status-item">
                <span class="status-label">Machine:</span>
                <span class="status-value" id="machine">48K</span>
            </span>
            <span class="status-item" id="rzxInfo" style="display:none;">
                <span class="status-label">RZX:</span>
                <span class="status-value" id="rzxStatus">-</span>
                <button id="btnRzxStop" class="small-btn" title="Stop RZX playback">Stop</button>
            </span>
            <span class="status-item" id="fileInfo" style="display:none;">
                <span class="status-label">File:</span>
                <span class="status-value" id="filename">-</span>
            </span>
        </div>
        
        <div class="controls">
            <button id="btnRun" class="primary">Run</button>
            <button id="btnReset">Reset</button>
            <select id="speedSelect">
                <option value="10">10%</option>
                <option value="25">25%</option>
                <option value="50">50%</option>
                <option value="75">75%</option>
                <option value="100" selected>100%</option>
                <option value="200">200%</option>
                <option value="400">400%</option>
                <option value="0">Max</option>
            </select>
        </div>
        <input type="file" id="rom48Input" class="file-input" accept=".rom,.bin">
        <input type="file" id="rom128Input" class="file-input" accept=".rom,.bin">
        <input type="file" id="romPentagonInput" class="file-input" accept=".rom,.bin">
        <input type="file" id="romTrdosInput" class="file-input" accept=".rom,.bin">
        <input type="file" id="fileInput" class="file-input" accept=".sna,.tap,.z80,.zip,.rzx,.trd,.scl">
        </div><!-- emulator-section -->

        <!-- Tab Container -->
        <div class="tab-container" id="tabContainer">
            <div class="tab-bar">
                <button class="tab-btn active" data-tab="debugger"><span class="arrow">▶</span>Debug</button>
                <button class="tab-btn" data-tab="assembler"><span class="arrow">▶</span>ASM</button>
                <button class="tab-btn" data-tab="opcodes"><span class="arrow">▶</span>Opcodes</button>
                <button class="tab-btn" data-tab="graphics"><span class="arrow">▶</span>GFX</button>
                <button class="tab-btn" data-tab="info"><span class="arrow">▶</span>Info</button>
                <button class="tab-btn" data-tab="settings"><span class="arrow">▶</span>Settings</button>
                <button class="tab-btn" data-tab="calculator"><span class="arrow">▶</span>Calc</button>
            </div>

            <!-- Debugger Tab -->
            <div class="tab-content active" id="tab-debugger">
            <div class="debugger-container">
            <div class="debugger-panel open" id="debuggerPanel">
                <div class="main-debug-row">
                    <div class="debugger-section disasm-panel">
                        <div class="memory-header">
                            <h4></h4>
                            <div class="memory-controls">
                                <input type="text" id="disasmAddress" placeholder="0000" maxlength="4" value="">
                                <button id="btnDisasmGo">Go</button>
                                <button id="btnDisasmPC">PC</button>
                                <button id="btnDisasmPgUp">▲</button>
                                <button id="btnDisasmPgDn">▼</button>
                                <label class="disasm-option"><input type="checkbox" id="chkShowTstates">T-states</label>
                                <button id="btnDisasmExport" title="Export visible disassembly">Export</button>
                                <button id="btnDisasmExportRange" title="Export address range">Export...</button>
                            </div>
                        </div>
                        <div class="disassembly-view" id="disassemblyView"></div>
                        <div class="bookmarks-bar" id="disasmBookmarks">
                            <span class="bookmarks-label">Bookmarks:</span>
                            <button class="bookmark-btn" data-index="0" title="Click: go, Right-click: set">-</button>
                            <button class="bookmark-btn" data-index="1" title="Click: go, Right-click: set">-</button>
                            <button class="bookmark-btn" data-index="2" title="Click: go, Right-click: set">-</button>
                            <button class="bookmark-btn" data-index="3" title="Click: go, Right-click: set">-</button>
                            <button class="bookmark-btn" data-index="4" title="Click: go, Right-click: set">-</button>
                        </div>
                        <div class="debugger-controls">
                            <button id="btnStepInto" title="Step Into (F7)">Step Into</button>
                            <button id="btnStepOver" title="Step Over (F8)">Step Over</button>
                            <button id="btnRunTo" title="Run to Cursor (F4)">To Cursor</button>
                            <button id="btnRunToInt" title="Run to INT">To INT</button>
                            <button id="btnRunToRet" title="Run to RET">To RET</button>
                            <input type="text" id="tstatesInput" class="tstates-input" placeholder="T" maxlength="8" value="1000">
                            <button id="btnRunTstates" title="Run T-States">Tstates</button>
                            <label style="margin-left: 8px; font-size: 11px;"><input type="checkbox" id="chkAutoComment"> comm</label>
                            <label style="margin-left: 8px; font-size: 11px;"><input type="checkbox" id="chkFollowPC" checked> follow</label>
                        </div>
                    </div>
                    <div class="right-column">
                        <div class="registers-row">
                            <div class="reg-group">
                                <h4>Regs</h4>
                                <div class="registers-grid" id="mainRegisters"></div>
                                <div class="registers-grid" id="altRegisters"></div>
                                <div class="registers-grid" id="ixiyRegisters"></div>
                            </div>
                            <div class="reg-group">
                                <h4>System</h4>
                                <div class="registers-grid" id="indexRegisters"></div>
                                <div class="registers-grid" id="statusRegisters"></div>
                                <div class="flags-label">Flags</div>
                                <div class="flags-display" id="flagsDisplay"></div>
                            </div>
                            <div class="stack-pages-row">
                                <div class="reg-group">
                                    <h4>Stack</h4>
                                    <div class="stack-view" id="stackView"></div>
                                </div>
                                <div class="reg-group" id="pagesGroup" style="display: none;">
                                    <h4>Pages</h4>
                                    <div class="registers-grid vertical" id="pagesInfo"></div>
                                </div>
                            </div>
                        </div>
                        <div class="memory-section memory-panel">
                            <div class="memory-header">
                                <h4></h4>
                                <div class="memory-controls">
                                    <input type="text" id="memoryAddress" placeholder="0000" maxlength="4" value="0000">
                                    <button id="btnMemoryGo">Go</button>
                                    <button id="btnMemoryPC">PC</button>
                                    <button id="btnMemorySP">SP</button>
                                    <button id="btnMemoryHL">HL</button>
                                    <button id="btnMemoryPgUp">▲</button>
                                    <button id="btnMemoryPgDn">▼</button>
                                    <button id="btnMemorySnap" title="Snapshot memory for diff">Snap</button>
                                    <button id="btnMemoryClearSnap" title="Clear snapshot" style="display:none">Clear</button>
                                    <label class="memory-option"><input type="checkbox" id="chkRomEdit">Edit ROM</label>
                                </div>
                            </div>
                            <div class="memory-view" id="memoryView" style="max-height: 405px; overflow: hidden;"></div>
                            <div class="bookmarks-bar" id="memoryBookmarks">
                                <span class="bookmarks-label">Bookmarks:</span>
                                <button class="bookmark-btn" data-index="0" title="Click: go, Right-click: set">-</button>
                                <button class="bookmark-btn" data-index="1" title="Click: go, Right-click: set">-</button>
                                <button class="bookmark-btn" data-index="2" title="Click: go, Right-click: set">-</button>
                                <button class="bookmark-btn" data-index="3" title="Click: go, Right-click: set">-</button>
                                <button class="bookmark-btn" data-index="4" title="Click: go, Right-click: set">-</button>
                            </div>
                            <div class="memory-search inline">
                                <div class="search-row">
                                    <span class="search-label">Search:</span>
                                    <input type="text" id="memSearchInput">
                                    <select id="memSearchType">
                                        <option value="hex">Hex</option>
                                        <option value="dec">Dec</option>
                                        <option value="text">Text</option>
                                    </select>
                                    <button id="btnMemSearch">Find</button>
                                    <button id="btnMemSearchNext">Next</button>
                                    <div class="search-options">
                                        <label class="search-option"><input type="checkbox" id="chkSearchCase"> Case</label>
                                        <label class="search-option"><input type="checkbox" id="chkSearch7bit"> +128</label>
                                    </div>
                                </div>
                                <div class="search-results" id="searchResults"></div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="panel-tabs">
                    <div class="panel-tab-bar">
                        <button class="panel-tab-btn active" data-panel="breakpoints">Breakpoints</button>
                        <button class="panel-tab-btn" data-panel="labels">Labels</button>
                        <button class="panel-tab-btn" data-panel="watches">Watches</button>
                        <button class="panel-tab-btn" data-panel="tools">Tools</button>
                    </div>
                    <!-- Breakpoints Panel -->
                    <div class="panel-tab-content active" id="panel-breakpoints">
                        <div class="bp-add-form" style="margin-bottom: 5px;">
                            <select id="triggerType" title="Trigger type">
                                <option value="exec">Exec</option>
                                <option value="read">Read</option>
                                <option value="write">Write</option>
                                <option value="rw">R/W</option>
                                <option value="port_in">Port IN</option>
                                <option value="port_out">Port OUT</option>
                                <option value="port_io">Port I/O</option>
                            </select>
                            <input type="text" id="triggerAddrInput" placeholder="ADDR" maxlength="15" title="Examples: 4000, 4000-4FFF, 5:C000, FE&FF">
                            <input type="text" id="triggerCondInput" placeholder="if..." maxlength="30" title="Condition: A==0, val==FF, port&FE==FE">
                            <input type="number" id="triggerSkipInput" placeholder="skip" min="0" value="0" title="Skip count: number of hits to skip before breaking" style="width: 45px;">
                            <button id="btnAddTrigger">+</button>
                            <button id="btnClearTriggers">Clear</button>
                        </div>
                        <div class="breakpoint-list trigger-list" id="triggerList">
                            <div class="no-breakpoints">No breakpoints</div>
                        </div>
                    </div>
                    <!-- Labels Panel -->
                    <div class="panel-tab-content" id="panel-labels">
                        <div class="bp-add-form" style="margin-bottom: 5px;">
                            <select id="labelDisplayMode" class="disasm-select" title="Label display mode">
                                <option value="addr">Addr</option>
                                <option value="label">Label</option>
                                <option value="both" selected>Both</option>
                            </select>
                            <label class="rom-labels-toggle" title="Show ROM labels"><input type="checkbox" id="chkShowRomLabels" checked>ROM</label>
                            <input type="text" id="labelFilterInput" placeholder="Filter..." maxlength="20" style="width: 80px;">
                            <button id="btnAddLabel" title="Add label">+</button>
                            <button id="btnExportLabels" title="Export labels to file">Export</button>
                            <button id="btnImportLabels" title="Import labels from file">Import</button>
                            <button id="btnClearLabels" title="Clear user labels">Clear</button>
                            <input type="file" id="labelFileInput" accept=".json,.txt" style="display:none">
                        </div>
                        <div class="breakpoint-list labels-list" id="labelsList">
                            <div class="no-breakpoints">No labels</div>
                        </div>
                    </div>
                    <!-- Watches Panel -->
                    <div class="panel-tab-content" id="panel-watches">
                        <div class="watches-controls">
                            <input type="text" id="watchAddrInput" placeholder="[P:]Addr" maxlength="7" title="Address (hex), e.g. 4000 or 5:C000">
                            <input type="text" id="watchNameInput" placeholder="Name" maxlength="16" title="Watch name (optional)">
                            <button id="btnWatchAdd" title="Add watch (max 10)">+</button>
                            <button id="btnWatchClear" title="Clear all watches">Clear</button>
                        </div>
                        <div class="watches-list" id="watchesList"></div>
                    </div>
                    <!-- Tools Panel -->
                    <div class="panel-tab-content" id="panel-tools">
                        <div class="tools-row">
                            <span class="search-label">POKE:</span>
                            <button id="btnPokeSnap" title="Take snapshot">Snap</button>
                            <select id="pokeSearchMode">
                                <option value="dec1">-1</option>
                                <option value="inc1">+1</option>
                                <option value="decreased">Decreased</option>
                                <option value="increased">Increased</option>
                                <option value="changed">Changed</option>
                                <option value="unchanged">Unchanged</option>
                                <option value="equals">Equals</option>
                            </select>
                            <input type="text" id="pokeSearchValue" placeholder="Val" maxlength="5" style="width:40px;display:none">
                            <button id="btnPokeSearch" title="Search candidates">Search</button>
                            <button id="btnPokeReset" title="Reset search">Reset</button>
                            <span id="pokeStatus" class="poke-status"></span>
                            <div class="poke-results" id="pokeResults"></div>
                        </div>
                        <div class="tools-row">
                            <span class="search-label">Auto-Map:</span>
                            <label class="search-option"><input type="checkbox" id="chkAutoMap"> Track</label>
                            <button id="btnAutoMapApply" title="Apply tracked regions">Apply</button>
                            <button id="btnAutoMapClear" title="Clear tracking data">Clear</button>
                            <span id="autoMapStats" class="automap-stats"></span>
                            <button id="btnClearRegions" title="Clear all marked regions">Clr Regions</button>
                            <button id="btnMemoryMap" title="Show memory map visualization">Map</button>
                        </div>
                        <div class="tools-row">
                            <span class="search-label">XRefs:</span>
                            <button id="btnXrefScan" title="Scan visible range for cross-references">Scan</button>
                            <button id="btnXrefScanAll" title="Scan full 64KB memory">Scan All</button>
                            <button id="btnXrefClear" title="Clear all cross-references">Clear</button>
                            <label class="search-option"><input type="checkbox" id="chkXrefRuntime"> Runtime</label>
                            <span id="xrefStats" class="automap-stats"></span>
                        </div>
                        <div class="tools-row">
                            <span class="search-label">Trace:</span>
                            <label class="search-option"><input type="checkbox" id="chkTraceEnabled" checked> Step</label>
                            <label class="search-option"><input type="checkbox" id="chkTraceRuntime"> Runtime</label>
                            <button id="btnTraceBack" title="Step back in history (Alt+←)">◀</button>
                            <button id="btnTraceForward" title="Step forward in history (Alt+→)">▶</button>
                            <button id="btnTraceLive" title="Return to live view">Live</button>
                            <button id="btnTraceClear" title="Clear trace history">Clear</button>
                            <span id="traceStatus" class="automap-stats"></span>
                        </div>
                        <div class="tools-row">
                            <span class="search-label">Text:</span>
                            <button id="btnTextScan" title="Scan memory for text strings">Scan</button>
                            <select id="textScanMode" title="Scan mode">
                                <option value="all">All strings</option>
                                <option value="dict">Dictionary</option>
                                <option value="custom">Custom</option>
                            </select>
                            <input type="text" id="textScanCustom" placeholder="Search text..." style="width:80px;display:none">
                            <label class="search-option" title="Minimum string length"><input type="number" id="textScanMinLen" value="4" min="2" max="20" style="width:35px"> min</label>
                            <label class="search-option" title="Include ROM area (0000-3FFF)"><input type="checkbox" id="textScanROM"> ROM</label>
                            <label class="search-option" title="Scan all 128K RAM banks"><input type="checkbox" id="textScanAllBanks"> All banks</label>
                            <select id="textScanMax" title="Max results to show">
                                <option value="10">10</option>
                                <option value="25">25</option>
                                <option value="50">50</option>
                                <option value="100">100</option>
                                <option value="0">All</option>
                            </select>
                            <span id="textScanStatus" class="automap-stats"></span>
                        </div>
                        <div class="tools-row" id="textScanPagination" style="display:none">
                            <button id="textScanPrev" title="Previous page">&lt;</button>
                            <span id="textScanPage">Page 1/1</span>
                            <button id="textScanNext" title="Next page">&gt;</button>
                        </div>
                        <div class="text-scan-results" id="textScanResults"></div>
                        <div class="trace-list" id="traceList"></div>
                    </div>
                </div>
            </div><!-- debugger-panel -->
        </div><!-- debugger-container -->
        </div><!-- tab-debugger -->

        <!-- Assembler Tab -->
        <div class="tab-content" id="tab-assembler">
            <div class="assembler-container">
                <div class="assembler-header">
                    <div class="assembler-controls">
                        <div class="asm-files-dropdown">
                            <button id="btnAsmFiles" title="Browse project files" disabled>Files ▼</button>
                            <div class="asm-files-list" id="asmFilesList"></div>
                        </div>
                        <button id="btnAsmAssemble" title="Assemble code (F9)" disabled>Assemble</button>
                        <button id="btnAsmInject" title="Inject assembled code to memory" disabled>Inject</button>
                        <button id="btnAsmDebug" title="Inject code and start debugging at entry point" disabled>Debug</button>
                        <button id="btnAsmClear" title="Clear all">Clear</button>
                        <button id="btnAsmNew" title="Create new file">New</button>
                        <button id="btnAsmLoad" title="Load files (ASM, ZIP, binary)">Load</button>
                        <button id="btnAsmExport" title="Export all source files as ZIP" style="display:none">Export</button>
                        <button id="btnAsmDownload" title="Download generated files (.bin, .sna, .tap, .trd)" disabled>Download</button>
                        <input type="file" id="asmFileInput" accept=".asm,.z80,.s,.a80,.inc,.bin,.scr,.tap,.zip" multiple style="display:none">
                        <label class="asm-option"><input type="checkbox" id="chkAsmUnusedLabels"> Unused labels</label>
                        <label class="asm-option"><input type="checkbox" id="chkAsmShowCompiled"> Show compiled</label>
                        <label class="asm-option asm-defines-label" title="Command-line defines for IFDEF/IFNDEF (e.g., DEBUG,VERSION=5)">Defines: <input type="text" id="asmDefines" placeholder="NAME,NAME=value" spellcheck="false"></label>
                        <select id="asmDetectedDefines" multiple size="1" title="Defines from @define markers in source (click to toggle)" style="display:none"></select>
                        <span id="asmMainFileLabel" class="asm-main-label" style="display:none" title="Click to change main file"></span>
                    </div>
                </div>
                <div class="assembler-body">
                    <div class="asm-editor-container">
                        <div class="asm-file-tabs" id="asmFileTabs"></div>
                        <div class="asm-search-bar" id="asmSearchBar" style="display:none">
                            <div class="asm-search-row">
                                <input type="text" id="asmSearchInput" placeholder="Find (Ctrl+F)" spellcheck="false">
                                <button id="btnAsmFindPrev" title="Find Previous (Shift+F3)">▲</button>
                                <button id="btnAsmFindNext" title="Find Next (F3)">▼</button>
                                <span id="asmSearchCount" class="asm-search-count"></span>
                                <label class="asm-search-option"><input type="checkbox" id="chkAsmSearchCase"> Case</label>
                                <button id="btnAsmSearchAll" title="Search in all project files">All Files</button>
                                <button id="btnAsmSearchClose" title="Close (Esc)">×</button>
                            </div>
                            <div class="asm-replace-row" id="asmReplaceRow" style="display:none">
                                <input type="text" id="asmReplaceInput" placeholder="Replace (Ctrl+R)" spellcheck="false">
                                <button id="btnAsmReplace" title="Replace">Replace</button>
                                <button id="btnAsmReplaceAll" title="Replace All">All</button>
                            </div>
                            <div class="asm-search-results" id="asmSearchResults" style="display:none"></div>
                        </div>
                        <div class="asm-editor-area">
                            <div class="asm-line-numbers" id="asmLineNumbers"></div>
                            <div class="asm-editor-wrap">
                                <pre class="asm-highlight" id="asmHighlight"></pre>
                                <textarea id="asmEditor" class="asm-textarea" spellcheck="false" placeholder="; Enter Z80 assembly code here
; Example:
        ORG $8000
start:
        LD A, 2
        OUT (254), A
        JP start"></textarea>
                            </div>
                        </div>
                    </div>
                    <div class="asm-output-container">
                        <div class="asm-output-header">Output</div>
                        <div class="asm-output" id="asmOutput"><span class="asm-hint">Press Assemble to compile</span></div>
                    </div>
                </div>
            </div>
        </div><!-- tab-assembler -->

        <!-- Opcodes Tab -->
        <div class="tab-content" id="tab-opcodes">
            <div class="opcodes-container">
                <div class="opcodes-header">
                    <h3>Z80 Instruction Set Reference</h3>
                    <div class="opcodes-filter">
                        <input type="text" id="opcodeSearch" placeholder="Search opcode..." class="opcode-search">
                        <select id="opcodeGroup">
                            <option value="all">All Groups</option>
                            <option value="load">Load (LD)</option>
                            <option value="arith">Arithmetic</option>
                            <option value="logic">Logic</option>
                            <option value="rotate">Rotate/Shift</option>
                            <option value="bit">Bit Operations</option>
                            <option value="jump">Jump/Call</option>
                            <option value="io">I/O</option>
                            <option value="block">Block</option>
                            <option value="misc">Misc</option>
                        </select>
                        <select id="opcodeCycles">
                            <option value="all">All T-states</option>
                        </select>
                        <select id="opcodeSort">
                            <option value="mnemonic">Sort: Mnemonic</option>
                            <option value="opcode">Sort: Opcode</option>
                        </select>
                    </div>
                </div>
                <div class="opcodes-body">
                    <table class="opcodes-table" id="opcodesTable">
                        <thead>
                            <tr>
                                <th>Mnemonic</th>
                                <th>Opcode</th>
                                <th>Size</th>
                                <th>Cycles</th>
                                <th>Flags</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody id="opcodesBody">
                        </tbody>
                    </table>
                </div>
                <div class="opcodes-footer">
                    <div class="flags-legend">
                        <span><b>Flags:</b></span>
                        <span>S=Sign</span>
                        <span>Z=Zero</span>
                        <span>H=Half-carry</span>
                        <span>P=Parity/Overflow</span>
                        <span>N=Subtract</span>
                        <span>C=Carry</span>
                        <span class="flag-symbol">*=affected</span>
                        <span class="flag-symbol">-=unchanged</span>
                        <span class="flag-symbol">0=reset</span>
                        <span class="flag-symbol">1=set</span>
                        <span class="flag-symbol">?=undefined</span>
                        <span style="color:#c080ff; margin-left:10px;"><b>*</b>=undocumented</span>
                    </div>
                </div>
            </div>
        </div><!-- tab-opcodes -->

        <!-- Graphics Viewer Tab -->
        <div class="tab-content" id="tab-graphics">
            <div class="graphics-container">
                <div class="graphics-body">
                    <div class="graphics-dump-wrap">
                        <canvas id="gfxDumpCanvas" class="graphics-dump-canvas"></canvas>
                    </div>
                    <div class="gfx-col-address">
                        <div class="gfx-control-group">
                            <label>Address</label>
                            <input type="text" id="gfxAddress" value="3000" maxlength="4" title="Memory address in hex (Enter to apply)">
                        </div>
                        <div class="gfx-control-group">
                            <label>Navigate</label>
                            <div class="gfx-nav-buttons">
                                <button id="btnGfxByte1" title="Back 1 byte">-1</button>
                                <button id="btnGfxByte2" title="Forward 1 byte">+1</button>
                            </div>
                            <div class="gfx-nav-buttons">
                                <button id="btnGfxLine1" title="Back 1 line">-Line</button>
                                <button id="btnGfxLine2" title="Forward 1 line">+Line</button>
                            </div>
                            <div class="gfx-nav-buttons">
                                <button id="btnGfxRow1" title="Back 8 lines">-Row</button>
                                <button id="btnGfxRow2" title="Forward 8 lines">+Row</button>
                            </div>
                            <div class="gfx-nav-buttons">
                                <button id="btnGfxSprite1" title="Previous sprite">-Spr</button>
                                <button id="btnGfxSprite2" title="Next sprite">+Spr</button>
                            </div>
                            <div class="gfx-nav-buttons">
                                <button id="btnGfxPage1" title="Back 24 rows (192 lines)">-Page</button>
                                <button id="btnGfxPage2" title="Forward 24 rows (192 lines)">+Page</button>
                            </div>
                        </div>
                        <div class="gfx-control-group">
                            <label>Width (bytes)</label>
                            <div class="gfx-spinner">
                                <button id="btnGfxWidthMin" title="Minimum width (1 byte)">|&lt;</button>
                                <button id="btnGfxWidthDec" title="Decrease width">-</button>
                                <input type="text" id="gfxWidth" value="24" maxlength="2" title="Sprite width in bytes (1-32)">
                                <button id="btnGfxWidthInc" title="Increase width">+</button>
                                <button id="btnGfxWidthMax" title="Maximum width (32 bytes)">&gt;|</button>
                            </div>
                        </div>
                        <div class="gfx-control-group">
                            <label>Height (lines)</label>
                            <div class="gfx-spinner">
                                <button id="btnGfxHeightDec8" title="Decrease height by 8 lines">-8</button>
                                <button id="btnGfxHeightDec" title="Decrease height">-</button>
                                <input type="text" id="gfxHeight" value="8" maxlength="2" title="Sprite height in lines (1-64)">
                                <button id="btnGfxHeightInc" title="Increase height">+</button>
                                <button id="btnGfxHeightInc8" title="Increase height by 8 lines">+8</button>
                            </div>
                        </div>
                        <div class="gfx-control-group gfx-checkboxes">
                            <label title="Invert colors (white on black)"><input type="checkbox" id="gfxInvert"> Invert</label>
                            <label title="Show pixel grid overlay"><input type="checkbox" id="gfxGrid" checked> Grid</label>
                            <label title="Character mode: 8x8 tiles stored sequentially"><input type="checkbox" id="gfxCharMode"> Char</label>
                            <div class="gfx-zoom-inline">
                                <label title="1:1 zoom"><input type="radio" name="gfxZoom" id="gfxZoom1" value="1"> x1</label>
                                <label title="2:1 zoom"><input type="radio" name="gfxZoom" id="gfxZoom2" value="2" checked> x2</label>
                                <label title="3:1 zoom"><input type="radio" name="gfxZoom" id="gfxZoom3" value="3"> x3</label>
                            </div>
                        </div>
                        <div class="gfx-control-group">
                            <label>Preview</label>
                            <div class="gfx-preview-wrap">
                                <canvas id="gfxPreviewCanvas" class="gfx-preview-canvas"></canvas>
                            </div>
                            <div class="gfx-info" id="gfxInfo">0000h: 8x8</div>
                        </div>
                    </div>
                    <div class="gfx-col-actions">
                        <div class="gfx-control-group">
                            <label>Comment</label>
                            <input type="text" id="gfxComment" placeholder="Sprite name..." maxlength="40" title="Label for the graphics region">
                        </div>
                        <div class="gfx-control-group gfx-actions">
                            <button id="btnGfxMarkRegion" title="Mark selected area as graphics region">Mark</button>
                            <button id="btnGfxCopyAsm" title="Copy selection as assembly DEFB statements">Copy</button>
                            <button id="btnGfxSaveAsm" title="Save selection as .asm file">Save</button>
                            <button id="btnGfxExportAll" title="Export all marked graphics regions">Export</button>
                        </div>
                        <div class="gfx-control-group gfx-actions">
                            <button id="btnGfxGoDisasm" title="Go to address in Disassembler">→Disasm</button>
                            <button id="btnGfxGoMem" title="Go to address in Memory view">→Memdump</button>
                        </div>
                    </div>
                </div>
            </div>
        </div><!-- tab-graphics -->

        <!-- Info Tab -->
        <div class="tab-content" id="tab-info">
            <div class="info-tab-content">
                <h3>ZX Spectrum Technical Reference</h3>

                <div class="keyboard-image">
                    <img src="keyboard.png" alt="ZX Spectrum Keyboard Layout">
                </div>

                <div class="info-section">
                    <h4>Frame Timing</h4>
                    <table class="info-table">
                        <thead>
                            <tr><th>Parameter</th><th>48K</th><th>128K</th><th>Pentagon</th></tr>
                        </thead>
                        <tbody>
                            <tr><td>T-states per line</td><td>224</td><td>228</td><td>224</td></tr>
                            <tr><td>Lines per frame</td><td>312</td><td>311</td><td>320</td></tr>
                            <tr><td>T-states per frame</td><td>69888</td><td>70908</td><td>71680</td></tr>
                            <tr><td>Frame rate (Hz)</td><td>50.08</td><td>50.02</td><td>48.83</td></tr>
                            <tr><td>CPU clock (MHz)</td><td>3.5</td><td>3.5469</td><td>3.5</td></tr>
                            <tr><td>First screen line</td><td>64</td><td>63</td><td>80</td></tr>
                            <tr><td>INT length (T)</td><td>32</td><td>32</td><td>32</td></tr>
                        </tbody>
                    </table>
                </div>

                <div class="info-section">
                    <h4>Border Sizes (pixels)</h4>
                    <table class="info-table">
                        <thead>
                            <tr><th>Border</th><th>48K</th><th>128K</th><th>Pentagon</th></tr>
                        </thead>
                        <tbody>
                            <tr><td>Top (lines)</td><td>64</td><td>63</td><td>80</td></tr>
                            <tr><td>Bottom (lines)</td><td>56</td><td>56</td><td>48</td></tr>
                            <tr><td>Left (pixels)</td><td>48</td><td>48</td><td>48</td></tr>
                            <tr><td>Right (pixels)</td><td>48</td><td>48</td><td>48</td></tr>
                            <tr><td>Total visible width</td><td>352</td><td>352</td><td>352</td></tr>
                            <tr><td>Total visible height</td><td>312</td><td>311</td><td>320</td></tr>
                        </tbody>
                    </table>
                </div>

                <div class="info-section">
                    <h4>Memory Map (128K/Pentagon)</h4>
                    <table class="info-table">
                        <thead>
                            <tr><th>Address</th><th>Content</th><th>Contention</th></tr>
                        </thead>
                        <tbody>
                            <tr><td>0000-3FFF</td><td>ROM (Bank 0 or 1)</td><td>No</td></tr>
                            <tr><td>4000-7FFF</td><td>RAM Bank 5 (Screen)</td><td class="contended">Yes (always)</td></tr>
                            <tr><td>8000-BFFF</td><td>RAM Bank 2</td><td>No</td></tr>
                            <tr><td>C000-FFFF</td><td>RAM Bank 0-7 (paged)</td><td>Odd banks only</td></tr>
                        </tbody>
                    </table>
                </div>

                <div class="info-section">
                    <h4>RAM Banks (128K)</h4>
                    <table class="info-table">
                        <thead>
                            <tr><th>Bank</th><th>Contended</th><th>Notes</th></tr>
                        </thead>
                        <tbody>
                            <tr><td>0</td><td>No</td><td>Default at C000</td></tr>
                            <tr><td>1</td><td class="contended">Yes</td><td></td></tr>
                            <tr><td>2</td><td>No</td><td>Always at 8000</td></tr>
                            <tr><td>3</td><td class="contended">Yes</td><td></td></tr>
                            <tr><td>4</td><td>No</td><td></td></tr>
                            <tr><td>5</td><td class="contended">Yes</td><td>Always at 4000 (screen 0)</td></tr>
                            <tr><td>6</td><td>No</td><td></td></tr>
                            <tr><td>7</td><td class="contended">Yes</td><td>Screen 1 (when selected)</td></tr>
                        </tbody>
                    </table>
                </div>

                <div class="info-section">
                    <h4>Contention Pattern</h4>
                    <p><strong>48K:</strong> Screen lines use 192 T-states for drawing. Memory contention occurs when CPU accesses 4000-7FFF during screen drawing (lines 64-255, T-states 14-126).</p>
                    <p><strong>128K:</strong> Screen lines use 196 T-states for drawing (228 total per line).</p>
                    <p>Pattern repeats every 8 T-states: <code>6, 5, 4, 3, 2, 1, 0, 0</code> (delay in T-states)</p>
                    <p>I/O contention: ULA port (xxFE) also causes delays when accessed during screen time.</p>
                </div>

                <div class="info-section">
                    <h4>Border/Attribute Colors</h4>
                    <table class="info-table">
                        <thead>
                            <tr><th>Value</th><th>Color</th><th>Bright</th></tr>
                        </thead>
                        <tbody>
                            <tr><td>0</td><td style="color:#000">Black</td><td style="color:#000">Black</td></tr>
                            <tr><td>1</td><td style="color:#0000D7">Blue</td><td style="color:#0000FF">Bright Blue</td></tr>
                            <tr><td>2</td><td style="color:#D70000">Red</td><td style="color:#FF0000">Bright Red</td></tr>
                            <tr><td>3</td><td style="color:#D700D7">Magenta</td><td style="color:#FF00FF">Bright Magenta</td></tr>
                            <tr><td>4</td><td style="color:#00D700">Green</td><td style="color:#00FF00">Bright Green</td></tr>
                            <tr><td>5</td><td style="color:#00D7D7">Cyan</td><td style="color:#00FFFF">Bright Cyan</td></tr>
                            <tr><td>6</td><td style="color:#D7D700">Yellow</td><td style="color:#FFFF00">Bright Yellow</td></tr>
                            <tr><td>7</td><td style="color:#D7D7D7">White</td><td style="color:#FFFFFF">Bright White</td></tr>
                        </tbody>
                    </table>
                    <p>Border: bits 0-2 of port #FE. Attributes: INK (bits 0-2), PAPER (bits 3-5), BRIGHT (bit 6), FLASH (bit 7).</p>
                </div>

                <div class="info-section">
                    <h4>Pentagon Differences</h4>
                    <ul>
                        <li>No memory or I/O contention</li>
                        <li>320 lines per frame (more top border)</li>
                        <li>TR-DOS ROM pages in/out via 3Dxx trigger</li>
                        <li>Beta Disk interface at ports 1F, 3F, 5F, 7F, FF</li>
                    </ul>
                </div>
            </div>
        </div><!-- tab-info -->

        <!-- Settings Tab -->
        <div class="tab-content" id="tab-settings">
            <div class="settings-tab-content">
                <h3>Emulator Settings</h3>

                <div class="settings-section">
                    <h4>Input</h4>
                    <div class="settings-row">
                        <label class="checkbox-label">
                            <input type="checkbox" id="chkKempston"> Kempston Joystick (Numpad)
                        </label>
                    </div>
                </div>

                <div class="settings-section">
                    <h4>Display</h4>
                    <div class="settings-row">
                        <label class="checkbox-label" title="Show full hardware border (all scanlines)">
                            <input type="checkbox" id="chkFullBorder" checked> Full Border
                        </label>
                        <label class="checkbox-label" title="Invert screen colors" style="margin-left: 15px;">
                            <input type="checkbox" id="chkInvertDisplay"> Invert
                        </label>
                        <button id="btnOverlay" class="control-btn" style="margin-left: 15px;" title="Cycle overlay modes: Normal → Grid → Box → Screen → Reveal → Beam → BeamScreen">Normal</button>
                        <span class="zoom-group" style="margin-left: 15px;">
                            Zoom:
                            <button id="zoom1" class="zoom-btn active">x1</button>
                            <button id="zoom2" class="zoom-btn">x2</button>
                            <button id="zoom3" class="zoom-btn">x3</button>
                        </span>
                    </div>
                    <div class="settings-row">
                        <label for="paletteSelect">Color Palette:</label>
                        <select id="paletteSelect">
                            <option value="default">Default</option>
                        </select>
                    </div>
                    <div class="palette-preview" id="palettePreview">
                        <div class="palette-row">
                            <span class="palette-row-label">Normal</span>
                            <span class="palette-color" data-index="0"></span>
                            <span class="palette-color" data-index="1"></span>
                            <span class="palette-color" data-index="2"></span>
                            <span class="palette-color" data-index="3"></span>
                            <span class="palette-color" data-index="4"></span>
                            <span class="palette-color" data-index="5"></span>
                            <span class="palette-color" data-index="6"></span>
                            <span class="palette-color" data-index="7"></span>
                        </div>
                        <div class="palette-row">
                            <span class="palette-row-label">Bright</span>
                            <span class="palette-color" data-index="8"></span>
                            <span class="palette-color" data-index="9"></span>
                            <span class="palette-color" data-index="10"></span>
                            <span class="palette-color" data-index="11"></span>
                            <span class="palette-color" data-index="12"></span>
                            <span class="palette-color" data-index="13"></span>
                            <span class="palette-color" data-index="14"></span>
                            <span class="palette-color" data-index="15"></span>
                        </div>
                    </div>
                </div>

                <div class="settings-section full-width">
                    <h4>Export</h4>
                    <div class="settings-row">
                        <button id="btnScreenshot" title="Save current screen as PNG">Screenshot</button>
                    </div>
                    <div class="settings-row">
                        <label for="frameExportFormat">Format:</label>
                        <select id="frameExportFormat">
                            <option value="zip">ZIP (PNG sequence)</option>
                            <option value="gif">Animated GIF</option>
                            <option value="scr">SCR (screen only)</option>
                            <option value="bsc">BSC (with border)</option>
                            <option value="sca">SCA (animation)</option>
                        </select>
                        <label for="maxFrames" style="min-width: auto; margin-left: 10px; margin-right: -6px;">Max:</label>
                        <input type="number" id="maxFrames" value="0" min="0" style="width: 50px;">
                        <span style="color: var(--text-secondary); font-size: 11px;">(0=∞)</span>
                    </div>
                    <div class="settings-row" id="sizeRow">
                        <label for="frameExportSize">Size:</label>
                        <select id="frameExportSize">
                            <option value="screen">Screen only (256×192)</option>
                            <option value="normal">Normal border</option>
                            <option value="full">Full border</option>
                            <option value="sprite-pixels">Sprite (pixels)</option>
                            <option value="sprite-cells">Sprite (cells 8×8)</option>
                        </select>
                    </div>
                    <div class="settings-row sprite-region-row" id="spriteRegionRow" style="display: none;">
                        <span class="sprite-input-group"><label id="spriteLabelX">X:</label><input type="number" id="spriteX" value="0" min="0" max="255"></span>
                        <span class="sprite-input-group"><label id="spriteLabelY">Y:</label><input type="number" id="spriteY" value="0" min="0" max="191"></span>
                        <span class="sprite-input-group"><label id="spriteLabelW">W:</label><input type="number" id="spriteW" value="16" min="1" max="256"></span>
                        <span class="sprite-input-group"><label id="spriteLabelH">H:</label><input type="number" id="spriteH" value="16" min="1" max="192"></span>
                    </div>
                    <div class="settings-row frame-export-controls">
                        <button id="btnFrameGrabStart" class="frame-grab-btn">Start</button>
                        <button id="btnFrameGrabStop" class="frame-grab-btn" disabled>Stop</button>
                        <button id="btnFrameGrabCancel" class="frame-grab-btn" disabled>Cancel</button>
                    </div>
                    <div class="frame-grab-status" id="frameGrabStatus"></div>
                </div>

                <div class="settings-section">
                    <h4>Tools</h4>
                    <div class="settings-row">
                        <a href="system-test.html" class="test-link" title="Run system tests">System Tests</a>
                        <a href="fuse-test.html" class="test-link" title="Run FUSE Z80 CPU tests">FUSE Tests</a>
                        <a href="asm-test.html" class="test-link" title="Run assembler tests">Assembler Tests</a>
                    </div>
                </div>
            </div>
        </div><!-- tab-settings -->

        <!-- Calculator Tab -->
        <div class="tab-content" id="tab-calculator">
            <div class="calc-wrapper">
            <div class="calc-container">
                <div class="calc-display">
                    <div class="calc-input-row">
                        <select id="calcInputBase" class="calc-base-select">
                            <option value="16">HEX</option>
                            <option value="10">DEC</option>
                            <option value="8">OCT</option>
                            <option value="2">BIN</option>
                        </select>
                        <input type="text" id="calcInput" class="calc-input" value="0" spellcheck="false">
                    </div>
                    <div class="calc-output-row">
                        <span class="calc-label dec">DEC</span>
                        <span class="calc-value" id="calcDec">0</span>
                        <span class="calc-signed" id="calcSigned"></span>
                    </div>
                    <div class="calc-output-row">
                        <span class="calc-label hex">HEX</span>
                        <span class="calc-value" id="calcHex">0</span>
                    </div>
                    <div class="calc-output-row">
                        <span class="calc-label oct">OCT</span>
                        <span class="calc-value" id="calcOct">0</span>
                    </div>
                    <div class="calc-output-row">
                        <span class="calc-label bin">BIN</span>
                        <span class="calc-value bin-value" id="calcBin">0</span>
                    </div>
                    <div class="calc-output-row ascii-row">
                        <span class="calc-label ascii">ASCII</span>
                        <span class="calc-value" id="calcAscii"></span>
                    </div>
                </div>
                <div class="calc-buttons">
                    <div class="calc-row">
                        <button class="calc-btn mode" id="calcBitSize" title="Toggle bit size (8/16/32 bits)">u16</button>
                        <button class="calc-btn op" data-op="and" title="Bitwise AND: A and B">and</button>
                        <button class="calc-btn op" data-op="or" title="Bitwise OR: A or B">or</button>
                        <button class="calc-btn op" data-op="not" title="Bitwise NOT: invert all bits">not</button>
                        <button class="calc-btn op" data-op="xor" title="Bitwise XOR: A xor B">xor</button>
                    </div>
                    <div class="calc-row">
                        <button class="calc-btn func" data-op="inc" title="Increment: add 1">inc</button>
                        <button class="calc-btn func" data-op="dec" title="Decrement: subtract 1">dec</button>
                        <button class="calc-btn func" data-op="lsl" title="Logical Shift Left: shift bits left, fill with 0">lsl</button>
                        <button class="calc-btn func" data-op="lsr" title="Logical Shift Right: shift bits right, fill with 0">lsr</button>
                        <button class="calc-btn func" data-op="asr" title="Arithmetic Shift Right: shift right, preserve sign bit">asr</button>
                        <button class="calc-btn func" data-op="rand" title="Random: generate random number">rand</button>
                    </div>
                    <div class="calc-row">
                        <button class="calc-btn paren" data-char="(">(</button>
                        <button class="calc-btn paren" data-char=")">)</button>
                        <button class="calc-btn func" data-op="rol" title="Rotate Left: shift left, top bit wraps to bottom">rol</button>
                        <button class="calc-btn func" data-op="ror" title="Rotate Right: shift right, bottom bit wraps to top">ror</button>
                        <button class="calc-btn op" data-op="mod" title="Modulo: remainder after division">mod</button>
                        <button class="calc-btn op" data-op="/" title="Divide: integer division">/</button>
                    </div>
                    <div class="calc-row">
                        <button class="calc-btn hex-digit" data-char="A">A</button>
                        <button class="calc-btn hex-digit" data-char="B">B</button>
                        <button class="calc-btn digit" data-char="7">7</button>
                        <button class="calc-btn digit" data-char="8">8</button>
                        <button class="calc-btn digit" data-char="9">9</button>
                        <button class="calc-btn op" data-op="*" title="Multiply">*</button>
                    </div>
                    <div class="calc-row">
                        <button class="calc-btn hex-digit" data-char="C">C</button>
                        <button class="calc-btn hex-digit" data-char="D">D</button>
                        <button class="calc-btn digit" data-char="4">4</button>
                        <button class="calc-btn digit" data-char="5">5</button>
                        <button class="calc-btn digit" data-char="6">6</button>
                        <button class="calc-btn op" data-op="-" title="Subtract">-</button>
                    </div>
                    <div class="calc-row">
                        <button class="calc-btn hex-digit" data-char="E">E</button>
                        <button class="calc-btn hex-digit" data-char="F">F</button>
                        <button class="calc-btn digit" data-char="1">1</button>
                        <button class="calc-btn digit" data-char="2">2</button>
                        <button class="calc-btn digit" data-char="3">3</button>
                        <button class="calc-btn op" data-op="+" title="Add">+</button>
                    </div>
                    <div class="calc-row">
                        <button class="calc-btn clear" id="calcClear" title="Clear: reset to 0">C</button>
                        <button class="calc-btn clear" id="calcDel" title="Delete: remove last digit">DEL</button>
                        <button class="calc-btn digit" data-char="0">0</button>
                        <button class="calc-btn digit" data-char="0" id="calcDot" style="visibility:hidden">.</button>
                        <button class="calc-btn func" id="calcNegate" title="Negate: two's complement (flip sign)">+/-</button>
                        <button class="calc-btn equals" id="calcEquals" title="Equals: calculate result">=</button>
                    </div>
                </div>
                <div class="calc-bits-panel" id="calcBitsPanel">
                    <div class="calc-bits-labels" id="calcBitsLabels"></div>
                    <div class="calc-bits-grid" id="calcBitsGrid"></div>
                </div>
            </div>
            <div class="calc-log">
                <div class="calc-log-header">
                    <span>History</span>
                    <button id="calcLogClear" title="Clear history">&times;</button>
                </div>
                <div class="calc-log-content" id="calcLogContent"></div>
            </div>
            </div>
        </div><!-- tab-calculator -->

        </div><!-- tab-container -->
    </div><!-- main-layout -->

    <!-- Memory Map Dialog -->
    <div class="memmap-dialog hidden" id="memmapDialog">
        <div class="memmap-content">
            <div class="memmap-header">
                <button class="memmap-close" id="btnMemmapClose">Close</button>
            </div>
            <div class="memmap-body">
                <div class="memmap-scale">
                    <div class="memmap-scale-item"><span id="memmapRomLabel">ROM</span><span class="memmap-scale-addr">0000</span></div>
                    <div class="memmap-scale-item"><span>Bank 5</span><span class="memmap-scale-addr">4000</span></div>
                    <div class="memmap-scale-tick" style="top:182px"><span class="memmap-scale-addr">5B00</span></div>
                    <div class="memmap-scale-item"><span>Bank 2</span><span class="memmap-scale-addr">8000</span></div>
                    <div class="memmap-scale-item"><span id="memmapBankLabel">Bank 0</span><span class="memmap-scale-addr">C000</span></div>
                    <div class="memmap-scale-end"><span class="memmap-scale-addr">FFFF</span></div>
                </div>
                <div class="memmap-canvas-container">
                    <canvas id="memmapCanvas" width="512" height="512"></canvas>
                    <div class="memmap-tooltip" id="memmapTooltip"></div>
                </div>
                <div class="memmap-sidebar">
                    <div class="memmap-view-toggle" style="margin-bottom:8px">
                        <button class="memmap-view-btn active" id="btnMemmapRegions">Regions</button>
                        <button class="memmap-view-btn" id="btnMemmapHeatmap">Heatmap</button>
                    </div>
                    <div class="memmap-view-toggle" id="memmapBankToggle" style="display:none;margin-bottom:8px">
                        <button class="memmap-view-btn active" id="btnMemmap64K">64KB</button>
                        <button class="memmap-view-btn" id="btnMemmap128K">128KB</button>
                    </div>
                    <div class="memmap-legend" id="memmapLegendRegions">
                        <div class="memmap-legend-item"><div class="memmap-legend-color" style="background:#4080ff"></div>Code</div>
                        <div class="memmap-legend-item"><div class="memmap-legend-color" style="background:#ff4040"></div>SMC</div>
                        <div class="memmap-legend-item"><div class="memmap-legend-color" style="background:#ffcc00"></div>DB (bytes)</div>
                        <div class="memmap-legend-item"><div class="memmap-legend-color" style="background:#ff8800"></div>DW (words)</div>
                        <div class="memmap-legend-item"><div class="memmap-legend-color" style="background:#40cc40"></div>Text</div>
                        <div class="memmap-legend-item"><div class="memmap-legend-color" style="background:#cc40cc"></div>Graphics</div>
                        <div class="memmap-legend-item"><div class="memmap-legend-color" style="background:#606060"></div>Unmapped</div>
                        <div class="memmap-legend-item"><div class="memmap-legend-color" style="background:#000000;border:1px solid #444"></div>Zeroes</div>
                    </div>
                    <div class="memmap-legend hidden" id="memmapLegendHeatmap">
                        <div class="memmap-legend-item"><div class="memmap-legend-color" style="background:#0066ff"></div>Execute</div>
                        <div class="memmap-legend-item"><div class="memmap-legend-color" style="background:#00ff66"></div>Read</div>
                        <div class="memmap-legend-item"><div class="memmap-legend-color" style="background:#ff6600"></div>Write</div>
                        <div class="memmap-legend-item"><div class="memmap-legend-color" style="background:#ffffff"></div>Mixed (high)</div>
                        <div class="memmap-legend-item"><div class="memmap-legend-color" style="background:#000000;border:1px solid #444"></div>No access</div>
                        <div class="memmap-heatmap-scale">
                            <div>Low</div>
                            <div class="memmap-gradient"></div>
                            <div>High</div>
                        </div>
                    </div>
                    <div class="memmap-stats" id="memmapStats"></div>
                    <div class="memmap-bar" id="memmapBar"></div>
                    <div class="memmap-addr-info" id="memmapAddrInfo">Hover over map to see details<br>Click to navigate</div>
                    <h3 class="memmap-title">Memory Map (64KB)</h3>
                </div>
            </div>
        </div>
    </div>

    <!-- Keyboard Help Modal -->
    <div class="help-modal hidden" id="helpModal">
        <div class="help-modal-content">
            <div class="help-modal-header">
                <h3>Keyboard Mapping</h3>
                <button class="help-modal-close" id="btnHelpClose">×</button>
            </div>
            <table>
                <tr><td>A-Z, 0-9</td><td>Standard keys</td></tr>
                <tr><td>Shift</td><td>Caps Shift</td></tr>
                <tr><td>Ctrl</td><td>Symbol Shift</td></tr>
                <tr><td>Enter</td><td>Enter</td></tr>
                <tr><td>Space</td><td>Space / Break</td></tr>
                <tr><td>Backspace</td><td>Delete (Shift+0)</td></tr>
                <tr><td>Arrow Keys</td><td>Cursor keys (Shift+5/6/7/8)</td></tr>
                <tr><td colspan="2" class="help-section-header">Symbols (Ctrl + Key)</td></tr>
                <tr><td>Ctrl+0</td><td>_ (underscore)</td></tr>
                <tr><td>Ctrl+1-9</td><td>! @ # $ % &amp; ' ( )</td></tr>
                <tr><td>Ctrl+Letter</td><td>Various symbols (see Help)</td></tr>
                <tr><td colspan="2" class="help-section-header">Kempston Joystick (Numpad)</td></tr>
                <tr><td>Numpad 8/2/4/6</td><td>Up/Down/Left/Right</td></tr>
                <tr><td>Numpad 5 or 0</td><td>Fire</td></tr>
                <tr><td>Numpad 7/9/1/3</td><td>Diagonals</td></tr>
                <tr><td colspan="2" class="help-section-header">Debugger</td></tr>
                <tr><td>F6 / Pause</td><td>Pause/Resume emulation</td></tr>
                <tr><td>F7</td><td>Step Into</td></tr>
                <tr><td>F8</td><td>Step Over</td></tr>
                <tr><td>F4</td><td>Run to Cursor</td></tr>
                <tr><td>F9</td><td>Toggle Breakpoint</td></tr>
            </table>
        </div>
    </div>
    
    <!-- Label Edit Dialog -->
    <div class="label-dialog hidden" id="labelDialog">
        <div class="label-dialog-content">
            <h4 id="labelDialogTitle">Add Label</h4>
            <div class="label-dialog-row">
                <label>Address</label>
                <input type="text" id="labelAddrInput" readonly>
            </div>
            <div class="label-dialog-row">
                <label>Name</label>
                <input type="text" id="labelNameInput" placeholder="LABEL_NAME" maxlength="32">
            </div>
            <div class="label-dialog-row">
                <label>Comment (optional)</label>
                <input type="text" id="labelCommentInput" placeholder="Description..." maxlength="100">
            </div>
            <div class="label-dialog-row">
                <label>Size (bytes, 1 = code)</label>
                <input type="number" id="labelSizeInput" value="1" min="1" max="65536">
            </div>
            <div class="label-dialog-buttons">
                <button id="btnLabelSave">Save</button>
                <button id="btnLabelCancel">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Region Mark Dialog -->
    <div class="label-dialog hidden" id="regionDialog">
        <div class="label-dialog-content">
            <h4 id="regionDialogTitle">Mark Region</h4>
            <div class="label-dialog-row">
                <label>Start Address</label>
                <input type="text" id="regionStartInput" readonly>
            </div>
            <div class="label-dialog-row">
                <label>End Address</label>
                <input type="text" id="regionEndInput" placeholder="FFFF" maxlength="4">
            </div>
            <div class="label-dialog-row">
                <label>Type</label>
                <select id="regionTypeSelect">
                    <option value="code">Code</option>
                    <option value="db">DB (bytes)</option>
                    <option value="dw">DW (words)</option>
                    <option value="text">Text (ASCII)</option>
                    <option value="graphics">Graphics</option>
                    <option value="smc">SMC (self-modifying)</option>
                </select>
            </div>
            <div class="label-dialog-row">
                <label>Comment (optional)</label>
                <input type="text" id="regionCommentInput" placeholder="Description..." maxlength="100">
            </div>
            <div class="label-dialog-buttons">
                <button id="btnRegionSave">Mark</button>
                <button id="btnRegionCancel">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Comment Dialog -->
    <div class="label-dialog hidden" id="commentDialog">
        <div class="label-dialog-content" style="width: 400px;">
            <h4 id="commentDialogTitle">Edit Comment</h4>
            <div class="label-dialog-row">
                <label>Address</label>
                <input type="text" id="commentAddrInput" readonly>
            </div>
            <div class="label-dialog-row">
                <label><input type="checkbox" id="commentSeparator"> Add separator line (----------)</label>
            </div>
            <div class="label-dialog-row">
                <label>Before (multiline)</label>
                <textarea id="commentBeforeInput" rows="3" placeholder="Comment before instruction..."></textarea>
            </div>
            <div class="label-dialog-row">
                <label>Inline</label>
                <input type="text" id="commentInlineInput" placeholder="Short comment on same line" maxlength="60">
            </div>
            <div class="label-dialog-row">
                <label>After (multiline)</label>
                <textarea id="commentAfterInput" rows="3" placeholder="Comment after instruction..."></textarea>
            </div>
            <div class="label-dialog-buttons">
                <button id="btnCommentSave">Save</button>
                <button id="btnCommentDelete" class="danger">Delete</button>
                <button id="btnCommentCancel">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Export Disasm Dialog -->
    <div class="label-dialog hidden" id="exportDisasmDialog">
        <div class="label-dialog-content">
            <h4>Export Disassembly</h4>
            <div class="label-dialog-row">
                <label>Start Address</label>
                <input type="text" id="exportStartAddr" placeholder="0000" maxlength="4">
            </div>
            <div class="label-dialog-row">
                <label>End Address</label>
                <input type="text" id="exportEndAddr" placeholder="FFFF" maxlength="4">
            </div>
            <div class="label-dialog-row">
                <label>Options</label>
                <div class="export-options">
                    <label><input type="checkbox" id="exportWithOrg" checked> ORG directive</label>
                    <label><input type="checkbox" id="exportWithAddr" checked> Address comments</label>
                    <label><input type="checkbox" id="exportWithBytes"> Byte comments</label>
                    <label><input type="checkbox" id="exportWithTstates"> T-states</label>
                </div>
            </div>
            <div class="label-dialog-buttons">
                <button id="btnExportSave">Export</button>
                <button id="btnExportCancel">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Comprehensive Help Dialog -->
    <div class="fullhelp-dialog hidden" id="fullHelpDialog">
        <div class="fullhelp-content">
            <div class="fullhelp-header">
                <h3>ZX-M8XXX <span class="help-version">v0.6.3</span> Help</h3>
                <button class="fullhelp-close" id="btnFullHelpClose">&times;</button>
            </div>
            <div class="fullhelp-body">
                <div class="fullhelp-nav">
                    <button class="fullhelp-nav-btn active" data-section="overview">Overview</button>
                    <button class="fullhelp-nav-btn" data-section="files">Files</button>
                    <button class="fullhelp-nav-btn" data-section="keyboard">Keyboard</button>
                    <button class="fullhelp-nav-btn" data-section="assembler">Assembler</button>
                    <button class="fullhelp-nav-btn" data-section="debugger">Debugger</button>
                    <button class="fullhelp-nav-btn" data-section="breakpoints">Breakpoints</button>
                    <button class="fullhelp-nav-btn" data-section="memory">Memory</button>
                    <button class="fullhelp-nav-btn" data-section="labels">Labels</button>
                    <button class="fullhelp-nav-btn" data-section="regions">Regions</button>
                    <button class="fullhelp-nav-btn" data-section="xrefs">XRefs</button>
                    <button class="fullhelp-nav-btn" data-section="graphics">Graphics</button>
                    <button class="fullhelp-nav-btn" data-section="api">API</button>
                    <button class="fullhelp-nav-btn" data-section="about">About</button>
                </div>
                <div class="fullhelp-section" id="help-overview">
                    <h4>Overview</h4>
                    <p>ZX-M8XXX (ZX Matrix) is a vanilla JavaScript ZX Spectrum emulator with integrated debugger for reverse engineering.</p>
                    <h5>Features</h5>
                    <ul>
                        <li>Full Z80 CPU emulation (all documented + undocumented opcodes)</li>
                        <li>48K, 128K, and Pentagon machine support</li>
                        <li>Memory banking (128K/Pentagon)</li>
                        <li>ULA video generation with border</li>
                        <li>Memory contention emulation</li>
                        <li>SNA/Z80 snapshot loading/saving</li>
                        <li>TAP tape loading with ROM traps (instant load)</li>
                        <li>ZIP archive support</li>
                        <li>RZX playback (partial)</li>
                    </ul>
                    <h5>Quick Start</h5>
                    <ol>
                        <li>Place ROM files in <code>roms/</code> directory (48.rom, 128.rom, pentagon.rom, trdos.rom)</li>
                        <li>Open index.html in a modern browser</li>
                        <li>Load SNA/Z80 snapshots, TAP tapes, or TRD/SCL disk images via the Load button</li>
                    </ol>
                </div>
                <div class="fullhelp-section hidden" id="help-keyboard">
                    <h4>Keyboard Mapping</h4>
                    <table>
                        <tr><th>PC Key</th><th>Spectrum Key</th></tr>
                        <tr><td>A-Z, 0-9</td><td>Standard keys</td></tr>
                        <tr><td>Shift</td><td>Caps Shift</td></tr>
                        <tr><td>Ctrl</td><td>Symbol Shift</td></tr>
                        <tr><td>Enter</td><td>Enter</td></tr>
                        <tr><td>Space</td><td>Space / Break</td></tr>
                        <tr><td>Backspace</td><td>Delete (Shift+0)</td></tr>
                        <tr><td>Arrow Keys</td><td>Cursor (Shift+5/6/7/8)</td></tr>
                    </table>
                    <h5>Symbol Shift Combinations (Ctrl + Key)</h5>
                    <table>
                        <tr><th>Keys</th><th>Symbol</th><th>Keys</th><th>Symbol</th><th>Keys</th><th>Symbol</th></tr>
                        <tr><td>Ctrl+1</td><td>!</td><td>Ctrl+Q</td><td>&lt;=</td><td>Ctrl+A</td><td>~</td></tr>
                        <tr><td>Ctrl+2</td><td>@</td><td>Ctrl+W</td><td>&lt;&gt;</td><td>Ctrl+S</td><td>|</td></tr>
                        <tr><td>Ctrl+3</td><td>#</td><td>Ctrl+E</td><td>&gt;=</td><td>Ctrl+D</td><td>\</td></tr>
                        <tr><td>Ctrl+4</td><td>$</td><td>Ctrl+R</td><td>&lt;</td><td>Ctrl+F</td><td>{</td></tr>
                        <tr><td>Ctrl+5</td><td>%</td><td>Ctrl+T</td><td>&gt;</td><td>Ctrl+G</td><td>}</td></tr>
                        <tr><td>Ctrl+6</td><td>&amp;</td><td>Ctrl+Y</td><td>[</td><td>Ctrl+H</td><td>^</td></tr>
                        <tr><td>Ctrl+7</td><td>'</td><td>Ctrl+U</td><td>]</td><td>Ctrl+J</td><td>-</td></tr>
                        <tr><td>Ctrl+8</td><td>(</td><td>Ctrl+I</td><td>©</td><td>Ctrl+K</td><td>+</td></tr>
                        <tr><td>Ctrl+9</td><td>)</td><td>Ctrl+O</td><td>;</td><td>Ctrl+L</td><td>=</td></tr>
                        <tr><td>Ctrl+0</td><td>_</td><td>Ctrl+P</td><td>"</td><td>Ctrl+Z</td><td>:</td></tr>
                        <tr><td>Ctrl+M</td><td>.</td><td>Ctrl+N</td><td>,</td><td>Ctrl+B</td><td>*</td></tr>
                        <tr><td>Ctrl+C</td><td>?</td><td>Ctrl+V</td><td>/</td><td>Ctrl+X</td><td>£</td></tr>
                    </table>
                    <h5>Kempston Joystick (Numpad)</h5>
                    <table>
                        <tr><td>Numpad 8/2/4/6</td><td>Up/Down/Left/Right</td></tr>
                        <tr><td>Numpad 5 or 0</td><td>Fire</td></tr>
                        <tr><td>Numpad 7/9/1/3</td><td>Diagonals</td></tr>
                    </table>
                    <h5>Debugger Hotkeys</h5>
                    <table>
                        <tr><td>F6 / Pause</td><td>Pause/Resume emulation</td></tr>
                        <tr><td>F7</td><td>Step Into (single instruction)</td></tr>
                        <tr><td>F8</td><td>Step Over (skip CALL/RST)</td></tr>
                        <tr><td>F4</td><td>Run to Cursor</td></tr>
                        <tr><td>F9</td><td>Toggle Breakpoint at PC</td></tr>
                    </table>
                </div>
                <div class="fullhelp-section hidden" id="help-debugger">
                    <h4>Debugger</h4>
                    <p>The built-in debugger provides comprehensive tools for development and reverse engineering.</p>
                    <h5>Registers View</h5>
                    <p>Shows all Z80 registers including the alternate set (AF', BC', DE', HL'). Flags are displayed as visual indicators: S, Z, H, P/V, N, C.</p>
                    <h5>Disassembly View</h5>
                    <ul>
                        <li>Live disassembly from current PC with label support</li>
                        <li>Click address to set "run to cursor" target</li>
                        <li>Right-click for context menu (labels, regions, operand format)</li>
                        <li>Hover over addresses to see cross-references</li>
                        <li>Syntax coloring: <span style="color:#daa520">registers</span>, <span style="color:#00aa00">numbers</span>, <span style="color:#cc66cc">chars</span></li>
                    </ul>
                    <h5>Operand Formatting</h5>
                    <p>Right-click any disassembly line and select "Operand format..." to change how numeric operands are displayed:</p>
                    <ul>
                        <li><strong>Hex</strong>: FFh, 1234h (default)</li>
                        <li><strong>Decimal</strong>: 255, 4660</li>
                        <li><strong>Binary</strong>: %11111111, %0001001000110100</li>
                        <li><strong>Char</strong>: 'A' (for printable ASCII)</li>
                    </ul>
                    <p>Format settings persist per instruction address and are saved with projects.</p>
                    <h5>Stack View</h5>
                    <p>Shows current stack contents with return addresses highlighted.</p>
                    <h5>Bookmarks</h5>
                    <p>Quick navigation: click bookmark to jump, right-click to set bookmark at current address. 5 slots for disassembly, 5 for memory view.</p>
                </div>
                <div class="fullhelp-section hidden" id="help-labels">
                    <h4>Labels</h4>
                    <p>Labels provide meaningful names for memory addresses in the disassembly view.</p>
                    <h5>Adding Labels</h5>
                    <ul>
                        <li>Right-click address in disassembly &rarr; "Add Label"</li>
                        <li>Or use the Labels panel "Add" button</li>
                    </ul>
                    <h5>Display Modes</h5>
                    <ul>
                        <li><strong>Address only</strong>: Show hex addresses</li>
                        <li><strong>Label only</strong>: Show label names</li>
                        <li><strong>Both</strong>: Show "address (label)"</li>
                    </ul>
                    <h5>Features</h5>
                    <ul>
                        <li>Labels appear in operands: <code>CALL main_loop</code></li>
                        <li>Persistent storage per loaded file (localStorage)</li>
                        <li>Import/Export to JSON files</li>
                        <li>Click label in list to navigate</li>
                    </ul>
                </div>
                <div class="fullhelp-section hidden" id="help-breakpoints">
                    <h4>Breakpoints &amp; Watchpoints</h4>
                    <h5>Execution Breakpoints</h5>
                    <ul>
                        <li>Click gutter (left margin) in disassembly</li>
                        <li>Or press F9 at current PC</li>
                        <li>Execution pauses when PC reaches breakpoint</li>
                    </ul>
                    <h5>Conditional Breakpoints</h5>
                    <p>Add conditions to break only when criteria are met:</p>
                    <table>
                        <tr><th>Type</th><th>Examples</th></tr>
                        <tr><td>Registers</td><td><code>A==0</code>, <code>HL&gt;4000</code>, <code>BC!=DE</code></td></tr>
                        <tr><td>Flags</td><td><code>Z</code>, <code>NZ</code>, <code>C</code>, <code>NC</code>, <code>P</code>, <code>M</code></td></tr>
                        <tr><td>Memory</td><td><code>(HL)==FF</code>, <code>(4000)==0</code>, <code>(IX+5)&gt;10</code></td></tr>
                        <tr><td>Operators</td><td><code>==</code>, <code>!=</code>, <code>&lt;&gt;</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>&amp;</code>, <code>|</code></td></tr>
                        <tr><td>Literals</td><td>Hex: <code>FF</code>, <code>4000h</code> / Decimal: <code>255</code></td></tr>
                    </table>
                    <h5>Watchpoints</h5>
                    <p>Break on memory access:</p>
                    <ul>
                        <li><strong>Read watchpoint</strong>: Break when address is read</li>
                        <li><strong>Write watchpoint</strong>: Break when address is written</li>
                    </ul>
                    <h5>Port Breakpoints</h5>
                    <p>Break on I/O port access (IN/OUT instructions).</p>
                </div>
                <div class="fullhelp-section hidden" id="help-memory">
                    <h4>Memory Tools</h4>
                    <h5>Memory Dump</h5>
                    <ul>
                        <li>Hex view with inline editing (click byte to edit)</li>
                        <li>Click and drag to select range</li>
                        <li>Right-click selection for region marking</li>
                    </ul>
                    <h5>Memory Diff</h5>
                    <ol>
                        <li>Click <strong>Snap</strong> to snapshot current memory</li>
                        <li>Run the program</li>
                        <li>Changed bytes are highlighted in the dump</li>
                    </ol>
                    <h5>POKE Search</h5>
                    <p>Find memory locations storing game values (lives, score, etc.):</p>
                    <ol>
                        <li><strong>Snap</strong> - Take initial memory snapshot</li>
                        <li>Play game and change target value</li>
                        <li><strong>Search</strong> with mode:
                            <ul>
                                <li><code>Decreased</code> - value went down</li>
                                <li><code>Increased</code> - value went up</li>
                                <li><code>Changed</code> - any change</li>
                                <li><code>Unchanged</code> - stayed same</li>
                                <li><code>Equals</code> - specific hex value</li>
                            </ul>
                        </li>
                        <li>Repeat to narrow candidates</li>
                        <li>Click result to view in memory dump</li>
                    </ol>
                </div>
                <div class="fullhelp-section hidden" id="help-graphics">
                    <h4>Graphics Viewer</h4>
                    <p>View and analyze sprite/tile graphics stored in memory. Features a continuous memory dump view (EmuzWin-style). Access via the <strong>Graphics</strong> tab.</p>
                    <h5>Memory Dump View</h5>
                    <p>The main area shows memory rendered as graphics. Each byte is displayed as 8 horizontal pixels. A <span style="color:#f00">red rectangle</span> marks the current sprite selection.</p>
                    <h5>Controls</h5>
                    <ul>
                        <li><strong>Address</strong>: Current sprite address (hex). Press Enter to jump.</li>
                        <li><strong>Width</strong>: Sprite width in bytes (1-32). Each byte = 8 pixels. Max 32 = full screen width.</li>
                        <li><strong>Height</strong>: Sprite height in lines (1-64)</li>
                        <li><strong>Invert</strong>: Swap foreground/background colors</li>
                        <li><strong>Grid</strong>: Show grid lines (vertical between bytes, horizontal every 8 rows)</li>
                        <li><strong>x1/x2/x3</strong>: Zoom level for main dump view</li>
                    </ul>
                    <h5>Navigation</h5>
                    <ul>
                        <li><strong>-1/+1</strong>: Move sprite selection by 1 byte</li>
                        <li><strong>-Line/+Line</strong>: Move by one line (width bytes)</li>
                        <li><strong>-Row/+Row</strong>: Move by 8 lines (character row)</li>
                        <li><strong>-Spr/+Spr</strong>: Move by full sprite (width × height bytes)</li>
                        <li><strong>-Page/+Page</strong>: Move by 24 rows (192 lines × width bytes)</li>
                        <li><strong>Mouse wheel</strong>: Scroll the dump view</li>
                    </ul>
                    <h5>Actions</h5>
                    <ul>
                        <li><strong>Mark Region</strong>: Mark sprite as Graphics region (stores width/height)</li>
                        <li><strong>Copy Selection</strong>: Copy current selection as assembler DB statements</li>
                        <li><strong>Save Selection</strong>: Save current selection to .asm file</li>
                        <li><strong>Export All Marked</strong>: Export all marked Graphics regions to single file</li>
                        <li><strong>→ Disasm</strong>: Jump to address in disassembly</li>
                        <li><strong>→ Memory</strong>: Jump to address in memory dump</li>
                    </ul>
                </div>
                <div class="fullhelp-section hidden" id="help-regions">
                    <h4>Memory Regions</h4>
                    <p>Mark memory regions for reverse engineering analysis. Affects how memory is displayed in disassembly and memory map.</p>
                    <h5>Region Types</h5>
                    <table>
                        <tr><td><strong>Code</strong></td><td>Executable code (default)</td></tr>
                        <tr><td><strong>DB</strong></td><td>Data bytes - shown as <code>DB nn,nn,...</code></td></tr>
                        <tr><td><strong>DW</strong></td><td>Data words - shown as <code>DW nnnn,...</code></td></tr>
                        <tr><td><strong>Text</strong></td><td>ASCII strings - shown as <code>DB "text"</code></td></tr>
                        <tr><td><strong>Graphics</strong></td><td>Sprite/tile graphics</td></tr>
                        <tr><td><strong>SMC</strong></td><td>Self-modifying code</td></tr>
                    </table>
                    <h5>Auto-Map</h5>
                    <p>Automatically detect regions during execution:</p>
                    <ul>
                        <li>Executed addresses marked as Code</li>
                        <li>Read addresses marked as Data</li>
                        <li>Code that gets overwritten marked as SMC</li>
                    </ul>
                    <h5>Memory Map Dialog</h5>
                    <p>Visual 256x256 map of entire 64KB memory. Click to navigate, colors indicate region types.</p>
                </div>
                <div class="fullhelp-section hidden" id="help-xrefs">
                    <h4>Cross-References (XRefs)</h4>
                    <p>Track where addresses are referenced from in the code.</p>
                    <h5>Generating XRefs</h5>
                    <ul>
                        <li><strong>Scan</strong> - Scan visible disassembly range</li>
                        <li><strong>Scan All</strong> - Scan full 64KB memory</li>
                        <li><strong>Runtime</strong> checkbox - Collect refs during execution</li>
                    </ul>
                    <h5>Viewing XRefs</h5>
                    <p>Hover over an address operand in disassembly to see tooltip showing all references to that address.</p>
                    <h5>Reference Types</h5>
                    <ul>
                        <li><span style="color:#ff8080">CALL</span> - subroutine calls</li>
                        <li><span style="color:#80ff80">JP</span> - absolute jumps</li>
                        <li><span style="color:#80ffff">JR/DJNZ</span> - relative jumps</li>
                        <li><span style="color:#ffff80">LD</span> - data references</li>
                    </ul>
                </div>
                <div class="fullhelp-section hidden" id="help-files">
                    <h4>File Formats</h4>
                    <h5>Snapshots</h5>
                    <table>
                        <tr><td><strong>SNA</strong></td><td>48K: 49179 bytes, 128K: 131103 bytes</td></tr>
                        <tr><td><strong>Z80</strong></td><td>v1, v2, v3 with compression support</td></tr>
                    </table>
                    <h5>Tapes</h5>
                    <table>
                        <tr><td><strong>TAP</strong></td><td>Instant load via ROM traps</td></tr>
                    </table>
                    <h5>Input Recording</h5>
                    <table>
                        <tr><td><strong>RZX</strong></td><td>Playback with embedded snapshot (may desync)</td></tr>
                    </table>
                    <h5>Disk Images</h5>
                    <table>
                        <tr><td><strong>TRD</strong></td><td>TR-DOS disk image (select file from disk)</td></tr>
                        <tr><td><strong>SCL</strong></td><td>TR-DOS file archive (more compact format)</td></tr>
                    </table>
                    <h5>Archives</h5>
                    <table>
                        <tr><td><strong>ZIP</strong></td><td>Select file from archive dialog</td></tr>
                    </table>
                    <h5>Project Files</h5>
                    <p>Save/Load complete session state:</p>
                    <ul>
                        <li>Current snapshot</li>
                        <li>All breakpoints and watchpoints</li>
                        <li>Labels and comments</li>
                        <li>Memory regions</li>
                        <li>Cross-references</li>
                        <li>Bookmarks</li>
                        <li>Loaded media (TAP/TRD/SCL) with tape position</li>
                    </ul>
                </div>
                <div class="fullhelp-section hidden" id="help-assembler">
                    <h4>Z80 Assembler</h4>
                    <p>Integrated sjasmplus-compatible Z80 assembler for writing and testing code directly in the emulator.</p>
                    <p><a href="https://z00m128.github.io/sjasmplus/documentation.html" target="_blank" style="color: var(--cyan);">Full sjasmplus Documentation</a></p>
                    <h5>Keyboard Shortcuts</h5>
                    <table>
                        <tr><td><strong>F9</strong></td><td>Assemble code</td></tr>
                        <tr><td><strong>Ctrl+F</strong></td><td>Find</td></tr>
                        <tr><td><strong>Ctrl+R</strong> or <strong>Ctrl+H</strong></td><td>Find and Replace</td></tr>
                        <tr><td><strong>F3</strong></td><td>Find Next</td></tr>
                        <tr><td><strong>Shift+F3</strong></td><td>Find Previous</td></tr>
                        <tr><td><strong>Escape</strong></td><td>Close search bar</td></tr>
                    </table>
                    <h5>Toolbar Buttons</h5>
                    <ul>
                        <li><strong>Files ▼</strong> - Browse project files (disabled when ≤1 file)</li>
                        <li><strong>Assemble</strong> - Compile the assembly code (F9)</li>
                        <li><strong>Inject</strong> - Write assembled bytes to emulator memory</li>
                        <li><strong>Debug</strong> - Inject code, set PC to entry point, switch to debugger. Entry point priority: SAVESNA address > single ORG > prompt if multiple ORGs</li>
                        <li><strong>Clear</strong> - Clear editor and reset project</li>
                        <li><strong>New</strong> - Add a new file to the project</li>
                        <li><strong>Load</strong> - Load .asm file or .zip project</li>
                        <li><strong>Export</strong> - Save source files as ZIP</li>
                        <li><strong>Download</strong> - Download generated output files (.bin, .sna, .tap). If multiple files, downloads as ZIP archive</li>
                    </ul>
                    <h5>Drag & Drop</h5>
                    <ul>
                        <li>Drag .asm or .zip files directly onto the editor to load them</li>
                        <li>If a file with the same name exists, you'll be asked to replace or add as new</li>
                        <li>Drag ROM/snapshot files (.sna, .tap, .trd) onto the emulator screen area instead</li>
                    </ul>
                    <h5>Multi-File Projects</h5>
                    <ul>
                        <li>Load a ZIP file containing multiple .asm files</li>
                        <li>Main file (red label) is assembled first and includes others</li>
                        <li>Click main file label to change which file is the main</li>
                        <li>Use tabs to switch between open files</li>
                        <li>Use <code>INCLUDE "filename.asm"</code> to include other files</li>
                    </ul>
                    <h5>Search All Files</h5>
                    <ul>
                        <li>Open search bar with Ctrl+F</li>
                        <li>Click <strong>All Files</strong> button to search across all project files</li>
                        <li>Results show filename, line number, and matching text</li>
                        <li>Click any result to jump to that file and line</li>
                    </ul>
                    <h5>Output Options</h5>
                    <ul>
                        <li><strong>Unused labels</strong> - Show labels that are defined but never referenced</li>
                        <li><strong>Show compiled</strong> - Include hex dump of assembled bytes</li>
                    </ul>
                    <h5>Command-Line Defines</h5>
                    <p>Use the <strong>Defines</strong> input field to pass defines for conditional assembly:</p>
                    <ul>
                        <li>Format: <code>NAME,NAME=value,...</code></li>
                        <li>Simple define: <code>DEBUG</code> (value = 1)</li>
                        <li>With value: <code>VERSION=5</code> or <code>BUILD=$100</code></li>
                        <li>Multiple: <code>DEBUG,VERSION=5,RELEASE</code></li>
                    </ul>
                    <h5>@define Markers</h5>
                    <p>Add <code>; @define</code> comments in the first 50 lines of your main file to show a dropdown of available defines:</p>
                    <pre>; @define DEBUG
; @define RELEASE
; @define VERSION=5
; @define BUILD=$0100</pre>
                    <p>The dropdown appears automatically. Ctrl+click to select multiple defines.</p>
                    <h5>Output Files</h5>
                    <p>Use directives to generate output files:</p>
                    <ul>
                        <li><code>SAVEBIN "file.bin", start, length</code> - Save binary data</li>
                        <li><code>SAVESNA "file.sna", start</code> - Save 48K SNA snapshot</li>
                        <li><code>SAVETAP "file.tap", CODE, "name", start, length</code> - Save TAP file</li>
                        <li><code>EMPTYTAP "file.tap"</code> - Create empty TAP (for multiple blocks)</li>
                    </ul>
                    <p>Generated files are listed in the output with size and MD5 hash.</p>
                    <h5>MD5 Checksum Verification</h5>
                    <p>Add expected MD5 hash in a comment to verify output:</p>
                    <pre>SAVEBIN "game.bin", $8000, $1000  ; md5: a1b2c3d4e5f6...</pre>
                    <p>Or use the MD5CHECK macro:</p>
                    <pre>MD5CHECK "game.bin", "a1b2c3d4e5f6..."</pre>
                    <p>Output shows <span style="color:#80ff80">MD5 OK</span> or <span style="color:#ff8080">MD5 MISMATCH</span>.</p>
                    <h5>Supported Directives</h5>
                    <ul>
                        <li><strong>ORG</strong> - Set origin address</li>
                        <li><strong>EQU</strong> - Define constant</li>
                        <li><strong>DEFINE</strong> - Define symbol</li>
                        <li><strong>DB/DEFB</strong> - Define bytes</li>
                        <li><strong>DW/DEFW</strong> - Define words</li>
                        <li><strong>DS/DEFS/BLOCK</strong> - Reserve space</li>
                        <li><strong>DZ</strong> - Zero-terminated string</li>
                        <li><strong>DC</strong> - High-bit terminated string</li>
                        <li><strong>ALIGN</strong> - Align to boundary</li>
                        <li><strong>INCLUDE</strong> - Include source file</li>
                        <li><strong>INCBIN</strong> - Include binary file</li>
                        <li><strong>IF/ELSE/ENDIF</strong> - Conditional assembly</li>
                        <li><strong>IFDEF/IFNDEF</strong> - Check if defined</li>
                        <li><strong>MACRO/ENDM</strong> - Define macro</li>
                        <li><strong>REPT/ENDR</strong> - Repeat block</li>
                        <li><strong>STRUCT/ENDS</strong> - Define structure</li>
                        <li><strong>DEVICE</strong> - Set target device (ZXSPECTRUM48, ZXSPECTRUM128)</li>
                        <li><strong>SLOT/PAGE</strong> - Memory paging (128K)</li>
                    </ul>
                </div>
                <div class="fullhelp-section hidden" id="help-api">
                    <h4>JavaScript API</h4>
                    <p>Access emulator via browser console:</p>
                    <pre>
// Access emulator
window.spectrum

// Get version
Spectrum.VERSION

// Memory access
spectrum.peek(0x4000)
spectrum.poke(0x4000, 0xff)

// Control
spectrum.start()
spectrum.stop()
spectrum.reset()

// Breakpoints
spectrum.addBreakpoint(0x0000)
spectrum.addBreakpointWithCondition('4000', 'A==0')
spectrum.removeBreakpoint(0x0000)
spectrum.getBreakpoints()
spectrum.clearBreakpoints()

// Labels
labelManager.add({
    address: 0x4000,
    name: 'main_loop',
    comment: 'Main game loop'
})
labelManager.get(0x4000)
labelManager.remove(0x4000)
labelManager.findByName('main_loop')
labelManager.exportJSON()
labelManager.importJSON(jsonStr, merge)</pre>
                </div>
                <div class="fullhelp-section hidden" id="help-about">
                    <h4>About</h4>
                    <h5>The Name</h5>
                    <p><strong>ZX-M8XXX</strong> stands for <strong>ZX Matrix</strong> — a nod to the iconic 8-bit architecture and the intricate web of code, memory, and pixels that make up the Spectrum experience.</p>
                    <h5>License</h5>
                    <p>This software is released under the <strong>GPL-3.0</strong> license.</p>
                    <p>You are free to use, modify, and distribute this software under the terms of the GNU General Public License version 3.</p>
                    <p><a href="https://www.gnu.org/licenses/gpl-3.0.html" target="_blank" style="color: var(--cyan);">Read the full GPL-3.0 license text</a></p>
                    <h5>Inspired By</h5>
                    <ul>
                        <li><strong>JSSpeccy 3</strong> - Matt Westcott's excellent JavaScript Spectrum emulator</li>
                        <li><strong>Fuse</strong> - The Free Unix Spectrum Emulator</li>
                        <li><strong>EmuzWin</strong> - Windows Spectrum emulator</li>
                        <li><strong>Swan</strong> - Delphi Spectrum emulator (I/O contention algorithm)</li>
                        <li><strong>ZXMAK2</strong> - .NET Spectrum emulator</li>
                    </ul>
                    <h5>Known Limitations</h5>
                    <ul>
                        <li><strong>Chained prefix interrupts:</strong> On real Z80, interrupts can occur between chained DD/FD prefix bytes (each prefix is a separate instruction fetch). This emulator processes prefix chains atomically within a single step, so interrupts cannot occur mid-chain. This rarely affects real software.</li>
                        <li><strong>Floating bus:</strong> Not fully emulated. Some copy protection schemes may not work.</li>
                        <li><strong>Tape loading:</strong> Uses ROM traps for instant loading. Real tape timing not emulated.</li>
                    </ul>
                    <h5>Technical References</h5>
                    <ul>
                        <li>Z80 CPU User Manual (Zilog)</li>
                        <li>The Undocumented Z80 Documented (Sean Young)</li>
                        <li>World of Spectrum documentation</li>
                    </ul>
                    <h5>Greetings</h5>
                    <p>Greetings fly out to:</p>
                    <ul>
                        <li>The ZX Spectrum demo scene and retro computing community</li>
                        <li>All the developers keeping the Speccy spirit alive</li>
                        <li>Everyone who contributed to documenting the Z80 and ZX Spectrum hardware</li>
                        <li>Amstrad for allowing free distribution of Spectrum ROMs</li>
                    </ul>
                    <p style="margin-top: 20px; color: var(--text-secondary); font-style: italic;">
                        "The Spectrum lives on!"
                    </p>
                </div>
            </div>
        </div>
    </div>

    <!-- File Selector Dialog -->
    <div class="file-selector-dialog hidden" id="fileSelectorDialog">
        <div class="file-selector-content">
            <div class="file-selector-header">
                <h3 id="fileSelectorTitle">Select Main File</h3>
                <button class="file-selector-close" id="btnFileSelectorClose">&times;</button>
            </div>
            <div class="file-selector-body" id="fileSelectorBody">
            </div>
        </div>
    </div>

    <div class="drop-zone" id="dropZone">Drop ROM or Snapshot here</div>

    <!-- Load modules in dependency order -->
    <script src="pako.min.js"></script>
    <script src="z80.js"></script>
    <script src="memory.js"></script>
    <script src="ula.js"></script>
    <script src="loaders.js"></script>
    <script src="spectrum.js"></script>
    <script src="disasm.js"></script>
    <!-- sjasmplus-js assembler -->
    <script src="sjasmplus/errors.js"></script>
    <script src="sjasmplus/lexer.js"></script>
    <script src="sjasmplus/expression.js"></script>
    <script src="sjasmplus/labels.js"></script>
    <script src="sjasmplus/instructions.js"></script>
    <script src="sjasmplus/instructions2.js"></script>
    <script src="sjasmplus/instructions3.js"></script>
    <script src="sjasmplus/memory.js"></script>
    <script src="sjasmplus/output.js"></script>
    <script src="sjasmplus/preprocessor.js"></script>
    <script src="sjasmplus/parser.js"></script>
    <script src="sjasmplus/vfs.js"></script>
    <script src="sjasmplus/md5.js"></script>
    <script src="sjasmplus/assembler.js"></script>
    
    <script>
        const APP_VERSION = '0.6.3';
        console.log('ZX-M8XXX v' + APP_VERSION);
        
        // Help modal
        const helpModal = document.getElementById('helpModal');
        const btnHelpClose = document.getElementById('btnHelpClose');

        btnHelpClose.addEventListener('click', () => helpModal.classList.add('hidden'));
        helpModal.addEventListener('click', (e) => {
            if (e.target === helpModal) helpModal.classList.add('hidden');
        });

        // Full Help Dialog
        const fullHelpDialog = document.getElementById('fullHelpDialog');
        const btnHelpFull = document.getElementById('btnHelpFull');
        const btnFullHelpClose = document.getElementById('btnFullHelpClose');
        const helpNavBtns = fullHelpDialog.querySelectorAll('.fullhelp-nav-btn');
        const helpSections = fullHelpDialog.querySelectorAll('.fullhelp-section');

        function showHelpSection(sectionId) {
            helpNavBtns.forEach(btn => btn.classList.remove('active'));
            helpSections.forEach(sec => sec.classList.add('hidden'));
            const activeBtn = fullHelpDialog.querySelector(`.fullhelp-nav-btn[data-section="${sectionId}"]`);
            const activeSection = document.getElementById('help-' + sectionId);
            if (activeBtn) activeBtn.classList.add('active');
            if (activeSection) activeSection.classList.remove('hidden');
        }

        btnHelpFull.addEventListener('click', () => {
            fullHelpDialog.classList.remove('hidden');
            showHelpSection('overview');
        });

        btnFullHelpClose.addEventListener('click', () => fullHelpDialog.classList.add('hidden'));

        fullHelpDialog.addEventListener('click', (e) => {
            if (e.target === fullHelpDialog) fullHelpDialog.classList.add('hidden');
        });

        helpNavBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                const section = btn.getAttribute('data-section');
                showHelpSection(section);
            });
        });

        // ========== Tab System ==========
        const tabContainer = document.getElementById('tabContainer');
        const tabBtns = document.querySelectorAll('.tab-btn');
        const tabContents = document.querySelectorAll('.tab-content');

        tabBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                const tabId = btn.getAttribute('data-tab');
                const isCurrentlyActive = btn.classList.contains('active');
                const isCollapsed = tabContainer.classList.contains('collapsed');

                if (isCurrentlyActive) {
                    // Toggle collapse when clicking active tab
                    tabContainer.classList.toggle('collapsed');
                } else {
                    // Switch to different tab and expand
                    tabContainer.classList.remove('collapsed');
                    tabBtns.forEach(b => b.classList.remove('active'));
                    tabContents.forEach(c => c.classList.remove('active'));
                    btn.classList.add('active');
                    document.getElementById('tab-' + tabId).classList.add('active');
                    // Update graphics viewer when switching to its tab
                    if (tabId === 'graphics' && typeof updateGraphicsViewer === 'function') {
                        updateGraphicsViewer();
                    }
                }
            });
        });

        // ========== Panel Tabs (Breakpoints/Labels/Tools) ==========
        document.querySelectorAll('.panel-tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const panelId = btn.dataset.panel;
                // Update buttons
                document.querySelectorAll('.panel-tab-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                // Update panels
                document.querySelectorAll('.panel-tab-content').forEach(p => p.classList.remove('active'));
                document.getElementById('panel-' + panelId).classList.add('active');
            });
        });

        // ========== Programmer Calculator ==========

        // Global key handler for calculator input (called from inline onkeydown)
        function calcHandleKey(e) {
            e.stopPropagation();
            if (e.key === 'Enter' || e.code === 'NumpadEnter') {
                document.getElementById('calcEquals').click();
                e.preventDefault();
                return false;
            }
            return true;  // Allow other keys (Backspace, typing, etc.)
        }

        // Expression parser for formulas like "25*(3+2)"
        function calcParseExpression(expr, base) {
            // Tokenize: numbers, operators, parentheses
            const tokens = [];
            let i = 0;
            expr = expr.replace(/\s/g, '').toUpperCase();

            while (i < expr.length) {
                const ch = expr[i];

                // Number (hex, dec, oct, bin based on current base)
                if (/[0-9A-F]/i.test(ch)) {
                    let num = '';
                    while (i < expr.length && /[0-9A-F]/i.test(expr[i])) {
                        num += expr[i++];
                    }
                    try {
                        let val;
                        if (base === 16) val = BigInt('0x' + num);
                        else if (base === 8) val = BigInt('0o' + num);
                        else if (base === 2) val = BigInt('0b' + num);
                        else val = BigInt(num);
                        tokens.push({ type: 'num', value: val });
                    } catch (e) {
                        return null;  // Parse error
                    }
                    continue;
                }

                // Operators
                if ('+-*/%&|^'.includes(ch)) {
                    tokens.push({ type: 'op', value: ch });
                    i++;
                    continue;
                }

                // Parentheses
                if (ch === '(') {
                    tokens.push({ type: 'lparen' });
                    i++;
                    continue;
                }
                if (ch === ')') {
                    tokens.push({ type: 'rparen' });
                    i++;
                    continue;
                }

                // Unknown character
                i++;
            }

            if (tokens.length === 0) return null;

            // Shunting-yard algorithm for operator precedence
            const output = [];
            const opStack = [];
            const precedence = { '+': 1, '-': 1, '*': 2, '/': 2, '%': 2, '&': 0, '|': 0, '^': 0 };

            for (const token of tokens) {
                if (token.type === 'num') {
                    output.push(token.value);
                } else if (token.type === 'op') {
                    while (opStack.length > 0 && opStack[opStack.length - 1].type === 'op' &&
                           precedence[opStack[opStack.length - 1].value] >= precedence[token.value]) {
                        output.push(opStack.pop().value);
                    }
                    opStack.push(token);
                } else if (token.type === 'lparen') {
                    opStack.push(token);
                } else if (token.type === 'rparen') {
                    while (opStack.length > 0 && opStack[opStack.length - 1].type !== 'lparen') {
                        output.push(opStack.pop().value);
                    }
                    if (opStack.length > 0) opStack.pop();  // Remove lparen
                }
            }
            while (opStack.length > 0) {
                output.push(opStack.pop().value);
            }

            // Evaluate RPN
            const evalStack = [];
            for (const item of output) {
                if (typeof item === 'bigint') {
                    evalStack.push(item);
                } else {
                    if (evalStack.length < 2) return null;
                    const b = evalStack.pop();
                    const a = evalStack.pop();
                    let result;
                    switch (item) {
                        case '+': result = a + b; break;
                        case '-': result = a - b; break;
                        case '*': result = a * b; break;
                        case '/': result = b !== 0n ? a / b : 0n; break;
                        case '%': result = b !== 0n ? a % b : 0n; break;
                        case '&': result = a & b; break;
                        case '|': result = a | b; break;
                        case '^': result = a ^ b; break;
                        default: return null;
                    }
                    evalStack.push(result);
                }
            }

            return evalStack.length === 1 ? { result: evalStack[0], expr: expr } : null;
        }

        const calcInput = document.getElementById('calcInput');
        const calcInputBase = document.getElementById('calcInputBase');
        const calcDec = document.getElementById('calcDec');
        const calcHex = document.getElementById('calcHex');
        const calcOct = document.getElementById('calcOct');
        const calcBin = document.getElementById('calcBin');
        const calcSigned = document.getElementById('calcSigned');
        const calcAscii = document.getElementById('calcAscii');
        const calcBitSize = document.getElementById('calcBitSize');
        const calcBitsPanel = document.getElementById('calcBitsPanel');
        const calcBitsGrid = document.getElementById('calcBitsGrid');
        const calcBitsLabels = document.getElementById('calcBitsLabels');
        const calcClear = document.getElementById('calcClear');
        const calcDel = document.getElementById('calcDel');
        const calcEquals = document.getElementById('calcEquals');
        const calcNegate = document.getElementById('calcNegate');
        const calcLogContent = document.getElementById('calcLogContent');
        const calcLogClear = document.getElementById('calcLogClear');

        let calcValue = 0n;  // Use BigInt for precision
        let calcBitSizeValue = 16;  // 8, 16, 32
        let calcPendingOp = null;
        let calcPendingValue = 0n;
        let calcNewInput = true;
        let calcLogEntries = [];
        let calcExpressionParts = [];  // Track full expression for logging

        function calcFormatValue(val) {
            val = val & CALC_BIT_MASKS[calcBitSizeValue];
            return val.toString(16).toUpperCase() + 'h (' + val.toString() + ')';
        }

        function calcAddLog(entry) {
            calcLogEntries.push(entry);
            const div = document.createElement('div');
            div.className = 'calc-log-entry';
            div.innerHTML = entry;
            div.dataset.index = calcLogEntries.length - 1;
            calcLogContent.appendChild(div);
            calcLogContent.scrollTop = calcLogContent.scrollHeight;
        }

        function calcLogBinaryOp(a, op, b, result) {
            const opSymbol = op === 'and' ? '&' : op === 'or' ? '|' : op === 'xor' ? '^' : op === 'mod' ? '%' : op;
            calcAddLog(`<span class="calc-log-val">${calcFormatValue(a)}</span> <span class="calc-log-op">${opSymbol}</span> <span class="calc-log-val">${calcFormatValue(b)}</span> = <span class="calc-log-result">${calcFormatValue(result)}</span>`);
        }

        function calcLogUnaryOp(op, before, after) {
            calcAddLog(`<span class="calc-log-op">${op}</span> <span class="calc-log-val">${calcFormatValue(before)}</span> = <span class="calc-log-result">${calcFormatValue(after)}</span>`);
        }

        function calcLogExpression(parts, result) {
            // Format expression like: 25 + 5 + 3 - 7 = 26
            let html = '';
            for (let i = 0; i < parts.length; i++) {
                if (i % 2 === 0) {
                    // Value
                    html += `<span class="calc-log-val">${calcFormatValue(parts[i])}</span>`;
                } else {
                    // Operator
                    const op = parts[i];
                    const opSymbol = op === 'and' ? '&' : op === 'or' ? '|' : op === 'xor' ? '^' : op === 'mod' ? '%' : op;
                    html += ` <span class="calc-log-op">${opSymbol}</span> `;
                }
            }
            html += ` = <span class="calc-log-result">${calcFormatValue(result)}</span>`;
            calcAddLog(html);
        }

        calcLogClear.addEventListener('click', () => {
            calcLogEntries = [];
            calcLogContent.innerHTML = '';
        });

        calcLogContent.addEventListener('click', (e) => {
            const entry = e.target.closest('.calc-log-entry');
            if (entry) {
                // Extract result value from the entry and load it
                const resultEl = entry.querySelector('.calc-log-result');
                if (resultEl) {
                    const text = resultEl.textContent;
                    const match = text.match(/([0-9A-F]+)h/i);
                    if (match) {
                        calcValue = BigInt('0x' + match[1]);
                        calcUpdateDisplay();
                        calcNewInput = true;
                    }
                }
            }
        });

        const CALC_BIT_MASKS = {
            8: 0xFFn,
            16: 0xFFFFn,
            32: 0xFFFFFFFFn
        };

        function calcMask(val) {
            return val & CALC_BIT_MASKS[calcBitSizeValue];
        }

        function calcToSigned(val) {
            const mask = CALC_BIT_MASKS[calcBitSizeValue];
            const signBit = 1n << BigInt(calcBitSizeValue - 1);
            val = val & mask;
            if (val & signBit) {
                return val - (mask + 1n);
            }
            return val;
        }

        function calcFormatBin(val) {
            val = calcMask(val);
            const bits = val.toString(2).padStart(calcBitSizeValue, '0');
            // Group by 4 bits
            let result = '';
            for (let i = 0; i < bits.length; i += 4) {
                if (i > 0) result += ' ';
                result += bits.substr(i, 4);
            }
            return result;
        }

        function calcFormatDec(val) {
            val = calcMask(val);
            const str = val.toString();
            // Add thousand separators
            let result = '';
            for (let i = str.length - 1, c = 0; i >= 0; i--, c++) {
                if (c > 0 && c % 3 === 0) result = ' ' + result;
                result = str[i] + result;
            }
            return result;
        }

        function calcFormatOct(val) {
            val = calcMask(val);
            const str = val.toString(8);
            // Group by 3 digits
            let result = '';
            const padLen = Math.ceil(str.length / 3) * 3;
            const padded = str.padStart(padLen, '0');
            for (let i = 0; i < padded.length; i += 3) {
                if (i > 0) result += ' ';
                result += padded.substr(i, 3);
            }
            return result.replace(/^0+\s*/, '') || '0';
        }

        function calcUpdateDisplay() {
            const val = calcMask(calcValue);
            calcDec.textContent = calcFormatDec(val);
            calcHex.textContent = val.toString(16).toUpperCase();
            calcOct.textContent = calcFormatOct(val);
            calcBin.textContent = calcFormatBin(val);

            // Show signed value if negative (high bit set)
            const signedVal = calcToSigned(val);
            if (signedVal < 0n) {
                calcSigned.textContent = signedVal.toString();
            } else {
                calcSigned.textContent = '';
            }

            // Show ASCII if byte-sized and printable
            if (calcBitSizeValue === 8 || val <= 0xFFn) {
                const byteVal = Number(val & 0xFFn);
                if (byteVal >= 32 && byteVal < 127) {
                    calcAscii.textContent = `'${String.fromCharCode(byteVal)}'`;
                } else if (byteVal >= 0x80) {
                    const lowByte = byteVal & 0x7F;
                    if (lowByte >= 32 && lowByte < 127) {
                        calcAscii.textContent = `'${String.fromCharCode(lowByte)}'+$80`;
                    } else {
                        calcAscii.textContent = '';
                    }
                } else {
                    calcAscii.textContent = '';
                }
            } else {
                calcAscii.textContent = '';
            }

            // Update input field only if it doesn't contain a formula
            const currentInput = calcInput.value;
            if (!/[+\-*/%&|^()]/.test(currentInput)) {
                const base = parseInt(calcInputBase.value);
                if (base === 16) calcInput.value = val.toString(16).toUpperCase();
                else if (base === 10) calcInput.value = val.toString();
                else if (base === 8) calcInput.value = val.toString(8);
                else if (base === 2) calcInput.value = val.toString(2);
            }

            // Always update bits panel
            calcRenderBits();
        }

        function calcUpdateDigitButtons() {
            const base = parseInt(calcInputBase.value);
            // Define valid digits for each base
            const validDigits = {
                2: ['0', '1'],
                8: ['0', '1', '2', '3', '4', '5', '6', '7'],
                10: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
                16: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F']
            };
            const valid = validDigits[base] || validDigits[16];

            // Update all digit and hex-digit buttons
            document.querySelectorAll('.calc-btn.digit, .calc-btn.hex-digit').forEach(btn => {
                const ch = btn.dataset.char;
                if (ch) {
                    const isValid = valid.includes(ch);
                    btn.disabled = !isValid;
                    btn.classList.toggle('calc-btn-disabled', !isValid);
                }
            });
        }

        function calcRenderBits() {
            if (!calcBitsLabels || !calcBitsGrid) return;
            const val = calcMask(calcValue);

            // Render labels (show key bit positions)
            let labelsHtml = '';
            for (let i = calcBitSizeValue - 1; i >= 0; i--) {
                // Show labels at positions: 31, 23, 15, 7, 0 (or subset based on bit size)
                if (i === calcBitSizeValue - 1 || i === 0 || (i + 1) % 8 === 0) {
                    labelsHtml += `<div class="calc-bits-label">${i}</div>`;
                } else {
                    labelsHtml += `<div class="calc-bits-label"></div>`;
                }
                if (i > 0 && i % 4 === 0) labelsHtml += '<div class="calc-bits-label-sep"></div>';
            }
            calcBitsLabels.innerHTML = labelsHtml;

            // Render bits
            let html = '';
            for (let i = calcBitSizeValue - 1; i >= 0; i--) {
                const bitSet = (val >> BigInt(i)) & 1n;
                html += `<div class="calc-bit${bitSet ? ' set' : ''}" data-bit="${i}">${bitSet}</div>`;
                if (i > 0 && i % 4 === 0) html += '<div class="calc-bit-separator"></div>';
            }
            calcBitsGrid.innerHTML = html;
        }

        function calcParseInput() {
            const base = parseInt(calcInputBase.value);
            const text = calcInput.value.trim().replace(/\s/g, '');
            try {
                if (base === 16) calcValue = BigInt('0x' + (text || '0'));
                else if (base === 8) calcValue = BigInt('0o' + (text || '0'));
                else if (base === 2) calcValue = BigInt('0b' + (text || '0'));
                else calcValue = BigInt(text || '0');
                calcValue = calcMask(calcValue);
            } catch (e) {
                // Invalid input, ignore
            }
        }

        function calcApplyOp(op, a, b) {
            switch (op) {
                case '+': return a + b;
                case '-': return a - b;
                case '*': return a * b;
                case '/': return b !== 0n ? a / b : 0n;
                case 'mod': return b !== 0n ? a % b : 0n;
                case 'and': return a & b;
                case 'or': return a | b;
                case 'xor': return a ^ b;
                default: return b;
            }
        }

        function calcApplyUnary(op) {
            const mask = CALC_BIT_MASKS[calcBitSizeValue];
            const before = calcValue;
            switch (op) {
                case 'not': calcValue = ~calcValue & mask; break;
                case 'inc': calcValue = (calcValue + 1n) & mask; break;
                case 'dec': calcValue = (calcValue - 1n) & mask; break;
                case 'lsl': calcValue = (calcValue << 1n) & mask; break;
                case 'lsr': calcValue = calcValue >> 1n; break;
                case 'asr': {
                    const signBit = 1n << BigInt(calcBitSizeValue - 1);
                    const sign = calcValue & signBit;
                    calcValue = (calcValue >> 1n) | sign;
                    break;
                }
                case 'rol': {
                    const topBit = (calcValue >> BigInt(calcBitSizeValue - 1)) & 1n;
                    calcValue = ((calcValue << 1n) | topBit) & mask;
                    break;
                }
                case 'ror': {
                    const bottomBit = calcValue & 1n;
                    calcValue = (calcValue >> 1n) | (bottomBit << BigInt(calcBitSizeValue - 1));
                    break;
                }
                case 'rand': calcValue = BigInt(Math.floor(Math.random() * Number(mask + 1n))); break;
            }
            calcLogUnaryOp(op, before, calcValue);
            calcUpdateDisplay();
        }

        // Button handlers
        document.querySelectorAll('.calc-btn[data-char]').forEach(btn => {
            btn.addEventListener('click', () => {
                const ch = btn.dataset.char;
                const isParen = (ch === '(' || ch === ')');
                // Don't clear for parentheses - append to existing expression
                if (calcNewInput && !isParen) {
                    calcInput.value = '';
                    calcNewInput = false;
                }
                calcInput.value += ch;
                // Only parse as number if no operators/parens in input
                if (!/[+\-*/%&|^()]/.test(calcInput.value)) {
                    calcParseInput();
                    calcUpdateDisplay();
                }
            });
        });

        document.querySelectorAll('.calc-btn[data-op]').forEach(btn => {
            btn.addEventListener('click', () => {
                const op = btn.dataset.op;
                // Unary operators - always apply immediately
                if (['not', 'inc', 'dec', 'lsl', 'lsr', 'asr', 'rol', 'ror', 'rand'].includes(op)) {
                    calcApplyUnary(op);
                    calcNewInput = true;
                    return;
                }
                // For +, -, *, /, %, &, |, ^ - append to input as formula
                const opSymbol = op === 'and' ? '&' : op === 'or' ? '|' : op === 'xor' ? '^' : op === 'mod' ? '%' : op;
                if ('+-*/%&|^'.includes(opSymbol)) {
                    calcInput.value += opSymbol;
                    calcNewInput = false;
                }
            });
        });

        calcEquals.addEventListener('click', () => {
            const inputText = calcInput.value.trim();
            const base = parseInt(calcInputBase.value);

            // Try to parse as expression if it contains operators or parentheses
            if (/[+\-*/%&|^()]/.test(inputText)) {
                const parsed = calcParseExpression(inputText, base);
                if (parsed) {
                    calcValue = calcMask(parsed.result);
                    calcAddLog(`<span class="calc-log-val">${inputText}</span> = <span class="calc-log-result">${calcFormatValue(calcValue)}</span>`);
                    calcExpressionParts = [];
                    calcPendingOp = null;
                    calcPendingValue = 0n;
                    // Update input to show result (clear formula first so calcUpdateDisplay updates it)
                    calcInput.value = '';
                    calcUpdateDisplay();
                    calcNewInput = true;
                    return;
                }
            }

            // Original button-based calculation
            if (calcPendingOp) {
                // Add final part to expression
                if (calcExpressionParts.length === 0) {
                    calcExpressionParts.push(calcPendingValue);
                }
                calcExpressionParts.push(calcPendingOp);
                calcExpressionParts.push(calcValue);

                // Calculate final result
                calcValue = calcMask(calcApplyOp(calcPendingOp, calcPendingValue, calcValue));

                // Log full expression
                calcLogExpression(calcExpressionParts, calcValue);

                calcExpressionParts = [];
                calcPendingOp = null;
                calcPendingValue = 0n;
                calcUpdateDisplay();
            }
            calcNewInput = true;
        });

        calcClear.addEventListener('click', () => {
            calcValue = 0n;
            calcPendingOp = null;
            calcPendingValue = 0n;
            calcExpressionParts = [];
            calcNewInput = true;
            calcInput.value = '0';  // Clear input directly
            calcUpdateDisplay();
        });

        calcDel.addEventListener('click', () => {
            const text = calcInput.value;
            if (text.length > 0) {
                calcInput.value = text.slice(0, -1) || '0';
                calcParseInput();
                calcUpdateDisplay();
            }
        });

        calcNegate.addEventListener('click', () => {
            const before = calcValue;
            calcValue = calcMask(-calcValue);
            calcLogUnaryOp('neg', before, calcValue);
            calcUpdateDisplay();
            calcNewInput = true;
        });

        calcBitSize.addEventListener('click', () => {
            if (calcBitSizeValue === 8) calcBitSizeValue = 16;
            else if (calcBitSizeValue === 16) calcBitSizeValue = 32;
            else calcBitSizeValue = 8;
            calcBitSize.textContent = 'u' + calcBitSizeValue;
            calcValue = calcMask(calcValue);
            calcUpdateDisplay();
        });

        calcInputBase.addEventListener('change', () => {
            calcUpdateDisplay();
            calcUpdateDigitButtons();
        });

        calcInput.addEventListener('input', () => {
            // Only parse as number if no operators/parens (pure number input)
            if (!/[+\-*/%&|^()]/.test(calcInput.value)) {
                calcParseInput();
                calcUpdateDisplay();
            }
        });

        calcBitsGrid.addEventListener('click', (e) => {
            const bitEl = e.target.closest('.calc-bit');
            if (bitEl) {
                const bitNum = parseInt(bitEl.dataset.bit);
                calcValue ^= (1n << BigInt(bitNum));
                calcUpdateDisplay();
            }
        });

        // Keyboard support for calculator
        function isCalcTabActive() {
            const calcTab = document.getElementById('tab-calculator');
            return calcTab && calcTab.classList.contains('active');
        }

        // Keyboard support for calculator
        document.addEventListener('keydown', (e) => {
            if (!isCalcTabActive()) return;
            // Don't capture if typing in other inputs (except calcInput)
            if (e.target.tagName === 'INPUT' && e.target.id !== 'calcInput') return;
            if (e.target.tagName === 'TEXTAREA') return;
            if (e.target.tagName === 'SELECT') return;

            const isInCalcInput = (e.target.id === 'calcInput');

            // Handle Enter first - before anything else
            if (e.key === 'Enter' || e.code === 'NumpadEnter') {
                e.preventDefault();
                e.stopPropagation();
                calcEquals.click();
                return;
            }

            // Handle Backspace
            if (e.key === 'Backspace') {
                e.stopPropagation();
                if (isInCalcInput) {
                    // Let browser handle backspace in input, but stop emulator
                    return;
                }
                e.preventDefault();
                calcDel.click();
                return;
            }

            // If in calcInput, let other keys work naturally
            if (isInCalcInput) {
                e.stopPropagation();
                return;
            }

            // Below is for when NOT focused on calcInput
            let handled = false;
            const base = parseInt(calcInputBase.value);

            // Only handle single character keys for digits
            if (e.key.length === 1) {
                const key = e.key.toUpperCase();

                // Digits 0-9 (check if valid for current base)
                if (key >= '0' && key <= '9') {
                    const digit = parseInt(key);
                    // Only allow digits valid for current base
                    if (digit < base) {
                        if (calcNewInput) {
                            calcInput.value = '';
                            calcNewInput = false;
                        }
                        calcInput.value += key;
                        if (!/[+\-*/%&|^()]/.test(calcInput.value)) {
                            calcParseInput();
                            calcUpdateDisplay();
                        }
                        handled = true;
                    }
                }

                // Hex digits A-F (only in hex mode)
                if (!handled && base === 16 && key >= 'A' && key <= 'F') {
                    if (calcNewInput) {
                        calcInput.value = '';
                        calcNewInput = false;
                    }
                    calcInput.value += key;
                    if (!/[+\-*/%&|^()]/.test(calcInput.value)) {
                        calcParseInput();
                        calcUpdateDisplay();
                    }
                    handled = true;
                }
            }

            // Operations
            if (!handled) {
                switch (e.key) {
                    case '+':
                        document.querySelector('.calc-btn[data-op="+"]').click();
                        handled = true;
                        break;
                    case '-':
                        document.querySelector('.calc-btn[data-op="-"]').click();
                        handled = true;
                        break;
                    case '*':
                        document.querySelector('.calc-btn[data-op="*"]').click();
                        handled = true;
                        break;
                    case '/':
                        document.querySelector('.calc-btn[data-op="/"]').click();
                        handled = true;
                        break;
                    case '%':
                        document.querySelector('.calc-btn[data-op="mod"]').click();
                        handled = true;
                        break;
                    case '&':
                        document.querySelector('.calc-btn[data-op="and"]').click();
                        handled = true;
                        break;
                    case '|':
                        document.querySelector('.calc-btn[data-op="or"]').click();
                        handled = true;
                        break;
                    case '^':
                        document.querySelector('.calc-btn[data-op="xor"]').click();
                        handled = true;
                        break;
                    case '~':
                        document.querySelector('.calc-btn[data-op="not"]').click();
                        handled = true;
                        break;
                    case '=':
                        calcEquals.click();
                        handled = true;
                        break;
                    case 'Escape':
                        calcClear.click();
                        handled = true;
                        break;
                    case '<':
                        document.querySelector('.calc-btn[data-op="lsl"]').click();
                        handled = true;
                        break;
                    case '>':
                        document.querySelector('.calc-btn[data-op="lsr"]').click();
                        handled = true;
                        break;
                    case '(':
                    case ')':
                        calcInput.value += e.key;
                        calcNewInput = false;
                        handled = true;
                        break;
                }
            }

            if (handled) {
                e.preventDefault();
                e.stopPropagation();
            }
        }, true);  // Use capture phase

        // Initial display
        calcUpdateDisplay();
        calcUpdateDigitButtons();

        // ========== Z80 Opcodes Reference ==========
        const z80Opcodes = [
            // Load 8-bit
            { m: 'LD A,A', o: '7F', b: 1, c: '4', f: '------', d: 'Load A from A', g: 'load' },
            { m: 'LD A,B', o: '78', b: 1, c: '4', f: '------', d: 'Load A from B', g: 'load' },
            { m: 'LD A,C', o: '79', b: 1, c: '4', f: '------', d: 'Load A from C', g: 'load' },
            { m: 'LD A,D', o: '7A', b: 1, c: '4', f: '------', d: 'Load A from D', g: 'load' },
            { m: 'LD A,E', o: '7B', b: 1, c: '4', f: '------', d: 'Load A from E', g: 'load' },
            { m: 'LD A,H', o: '7C', b: 1, c: '4', f: '------', d: 'Load A from H', g: 'load' },
            { m: 'LD A,L', o: '7D', b: 1, c: '4', f: '------', d: 'Load A from L', g: 'load' },
            { m: 'LD B,A', o: '47', b: 1, c: '4', f: '------', d: 'Load B from A', g: 'load' },
            { m: 'LD B,B', o: '40', b: 1, c: '4', f: '------', d: 'Load B from B', g: 'load' },
            { m: 'LD B,C', o: '41', b: 1, c: '4', f: '------', d: 'Load B from C', g: 'load' },
            { m: 'LD B,D', o: '42', b: 1, c: '4', f: '------', d: 'Load B from D', g: 'load' },
            { m: 'LD B,E', o: '43', b: 1, c: '4', f: '------', d: 'Load B from E', g: 'load' },
            { m: 'LD B,H', o: '44', b: 1, c: '4', f: '------', d: 'Load B from H', g: 'load' },
            { m: 'LD B,L', o: '45', b: 1, c: '4', f: '------', d: 'Load B from L', g: 'load' },
            { m: 'LD C,A', o: '4F', b: 1, c: '4', f: '------', d: 'Load C from A', g: 'load' },
            { m: 'LD C,B', o: '48', b: 1, c: '4', f: '------', d: 'Load C from B', g: 'load' },
            { m: 'LD C,C', o: '49', b: 1, c: '4', f: '------', d: 'Load C from C', g: 'load' },
            { m: 'LD C,D', o: '4A', b: 1, c: '4', f: '------', d: 'Load C from D', g: 'load' },
            { m: 'LD C,E', o: '4B', b: 1, c: '4', f: '------', d: 'Load C from E', g: 'load' },
            { m: 'LD C,H', o: '4C', b: 1, c: '4', f: '------', d: 'Load C from H', g: 'load' },
            { m: 'LD C,L', o: '4D', b: 1, c: '4', f: '------', d: 'Load C from L', g: 'load' },
            { m: 'LD D,A', o: '57', b: 1, c: '4', f: '------', d: 'Load D from A', g: 'load' },
            { m: 'LD D,B', o: '50', b: 1, c: '4', f: '------', d: 'Load D from B', g: 'load' },
            { m: 'LD D,C', o: '51', b: 1, c: '4', f: '------', d: 'Load D from C', g: 'load' },
            { m: 'LD D,D', o: '52', b: 1, c: '4', f: '------', d: 'Load D from D', g: 'load' },
            { m: 'LD D,E', o: '53', b: 1, c: '4', f: '------', d: 'Load D from E', g: 'load' },
            { m: 'LD D,H', o: '54', b: 1, c: '4', f: '------', d: 'Load D from H', g: 'load' },
            { m: 'LD D,L', o: '55', b: 1, c: '4', f: '------', d: 'Load D from L', g: 'load' },
            { m: 'LD E,A', o: '5F', b: 1, c: '4', f: '------', d: 'Load E from A', g: 'load' },
            { m: 'LD E,B', o: '58', b: 1, c: '4', f: '------', d: 'Load E from B', g: 'load' },
            { m: 'LD E,C', o: '59', b: 1, c: '4', f: '------', d: 'Load E from C', g: 'load' },
            { m: 'LD E,D', o: '5A', b: 1, c: '4', f: '------', d: 'Load E from D', g: 'load' },
            { m: 'LD E,E', o: '5B', b: 1, c: '4', f: '------', d: 'Load E from E', g: 'load' },
            { m: 'LD E,H', o: '5C', b: 1, c: '4', f: '------', d: 'Load E from H', g: 'load' },
            { m: 'LD E,L', o: '5D', b: 1, c: '4', f: '------', d: 'Load E from L', g: 'load' },
            { m: 'LD H,A', o: '67', b: 1, c: '4', f: '------', d: 'Load H from A', g: 'load' },
            { m: 'LD H,B', o: '60', b: 1, c: '4', f: '------', d: 'Load H from B', g: 'load' },
            { m: 'LD H,C', o: '61', b: 1, c: '4', f: '------', d: 'Load H from C', g: 'load' },
            { m: 'LD H,D', o: '62', b: 1, c: '4', f: '------', d: 'Load H from D', g: 'load' },
            { m: 'LD H,E', o: '63', b: 1, c: '4', f: '------', d: 'Load H from E', g: 'load' },
            { m: 'LD H,H', o: '64', b: 1, c: '4', f: '------', d: 'Load H from H', g: 'load' },
            { m: 'LD H,L', o: '65', b: 1, c: '4', f: '------', d: 'Load H from L', g: 'load' },
            { m: 'LD L,A', o: '6F', b: 1, c: '4', f: '------', d: 'Load L from A', g: 'load' },
            { m: 'LD L,B', o: '68', b: 1, c: '4', f: '------', d: 'Load L from B', g: 'load' },
            { m: 'LD L,C', o: '69', b: 1, c: '4', f: '------', d: 'Load L from C', g: 'load' },
            { m: 'LD L,D', o: '6A', b: 1, c: '4', f: '------', d: 'Load L from D', g: 'load' },
            { m: 'LD L,E', o: '6B', b: 1, c: '4', f: '------', d: 'Load L from E', g: 'load' },
            { m: 'LD L,H', o: '6C', b: 1, c: '4', f: '------', d: 'Load L from H', g: 'load' },
            { m: 'LD L,L', o: '6D', b: 1, c: '4', f: '------', d: 'Load L from L', g: 'load' },
            { m: 'LD A,n', o: '3E nn', b: 2, c: '7', f: '------', d: 'Load A with immediate', g: 'load' },
            { m: 'LD B,n', o: '06 nn', b: 2, c: '7', f: '------', d: 'Load B with immediate', g: 'load' },
            { m: 'LD C,n', o: '0E nn', b: 2, c: '7', f: '------', d: 'Load C with immediate', g: 'load' },
            { m: 'LD D,n', o: '16 nn', b: 2, c: '7', f: '------', d: 'Load D with immediate', g: 'load' },
            { m: 'LD E,n', o: '1E nn', b: 2, c: '7', f: '------', d: 'Load E with immediate', g: 'load' },
            { m: 'LD H,n', o: '26 nn', b: 2, c: '7', f: '------', d: 'Load H with immediate', g: 'load' },
            { m: 'LD L,n', o: '2E nn', b: 2, c: '7', f: '------', d: 'Load L with immediate', g: 'load' },
            { m: 'LD A,(HL)', o: '7E', b: 1, c: '7', f: '------', d: 'Load A from (HL)', g: 'load' },
            { m: 'LD B,(HL)', o: '46', b: 1, c: '7', f: '------', d: 'Load B from (HL)', g: 'load' },
            { m: 'LD C,(HL)', o: '4E', b: 1, c: '7', f: '------', d: 'Load C from (HL)', g: 'load' },
            { m: 'LD D,(HL)', o: '56', b: 1, c: '7', f: '------', d: 'Load D from (HL)', g: 'load' },
            { m: 'LD E,(HL)', o: '5E', b: 1, c: '7', f: '------', d: 'Load E from (HL)', g: 'load' },
            { m: 'LD H,(HL)', o: '66', b: 1, c: '7', f: '------', d: 'Load H from (HL)', g: 'load' },
            { m: 'LD L,(HL)', o: '6E', b: 1, c: '7', f: '------', d: 'Load L from (HL)', g: 'load' },
            { m: 'LD A,(IX+d)', o: 'DD 7E dd', b: 3, c: '19', f: '------', d: 'Load A from (IX+d)', g: 'load' },
            { m: 'LD B,(IX+d)', o: 'DD 46 dd', b: 3, c: '19', f: '------', d: 'Load B from (IX+d)', g: 'load' },
            { m: 'LD C,(IX+d)', o: 'DD 4E dd', b: 3, c: '19', f: '------', d: 'Load C from (IX+d)', g: 'load' },
            { m: 'LD D,(IX+d)', o: 'DD 56 dd', b: 3, c: '19', f: '------', d: 'Load D from (IX+d)', g: 'load' },
            { m: 'LD E,(IX+d)', o: 'DD 5E dd', b: 3, c: '19', f: '------', d: 'Load E from (IX+d)', g: 'load' },
            { m: 'LD H,(IX+d)', o: 'DD 66 dd', b: 3, c: '19', f: '------', d: 'Load H from (IX+d)', g: 'load' },
            { m: 'LD L,(IX+d)', o: 'DD 6E dd', b: 3, c: '19', f: '------', d: 'Load L from (IX+d)', g: 'load' },
            { m: 'LD A,(IY+d)', o: 'FD 7E dd', b: 3, c: '19', f: '------', d: 'Load A from (IY+d)', g: 'load' },
            { m: 'LD B,(IY+d)', o: 'FD 46 dd', b: 3, c: '19', f: '------', d: 'Load B from (IY+d)', g: 'load' },
            { m: 'LD C,(IY+d)', o: 'FD 4E dd', b: 3, c: '19', f: '------', d: 'Load C from (IY+d)', g: 'load' },
            { m: 'LD D,(IY+d)', o: 'FD 56 dd', b: 3, c: '19', f: '------', d: 'Load D from (IY+d)', g: 'load' },
            { m: 'LD E,(IY+d)', o: 'FD 5E dd', b: 3, c: '19', f: '------', d: 'Load E from (IY+d)', g: 'load' },
            { m: 'LD H,(IY+d)', o: 'FD 66 dd', b: 3, c: '19', f: '------', d: 'Load H from (IY+d)', g: 'load' },
            { m: 'LD L,(IY+d)', o: 'FD 6E dd', b: 3, c: '19', f: '------', d: 'Load L from (IY+d)', g: 'load' },
            { m: 'LD (HL),A', o: '77', b: 1, c: '7', f: '------', d: 'Load (HL) from A', g: 'load' },
            { m: 'LD (HL),B', o: '70', b: 1, c: '7', f: '------', d: 'Load (HL) from B', g: 'load' },
            { m: 'LD (HL),C', o: '71', b: 1, c: '7', f: '------', d: 'Load (HL) from C', g: 'load' },
            { m: 'LD (HL),D', o: '72', b: 1, c: '7', f: '------', d: 'Load (HL) from D', g: 'load' },
            { m: 'LD (HL),E', o: '73', b: 1, c: '7', f: '------', d: 'Load (HL) from E', g: 'load' },
            { m: 'LD (HL),H', o: '74', b: 1, c: '7', f: '------', d: 'Load (HL) from H', g: 'load' },
            { m: 'LD (HL),L', o: '75', b: 1, c: '7', f: '------', d: 'Load (HL) from L', g: 'load' },
            { m: 'LD (IX+d),A', o: 'DD 77 dd', b: 3, c: '19', f: '------', d: 'Load (IX+d) from A', g: 'load' },
            { m: 'LD (IX+d),B', o: 'DD 70 dd', b: 3, c: '19', f: '------', d: 'Load (IX+d) from B', g: 'load' },
            { m: 'LD (IX+d),C', o: 'DD 71 dd', b: 3, c: '19', f: '------', d: 'Load (IX+d) from C', g: 'load' },
            { m: 'LD (IX+d),D', o: 'DD 72 dd', b: 3, c: '19', f: '------', d: 'Load (IX+d) from D', g: 'load' },
            { m: 'LD (IX+d),E', o: 'DD 73 dd', b: 3, c: '19', f: '------', d: 'Load (IX+d) from E', g: 'load' },
            { m: 'LD (IX+d),H', o: 'DD 74 dd', b: 3, c: '19', f: '------', d: 'Load (IX+d) from H', g: 'load' },
            { m: 'LD (IX+d),L', o: 'DD 75 dd', b: 3, c: '19', f: '------', d: 'Load (IX+d) from L', g: 'load' },
            { m: 'LD (IY+d),A', o: 'FD 77 dd', b: 3, c: '19', f: '------', d: 'Load (IY+d) from A', g: 'load' },
            { m: 'LD (IY+d),B', o: 'FD 70 dd', b: 3, c: '19', f: '------', d: 'Load (IY+d) from B', g: 'load' },
            { m: 'LD (IY+d),C', o: 'FD 71 dd', b: 3, c: '19', f: '------', d: 'Load (IY+d) from C', g: 'load' },
            { m: 'LD (IY+d),D', o: 'FD 72 dd', b: 3, c: '19', f: '------', d: 'Load (IY+d) from D', g: 'load' },
            { m: 'LD (IY+d),E', o: 'FD 73 dd', b: 3, c: '19', f: '------', d: 'Load (IY+d) from E', g: 'load' },
            { m: 'LD (IY+d),H', o: 'FD 74 dd', b: 3, c: '19', f: '------', d: 'Load (IY+d) from H', g: 'load' },
            { m: 'LD (IY+d),L', o: 'FD 75 dd', b: 3, c: '19', f: '------', d: 'Load (IY+d) from L', g: 'load' },
            { m: 'LD (HL),n', o: '36 nn', b: 2, c: '10', f: '------', d: 'Load (HL) with immediate', g: 'load' },
            { m: 'LD (IX+d),n', o: 'DD 36 dd nn', b: 4, c: '19', f: '------', d: 'Load (IX+d) with immediate', g: 'load' },
            { m: 'LD (IY+d),n', o: 'FD 36 dd nn', b: 4, c: '19', f: '------', d: 'Load (IY+d) with immediate', g: 'load' },
            { m: 'LD A,(BC)', o: '0A', b: 1, c: '7', f: '------', d: 'Load A from (BC)', g: 'load' },
            { m: 'LD A,(DE)', o: '1A', b: 1, c: '7', f: '------', d: 'Load A from (DE)', g: 'load' },
            { m: 'LD A,(nn)', o: '3A nn nn', b: 3, c: '13', f: '------', d: 'Load A from memory', g: 'load' },
            { m: 'LD (BC),A', o: '02', b: 1, c: '7', f: '------', d: 'Load (BC) from A', g: 'load' },
            { m: 'LD (DE),A', o: '12', b: 1, c: '7', f: '------', d: 'Load (DE) from A', g: 'load' },
            { m: 'LD (nn),A', o: '32 nn nn', b: 3, c: '13', f: '------', d: 'Load memory from A', g: 'load' },
            { m: 'LD A,I', o: 'ED 57', b: 2, c: '9', f: 'SZ*P0-', d: 'Load A from I', g: 'load' },
            { m: 'LD A,R', o: 'ED 5F', b: 2, c: '9', f: 'SZ*P0-', d: 'Load A from R', g: 'load' },
            { m: 'LD I,A', o: 'ED 47', b: 2, c: '9', f: '------', d: 'Load I from A', g: 'load' },
            { m: 'LD R,A', o: 'ED 4F', b: 2, c: '9', f: '------', d: 'Load R from A', g: 'load' },
            // Undocumented LD with IXH/IXL/IYH/IYL
            { m: 'LD A,IXH', o: 'DD 7C', b: 2, c: '8', f: '------', d: 'Load A from IXH', g: 'load', u: true },
            { m: 'LD A,IXL', o: 'DD 7D', b: 2, c: '8', f: '------', d: 'Load A from IXL', g: 'load', u: true },
            { m: 'LD A,IYH', o: 'FD 7C', b: 2, c: '8', f: '------', d: 'Load A from IYH', g: 'load', u: true },
            { m: 'LD A,IYL', o: 'FD 7D', b: 2, c: '8', f: '------', d: 'Load A from IYL', g: 'load', u: true },
            { m: 'LD IXH,A', o: 'DD 67', b: 2, c: '8', f: '------', d: 'Load IXH from A', g: 'load', u: true },
            { m: 'LD IXL,A', o: 'DD 6F', b: 2, c: '8', f: '------', d: 'Load IXL from A', g: 'load', u: true },
            { m: 'LD IYH,A', o: 'FD 67', b: 2, c: '8', f: '------', d: 'Load IYH from A', g: 'load', u: true },
            { m: 'LD IYL,A', o: 'FD 6F', b: 2, c: '8', f: '------', d: 'Load IYL from A', g: 'load', u: true },
            { m: 'LD IXH,n', o: 'DD 26 nn', b: 3, c: '11', f: '------', d: 'Load IXH with immediate', g: 'load', u: true },
            { m: 'LD IXL,n', o: 'DD 2E nn', b: 3, c: '11', f: '------', d: 'Load IXL with immediate', g: 'load', u: true },
            { m: 'LD IYH,n', o: 'FD 26 nn', b: 3, c: '11', f: '------', d: 'Load IYH with immediate', g: 'load', u: true },
            { m: 'LD IYL,n', o: 'FD 2E nn', b: 3, c: '11', f: '------', d: 'Load IYL with immediate', g: 'load', u: true },
            // Load 16-bit
            { m: 'LD BC,nn', o: '01 nn nn', b: 3, c: '10', f: '------', d: 'Load BC with immediate', g: 'load' },
            { m: 'LD DE,nn', o: '11 nn nn', b: 3, c: '10', f: '------', d: 'Load DE with immediate', g: 'load' },
            { m: 'LD HL,nn', o: '21 nn nn', b: 3, c: '10', f: '------', d: 'Load HL with immediate', g: 'load' },
            { m: 'LD SP,nn', o: '31 nn nn', b: 3, c: '10', f: '------', d: 'Load SP with immediate', g: 'load' },
            { m: 'LD IX,nn', o: 'DD 21 nn nn', b: 4, c: '14', f: '------', d: 'Load IX with immediate', g: 'load' },
            { m: 'LD IY,nn', o: 'FD 21 nn nn', b: 4, c: '14', f: '------', d: 'Load IY with immediate', g: 'load' },
            { m: 'LD HL,(nn)', o: '2A nn nn', b: 3, c: '16', f: '------', d: 'Load HL from memory', g: 'load' },
            { m: 'LD BC,(nn)', o: 'ED 4B nn nn', b: 4, c: '20', f: '------', d: 'Load BC from memory', g: 'load' },
            { m: 'LD DE,(nn)', o: 'ED 5B nn nn', b: 4, c: '20', f: '------', d: 'Load DE from memory', g: 'load' },
            { m: 'LD SP,(nn)', o: 'ED 7B nn nn', b: 4, c: '20', f: '------', d: 'Load SP from memory', g: 'load' },
            { m: 'LD IX,(nn)', o: 'DD 2A nn nn', b: 4, c: '20', f: '------', d: 'Load IX from memory', g: 'load' },
            { m: 'LD IY,(nn)', o: 'FD 2A nn nn', b: 4, c: '20', f: '------', d: 'Load IY from memory', g: 'load' },
            { m: 'LD (nn),HL', o: '22 nn nn', b: 3, c: '16', f: '------', d: 'Load memory from HL', g: 'load' },
            { m: 'LD (nn),BC', o: 'ED 43 nn nn', b: 4, c: '20', f: '------', d: 'Load memory from BC', g: 'load' },
            { m: 'LD (nn),DE', o: 'ED 53 nn nn', b: 4, c: '20', f: '------', d: 'Load memory from DE', g: 'load' },
            { m: 'LD (nn),SP', o: 'ED 73 nn nn', b: 4, c: '20', f: '------', d: 'Load memory from SP', g: 'load' },
            { m: 'LD (nn),IX', o: 'DD 22 nn nn', b: 4, c: '20', f: '------', d: 'Load memory from IX', g: 'load' },
            { m: 'LD (nn),IY', o: 'FD 22 nn nn', b: 4, c: '20', f: '------', d: 'Load memory from IY', g: 'load' },
            { m: 'LD SP,HL', o: 'F9', b: 1, c: '6', f: '------', d: 'Load SP from HL', g: 'load' },
            { m: 'LD SP,IX', o: 'DD F9', b: 2, c: '10', f: '------', d: 'Load SP from IX', g: 'load' },
            { m: 'LD SP,IY', o: 'FD F9', b: 2, c: '10', f: '------', d: 'Load SP from IY', g: 'load' },
            { m: 'PUSH AF', o: 'F5', b: 1, c: '11', f: '------', d: 'Push AF to stack', g: 'load' },
            { m: 'PUSH BC', o: 'C5', b: 1, c: '11', f: '------', d: 'Push BC to stack', g: 'load' },
            { m: 'PUSH DE', o: 'D5', b: 1, c: '11', f: '------', d: 'Push DE to stack', g: 'load' },
            { m: 'PUSH HL', o: 'E5', b: 1, c: '11', f: '------', d: 'Push HL to stack', g: 'load' },
            { m: 'PUSH IX', o: 'DD E5', b: 2, c: '15', f: '------', d: 'Push IX to stack', g: 'load' },
            { m: 'PUSH IY', o: 'FD E5', b: 2, c: '15', f: '------', d: 'Push IY to stack', g: 'load' },
            { m: 'POP AF', o: 'F1', b: 1, c: '10', f: '------', d: 'Pop AF from stack', g: 'load' },
            { m: 'POP BC', o: 'C1', b: 1, c: '10', f: '------', d: 'Pop BC from stack', g: 'load' },
            { m: 'POP DE', o: 'D1', b: 1, c: '10', f: '------', d: 'Pop DE from stack', g: 'load' },
            { m: 'POP HL', o: 'E1', b: 1, c: '10', f: '------', d: 'Pop HL from stack', g: 'load' },
            { m: 'POP IX', o: 'DD E1', b: 2, c: '14', f: '------', d: 'Pop IX from stack', g: 'load' },
            { m: 'POP IY', o: 'FD E1', b: 2, c: '14', f: '------', d: 'Pop IY from stack', g: 'load' },
            // Exchange
            { m: 'EX DE,HL', o: 'EB', b: 1, c: '4', f: '------', d: 'Exchange DE and HL', g: 'load' },
            { m: 'EX AF,AF\'', o: '08', b: 1, c: '4', f: '------', d: 'Exchange AF and AF\'', g: 'load' },
            { m: 'EXX', o: 'D9', b: 1, c: '4', f: '------', d: 'Exchange BC,DE,HL with alternates', g: 'load' },
            { m: 'EX (SP),HL', o: 'E3', b: 1, c: '19', f: '------', d: 'Exchange (SP) and HL', g: 'load' },
            { m: 'EX (SP),IX', o: 'DD E3', b: 2, c: '23', f: '------', d: 'Exchange (SP) and IX', g: 'load' },
            { m: 'EX (SP),IY', o: 'FD E3', b: 2, c: '23', f: '------', d: 'Exchange (SP) and IY', g: 'load' },
            // Arithmetic 8-bit
            { m: 'ADD A,A', o: '87', b: 1, c: '4', f: 'SZ*V0C', d: 'Add A to A', g: 'arith' },
            { m: 'ADD A,B', o: '80', b: 1, c: '4', f: 'SZ*V0C', d: 'Add B to A', g: 'arith' },
            { m: 'ADD A,C', o: '81', b: 1, c: '4', f: 'SZ*V0C', d: 'Add C to A', g: 'arith' },
            { m: 'ADD A,D', o: '82', b: 1, c: '4', f: 'SZ*V0C', d: 'Add D to A', g: 'arith' },
            { m: 'ADD A,E', o: '83', b: 1, c: '4', f: 'SZ*V0C', d: 'Add E to A', g: 'arith' },
            { m: 'ADD A,H', o: '84', b: 1, c: '4', f: 'SZ*V0C', d: 'Add H to A', g: 'arith' },
            { m: 'ADD A,L', o: '85', b: 1, c: '4', f: 'SZ*V0C', d: 'Add L to A', g: 'arith' },
            { m: 'ADD A,n', o: 'C6 nn', b: 2, c: '7', f: 'SZ*V0C', d: 'Add immediate to A', g: 'arith' },
            { m: 'ADD A,(HL)', o: '86', b: 1, c: '7', f: 'SZ*V0C', d: 'Add (HL) to A', g: 'arith' },
            { m: 'ADD A,(IX+d)', o: 'DD 86 dd', b: 3, c: '19', f: 'SZ*V0C', d: 'Add (IX+d) to A', g: 'arith' },
            { m: 'ADD A,(IY+d)', o: 'FD 86 dd', b: 3, c: '19', f: 'SZ*V0C', d: 'Add (IY+d) to A', g: 'arith' },
            { m: 'ADD A,IXH', o: 'DD 84', b: 2, c: '8', f: 'SZ*V0C', d: 'Add IXH to A', g: 'arith', u: true },
            { m: 'ADD A,IXL', o: 'DD 85', b: 2, c: '8', f: 'SZ*V0C', d: 'Add IXL to A', g: 'arith', u: true },
            { m: 'ADD A,IYH', o: 'FD 84', b: 2, c: '8', f: 'SZ*V0C', d: 'Add IYH to A', g: 'arith', u: true },
            { m: 'ADD A,IYL', o: 'FD 85', b: 2, c: '8', f: 'SZ*V0C', d: 'Add IYL to A', g: 'arith', u: true },
            { m: 'ADC A,A', o: '8F', b: 1, c: '4', f: 'SZ*V0C', d: 'Add with carry A to A', g: 'arith' },
            { m: 'ADC A,B', o: '88', b: 1, c: '4', f: 'SZ*V0C', d: 'Add with carry B to A', g: 'arith' },
            { m: 'ADC A,C', o: '89', b: 1, c: '4', f: 'SZ*V0C', d: 'Add with carry C to A', g: 'arith' },
            { m: 'ADC A,D', o: '8A', b: 1, c: '4', f: 'SZ*V0C', d: 'Add with carry D to A', g: 'arith' },
            { m: 'ADC A,E', o: '8B', b: 1, c: '4', f: 'SZ*V0C', d: 'Add with carry E to A', g: 'arith' },
            { m: 'ADC A,H', o: '8C', b: 1, c: '4', f: 'SZ*V0C', d: 'Add with carry H to A', g: 'arith' },
            { m: 'ADC A,L', o: '8D', b: 1, c: '4', f: 'SZ*V0C', d: 'Add with carry L to A', g: 'arith' },
            { m: 'ADC A,n', o: 'CE nn', b: 2, c: '7', f: 'SZ*V0C', d: 'Add with carry immediate to A', g: 'arith' },
            { m: 'ADC A,(HL)', o: '8E', b: 1, c: '7', f: 'SZ*V0C', d: 'Add with carry (HL) to A', g: 'arith' },
            { m: 'ADC A,(IX+d)', o: 'DD 8E dd', b: 3, c: '19', f: 'SZ*V0C', d: 'Add with carry (IX+d) to A', g: 'arith' },
            { m: 'ADC A,(IY+d)', o: 'FD 8E dd', b: 3, c: '19', f: 'SZ*V0C', d: 'Add with carry (IY+d) to A', g: 'arith' },
            { m: 'SUB A', o: '97', b: 1, c: '4', f: 'SZ*V1C', d: 'Subtract A from A', g: 'arith' },
            { m: 'SUB B', o: '90', b: 1, c: '4', f: 'SZ*V1C', d: 'Subtract B from A', g: 'arith' },
            { m: 'SUB C', o: '91', b: 1, c: '4', f: 'SZ*V1C', d: 'Subtract C from A', g: 'arith' },
            { m: 'SUB D', o: '92', b: 1, c: '4', f: 'SZ*V1C', d: 'Subtract D from A', g: 'arith' },
            { m: 'SUB E', o: '93', b: 1, c: '4', f: 'SZ*V1C', d: 'Subtract E from A', g: 'arith' },
            { m: 'SUB H', o: '94', b: 1, c: '4', f: 'SZ*V1C', d: 'Subtract H from A', g: 'arith' },
            { m: 'SUB L', o: '95', b: 1, c: '4', f: 'SZ*V1C', d: 'Subtract L from A', g: 'arith' },
            { m: 'SUB n', o: 'D6 nn', b: 2, c: '7', f: 'SZ*V1C', d: 'Subtract immediate from A', g: 'arith' },
            { m: 'SUB (HL)', o: '96', b: 1, c: '7', f: 'SZ*V1C', d: 'Subtract (HL) from A', g: 'arith' },
            { m: 'SUB (IX+d)', o: 'DD 96 dd', b: 3, c: '19', f: 'SZ*V1C', d: 'Subtract (IX+d) from A', g: 'arith' },
            { m: 'SUB (IY+d)', o: 'FD 96 dd', b: 3, c: '19', f: 'SZ*V1C', d: 'Subtract (IY+d) from A', g: 'arith' },
            { m: 'SBC A,A', o: '9F', b: 1, c: '4', f: 'SZ*V1C', d: 'Subtract with carry A from A', g: 'arith' },
            { m: 'SBC A,B', o: '98', b: 1, c: '4', f: 'SZ*V1C', d: 'Subtract with carry B from A', g: 'arith' },
            { m: 'SBC A,C', o: '99', b: 1, c: '4', f: 'SZ*V1C', d: 'Subtract with carry C from A', g: 'arith' },
            { m: 'SBC A,D', o: '9A', b: 1, c: '4', f: 'SZ*V1C', d: 'Subtract with carry D from A', g: 'arith' },
            { m: 'SBC A,E', o: '9B', b: 1, c: '4', f: 'SZ*V1C', d: 'Subtract with carry E from A', g: 'arith' },
            { m: 'SBC A,H', o: '9C', b: 1, c: '4', f: 'SZ*V1C', d: 'Subtract with carry H from A', g: 'arith' },
            { m: 'SBC A,L', o: '9D', b: 1, c: '4', f: 'SZ*V1C', d: 'Subtract with carry L from A', g: 'arith' },
            { m: 'SBC A,n', o: 'DE nn', b: 2, c: '7', f: 'SZ*V1C', d: 'Subtract with carry immediate from A', g: 'arith' },
            { m: 'SBC A,(HL)', o: '9E', b: 1, c: '7', f: 'SZ*V1C', d: 'Subtract with carry (HL) from A', g: 'arith' },
            { m: 'SBC A,(IX+d)', o: 'DD 9E dd', b: 3, c: '19', f: 'SZ*V1C', d: 'Subtract with carry (IX+d) from A', g: 'arith' },
            { m: 'SBC A,(IY+d)', o: 'FD 9E dd', b: 3, c: '19', f: 'SZ*V1C', d: 'Subtract with carry (IY+d) from A', g: 'arith' },
            { m: 'CP A', o: 'BF', b: 1, c: '4', f: 'SZ*V1C', d: 'Compare A with A', g: 'arith' },
            { m: 'CP B', o: 'B8', b: 1, c: '4', f: 'SZ*V1C', d: 'Compare B with A', g: 'arith' },
            { m: 'CP C', o: 'B9', b: 1, c: '4', f: 'SZ*V1C', d: 'Compare C with A', g: 'arith' },
            { m: 'CP D', o: 'BA', b: 1, c: '4', f: 'SZ*V1C', d: 'Compare D with A', g: 'arith' },
            { m: 'CP E', o: 'BB', b: 1, c: '4', f: 'SZ*V1C', d: 'Compare E with A', g: 'arith' },
            { m: 'CP H', o: 'BC', b: 1, c: '4', f: 'SZ*V1C', d: 'Compare H with A', g: 'arith' },
            { m: 'CP L', o: 'BD', b: 1, c: '4', f: 'SZ*V1C', d: 'Compare L with A', g: 'arith' },
            { m: 'CP n', o: 'FE nn', b: 2, c: '7', f: 'SZ*V1C', d: 'Compare immediate with A', g: 'arith' },
            { m: 'CP (HL)', o: 'BE', b: 1, c: '7', f: 'SZ*V1C', d: 'Compare (HL) with A', g: 'arith' },
            { m: 'CP (IX+d)', o: 'DD BE dd', b: 3, c: '19', f: 'SZ*V1C', d: 'Compare (IX+d) with A', g: 'arith' },
            { m: 'CP (IY+d)', o: 'FD BE dd', b: 3, c: '19', f: 'SZ*V1C', d: 'Compare (IY+d) with A', g: 'arith' },
            { m: 'INC A', o: '3C', b: 1, c: '4', f: 'SZ*V0-', d: 'Increment A', g: 'arith' },
            { m: 'INC B', o: '04', b: 1, c: '4', f: 'SZ*V0-', d: 'Increment B', g: 'arith' },
            { m: 'INC C', o: '0C', b: 1, c: '4', f: 'SZ*V0-', d: 'Increment C', g: 'arith' },
            { m: 'INC D', o: '14', b: 1, c: '4', f: 'SZ*V0-', d: 'Increment D', g: 'arith' },
            { m: 'INC E', o: '1C', b: 1, c: '4', f: 'SZ*V0-', d: 'Increment E', g: 'arith' },
            { m: 'INC H', o: '24', b: 1, c: '4', f: 'SZ*V0-', d: 'Increment H', g: 'arith' },
            { m: 'INC L', o: '2C', b: 1, c: '4', f: 'SZ*V0-', d: 'Increment L', g: 'arith' },
            { m: 'INC (HL)', o: '34', b: 1, c: '11', f: 'SZ*V0-', d: 'Increment (HL)', g: 'arith' },
            { m: 'INC (IX+d)', o: 'DD 34 dd', b: 3, c: '23', f: 'SZ*V0-', d: 'Increment (IX+d)', g: 'arith' },
            { m: 'INC (IY+d)', o: 'FD 34 dd', b: 3, c: '23', f: 'SZ*V0-', d: 'Increment (IY+d)', g: 'arith' },
            { m: 'INC IXH', o: 'DD 24', b: 2, c: '8', f: 'SZ*V0-', d: 'Increment IXH', g: 'arith', u: true },
            { m: 'INC IXL', o: 'DD 2C', b: 2, c: '8', f: 'SZ*V0-', d: 'Increment IXL', g: 'arith', u: true },
            { m: 'INC IYH', o: 'FD 24', b: 2, c: '8', f: 'SZ*V0-', d: 'Increment IYH', g: 'arith', u: true },
            { m: 'INC IYL', o: 'FD 2C', b: 2, c: '8', f: 'SZ*V0-', d: 'Increment IYL', g: 'arith', u: true },
            { m: 'DEC A', o: '3D', b: 1, c: '4', f: 'SZ*V1-', d: 'Decrement A', g: 'arith' },
            { m: 'DEC B', o: '05', b: 1, c: '4', f: 'SZ*V1-', d: 'Decrement B', g: 'arith' },
            { m: 'DEC C', o: '0D', b: 1, c: '4', f: 'SZ*V1-', d: 'Decrement C', g: 'arith' },
            { m: 'DEC D', o: '15', b: 1, c: '4', f: 'SZ*V1-', d: 'Decrement D', g: 'arith' },
            { m: 'DEC E', o: '1D', b: 1, c: '4', f: 'SZ*V1-', d: 'Decrement E', g: 'arith' },
            { m: 'DEC H', o: '25', b: 1, c: '4', f: 'SZ*V1-', d: 'Decrement H', g: 'arith' },
            { m: 'DEC L', o: '2D', b: 1, c: '4', f: 'SZ*V1-', d: 'Decrement L', g: 'arith' },
            { m: 'DEC (HL)', o: '35', b: 1, c: '11', f: 'SZ*V1-', d: 'Decrement (HL)', g: 'arith' },
            { m: 'DEC (IX+d)', o: 'DD 35 dd', b: 3, c: '23', f: 'SZ*V1-', d: 'Decrement (IX+d)', g: 'arith' },
            { m: 'DEC (IY+d)', o: 'FD 35 dd', b: 3, c: '23', f: 'SZ*V1-', d: 'Decrement (IY+d)', g: 'arith' },
            { m: 'DEC IXH', o: 'DD 25', b: 2, c: '8', f: 'SZ*V1-', d: 'Decrement IXH', g: 'arith', u: true },
            { m: 'DEC IXL', o: 'DD 2D', b: 2, c: '8', f: 'SZ*V1-', d: 'Decrement IXL', g: 'arith', u: true },
            { m: 'DEC IYH', o: 'FD 25', b: 2, c: '8', f: 'SZ*V1-', d: 'Decrement IYH', g: 'arith', u: true },
            { m: 'DEC IYL', o: 'FD 2D', b: 2, c: '8', f: 'SZ*V1-', d: 'Decrement IYL', g: 'arith', u: true },
            { m: 'DAA', o: '27', b: 1, c: '4', f: 'SZ*P-C', d: 'Decimal adjust A', g: 'arith' },
            { m: 'NEG', o: 'ED 44', b: 2, c: '8', f: 'SZ*V1C', d: 'Negate A (two\'s complement)', g: 'arith' },
            // Arithmetic 16-bit
            { m: 'ADD HL,BC', o: '09', b: 1, c: '11', f: '--*-0C', d: 'Add BC to HL', g: 'arith' },
            { m: 'ADD HL,DE', o: '19', b: 1, c: '11', f: '--*-0C', d: 'Add DE to HL', g: 'arith' },
            { m: 'ADD HL,HL', o: '29', b: 1, c: '11', f: '--*-0C', d: 'Add HL to HL', g: 'arith' },
            { m: 'ADD HL,SP', o: '39', b: 1, c: '11', f: '--*-0C', d: 'Add SP to HL', g: 'arith' },
            { m: 'ADC HL,BC', o: 'ED 4A', b: 2, c: '15', f: 'SZ*V0C', d: 'Add with carry BC to HL', g: 'arith' },
            { m: 'ADC HL,DE', o: 'ED 5A', b: 2, c: '15', f: 'SZ*V0C', d: 'Add with carry DE to HL', g: 'arith' },
            { m: 'ADC HL,HL', o: 'ED 6A', b: 2, c: '15', f: 'SZ*V0C', d: 'Add with carry HL to HL', g: 'arith' },
            { m: 'ADC HL,SP', o: 'ED 7A', b: 2, c: '15', f: 'SZ*V0C', d: 'Add with carry SP to HL', g: 'arith' },
            { m: 'SBC HL,BC', o: 'ED 42', b: 2, c: '15', f: 'SZ*V1C', d: 'Subtract with carry BC from HL', g: 'arith' },
            { m: 'SBC HL,DE', o: 'ED 52', b: 2, c: '15', f: 'SZ*V1C', d: 'Subtract with carry DE from HL', g: 'arith' },
            { m: 'SBC HL,HL', o: 'ED 62', b: 2, c: '15', f: 'SZ*V1C', d: 'Subtract with carry HL from HL', g: 'arith' },
            { m: 'SBC HL,SP', o: 'ED 72', b: 2, c: '15', f: 'SZ*V1C', d: 'Subtract with carry SP from HL', g: 'arith' },
            { m: 'ADD IX,BC', o: 'DD 09', b: 2, c: '15', f: '--*-0C', d: 'Add BC to IX', g: 'arith' },
            { m: 'ADD IX,DE', o: 'DD 19', b: 2, c: '15', f: '--*-0C', d: 'Add DE to IX', g: 'arith' },
            { m: 'ADD IX,IX', o: 'DD 29', b: 2, c: '15', f: '--*-0C', d: 'Add IX to IX', g: 'arith' },
            { m: 'ADD IX,SP', o: 'DD 39', b: 2, c: '15', f: '--*-0C', d: 'Add SP to IX', g: 'arith' },
            { m: 'ADD IY,BC', o: 'FD 09', b: 2, c: '15', f: '--*-0C', d: 'Add BC to IY', g: 'arith' },
            { m: 'ADD IY,DE', o: 'FD 19', b: 2, c: '15', f: '--*-0C', d: 'Add DE to IY', g: 'arith' },
            { m: 'ADD IY,IY', o: 'FD 29', b: 2, c: '15', f: '--*-0C', d: 'Add IY to IY', g: 'arith' },
            { m: 'ADD IY,SP', o: 'FD 39', b: 2, c: '15', f: '--*-0C', d: 'Add SP to IY', g: 'arith' },
            { m: 'INC BC', o: '03', b: 1, c: '6', f: '------', d: 'Increment BC', g: 'arith' },
            { m: 'INC DE', o: '13', b: 1, c: '6', f: '------', d: 'Increment DE', g: 'arith' },
            { m: 'INC HL', o: '23', b: 1, c: '6', f: '------', d: 'Increment HL', g: 'arith' },
            { m: 'INC SP', o: '33', b: 1, c: '6', f: '------', d: 'Increment SP', g: 'arith' },
            { m: 'INC IX', o: 'DD 23', b: 2, c: '10', f: '------', d: 'Increment IX', g: 'arith' },
            { m: 'INC IY', o: 'FD 23', b: 2, c: '10', f: '------', d: 'Increment IY', g: 'arith' },
            { m: 'DEC BC', o: '0B', b: 1, c: '6', f: '------', d: 'Decrement BC', g: 'arith' },
            { m: 'DEC DE', o: '1B', b: 1, c: '6', f: '------', d: 'Decrement DE', g: 'arith' },
            { m: 'DEC HL', o: '2B', b: 1, c: '6', f: '------', d: 'Decrement HL', g: 'arith' },
            { m: 'DEC SP', o: '3B', b: 1, c: '6', f: '------', d: 'Decrement SP', g: 'arith' },
            { m: 'DEC IX', o: 'DD 2B', b: 2, c: '10', f: '------', d: 'Decrement IX', g: 'arith' },
            { m: 'DEC IY', o: 'FD 2B', b: 2, c: '10', f: '------', d: 'Decrement IY', g: 'arith' },
            // Logic
            { m: 'AND A', o: 'A7', b: 1, c: '4', f: 'SZ*P10', d: 'Logical AND A with A', g: 'logic' },
            { m: 'AND B', o: 'A0', b: 1, c: '4', f: 'SZ*P10', d: 'Logical AND B with A', g: 'logic' },
            { m: 'AND C', o: 'A1', b: 1, c: '4', f: 'SZ*P10', d: 'Logical AND C with A', g: 'logic' },
            { m: 'AND D', o: 'A2', b: 1, c: '4', f: 'SZ*P10', d: 'Logical AND D with A', g: 'logic' },
            { m: 'AND E', o: 'A3', b: 1, c: '4', f: 'SZ*P10', d: 'Logical AND E with A', g: 'logic' },
            { m: 'AND H', o: 'A4', b: 1, c: '4', f: 'SZ*P10', d: 'Logical AND H with A', g: 'logic' },
            { m: 'AND L', o: 'A5', b: 1, c: '4', f: 'SZ*P10', d: 'Logical AND L with A', g: 'logic' },
            { m: 'AND n', o: 'E6 nn', b: 2, c: '7', f: 'SZ*P10', d: 'Logical AND immediate with A', g: 'logic' },
            { m: 'AND (HL)', o: 'A6', b: 1, c: '7', f: 'SZ*P10', d: 'Logical AND (HL) with A', g: 'logic' },
            { m: 'AND (IX+d)', o: 'DD A6 dd', b: 3, c: '19', f: 'SZ*P10', d: 'Logical AND (IX+d) with A', g: 'logic' },
            { m: 'AND (IY+d)', o: 'FD A6 dd', b: 3, c: '19', f: 'SZ*P10', d: 'Logical AND (IY+d) with A', g: 'logic' },
            { m: 'OR A', o: 'B7', b: 1, c: '4', f: 'SZ*P00', d: 'Logical OR A with A', g: 'logic' },
            { m: 'OR B', o: 'B0', b: 1, c: '4', f: 'SZ*P00', d: 'Logical OR B with A', g: 'logic' },
            { m: 'OR C', o: 'B1', b: 1, c: '4', f: 'SZ*P00', d: 'Logical OR C with A', g: 'logic' },
            { m: 'OR D', o: 'B2', b: 1, c: '4', f: 'SZ*P00', d: 'Logical OR D with A', g: 'logic' },
            { m: 'OR E', o: 'B3', b: 1, c: '4', f: 'SZ*P00', d: 'Logical OR E with A', g: 'logic' },
            { m: 'OR H', o: 'B4', b: 1, c: '4', f: 'SZ*P00', d: 'Logical OR H with A', g: 'logic' },
            { m: 'OR L', o: 'B5', b: 1, c: '4', f: 'SZ*P00', d: 'Logical OR L with A', g: 'logic' },
            { m: 'OR n', o: 'F6 nn', b: 2, c: '7', f: 'SZ*P00', d: 'Logical OR immediate with A', g: 'logic' },
            { m: 'OR (HL)', o: 'B6', b: 1, c: '7', f: 'SZ*P00', d: 'Logical OR (HL) with A', g: 'logic' },
            { m: 'OR (IX+d)', o: 'DD B6 dd', b: 3, c: '19', f: 'SZ*P00', d: 'Logical OR (IX+d) with A', g: 'logic' },
            { m: 'OR (IY+d)', o: 'FD B6 dd', b: 3, c: '19', f: 'SZ*P00', d: 'Logical OR (IY+d) with A', g: 'logic' },
            { m: 'XOR A', o: 'AF', b: 1, c: '4', f: 'SZ*P00', d: 'Logical XOR A with A', g: 'logic' },
            { m: 'XOR B', o: 'A8', b: 1, c: '4', f: 'SZ*P00', d: 'Logical XOR B with A', g: 'logic' },
            { m: 'XOR C', o: 'A9', b: 1, c: '4', f: 'SZ*P00', d: 'Logical XOR C with A', g: 'logic' },
            { m: 'XOR D', o: 'AA', b: 1, c: '4', f: 'SZ*P00', d: 'Logical XOR D with A', g: 'logic' },
            { m: 'XOR E', o: 'AB', b: 1, c: '4', f: 'SZ*P00', d: 'Logical XOR E with A', g: 'logic' },
            { m: 'XOR H', o: 'AC', b: 1, c: '4', f: 'SZ*P00', d: 'Logical XOR H with A', g: 'logic' },
            { m: 'XOR L', o: 'AD', b: 1, c: '4', f: 'SZ*P00', d: 'Logical XOR L with A', g: 'logic' },
            { m: 'XOR n', o: 'EE nn', b: 2, c: '7', f: 'SZ*P00', d: 'Logical XOR immediate with A', g: 'logic' },
            { m: 'XOR (HL)', o: 'AE', b: 1, c: '7', f: 'SZ*P00', d: 'Logical XOR (HL) with A', g: 'logic' },
            { m: 'XOR (IX+d)', o: 'DD AE dd', b: 3, c: '19', f: 'SZ*P00', d: 'Logical XOR (IX+d) with A', g: 'logic' },
            { m: 'XOR (IY+d)', o: 'FD AE dd', b: 3, c: '19', f: 'SZ*P00', d: 'Logical XOR (IY+d) with A', g: 'logic' },
            { m: 'CPL', o: '2F', b: 1, c: '4', f: '--1-1-', d: 'Complement A (one\'s complement)', g: 'logic' },
            { m: 'CCF', o: '3F', b: 1, c: '4', f: '--*-0C', d: 'Complement carry flag', g: 'logic' },
            { m: 'SCF', o: '37', b: 1, c: '4', f: '--0-01', d: 'Set carry flag', g: 'logic' },
            // Rotate & Shift
            { m: 'RLCA', o: '07', b: 1, c: '4', f: '--0-0C', d: 'Rotate A left circular', g: 'rotate' },
            { m: 'RLA', o: '17', b: 1, c: '4', f: '--0-0C', d: 'Rotate A left through carry', g: 'rotate' },
            { m: 'RRCA', o: '0F', b: 1, c: '4', f: '--0-0C', d: 'Rotate A right circular', g: 'rotate' },
            { m: 'RRA', o: '1F', b: 1, c: '4', f: '--0-0C', d: 'Rotate A right through carry', g: 'rotate' },
            { m: 'RLC A', o: 'CB 07', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate A left circular', g: 'rotate' },
            { m: 'RLC B', o: 'CB 00', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate B left circular', g: 'rotate' },
            { m: 'RLC C', o: 'CB 01', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate C left circular', g: 'rotate' },
            { m: 'RLC D', o: 'CB 02', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate D left circular', g: 'rotate' },
            { m: 'RLC E', o: 'CB 03', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate E left circular', g: 'rotate' },
            { m: 'RLC H', o: 'CB 04', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate H left circular', g: 'rotate' },
            { m: 'RLC L', o: 'CB 05', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate L left circular', g: 'rotate' },
            { m: 'RLC (HL)', o: 'CB 06', b: 2, c: '15', f: 'SZ*P0C', d: 'Rotate (HL) left circular', g: 'rotate' },
            { m: 'RLC (IX+d)', o: 'DD CB dd 06', b: 4, c: '23', f: 'SZ*P0C', d: 'Rotate (IX+d) left circular', g: 'rotate' },
            { m: 'RLC (IY+d)', o: 'FD CB dd 06', b: 4, c: '23', f: 'SZ*P0C', d: 'Rotate (IY+d) left circular', g: 'rotate' },
            { m: 'RL A', o: 'CB 17', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate A left through carry', g: 'rotate' },
            { m: 'RL B', o: 'CB 10', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate B left through carry', g: 'rotate' },
            { m: 'RL C', o: 'CB 11', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate C left through carry', g: 'rotate' },
            { m: 'RL D', o: 'CB 12', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate D left through carry', g: 'rotate' },
            { m: 'RL E', o: 'CB 13', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate E left through carry', g: 'rotate' },
            { m: 'RL H', o: 'CB 14', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate H left through carry', g: 'rotate' },
            { m: 'RL L', o: 'CB 15', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate L left through carry', g: 'rotate' },
            { m: 'RL (HL)', o: 'CB 16', b: 2, c: '15', f: 'SZ*P0C', d: 'Rotate (HL) left through carry', g: 'rotate' },
            { m: 'RL (IX+d)', o: 'DD CB dd 16', b: 4, c: '23', f: 'SZ*P0C', d: 'Rotate (IX+d) left through carry', g: 'rotate' },
            { m: 'RL (IY+d)', o: 'FD CB dd 16', b: 4, c: '23', f: 'SZ*P0C', d: 'Rotate (IY+d) left through carry', g: 'rotate' },
            { m: 'RRC A', o: 'CB 0F', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate A right circular', g: 'rotate' },
            { m: 'RRC B', o: 'CB 08', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate B right circular', g: 'rotate' },
            { m: 'RRC C', o: 'CB 09', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate C right circular', g: 'rotate' },
            { m: 'RRC D', o: 'CB 0A', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate D right circular', g: 'rotate' },
            { m: 'RRC E', o: 'CB 0B', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate E right circular', g: 'rotate' },
            { m: 'RRC H', o: 'CB 0C', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate H right circular', g: 'rotate' },
            { m: 'RRC L', o: 'CB 0D', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate L right circular', g: 'rotate' },
            { m: 'RRC (HL)', o: 'CB 0E', b: 2, c: '15', f: 'SZ*P0C', d: 'Rotate (HL) right circular', g: 'rotate' },
            { m: 'RRC (IX+d)', o: 'DD CB dd 0E', b: 4, c: '23', f: 'SZ*P0C', d: 'Rotate (IX+d) right circular', g: 'rotate' },
            { m: 'RRC (IY+d)', o: 'FD CB dd 0E', b: 4, c: '23', f: 'SZ*P0C', d: 'Rotate (IY+d) right circular', g: 'rotate' },
            { m: 'RR A', o: 'CB 1F', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate A right through carry', g: 'rotate' },
            { m: 'RR B', o: 'CB 18', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate B right through carry', g: 'rotate' },
            { m: 'RR C', o: 'CB 19', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate C right through carry', g: 'rotate' },
            { m: 'RR D', o: 'CB 1A', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate D right through carry', g: 'rotate' },
            { m: 'RR E', o: 'CB 1B', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate E right through carry', g: 'rotate' },
            { m: 'RR H', o: 'CB 1C', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate H right through carry', g: 'rotate' },
            { m: 'RR L', o: 'CB 1D', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate L right through carry', g: 'rotate' },
            { m: 'RR (HL)', o: 'CB 1E', b: 2, c: '15', f: 'SZ*P0C', d: 'Rotate (HL) right through carry', g: 'rotate' },
            { m: 'RR (IX+d)', o: 'DD CB dd 1E', b: 4, c: '23', f: 'SZ*P0C', d: 'Rotate (IX+d) right through carry', g: 'rotate' },
            { m: 'RR (IY+d)', o: 'FD CB dd 1E', b: 4, c: '23', f: 'SZ*P0C', d: 'Rotate (IY+d) right through carry', g: 'rotate' },
            { m: 'SLA A', o: 'CB 27', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift A left arithmetic', g: 'rotate' },
            { m: 'SLA B', o: 'CB 20', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift B left arithmetic', g: 'rotate' },
            { m: 'SLA C', o: 'CB 21', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift C left arithmetic', g: 'rotate' },
            { m: 'SLA D', o: 'CB 22', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift D left arithmetic', g: 'rotate' },
            { m: 'SLA E', o: 'CB 23', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift E left arithmetic', g: 'rotate' },
            { m: 'SLA H', o: 'CB 24', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift H left arithmetic', g: 'rotate' },
            { m: 'SLA L', o: 'CB 25', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift L left arithmetic', g: 'rotate' },
            { m: 'SLA (HL)', o: 'CB 26', b: 2, c: '15', f: 'SZ*P0C', d: 'Shift (HL) left arithmetic', g: 'rotate' },
            { m: 'SLA (IX+d)', o: 'DD CB dd 26', b: 4, c: '23', f: 'SZ*P0C', d: 'Shift (IX+d) left arithmetic', g: 'rotate' },
            { m: 'SLA (IY+d)', o: 'FD CB dd 26', b: 4, c: '23', f: 'SZ*P0C', d: 'Shift (IY+d) left arithmetic', g: 'rotate' },
            { m: 'SLL A', o: 'CB 37', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift A left logical (bit0=1)', g: 'rotate', u: true },
            { m: 'SLL B', o: 'CB 30', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift B left logical (bit0=1)', g: 'rotate', u: true },
            { m: 'SLL C', o: 'CB 31', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift C left logical (bit0=1)', g: 'rotate', u: true },
            { m: 'SLL D', o: 'CB 32', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift D left logical (bit0=1)', g: 'rotate', u: true },
            { m: 'SLL E', o: 'CB 33', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift E left logical (bit0=1)', g: 'rotate', u: true },
            { m: 'SLL H', o: 'CB 34', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift H left logical (bit0=1)', g: 'rotate', u: true },
            { m: 'SLL L', o: 'CB 35', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift L left logical (bit0=1)', g: 'rotate', u: true },
            { m: 'SLL (HL)', o: 'CB 36', b: 2, c: '15', f: 'SZ*P0C', d: 'Shift (HL) left logical (bit0=1)', g: 'rotate', u: true },
            { m: 'SRA A', o: 'CB 2F', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift A right arithmetic', g: 'rotate' },
            { m: 'SRA B', o: 'CB 28', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift B right arithmetic', g: 'rotate' },
            { m: 'SRA C', o: 'CB 29', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift C right arithmetic', g: 'rotate' },
            { m: 'SRA D', o: 'CB 2A', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift D right arithmetic', g: 'rotate' },
            { m: 'SRA E', o: 'CB 2B', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift E right arithmetic', g: 'rotate' },
            { m: 'SRA H', o: 'CB 2C', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift H right arithmetic', g: 'rotate' },
            { m: 'SRA L', o: 'CB 2D', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift L right arithmetic', g: 'rotate' },
            { m: 'SRA (HL)', o: 'CB 2E', b: 2, c: '15', f: 'SZ*P0C', d: 'Shift (HL) right arithmetic', g: 'rotate' },
            { m: 'SRA (IX+d)', o: 'DD CB dd 2E', b: 4, c: '23', f: 'SZ*P0C', d: 'Shift (IX+d) right arithmetic', g: 'rotate' },
            { m: 'SRA (IY+d)', o: 'FD CB dd 2E', b: 4, c: '23', f: 'SZ*P0C', d: 'Shift (IY+d) right arithmetic', g: 'rotate' },
            { m: 'SRL A', o: 'CB 3F', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift A right logical', g: 'rotate' },
            { m: 'SRL B', o: 'CB 38', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift B right logical', g: 'rotate' },
            { m: 'SRL C', o: 'CB 39', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift C right logical', g: 'rotate' },
            { m: 'SRL D', o: 'CB 3A', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift D right logical', g: 'rotate' },
            { m: 'SRL E', o: 'CB 3B', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift E right logical', g: 'rotate' },
            { m: 'SRL H', o: 'CB 3C', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift H right logical', g: 'rotate' },
            { m: 'SRL L', o: 'CB 3D', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift L right logical', g: 'rotate' },
            { m: 'SRL (HL)', o: 'CB 3E', b: 2, c: '15', f: 'SZ*P0C', d: 'Shift (HL) right logical', g: 'rotate' },
            { m: 'SRL (IX+d)', o: 'DD CB dd 3E', b: 4, c: '23', f: 'SZ*P0C', d: 'Shift (IX+d) right logical', g: 'rotate' },
            { m: 'SRL (IY+d)', o: 'FD CB dd 3E', b: 4, c: '23', f: 'SZ*P0C', d: 'Shift (IY+d) right logical', g: 'rotate' },
            { m: 'RLD', o: 'ED 6F', b: 2, c: '18', f: 'SZ*P0-', d: 'Rotate left digit', g: 'rotate' },
            { m: 'RRD', o: 'ED 67', b: 2, c: '18', f: 'SZ*P0-', d: 'Rotate right digit', g: 'rotate' },
            // Bit Operations (example opcodes for bit 0)
            { m: 'BIT 0,A', o: 'CB 47', b: 2, c: '8', f: 'SZ?10-', d: 'Test bit 0 of A', g: 'bit' },
            { m: 'BIT 0,B', o: 'CB 40', b: 2, c: '8', f: 'SZ?10-', d: 'Test bit 0 of B', g: 'bit' },
            { m: 'BIT 0,C', o: 'CB 41', b: 2, c: '8', f: 'SZ?10-', d: 'Test bit 0 of C', g: 'bit' },
            { m: 'BIT 0,D', o: 'CB 42', b: 2, c: '8', f: 'SZ?10-', d: 'Test bit 0 of D', g: 'bit' },
            { m: 'BIT 0,E', o: 'CB 43', b: 2, c: '8', f: 'SZ?10-', d: 'Test bit 0 of E', g: 'bit' },
            { m: 'BIT 0,H', o: 'CB 44', b: 2, c: '8', f: 'SZ?10-', d: 'Test bit 0 of H', g: 'bit' },
            { m: 'BIT 0,L', o: 'CB 45', b: 2, c: '8', f: 'SZ?10-', d: 'Test bit 0 of L', g: 'bit' },
            { m: 'BIT 0,(HL)', o: 'CB 46', b: 2, c: '12', f: 'SZ?10-', d: 'Test bit 0 of (HL)', g: 'bit' },
            { m: 'BIT b,r', o: 'CB 40+8*b+r', b: 2, c: '8', f: 'SZ?10-', d: 'Test bit b of register (b=0-7)', g: 'bit' },
            { m: 'BIT b,(HL)', o: 'CB 46+8*b', b: 2, c: '12', f: 'SZ?10-', d: 'Test bit b of (HL) (b=0-7)', g: 'bit' },
            { m: 'BIT b,(IX+d)', o: 'DD CB dd 46+8*b', b: 4, c: '20', f: 'SZ?10-', d: 'Test bit b of (IX+d)', g: 'bit' },
            { m: 'BIT b,(IY+d)', o: 'FD CB dd 46+8*b', b: 4, c: '20', f: 'SZ?10-', d: 'Test bit b of (IY+d)', g: 'bit' },
            { m: 'SET 0,A', o: 'CB C7', b: 2, c: '8', f: '------', d: 'Set bit 0 of A', g: 'bit' },
            { m: 'SET 0,B', o: 'CB C0', b: 2, c: '8', f: '------', d: 'Set bit 0 of B', g: 'bit' },
            { m: 'SET 0,C', o: 'CB C1', b: 2, c: '8', f: '------', d: 'Set bit 0 of C', g: 'bit' },
            { m: 'SET 0,D', o: 'CB C2', b: 2, c: '8', f: '------', d: 'Set bit 0 of D', g: 'bit' },
            { m: 'SET 0,E', o: 'CB C3', b: 2, c: '8', f: '------', d: 'Set bit 0 of E', g: 'bit' },
            { m: 'SET 0,H', o: 'CB C4', b: 2, c: '8', f: '------', d: 'Set bit 0 of H', g: 'bit' },
            { m: 'SET 0,L', o: 'CB C5', b: 2, c: '8', f: '------', d: 'Set bit 0 of L', g: 'bit' },
            { m: 'SET 0,(HL)', o: 'CB C6', b: 2, c: '15', f: '------', d: 'Set bit 0 of (HL)', g: 'bit' },
            { m: 'SET b,r', o: 'CB C0+8*b+r', b: 2, c: '8', f: '------', d: 'Set bit b of register (b=0-7)', g: 'bit' },
            { m: 'SET b,(HL)', o: 'CB C6+8*b', b: 2, c: '15', f: '------', d: 'Set bit b of (HL) (b=0-7)', g: 'bit' },
            { m: 'SET b,(IX+d)', o: 'DD CB dd C6+8*b', b: 4, c: '23', f: '------', d: 'Set bit b of (IX+d)', g: 'bit' },
            { m: 'SET b,(IY+d)', o: 'FD CB dd C6+8*b', b: 4, c: '23', f: '------', d: 'Set bit b of (IY+d)', g: 'bit' },
            { m: 'RES 0,A', o: 'CB 87', b: 2, c: '8', f: '------', d: 'Reset bit 0 of A', g: 'bit' },
            { m: 'RES 0,B', o: 'CB 80', b: 2, c: '8', f: '------', d: 'Reset bit 0 of B', g: 'bit' },
            { m: 'RES 0,C', o: 'CB 81', b: 2, c: '8', f: '------', d: 'Reset bit 0 of C', g: 'bit' },
            { m: 'RES 0,D', o: 'CB 82', b: 2, c: '8', f: '------', d: 'Reset bit 0 of D', g: 'bit' },
            { m: 'RES 0,E', o: 'CB 83', b: 2, c: '8', f: '------', d: 'Reset bit 0 of E', g: 'bit' },
            { m: 'RES 0,H', o: 'CB 84', b: 2, c: '8', f: '------', d: 'Reset bit 0 of H', g: 'bit' },
            { m: 'RES 0,L', o: 'CB 85', b: 2, c: '8', f: '------', d: 'Reset bit 0 of L', g: 'bit' },
            { m: 'RES 0,(HL)', o: 'CB 86', b: 2, c: '15', f: '------', d: 'Reset bit 0 of (HL)', g: 'bit' },
            { m: 'RES b,r', o: 'CB 80+8*b+r', b: 2, c: '8', f: '------', d: 'Reset bit b of register (b=0-7)', g: 'bit' },
            { m: 'RES b,(HL)', o: 'CB 86+8*b', b: 2, c: '15', f: '------', d: 'Reset bit b of (HL) (b=0-7)', g: 'bit' },
            { m: 'RES b,(IX+d)', o: 'DD CB dd 86+8*b', b: 4, c: '23', f: '------', d: 'Reset bit b of (IX+d)', g: 'bit' },
            { m: 'RES b,(IY+d)', o: 'FD CB dd 86+8*b', b: 4, c: '23', f: '------', d: 'Reset bit b of (IY+d)', g: 'bit' },
            // Jump
            { m: 'JP nn', o: 'C3 nn nn', b: 3, c: '10', f: '------', d: 'Jump to address', g: 'jump' },
            { m: 'JP NZ,nn', o: 'C2 nn nn', b: 3, c: '10', f: '------', d: 'Jump if not zero', g: 'jump' },
            { m: 'JP Z,nn', o: 'CA nn nn', b: 3, c: '10', f: '------', d: 'Jump if zero', g: 'jump' },
            { m: 'JP NC,nn', o: 'D2 nn nn', b: 3, c: '10', f: '------', d: 'Jump if no carry', g: 'jump' },
            { m: 'JP C,nn', o: 'DA nn nn', b: 3, c: '10', f: '------', d: 'Jump if carry', g: 'jump' },
            { m: 'JP PO,nn', o: 'E2 nn nn', b: 3, c: '10', f: '------', d: 'Jump if parity odd', g: 'jump' },
            { m: 'JP PE,nn', o: 'EA nn nn', b: 3, c: '10', f: '------', d: 'Jump if parity even', g: 'jump' },
            { m: 'JP P,nn', o: 'F2 nn nn', b: 3, c: '10', f: '------', d: 'Jump if positive', g: 'jump' },
            { m: 'JP M,nn', o: 'FA nn nn', b: 3, c: '10', f: '------', d: 'Jump if minus', g: 'jump' },
            { m: 'JR e', o: '18 ee', b: 2, c: '12', f: '------', d: 'Relative jump', g: 'jump' },
            { m: 'JR C,e', o: '38 ee', b: 2, c: '12/7', f: '------', d: 'Relative jump if carry', g: 'jump' },
            { m: 'JR NC,e', o: '30 ee', b: 2, c: '12/7', f: '------', d: 'Relative jump if no carry', g: 'jump' },
            { m: 'JR Z,e', o: '28 ee', b: 2, c: '12/7', f: '------', d: 'Relative jump if zero', g: 'jump' },
            { m: 'JR NZ,e', o: '20 ee', b: 2, c: '12/7', f: '------', d: 'Relative jump if not zero', g: 'jump' },
            { m: 'JP (HL)', o: 'E9', b: 1, c: '4', f: '------', d: 'Jump to address in HL', g: 'jump' },
            { m: 'JP (IX)', o: 'DD E9', b: 2, c: '8', f: '------', d: 'Jump to address in IX', g: 'jump' },
            { m: 'JP (IY)', o: 'FD E9', b: 2, c: '8', f: '------', d: 'Jump to address in IY', g: 'jump' },
            { m: 'DJNZ e', o: '10 ee', b: 2, c: '13/8', f: '------', d: 'Decrement B and jump if not zero', g: 'jump' },
            // Call & Return
            { m: 'CALL nn', o: 'CD nn nn', b: 3, c: '17', f: '------', d: 'Call subroutine', g: 'jump' },
            { m: 'CALL NZ,nn', o: 'C4 nn nn', b: 3, c: '17/10', f: '------', d: 'Call if not zero', g: 'jump' },
            { m: 'CALL Z,nn', o: 'CC nn nn', b: 3, c: '17/10', f: '------', d: 'Call if zero', g: 'jump' },
            { m: 'CALL NC,nn', o: 'D4 nn nn', b: 3, c: '17/10', f: '------', d: 'Call if no carry', g: 'jump' },
            { m: 'CALL C,nn', o: 'DC nn nn', b: 3, c: '17/10', f: '------', d: 'Call if carry', g: 'jump' },
            { m: 'CALL PO,nn', o: 'E4 nn nn', b: 3, c: '17/10', f: '------', d: 'Call if parity odd', g: 'jump' },
            { m: 'CALL PE,nn', o: 'EC nn nn', b: 3, c: '17/10', f: '------', d: 'Call if parity even', g: 'jump' },
            { m: 'CALL P,nn', o: 'F4 nn nn', b: 3, c: '17/10', f: '------', d: 'Call if positive', g: 'jump' },
            { m: 'CALL M,nn', o: 'FC nn nn', b: 3, c: '17/10', f: '------', d: 'Call if minus', g: 'jump' },
            { m: 'RET', o: 'C9', b: 1, c: '10', f: '------', d: 'Return from subroutine', g: 'jump' },
            { m: 'RET NZ', o: 'C0', b: 1, c: '11/5', f: '------', d: 'Return if not zero', g: 'jump' },
            { m: 'RET Z', o: 'C8', b: 1, c: '11/5', f: '------', d: 'Return if zero', g: 'jump' },
            { m: 'RET NC', o: 'D0', b: 1, c: '11/5', f: '------', d: 'Return if no carry', g: 'jump' },
            { m: 'RET C', o: 'D8', b: 1, c: '11/5', f: '------', d: 'Return if carry', g: 'jump' },
            { m: 'RET PO', o: 'E0', b: 1, c: '11/5', f: '------', d: 'Return if parity odd', g: 'jump' },
            { m: 'RET PE', o: 'E8', b: 1, c: '11/5', f: '------', d: 'Return if parity even', g: 'jump' },
            { m: 'RET P', o: 'F0', b: 1, c: '11/5', f: '------', d: 'Return if positive', g: 'jump' },
            { m: 'RET M', o: 'F8', b: 1, c: '11/5', f: '------', d: 'Return if minus', g: 'jump' },
            { m: 'RETI', o: 'ED 4D', b: 2, c: '14', f: '------', d: 'Return from interrupt', g: 'jump' },
            { m: 'RETN', o: 'ED 45', b: 2, c: '14', f: '------', d: 'Return from NMI', g: 'jump' },
            { m: 'RST 00H', o: 'C7', b: 1, c: '11', f: '------', d: 'Restart at 0000H', g: 'jump' },
            { m: 'RST 08H', o: 'CF', b: 1, c: '11', f: '------', d: 'Restart at 0008H', g: 'jump' },
            { m: 'RST 10H', o: 'D7', b: 1, c: '11', f: '------', d: 'Restart at 0010H', g: 'jump' },
            { m: 'RST 18H', o: 'DF', b: 1, c: '11', f: '------', d: 'Restart at 0018H', g: 'jump' },
            { m: 'RST 20H', o: 'E7', b: 1, c: '11', f: '------', d: 'Restart at 0020H', g: 'jump' },
            { m: 'RST 28H', o: 'EF', b: 1, c: '11', f: '------', d: 'Restart at 0028H', g: 'jump' },
            { m: 'RST 30H', o: 'F7', b: 1, c: '11', f: '------', d: 'Restart at 0030H', g: 'jump' },
            { m: 'RST 38H', o: 'FF', b: 1, c: '11', f: '------', d: 'Restart at 0038H', g: 'jump' },
            // I/O
            { m: 'IN A,(n)', o: 'DB nn', b: 2, c: '11', f: '------', d: 'Input from port n', g: 'io' },
            { m: 'IN A,(C)', o: 'ED 78', b: 2, c: '12', f: 'SZ*P0-', d: 'Input from port C to A', g: 'io' },
            { m: 'IN B,(C)', o: 'ED 40', b: 2, c: '12', f: 'SZ*P0-', d: 'Input from port C to B', g: 'io' },
            { m: 'IN C,(C)', o: 'ED 48', b: 2, c: '12', f: 'SZ*P0-', d: 'Input from port C to C', g: 'io' },
            { m: 'IN D,(C)', o: 'ED 50', b: 2, c: '12', f: 'SZ*P0-', d: 'Input from port C to D', g: 'io' },
            { m: 'IN E,(C)', o: 'ED 58', b: 2, c: '12', f: 'SZ*P0-', d: 'Input from port C to E', g: 'io' },
            { m: 'IN H,(C)', o: 'ED 60', b: 2, c: '12', f: 'SZ*P0-', d: 'Input from port C to H', g: 'io' },
            { m: 'IN L,(C)', o: 'ED 68', b: 2, c: '12', f: 'SZ*P0-', d: 'Input from port C to L', g: 'io' },
            { m: 'IN F,(C)', o: 'ED 70', b: 2, c: '12', f: 'SZ*P0-', d: 'Input port C, set flags only', g: 'io', u: true },
            { m: 'INI', o: 'ED A2', b: 2, c: '16', f: '?Z???-', d: 'Input and increment', g: 'io' },
            { m: 'INIR', o: 'ED B2', b: 2, c: '21/16', f: '?1???-', d: 'Input, increment and repeat', g: 'io' },
            { m: 'IND', o: 'ED AA', b: 2, c: '16', f: '?Z???-', d: 'Input and decrement', g: 'io' },
            { m: 'INDR', o: 'ED BA', b: 2, c: '21/16', f: '?1???-', d: 'Input, decrement and repeat', g: 'io' },
            { m: 'OUT (n),A', o: 'D3 nn', b: 2, c: '11', f: '------', d: 'Output A to port n', g: 'io' },
            { m: 'OUT (C),A', o: 'ED 79', b: 2, c: '12', f: '------', d: 'Output A to port C', g: 'io' },
            { m: 'OUT (C),B', o: 'ED 41', b: 2, c: '12', f: '------', d: 'Output B to port C', g: 'io' },
            { m: 'OUT (C),C', o: 'ED 49', b: 2, c: '12', f: '------', d: 'Output C to port C', g: 'io' },
            { m: 'OUT (C),D', o: 'ED 51', b: 2, c: '12', f: '------', d: 'Output D to port C', g: 'io' },
            { m: 'OUT (C),E', o: 'ED 59', b: 2, c: '12', f: '------', d: 'Output E to port C', g: 'io' },
            { m: 'OUT (C),H', o: 'ED 61', b: 2, c: '12', f: '------', d: 'Output H to port C', g: 'io' },
            { m: 'OUT (C),L', o: 'ED 69', b: 2, c: '12', f: '------', d: 'Output L to port C', g: 'io' },
            { m: 'OUT (C),0', o: 'ED 71', b: 2, c: '12', f: '------', d: 'Output 0 to port C', g: 'io', u: true },
            { m: 'OUTI', o: 'ED A3', b: 2, c: '16', f: '?Z???-', d: 'Output and increment', g: 'io' },
            { m: 'OTIR', o: 'ED B3', b: 2, c: '21/16', f: '?1???-', d: 'Output, increment and repeat', g: 'io' },
            { m: 'OUTD', o: 'ED AB', b: 2, c: '16', f: '?Z???-', d: 'Output and decrement', g: 'io' },
            { m: 'OTDR', o: 'ED BB', b: 2, c: '21/16', f: '?1???-', d: 'Output, decrement and repeat', g: 'io' },
            // Block Transfer
            { m: 'LDI', o: 'ED A0', b: 2, c: '16', f: '--0*0-', d: 'Load and increment', g: 'block' },
            { m: 'LDIR', o: 'ED B0', b: 2, c: '21/16', f: '--000-', d: 'Load, increment and repeat', g: 'block' },
            { m: 'LDD', o: 'ED A8', b: 2, c: '16', f: '--0*0-', d: 'Load and decrement', g: 'block' },
            { m: 'LDDR', o: 'ED B8', b: 2, c: '21/16', f: '--000-', d: 'Load, decrement and repeat', g: 'block' },
            { m: 'CPI', o: 'ED A1', b: 2, c: '16', f: 'SZ*?1-', d: 'Compare and increment', g: 'block' },
            { m: 'CPIR', o: 'ED B1', b: 2, c: '21/16', f: 'SZ*?1-', d: 'Compare, increment and repeat', g: 'block' },
            { m: 'CPD', o: 'ED A9', b: 2, c: '16', f: 'SZ*?1-', d: 'Compare and decrement', g: 'block' },
            { m: 'CPDR', o: 'ED B9', b: 2, c: '21/16', f: 'SZ*?1-', d: 'Compare, decrement and repeat', g: 'block' },
            // Misc
            { m: 'NOP', o: '00', b: 1, c: '4', f: '------', d: 'No operation', g: 'misc' },
            { m: 'HALT', o: '76', b: 1, c: '4', f: '------', d: 'Halt CPU until interrupt', g: 'misc' },
            { m: 'DI', o: 'F3', b: 1, c: '4', f: '------', d: 'Disable interrupts', g: 'misc' },
            { m: 'EI', o: 'FB', b: 1, c: '4', f: '------', d: 'Enable interrupts', g: 'misc' },
            { m: 'IM 0', o: 'ED 46', b: 2, c: '8', f: '------', d: 'Set interrupt mode 0', g: 'misc' },
            { m: 'IM 1', o: 'ED 56', b: 2, c: '8', f: '------', d: 'Set interrupt mode 1', g: 'misc' },
            { m: 'IM 2', o: 'ED 5E', b: 2, c: '8', f: '------', d: 'Set interrupt mode 2', g: 'misc' },
        ];

        function renderOpcodes(filter = '', group = 'all', cycles = 'all', sortBy = 'mnemonic') {
            const tbody = document.getElementById('opcodesBody');
            const filterLower = filter.toLowerCase();
            const filtered = z80Opcodes
                .filter(op => {
                    const matchesFilter = !filter ||
                        op.m.toLowerCase().includes(filterLower) ||
                        op.d.toLowerCase().includes(filterLower) ||
                        (op.o && op.o.toLowerCase().includes(filterLower));
                    const matchesGroup = group === 'all' || op.g === group;
                    const matchesCycles = cycles === 'all' || op.c.split('/').some(c => c.trim() === cycles);
                    return matchesFilter && matchesGroup && matchesCycles;
                })
                .sort((a, b) => {
                    if (sortBy === 'opcode') {
                        const oCmp = (a.o || 'ZZ').localeCompare(b.o || 'ZZ');
                        if (oCmp !== 0) return oCmp;
                        return a.m.localeCompare(b.m);
                    }
                    // Default: sort by mnemonic
                    const mCmp = a.m.localeCompare(b.m);
                    if (mCmp !== 0) return mCmp;
                    return (a.o || '').localeCompare(b.o || '');
                });
            const rows = filtered.map(op => `<tr>
                    <td class="op-mnemonic${op.u ? ' undoc' : ''}">${op.m}</td>
                    <td class="op-opcode">${op.o || ''}</td>
                    <td class="op-bytes">${op.b}</td>
                    <td class="op-cycles">${op.c}</td>
                    <td class="op-flags">${op.f}</td>
                    <td class="op-desc">${op.d}</td>
                </tr>`).join('');
            tbody.innerHTML = rows;
        }

        // Populate T-states dropdown with unique values
        const cyclesSet = new Set();
        z80Opcodes.forEach(op => {
            // Handle both simple (e.g., '4') and conditional (e.g., '17/10') cycles
            op.c.split('/').forEach(c => cyclesSet.add(c.trim()));
        });
        const cyclesSorted = [...cyclesSet].sort((a, b) => parseInt(a) - parseInt(b));
        const opcodeCyclesSelect = document.getElementById('opcodeCycles');
        cyclesSorted.forEach(c => {
            const opt = document.createElement('option');
            opt.value = c;
            opt.textContent = c + 'T';
            opcodeCyclesSelect.appendChild(opt);
        });

        function getOpcodeFilters() {
            return {
                search: document.getElementById('opcodeSearch').value,
                group: document.getElementById('opcodeGroup').value,
                cycles: document.getElementById('opcodeCycles').value,
                sort: document.getElementById('opcodeSort').value
            };
        }

        function applyOpcodeFilters() {
            const f = getOpcodeFilters();
            renderOpcodes(f.search, f.group, f.cycles, f.sort);
        }

        document.getElementById('opcodeSearch').addEventListener('input', applyOpcodeFilters);
        document.getElementById('opcodeGroup').addEventListener('change', applyOpcodeFilters);
        document.getElementById('opcodeCycles').addEventListener('change', applyOpcodeFilters);
        document.getElementById('opcodeSort').addEventListener('change', applyOpcodeFilters);

        // Initial render
        renderOpcodes();

        // ========== Graphics Viewer ==========
        const gfxDumpCanvas = document.getElementById('gfxDumpCanvas');
        const gfxDumpCtx = gfxDumpCanvas.getContext('2d');
        const gfxDumpWrap = document.querySelector('.graphics-dump-wrap');
        const gfxPreviewCanvas = document.getElementById('gfxPreviewCanvas');
        const gfxPreviewCtx = gfxPreviewCanvas.getContext('2d');
        const gfxAddress = document.getElementById('gfxAddress');
        const gfxWidth = document.getElementById('gfxWidth');
        const gfxHeight = document.getElementById('gfxHeight');
        const gfxGrid = document.getElementById('gfxGrid');
        const gfxInvert = document.getElementById('gfxInvert');
        const gfxCharMode = document.getElementById('gfxCharMode');
        const gfxInfo = document.getElementById('gfxInfo');

        // Graphics viewer state
        let gfxSpriteAddress = 0x3000; // Current sprite/view address
        const GFX_DUMP_COLS = 24;  // Bytes per row in dump view
        const GFX_DUMP_ROWS = 302;  // Rows visible

        function getGfxParams() {
            const widthBytes = Math.max(1, Math.min(32, parseInt(gfxWidth.value) || 1));
            const heightRows = Math.max(1, Math.min(64, parseInt(gfxHeight.value) || 8));
            const invert = gfxInvert.checked;
            const showGrid = gfxGrid.checked;
            const charMode = gfxCharMode.checked;
            const widthPx = widthBytes * 8;
            const bytesPerSprite = widthBytes * heightRows;
            return { widthBytes, heightRows, widthPx, bytesPerSprite, invert, showGrid, charMode };
        }

        function renderGfxDump() {
            if (!spectrum) return;

            const params = getGfxParams();
            const zoom = document.getElementById('gfxZoom3').checked ? 3 :
                         document.getElementById('gfxZoom2').checked ? 2 : 1;
            const canvasWidth = GFX_DUMP_COLS * 8 * zoom;
            const canvasHeight = GFX_DUMP_ROWS * zoom;
            const anchorRow = 8;  // Selection anchored at row 8 (row 1 in 8-row terms)

            // Calculate view start so selected address appears at row 8, column 0
            // In both modes: 8 rows of context = widthBytes * 8 bytes
            const viewStartAddr = (gfxSpriteAddress - params.widthBytes * 8) & 0xffff;

            gfxDumpCanvas.width = canvasWidth;
            gfxDumpCanvas.height = canvasHeight;
            gfxDumpWrap.style.height = canvasHeight + 'px';

            // Clear with gray background
            gfxDumpCtx.fillStyle = '#808080';
            gfxDumpCtx.fillRect(0, 0, canvasWidth, canvasHeight);

            // Region colors for graphics
            const GFX_REGION_COLORS = {
                code: '#4080ff', smc: '#ff4040', db: '#ffcc00', dw: '#ff8800',
                text: '#40cc40', graphics: '#cc40cc', default: '#00cc00'
            };

            // Render sprite width bytes as graphics (canvas width stays at 256px)
            for (let row = 0; row < GFX_DUMP_ROWS; row++) {
                for (let col = 0; col < params.widthBytes; col++) {
                    let addr;
                    if (params.charMode) {
                        // Character-based: 8x8 cells stored sequentially
                        const charRow = Math.floor(row / 8);
                        const lineInChar = row % 8;
                        addr = (viewStartAddr + (charRow * params.widthBytes + col) * 8 + lineInChar) & 0xffff;
                    } else {
                        // Linear: row by row
                        addr = (viewStartAddr + row * params.widthBytes + col) & 0xffff;
                    }
                    const byte = spectrum.memory.read(addr);
                    const x = col * 8 * zoom;
                    const y = row * zoom;

                    // Get region color for this address
                    const region = regionManager.get(addr);
                    const hasRegion = region && GFX_REGION_COLORS[region.type];
                    let pixelColor = hasRegion ? GFX_REGION_COLORS[region.type] : GFX_REGION_COLORS.default;
                    // Zero bits: black if unmarked, dark gray if marked
                    const zeroBitColor = hasRegion ? '#333333' : '#000000';
                    // Invert mode swaps fg/bg
                    const actualBg = params.invert ? pixelColor : zeroBitColor;
                    const actualFg = params.invert ? zeroBitColor : pixelColor;

                    // Draw background for this byte
                    gfxDumpCtx.fillStyle = actualBg;
                    gfxDumpCtx.fillRect(x, y, 8 * zoom, zoom);

                    // Draw foreground pixels with region color
                    gfxDumpCtx.fillStyle = actualFg;
                    for (let bit = 0; bit < 8; bit++) {
                        if ((byte >> (7 - bit)) & 1) {
                            gfxDumpCtx.fillRect(x + bit * zoom, y, zoom, zoom);
                        }
                    }
                }
            }

            // Draw red rectangle at fixed anchor position (column 0, row 8)
            const rectX = 0;
            const rectY = anchorRow * zoom;
            const rectW = params.widthBytes * 8 * zoom;
            const rectH = params.heightRows * zoom;

            gfxDumpCtx.strokeStyle = '#ff0000';
            gfxDumpCtx.lineWidth = 2;
            gfxDumpCtx.strokeRect(rectX + 1, rectY + 1, rectW - 2, rectH - 2);

            // Draw grid lines between bytes if enabled (vertical and horizontal)
            if (params.showGrid) {
                gfxDumpCtx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                gfxDumpCtx.lineWidth = 1;
                const spriteWidthPx = params.widthBytes * 8 * zoom;
                // Vertical lines
                for (let col = 0; col <= params.widthBytes; col++) {
                    const x = col * 8 * zoom;
                    gfxDumpCtx.beginPath();
                    gfxDumpCtx.moveTo(x + 0.5, 0);
                    gfxDumpCtx.lineTo(x + 0.5, canvasHeight);
                    gfxDumpCtx.stroke();
                }
                // Horizontal lines every 8 rows
                for (let row = 0; row <= GFX_DUMP_ROWS; row += 8) {
                    const y = row * zoom;
                    gfxDumpCtx.beginPath();
                    gfxDumpCtx.moveTo(0, y + 0.5);
                    gfxDumpCtx.lineTo(spriteWidthPx, y + 0.5);
                    gfxDumpCtx.stroke();
                }
            }
        }

        function renderGfxPreview() {
            if (!spectrum) return;

            const params = getGfxParams();
            const previewZoom = 2;  // Fixed zoom for small preview
            // No context rows - sprite starts at row 0
            const totalRows = params.heightRows;
            const canvasW = params.widthPx * previewZoom;
            const canvasH = totalRows * previewZoom;

            gfxPreviewCanvas.width = canvasW;
            gfxPreviewCanvas.height = canvasH;

            // Region colors for graphics
            const GFX_REGION_COLORS = {
                code: '#4080ff', smc: '#ff4040', db: '#ffcc00', dw: '#ff8800',
                text: '#40cc40', graphics: '#cc40cc', default: '#00cc00'
            };

            // Fill with black background
            gfxPreviewCtx.fillStyle = '#000000';
            gfxPreviewCtx.fillRect(0, 0, canvasW, canvasH);

            for (let row = 0; row < totalRows; row++) {
                for (let byteX = 0; byteX < params.widthBytes; byteX++) {
                    let addr;
                    if (params.charMode) {
                        // Character-based: 8x8 cells stored sequentially
                        const charRow = Math.floor(row / 8);
                        const lineInChar = row % 8;
                        addr = (gfxSpriteAddress + (charRow * params.widthBytes + byteX) * 8 + lineInChar) & 0xffff;
                    } else {
                        // Linear: row by row, starting from gfxSpriteAddress
                        addr = (gfxSpriteAddress + row * params.widthBytes + byteX) & 0xffff;
                    }
                    const byte = spectrum.memory.read(addr);

                    // Get region color for this address
                    const region = regionManager.get(addr);
                    const hasRegion = region && GFX_REGION_COLORS[region.type];
                    let pixelColor = hasRegion ? GFX_REGION_COLORS[region.type] : GFX_REGION_COLORS.default;
                    // Zero bits: black if unmarked, dark gray if marked
                    const zeroBitColor = hasRegion ? '#333333' : '#000000';
                    // Invert mode swaps fg/bg
                    const fgColor = params.invert ? zeroBitColor : pixelColor;
                    const bgColor = params.invert ? pixelColor : zeroBitColor;

                    // Draw background for this byte
                    gfxPreviewCtx.fillStyle = bgColor;
                    gfxPreviewCtx.fillRect(byteX * 8 * previewZoom, row * previewZoom, 8 * previewZoom, previewZoom);

                    // Draw foreground pixels
                    gfxPreviewCtx.fillStyle = fgColor;
                    for (let bit = 0; bit < 8; bit++) {
                        if ((byte >> (7 - bit)) & 1) {
                            const px = byteX * 8 + bit;
                            gfxPreviewCtx.fillRect(px * previewZoom, row * previewZoom, previewZoom, previewZoom);
                        }
                    }
                }
            }

            // Draw red rectangle around entire sprite
            gfxPreviewCtx.strokeStyle = '#ff0000';
            gfxPreviewCtx.lineWidth = 2;
            gfxPreviewCtx.strokeRect(1, 1, canvasW - 2, canvasH - 2);

            // Draw grid overlay if enabled
            if (params.showGrid) {
                gfxPreviewCtx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                gfxPreviewCtx.lineWidth = 1;
                // Vertical lines every 8 pixels
                for (let x = 8; x < params.widthPx; x += 8) {
                    gfxPreviewCtx.beginPath();
                    gfxPreviewCtx.moveTo(x * previewZoom + 0.5, 0);
                    gfxPreviewCtx.lineTo(x * previewZoom + 0.5, canvasH);
                    gfxPreviewCtx.stroke();
                }
                // Horizontal lines every 8 rows
                for (let y = 8; y <= totalRows; y += 8) {
                    gfxPreviewCtx.beginPath();
                    gfxPreviewCtx.moveTo(0, y * previewZoom + 0.5);
                    gfxPreviewCtx.lineTo(canvasW, y * previewZoom + 0.5);
                    gfxPreviewCtx.stroke();
                }
            }

            // Update info
            const addrHex = gfxSpriteAddress.toString(16).toUpperCase().padStart(4, '0');
            gfxInfo.textContent = `${addrHex}h: ${params.widthPx}x${params.heightRows}`;
        }

        function updateGfxSpinnerButtons() {
            const width = parseInt(gfxWidth.value) || 1;
            const height = parseInt(gfxHeight.value) || 8;
            // Width buttons
            document.getElementById('btnGfxWidthMin').disabled = width <= 1;
            document.getElementById('btnGfxWidthDec').disabled = width <= 1;
            document.getElementById('btnGfxWidthInc').disabled = width >= 32;
            document.getElementById('btnGfxWidthMax').disabled = width >= 32;
            // Height buttons
            document.getElementById('btnGfxHeightDec8').disabled = height <= 8;
            document.getElementById('btnGfxHeightDec').disabled = height <= 1;
            document.getElementById('btnGfxHeightInc').disabled = height >= 64;
            document.getElementById('btnGfxHeightInc8').disabled = height >= 64;
        }

        function updateGraphicsViewer() {
            renderGfxDump();
            renderGfxPreview();
            updateGfxSpinnerButtons();
        }

        function gfxNavigate(delta) {
            gfxSpriteAddress = (gfxSpriteAddress + delta) & 0xffff;
            gfxAddress.value = gfxSpriteAddress.toString(16).toUpperCase().padStart(4, '0');
            updateGraphicsViewer();
        }

        // Navigation buttons (different behavior in char mode vs linear mode)
        document.getElementById('btnGfxByte1').addEventListener('click', () => {
            const params = getGfxParams();
            // Char mode: move by sprite height (next/prev char column); Linear: move by 1 byte
            gfxNavigate(params.charMode ? -params.heightRows : -1);
        });
        document.getElementById('btnGfxByte2').addEventListener('click', () => {
            const params = getGfxParams();
            gfxNavigate(params.charMode ? params.heightRows : 1);
        });
        document.getElementById('btnGfxLine1').addEventListener('click', () => {
            const params = getGfxParams();
            // Char mode: move by 1 byte; Linear: move by width bytes
            gfxNavigate(params.charMode ? -1 : -params.widthBytes);
        });
        document.getElementById('btnGfxLine2').addEventListener('click', () => {
            const params = getGfxParams();
            gfxNavigate(params.charMode ? 1 : params.widthBytes);
        });
        document.getElementById('btnGfxRow1').addEventListener('click', () => {
            const params = getGfxParams();
            // Move by one character row (width * 8 bytes)
            gfxNavigate(-params.widthBytes * 8);
        });
        document.getElementById('btnGfxRow2').addEventListener('click', () => {
            const params = getGfxParams();
            gfxNavigate(params.widthBytes * 8);
        });
        document.getElementById('btnGfxSprite1').addEventListener('click', () => {
            const params = getGfxParams();
            gfxNavigate(-params.bytesPerSprite);
        });
        document.getElementById('btnGfxSprite2').addEventListener('click', () => {
            const params = getGfxParams();
            gfxNavigate(params.bytesPerSprite);
        });
        document.getElementById('btnGfxPage1').addEventListener('click', () => {
            const params = getGfxParams();
            gfxNavigate(-params.widthBytes * 8 * 24);
        });
        document.getElementById('btnGfxPage2').addEventListener('click', () => {
            const params = getGfxParams();
            gfxNavigate(params.widthBytes * 8 * 24);
        });

        // Width/Height spinners
        document.getElementById('btnGfxWidthMin').addEventListener('click', () => {
            gfxWidth.value = 1;
            updateGraphicsViewer();
        });
        document.getElementById('btnGfxWidthDec').addEventListener('click', () => {
            const val = Math.max(1, (parseInt(gfxWidth.value) || 1) - 1);
            gfxWidth.value = val;
            updateGraphicsViewer();
        });
        document.getElementById('btnGfxWidthInc').addEventListener('click', () => {
            const val = Math.min(32, (parseInt(gfxWidth.value) || 1) + 1);
            gfxWidth.value = val;
            updateGraphicsViewer();
        });
        document.getElementById('btnGfxWidthMax').addEventListener('click', () => {
            gfxWidth.value = 32;
            updateGraphicsViewer();
        });
        document.getElementById('btnGfxHeightDec8').addEventListener('click', () => {
            const current = parseInt(gfxHeight.value) || 8;
            const remainder = current % 8;
            const val = remainder === 0 ? Math.max(8, current - 8) : Math.max(8, current - remainder);
            gfxHeight.value = val;
            updateGraphicsViewer();
        });
        document.getElementById('btnGfxHeightDec').addEventListener('click', () => {
            const val = Math.max(1, (parseInt(gfxHeight.value) || 8) - 1);
            gfxHeight.value = val;
            updateGraphicsViewer();
        });
        document.getElementById('btnGfxHeightInc').addEventListener('click', () => {
            const val = Math.min(64, (parseInt(gfxHeight.value) || 8) + 1);
            gfxHeight.value = val;
            updateGraphicsViewer();
        });
        document.getElementById('btnGfxHeightInc8').addEventListener('click', () => {
            const current = parseInt(gfxHeight.value) || 8;
            const remainder = current % 8;
            const val = remainder === 0 ? Math.min(64, current + 8) : Math.min(64, current + (8 - remainder));
            gfxHeight.value = val;
            updateGraphicsViewer();
        });

        // Address input
        gfxAddress.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                gfxSpriteAddress = parseInt(gfxAddress.value, 16) || 0;
                gfxViewAddress = gfxSpriteAddress;
                updateGraphicsViewer();
            }
        });

        gfxWidth.addEventListener('change', updateGraphicsViewer);
        gfxHeight.addEventListener('change', updateGraphicsViewer);
        gfxGrid.addEventListener('change', updateGraphicsViewer);
        gfxInvert.addEventListener('change', updateGraphicsViewer);
        gfxCharMode.addEventListener('change', updateGraphicsViewer);
        document.getElementById('gfxZoom1').addEventListener('change', updateGraphicsViewer);
        document.getElementById('gfxZoom2').addEventListener('change', updateGraphicsViewer);
        document.getElementById('gfxZoom3').addEventListener('change', updateGraphicsViewer);

        // Scroll dump view (char mode: 1 byte per scroll; linear: widthBytes per scroll)
        document.querySelector('.graphics-dump-wrap').addEventListener('wheel', (e) => {
            e.preventDefault();
            const params = getGfxParams();
            const step = params.charMode ? 1 : params.widthBytes;
            const delta = e.deltaY > 0 ? step : -step;
            gfxSpriteAddress = (gfxSpriteAddress + delta) & 0xffff;
            gfxAddress.value = gfxSpriteAddress.toString(16).toUpperCase().padStart(4, '0');
            updateGraphicsViewer();
        }, { passive: false });

        // Tooltip for gfx dump
        const gfxTooltip = document.createElement('div');
        gfxTooltip.style.cssText = 'position:fixed;background:rgba(0,0,0,0.9);color:#fff;padding:4px 8px;border-radius:4px;font-size:12px;font-family:monospace;pointer-events:none;z-index:1000;display:none';
        document.body.appendChild(gfxTooltip);
        let gfxTooltipTimeout = null;

        // Click on dump to show address popup near cursor
        gfxDumpCanvas.addEventListener('click', (e) => {
            const params = getGfxParams();
            const zoom = document.getElementById('gfxZoom3').checked ? 3 :
                         document.getElementById('gfxZoom2').checked ? 2 : 1;
            const rect = gfxDumpCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Calculate byte position
            const col = Math.floor(x / (8 * zoom));
            const row = Math.floor(y / zoom);

            if (col >= params.widthBytes) return;

            // Calculate view start (same as in renderGfxDump)
            const anchorRow = 8;
            const viewStartAddr = (gfxSpriteAddress - params.widthBytes * anchorRow) & 0xffff;

            // Calculate address for clicked position
            let addr;
            if (params.charMode) {
                const charRow = Math.floor(row / 8);
                const lineInChar = row % 8;
                addr = (viewStartAddr + (charRow * params.widthBytes + col) * 8 + lineInChar) & 0xffff;
            } else {
                addr = (viewStartAddr + row * params.widthBytes + col) & 0xffff;
            }

            // Format address based on machine type
            let addrStr;
            if (spectrum.memory.machineType === '48k') {
                addrStr = addr.toString(16).toUpperCase().padStart(4, '0') + 'h';
            } else {
                // 128K: show page:address
                let page;
                if (addr < 0x4000) page = 'ROM' + spectrum.memory.currentRomBank;
                else if (addr < 0x8000) page = '5';
                else if (addr < 0xC000) page = '2';
                else page = spectrum.memory.currentRamBank.toString();
                const offset = addr & 0x3FFF;
                addrStr = page + ':' + offset.toString(16).toUpperCase().padStart(4, '0') + 'h';
            }

            // Show tooltip near cursor
            gfxTooltip.textContent = addrStr;
            gfxTooltip.style.left = (e.clientX + 10) + 'px';
            gfxTooltip.style.top = (e.clientY - 25) + 'px';
            gfxTooltip.style.display = 'block';

            // Hide after 2 seconds
            if (gfxTooltipTimeout) clearTimeout(gfxTooltipTimeout);
            gfxTooltipTimeout = setTimeout(() => {
                gfxTooltip.style.display = 'none';
            }, 2000);
        });

        // Action buttons
        document.getElementById('btnGfxGoDisasm').addEventListener('click', () => {
            document.querySelector('[data-tab="debugger"]').click();
            setTimeout(() => {
                goToAddress(gfxSpriteAddress);
                updateDebugger();
            }, 100);
        });

        document.getElementById('btnGfxGoMem').addEventListener('click', () => {
            document.querySelector('[data-tab="debugger"]').click();
            setTimeout(() => {
                goToMemoryAddress(gfxSpriteAddress);
            }, 100);
        });

        document.getElementById('btnGfxMarkRegion').addEventListener('click', () => {
            const params = getGfxParams();
            const endAddr = (gfxSpriteAddress + params.bytesPerSprite - 1) & 0xffff;
            const userComment = document.getElementById('gfxComment').value.trim();
            const comment = userComment || `Sprite ${params.widthPx}x${params.heightRows}`;

            const result = regionManager.add({
                start: gfxSpriteAddress,
                end: endAddr,
                type: REGION_TYPES.GRAPHICS,
                comment: comment,
                width: params.widthBytes,
                height: params.heightRows,
                charMode: params.charMode
            });

            if (result.error === 'overlap') {
                const r = result.regions[0];
                const existingRange = `${r.start.toString(16).toUpperCase()}-${r.end.toString(16).toUpperCase()}`;
                const existingType = r.type.toUpperCase();
                showMessage(`Overlap with existing ${existingType} region at ${existingRange}. Remove it first.`);
                return;
            }

            showMessage(`Marked ${gfxSpriteAddress.toString(16).toUpperCase()}-${endAddr.toString(16).toUpperCase()} as Graphics`);
            // Immediately update graphics preview to show region colors
            renderGfxDump();
            renderGfxPreview();
        });

        // Generate sprite as assembler DB statements
        function generateSpriteAsm() {
            const params = getGfxParams();
            const userComment = document.getElementById('gfxComment').value.trim();
            const lines = [];

            // Header comment
            const addrHex = gfxSpriteAddress.toString(16).toUpperCase().padStart(4, '0');
            if (userComment) {
                lines.push(`; ${userComment}`);
            }
            const charNote = params.charMode ? ', char-based' : '';
            lines.push(`; ${addrHex}h: ${params.widthPx}x${params.heightRows} (${params.bytesPerSprite} bytes${charNote})`);

            if (params.charMode) {
                // For char-based: first show visual preview, then output bytes in memory order
                lines.push(';');
                lines.push('; Visual:');

                // Generate visual preview (screen order)
                for (let row = 0; row < params.heightRows; row++) {
                    let visualLine = ';   ';
                    for (let col = 0; col < params.widthBytes; col++) {
                        const charRow = Math.floor(row / 8);
                        const lineInChar = row % 8;
                        const addr = (gfxSpriteAddress + (charRow * params.widthBytes + col) * 8 + lineInChar) & 0xffff;
                        const byte = spectrum.memory.read(addr);
                        for (let bit = 7; bit >= 0; bit--) {
                            visualLine += (byte >> bit) & 1 ? '█' : '·';
                        }
                    }
                    lines.push(visualLine);
                }
                lines.push('');

                // Output bytes in memory order (character by character)
                const charsWide = params.widthBytes;
                const charsTall = Math.ceil(params.heightRows / 8);

                for (let charY = 0; charY < charsTall; charY++) {
                    for (let charX = 0; charX < charsWide; charX++) {
                        const charIndex = charY * charsWide + charX;
                        const charBaseAddr = gfxSpriteAddress + charIndex * 8;

                        lines.push(`; Char ${charX},${charY}`);

                        const rowBytes = [];
                        for (let line = 0; line < 8; line++) {
                            const addr = (charBaseAddr + line) & 0xffff;
                            const byte = spectrum.memory.read(addr);
                            rowBytes.push('$' + byte.toString(16).toUpperCase().padStart(2, '0'));
                        }
                        lines.push('        db ' + rowBytes.join(', '));
                    }
                }
            } else {
                // Linear mode: output row by row with visual comments
                lines.push('');

                for (let row = 0; row < params.heightRows; row++) {
                    const rowBytes = [];
                    const visualParts = [];

                    for (let col = 0; col < params.widthBytes; col++) {
                        const addr = (gfxSpriteAddress + row * params.widthBytes + col) & 0xffff;
                        const byte = spectrum.memory.read(addr);
                        rowBytes.push('$' + byte.toString(16).toUpperCase().padStart(2, '0'));

                        // Create visual binary: █ for 1, · for 0
                        let visual = '';
                        for (let bit = 7; bit >= 0; bit--) {
                            visual += (byte >> bit) & 1 ? '█' : '·';
                        }
                        visualParts.push(visual);
                    }

                    const dbLine = '        db ' + rowBytes.join(', ');
                    const visualComment = ' ; ' + visualParts.join(' ');
                    lines.push(dbLine + visualComment);
                }
            }

            return lines.join('\n');
        }

        // Copy ASM to clipboard
        document.getElementById('btnGfxCopyAsm').addEventListener('click', () => {
            const text = generateSpriteAsm();
            navigator.clipboard.writeText(text).then(() => {
                showMessage('Copied to clipboard');
            }).catch(() => {
                alert(text);
            });
        });

        // Save ASM to file
        document.getElementById('btnGfxSaveAsm').addEventListener('click', () => {
            const text = generateSpriteAsm();
            const userComment = document.getElementById('gfxComment').value.trim();
            const addrHex = gfxSpriteAddress.toString(16).toUpperCase().padStart(4, '0');

            // Generate filename
            let filename;
            if (userComment) {
                filename = userComment.replace(/[^a-zA-Z0-9_-]/g, '_') + '.asm';
            } else {
                filename = 'sprite_' + addrHex + '.asm';
            }

            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
            showMessage('Saved ' + filename);
        });

        // Generate ASM for a specific graphics region
        function generateRegionSpriteAsm(region) {
            const lines = [];
            const addrHex = region.start.toString(16).toUpperCase().padStart(4, '0');
            const widthBytes = region.width || 1;
            const totalBytes = region.end - region.start + 1;
            const heightRows = region.height || Math.ceil(totalBytes / widthBytes);
            const widthPx = widthBytes * 8;
            const charMode = region.charMode || false;

            // Helper to read byte from region (handles 128K banks)
            function readByte(addr) {
                addr = addr & 0xffff;
                if (region.page !== null && region.page !== undefined && spectrum.memory.machineType !== '48k') {
                    if (region.page === 5 && addr >= 0x4000 && addr < 0x8000) {
                        return spectrum.memory.ram[5][addr - 0x4000];
                    } else if (region.page === 2 && addr >= 0x8000 && addr < 0xC000) {
                        return spectrum.memory.ram[2][addr - 0x8000];
                    } else if (addr >= 0xC000) {
                        return spectrum.memory.ram[region.page][addr - 0xC000];
                    }
                }
                return spectrum.memory.read(addr);
            }

            // Header comment
            if (region.comment) {
                lines.push(`; ${region.comment}`);
            }
            const charNote = charMode ? ', char-based' : '';
            lines.push(`; ${addrHex}h: ${widthPx}x${heightRows} (${totalBytes} bytes${charNote})`);
            if (region.page !== null && region.page !== undefined) {
                lines.push(`; Bank ${region.page}`);
            }

            if (charMode) {
                // For char-based: first show visual preview, then output bytes in memory order
                lines.push(';');
                lines.push('; Visual:');

                // Generate visual preview (screen order)
                for (let row = 0; row < heightRows; row++) {
                    let visualLine = ';   ';
                    for (let col = 0; col < widthBytes; col++) {
                        const charRow = Math.floor(row / 8);
                        const lineInChar = row % 8;
                        const addr = region.start + (charRow * widthBytes + col) * 8 + lineInChar;
                        const byte = readByte(addr);
                        for (let bit = 7; bit >= 0; bit--) {
                            visualLine += (byte >> bit) & 1 ? '█' : '·';
                        }
                    }
                    lines.push(visualLine);
                }
                lines.push('');

                // Output bytes in memory order (character by character)
                const charsWide = widthBytes;
                const charsTall = Math.ceil(heightRows / 8);

                for (let charY = 0; charY < charsTall; charY++) {
                    for (let charX = 0; charX < charsWide; charX++) {
                        const charIndex = charY * charsWide + charX;
                        const charBaseAddr = region.start + charIndex * 8;

                        lines.push(`; Char ${charX},${charY}`);

                        const rowBytes = [];
                        for (let line = 0; line < 8; line++) {
                            const byte = readByte(charBaseAddr + line);
                            rowBytes.push('$' + byte.toString(16).toUpperCase().padStart(2, '0'));
                        }
                        lines.push('        db ' + rowBytes.join(', '));
                    }
                }
            } else {
                // Linear mode: output row by row with visual comments
                lines.push('');

                for (let row = 0; row < heightRows; row++) {
                    const rowBytes = [];
                    const visualParts = [];

                    for (let col = 0; col < widthBytes; col++) {
                        const offset = row * widthBytes + col;
                        if (offset >= totalBytes) break;

                        const byte = readByte(region.start + offset);
                        rowBytes.push('$' + byte.toString(16).toUpperCase().padStart(2, '0'));

                        // Create visual binary: █ for 1, · for 0
                        let visual = '';
                        for (let bit = 7; bit >= 0; bit--) {
                            visual += (byte >> bit) & 1 ? '█' : '·';
                        }
                        visualParts.push(visual);
                    }

                    if (rowBytes.length > 0) {
                        const dbLine = '        db ' + rowBytes.join(', ');
                        const visualComment = ' ; ' + visualParts.join(' ');
                        lines.push(dbLine + visualComment);
                    }
                }
            }

            return lines.join('\n');
        }

        // Export All Sprites - finds all graphics regions and exports them
        document.getElementById('btnGfxExportAll').addEventListener('click', () => {
            const graphicsRegions = regionManager.getAll().filter(r => r.type === REGION_TYPES.GRAPHICS);

            if (graphicsRegions.length === 0) {
                showMessage('No graphics regions marked. Use "Mark Region" to mark sprites first.');
                return;
            }

            // Sort by address
            graphicsRegions.sort((a, b) => {
                if (a.page !== b.page) return (a.page || 0) - (b.page || 0);
                return a.start - b.start;
            });

            const allLines = [
                '; ================================================',
                '; Exported Sprites',
                '; ' + graphicsRegions.length + ' graphics regions',
                '; ================================================',
                ''
            ];

            for (const region of graphicsRegions) {
                allLines.push(generateRegionSpriteAsm(region));
                allLines.push('');
            }

            const text = allLines.join('\n');
            const filename = 'sprites_export.asm';

            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
            showMessage(`Exported ${graphicsRegions.length} sprites to ${filename}`);
        });

        // Verify modules
        if (typeof Z80 === 'undefined' || typeof Memory === 'undefined' ||
            typeof ULA === 'undefined' || typeof Spectrum === 'undefined') {
            alert('Failed to load emulator modules.');
            throw new Error('Missing modules');
        }

        // ========== Label Manager ==========
        class LabelManager {
            constructor() {
                this.labels = new Map();  // key = "page:address", value = label object
                this.romLabels = new Map(); // ROM labels loaded from file
                this.showRomLabels = true;
                this.currentFile = null;
                this.autoSaveEnabled = true;
            }

            // Generate key for label lookup
            _key(address, page = null) {
                const pageStr = page === null ? 'g' : page.toString();
                return `${pageStr}:${address.toString(16).padStart(4, '0')}`;
            }

            // Add or update a label
            add(label) {
                const key = this._key(label.address, label.page);
                const entry = {
                    address: label.address & 0xffff,
                    page: label.page ?? null,
                    name: label.name || '',
                    comment: label.comment || '',
                    size: label.size || 1
                };
                this.labels.set(key, entry);
                if (this.autoSaveEnabled) this._autoSave();
                return entry;
            }

            // Remove a label
            remove(address, page = null) {
                const key = this._key(address, page);
                const existed = this.labels.delete(key);
                if (existed && this.autoSaveEnabled) this._autoSave();
                return existed;
            }

            // Get label at exact address and page
            get(address, page = null) {
                // First try user labels (exact page match)
                let label = this.labels.get(this._key(address, page));
                if (label) return label;
                // Fall back to global user label
                if (page !== null) {
                    label = this.labels.get(this._key(address, null));
                    if (label) return label;
                }
                // Fall back to ROM labels if enabled
                if (this.showRomLabels) {
                    label = this.romLabels.get(this._key(address, page));
                    if (label) return label;
                    if (page !== null) {
                        label = this.romLabels.get(this._key(address, null));
                    }
                }
                return label || null;
            }

            // Find label by name
            findByName(name) {
                const nameLower = name.toLowerCase();
                for (const label of this.labels.values()) {
                    if (label.name.toLowerCase() === nameLower) return label;
                }
                return null;
            }

            // Get all labels, optionally filtered by page
            getAll(pageFilter = undefined) {
                const result = [];
                for (const label of this.labels.values()) {
                    if (pageFilter === undefined || label.page === pageFilter || label.page === null) {
                        result.push(label);
                    }
                }
                return result.sort((a, b) => a.address - b.address);
            }

            // Clear all labels
            clear() {
                this.labels.clear();
                if (this.autoSaveEnabled) this._autoSave();
            }

            // Set current file (for auto-save key)
            setCurrentFile(filename) {
                this.currentFile = filename;
                this._autoLoad();
            }

            // Get storage key for current file
            _storageKey() {
                if (!this.currentFile) return null;
                return `zx_labels_${this.currentFile.toLowerCase()}`;
            }

            // Auto-save to localStorage
            _autoSave() {
                const key = this._storageKey();
                if (!key) return;
                const data = JSON.stringify(Array.from(this.labels.values()));
                try {
                    localStorage.setItem(key, data);
                } catch (e) {
                    console.warn('Failed to save labels:', e);
                }
            }

            // Auto-load from localStorage
            _autoLoad() {
                this.labels.clear();
                const key = this._storageKey();
                if (!key) return;
                try {
                    const data = localStorage.getItem(key);
                    if (data) {
                        const arr = JSON.parse(data);
                        for (const label of arr) {
                            this.labels.set(this._key(label.address, label.page), label);
                        }
                    }
                } catch (e) {
                    console.warn('Failed to load labels:', e);
                }
            }

            // Export labels to JSON string
            exportJSON() {
                return JSON.stringify(Array.from(this.labels.values()), null, 2);
            }

            // Import labels from JSON string
            importJSON(jsonStr, merge = false) {
                try {
                    const arr = JSON.parse(jsonStr);
                    if (!merge) this.labels.clear();
                    for (const label of arr) {
                        this.labels.set(this._key(label.address, label.page), label);
                    }
                    if (this.autoSaveEnabled) this._autoSave();
                    return arr.length;
                } catch (e) {
                    console.error('Failed to import labels:', e);
                    return -1;
                }
            }

            // Load ROM labels from JSON string
            loadRomLabels(jsonStr) {
                try {
                    const arr = JSON.parse(jsonStr);
                    this.romLabels.clear();
                    for (const label of arr) {
                        const entry = {
                            address: label.address & 0xffff,
                            page: label.page ?? null,
                            name: label.name || '',
                            comment: label.comment || '',
                            size: label.size || 1,
                            isRom: true
                        };
                        this.romLabels.set(this._key(entry.address, entry.page), entry);
                    }
                    return arr.length;
                } catch (e) {
                    console.error('Failed to load ROM labels:', e);
                    return -1;
                }
            }

            // Get count of ROM labels
            getRomLabelCount() {
                return this.romLabels.size;
            }
        }

        // Memory region types for marking code/data/etc
        const REGION_TYPES = {
            CODE: 'code',
            DB: 'db',       // Data bytes
            DW: 'dw',       // Data words (16-bit)
            TEXT: 'text',   // Text strings
            GRAPHICS: 'graphics',
            SMC: 'smc'      // Self-modifying code
        };

        class RegionManager {
            constructor() {
                this.regions = [];  // Array of {start, end, type, page, comment}
                this.currentFile = null;
                this.autoSaveEnabled = true;
            }

            // Check if a range overlaps with existing regions
            getOverlapping(start, end, page = null) {
                start = start & 0xffff;
                end = end & 0xffff;
                return this.regions.filter(r => {
                    if (r.page !== page && r.page !== null && page !== null) return false;
                    // Check for overlap
                    return !(r.end < start || r.start > end);
                });
            }

            // Add or update a region
            add(region, allowOverwrite = false) {
                const entry = {
                    start: region.start & 0xffff,
                    end: region.end & 0xffff,
                    type: region.type || REGION_TYPES.CODE,
                    page: region.page ?? null,
                    comment: region.comment || ''
                };
                // Store width/height/charMode for graphics regions
                if (region.width) entry.width = region.width;
                if (region.height) entry.height = region.height;
                if (region.charMode) entry.charMode = region.charMode;

                // Check for overlapping regions
                const overlapping = this.getOverlapping(entry.start, entry.end, entry.page);
                if (overlapping.length > 0 && !allowOverwrite) {
                    return { error: 'overlap', regions: overlapping };
                }

                // Remove overlapping regions if overwrite allowed
                if (allowOverwrite) {
                    this.regions = this.regions.filter(r => {
                        if (r.page !== entry.page && r.page !== null && entry.page !== null) return true;
                        return r.end < entry.start || r.start > entry.end;
                    });
                }

                this.regions.push(entry);
                this.regions.sort((a, b) => a.start - b.start);
                if (this.autoSaveEnabled) this._autoSave();
                return entry;
            }

            // Remove region containing address
            remove(address, page = null) {
                const before = this.regions.length;
                this.regions = this.regions.filter(r => {
                    if (r.page !== page && r.page !== null && page !== null) return true;
                    return !(address >= r.start && address <= r.end);
                });
                if (this.regions.length !== before && this.autoSaveEnabled) {
                    this._autoSave();
                }
                return this.regions.length !== before;
            }

            // Get region at address
            get(address, page = null) {
                for (const r of this.regions) {
                    if ((r.page === page || r.page === null) &&
                        address >= r.start && address <= r.end) {
                        return r;
                    }
                }
                return null;
            }

            // Get region type at address (for quick checks)
            getType(address, page = null) {
                const region = this.get(address, page);
                return region ? region.type : REGION_TYPES.CODE;
            }

            // Check if address is in a non-code region
            isData(address, page = null) {
                const type = this.getType(address, page);
                return type !== REGION_TYPES.CODE && type !== REGION_TYPES.SMC;
            }

            // Get all regions
            getAll(pageFilter = undefined) {
                if (pageFilter === undefined) return [...this.regions];
                return this.regions.filter(r => r.page === pageFilter || r.page === null);
            }

            // Clear all regions
            clear() {
                this.regions = [];
                if (this.autoSaveEnabled) this._autoSave();
            }

            // Set current file (for auto-save key)
            setCurrentFile(filename) {
                this.currentFile = filename;
                this._autoLoad();
            }

            // Get storage key for current file
            _storageKey() {
                if (!this.currentFile) return null;
                return `zx_regions_${this.currentFile.toLowerCase()}`;
            }

            // Auto-save to localStorage
            _autoSave() {
                const key = this._storageKey();
                if (!key) return;
                try {
                    localStorage.setItem(key, JSON.stringify(this.regions));
                } catch (e) {
                    console.warn('Failed to save regions:', e);
                }
            }

            // Auto-load from localStorage
            _autoLoad() {
                this.regions = [];
                const key = this._storageKey();
                if (!key) return;
                try {
                    const data = localStorage.getItem(key);
                    if (data) {
                        this.regions = JSON.parse(data);
                    }
                } catch (e) {
                    console.warn('Failed to load regions:', e);
                }
            }

            // Export to JSON
            exportJSON() {
                return JSON.stringify(this.regions, null, 2);
            }

            // Import from JSON
            importJSON(jsonStr, merge = false) {
                try {
                    const arr = JSON.parse(jsonStr);
                    if (!merge) this.regions = [];
                    for (const r of arr) {
                        this.regions.push(r);
                    }
                    this.regions.sort((a, b) => a.start - b.start);
                    if (this.autoSaveEnabled) this._autoSave();
                    return arr.length;
                } catch (e) {
                    console.error('Failed to import regions:', e);
                    return -1;
                }
            }
        }

        const regionManager = new RegionManager();
        const labelManager = new LabelManager();

        // ========== Comment Manager ==========
        class CommentManager {
            constructor() {
                this.comments = new Map();  // Map<address, {before, inline, after, separator}>
                this.currentFile = null;
                this.autoSaveEnabled = true;
            }

            // Add or update comment at address
            set(address, comment) {
                address = address & 0xffff;
                const existing = this.comments.get(address) || {};
                const entry = {
                    before: comment.before !== undefined ? comment.before : (existing.before || ''),
                    inline: comment.inline !== undefined ? comment.inline : (existing.inline || ''),
                    after: comment.after !== undefined ? comment.after : (existing.after || ''),
                    separator: comment.separator !== undefined ? comment.separator : (existing.separator || false)
                };
                // Remove if all empty
                if (!entry.before && !entry.inline && !entry.after && !entry.separator) {
                    this.comments.delete(address);
                } else {
                    this.comments.set(address, entry);
                }
                if (this.autoSaveEnabled) this._autoSave();
                return entry;
            }

            // Get comment at address
            get(address) {
                return this.comments.get(address & 0xffff) || null;
            }

            // Remove all comments at address
            remove(address) {
                const had = this.comments.has(address & 0xffff);
                this.comments.delete(address & 0xffff);
                if (had && this.autoSaveEnabled) this._autoSave();
                return had;
            }

            // Get all comments as array
            getAll() {
                const result = [];
                for (const [addr, comment] of this.comments) {
                    result.push({ address: addr, ...comment });
                }
                return result.sort((a, b) => a.address - b.address);
            }

            // Clear all comments
            clear() {
                this.comments.clear();
                if (this.autoSaveEnabled) this._autoSave();
            }

            // Set current file for auto-save
            setCurrentFile(filename) {
                this.currentFile = filename;
                this._autoLoad();
            }

            _storageKey() {
                if (!this.currentFile) return null;
                return `zx_comments_${this.currentFile.toLowerCase()}`;
            }

            _autoSave() {
                const key = this._storageKey();
                if (!key) return;
                try {
                    localStorage.setItem(key, JSON.stringify(this.getAll()));
                } catch (e) {
                    console.warn('Failed to save comments:', e);
                }
            }

            _autoLoad() {
                this.comments.clear();
                const key = this._storageKey();
                if (!key) return;
                try {
                    const data = localStorage.getItem(key);
                    if (data) {
                        const arr = JSON.parse(data);
                        for (const c of arr) {
                            this.comments.set(c.address, {
                                before: c.before || '',
                                inline: c.inline || '',
                                after: c.after || '',
                                separator: c.separator || false
                            });
                        }
                    }
                } catch (e) {
                    console.warn('Failed to load comments:', e);
                }
            }

            exportJSON() {
                return JSON.stringify(this.getAll(), null, 2);
            }

            importJSON(jsonStr, merge = false) {
                try {
                    const arr = JSON.parse(jsonStr);
                    if (!merge) this.comments.clear();
                    for (const c of arr) {
                        this.comments.set(c.address, {
                            before: c.before || '',
                            inline: c.inline || '',
                            after: c.after || '',
                            separator: c.separator || false
                        });
                    }
                    if (this.autoSaveEnabled) this._autoSave();
                    return arr.length;
                } catch (e) {
                    console.error('Failed to import comments:', e);
                    return -1;
                }
            }
        }

        const commentManager = new CommentManager();

        // ========== Operand Format Manager ==========
        // Stores custom display formats for operands (hex/dec/bin/char)
        const OPERAND_FORMATS = {
            HEX: 'hex',
            DEC: 'dec',
            BIN: 'bin',
            CHAR: 'char'
        };

        class OperandFormatManager {
            constructor() {
                this.formats = new Map();  // Map<address, format>
                this.currentFile = null;
                this.autoSaveEnabled = true;
            }

            // Set format for operand at instruction address
            set(address, format) {
                address = address & 0xffff;
                if (format === OPERAND_FORMATS.HEX) {
                    // Default format - remove entry
                    this.formats.delete(address);
                } else {
                    this.formats.set(address, format);
                }
                if (this.autoSaveEnabled) this._autoSave();
            }

            // Get format at address (returns 'hex' as default)
            get(address) {
                return this.formats.get(address & 0xffff) || OPERAND_FORMATS.HEX;
            }

            // Remove format at address
            remove(address) {
                const had = this.formats.has(address & 0xffff);
                this.formats.delete(address & 0xffff);
                if (had && this.autoSaveEnabled) this._autoSave();
                return had;
            }

            // Get all formats as array
            getAll() {
                const result = [];
                for (const [addr, format] of this.formats) {
                    result.push({ address: addr, format });
                }
                return result.sort((a, b) => a.address - b.address);
            }

            // Clear all formats
            clear() {
                this.formats.clear();
                if (this.autoSaveEnabled) this._autoSave();
            }

            // Format a value according to format type
            formatValue(value, format, is16bit = false) {
                const val = is16bit ? (value & 0xffff) : (value & 0xff);
                switch (format) {
                    case OPERAND_FORMATS.DEC:
                        return val.toString(10);
                    case OPERAND_FORMATS.BIN:
                        return '%' + val.toString(2).padStart(is16bit ? 16 : 8, '0');
                    case OPERAND_FORMATS.CHAR:
                        if (!is16bit && val >= 32 && val < 127) {
                            const ch = String.fromCharCode(val);
                            // Escape quotes
                            if (ch === "'") return '"\'"';
                            return "'" + ch + "'";
                        }
                        // Fall back to hex for non-printable or 16-bit
                        return val.toString(16).toUpperCase().padStart(is16bit ? 4 : 2, '0') + 'h';
                    case OPERAND_FORMATS.HEX:
                    default:
                        return val.toString(16).toUpperCase().padStart(is16bit ? 4 : 2, '0') + 'h';
                }
            }

            // Set current file for auto-save
            setCurrentFile(filename) {
                this.currentFile = filename;
                this._autoLoad();
            }

            _storageKey() {
                if (!this.currentFile) return null;
                return `zx_opformats_${this.currentFile.toLowerCase()}`;
            }

            _autoSave() {
                const key = this._storageKey();
                if (!key) return;
                try {
                    localStorage.setItem(key, JSON.stringify(this.getAll()));
                } catch (e) {
                    console.warn('Failed to save operand formats:', e);
                }
            }

            _autoLoad() {
                this.formats.clear();
                const key = this._storageKey();
                if (!key) return;
                try {
                    const data = localStorage.getItem(key);
                    if (data) {
                        const arr = JSON.parse(data);
                        for (const f of arr) {
                            this.formats.set(f.address, f.format);
                        }
                    }
                } catch (e) {
                    console.warn('Failed to load operand formats:', e);
                }
            }
        }

        const operandFormatManager = new OperandFormatManager();

        // ========== Cross-Reference Manager ==========
        class XRefManager {
            constructor() {
                this.xrefs = new Map();  // "page:addr" -> [{fromAddr, type, page}]
                this.currentFile = null;
                this.autoSaveEnabled = true;
            }

            _key(address, page = null) {
                const pageStr = page === null ? 'g' : page.toString();
                return `${pageStr}:${address.toString(16).padStart(4, '0')}`;
            }

            add(targetAddr, fromAddr, type, page = null) {
                const key = this._key(targetAddr, page);
                if (!this.xrefs.has(key)) {
                    this.xrefs.set(key, []);
                }
                const refs = this.xrefs.get(key);
                // Avoid duplicates
                if (!refs.some(r => r.fromAddr === fromAddr && r.type === type && r.page === page)) {
                    refs.push({ fromAddr, type, page });
                }
            }

            get(targetAddr, page = null) {
                const key = this._key(targetAddr, page);
                const refs = this.xrefs.get(key) || [];
                // Also check global refs if page-specific
                if (page !== null) {
                    const globalRefs = this.xrefs.get(this._key(targetAddr, null)) || [];
                    return [...refs, ...globalRefs];
                }
                return [...refs];
            }

            hasRefs(targetAddr, page = null) {
                return this.get(targetAddr, page).length > 0;
            }

            getCount() {
                let count = 0;
                for (const refs of this.xrefs.values()) {
                    count += refs.length;
                }
                return count;
            }

            scanRange(startAddr, endAddr, page = null) {
                if (!disasm) return 0;
                let count = 0;
                let addr = startAddr;

                while (addr <= endAddr && addr < 0x10000) {
                    const instr = disasm.disassemble(addr, true);
                    if (instr.refs) {
                        for (const ref of instr.refs) {
                            this.add(ref.target, addr, ref.type, page);
                            count++;
                        }
                    }
                    addr = (addr + instr.length) & 0xffff;
                    // Prevent infinite loop if we wrap around
                    if (addr <= startAddr && addr !== 0) break;
                }
                if (this.autoSaveEnabled) this._autoSave();
                return count;
            }

            clear() {
                this.xrefs.clear();
                if (this.autoSaveEnabled) this._autoSave();
            }

            setCurrentFile(filename) {
                // Save current file's xrefs before switching
                if (this.currentFile && this.autoSaveEnabled) {
                    this._autoSave();
                }
                this.currentFile = filename;
                if (filename) {
                    this._autoLoad();
                } else {
                    this.xrefs.clear();
                }
            }

            _storageKey() {
                if (!this.currentFile) return null;
                return `zx_xrefs_${this.currentFile.toLowerCase()}`;
            }

            _autoSave() {
                const key = this._storageKey();
                if (!key) return;
                try {
                    const data = this.exportJSON();
                    if (data) {
                        localStorage.setItem(key, data);
                    } else {
                        localStorage.removeItem(key);
                    }
                } catch (e) {
                    console.warn('Failed to save xrefs:', e);
                }
            }

            _autoLoad() {
                const key = this._storageKey();
                if (!key) return;
                try {
                    const data = localStorage.getItem(key);
                    if (data) {
                        this.importJSON(data, false);
                    }
                } catch (e) {
                    console.warn('Failed to load xrefs:', e);
                }
            }

            exportJSON() {
                if (this.xrefs.size === 0) return null;
                const arr = [];
                for (const [key, refs] of this.xrefs.entries()) {
                    arr.push({ key, refs });
                }
                return JSON.stringify(arr);
            }

            importJSON(jsonStr, merge = false) {
                try {
                    const arr = JSON.parse(jsonStr);
                    if (!merge) this.xrefs.clear();
                    for (const item of arr) {
                        if (merge && this.xrefs.has(item.key)) {
                            const existing = this.xrefs.get(item.key);
                            for (const ref of item.refs) {
                                if (!existing.some(r => r.fromAddr === ref.fromAddr && r.type === ref.type)) {
                                    existing.push(ref);
                                }
                            }
                        } else {
                            this.xrefs.set(item.key, item.refs);
                        }
                    }
                    return arr.length;
                } catch (e) {
                    console.error('Failed to import xrefs:', e);
                    return -1;
                }
            }
        }

        const xrefManager = new XRefManager();
        let xrefRuntimeEnabled = false;

        // ========== Undo/Redo System ==========
        class UndoManager {
            constructor(maxHistory = 50) {
                this.undoStack = [];
                this.redoStack = [];
                this.maxHistory = maxHistory;
            }

            push(action) {
                // action = {type, description, undo(), redo()}
                this.undoStack.push(action);
                this.redoStack = [];
                if (this.undoStack.length > this.maxHistory) {
                    this.undoStack.shift();
                }
                this.updateButtons();
            }

            undo() {
                if (this.undoStack.length === 0) return false;
                const action = this.undoStack.pop();
                action.undo();
                this.redoStack.push(action);
                this.updateButtons();
                updateDebugger();
                showMessage(`Undo: ${action.description}`);
                return true;
            }

            redo() {
                if (this.redoStack.length === 0) return false;
                const action = this.redoStack.pop();
                action.redo();
                this.undoStack.push(action);
                this.updateButtons();
                updateDebugger();
                showMessage(`Redo: ${action.description}`);
                return true;
            }

            clear() {
                this.undoStack = [];
                this.redoStack = [];
                this.updateButtons();
            }

            updateButtons() {
                const btnUndo = document.getElementById('btnUndo');
                const btnRedo = document.getElementById('btnRedo');
                if (btnUndo) btnUndo.disabled = this.undoStack.length === 0;
                if (btnRedo) btnRedo.disabled = this.redoStack.length === 0;
            }
        }

        const undoManager = new UndoManager();

        // ========== Execution Trace ==========
        class TraceManager {
            constructor(maxHistory = 10000) {
                this.history = [];        // Array of trace entries
                this.maxHistory = maxHistory;
                this.enabled = true;      // Can be toggled for performance
                this.position = -1;       // Current viewing position (-1 = live)
            }

            record(cpu, memory, instrPC = null, portOps = null, memOps = null) {
                if (!this.enabled) return;

                // Use provided PC (before execution) or fall back to current PC
                const pc = instrPC !== null ? instrPC : cpu.pc;
                const entry = {
                    pc: pc,
                    sp: cpu.sp,
                    af: cpu.af,
                    bc: cpu.bc,
                    de: cpu.de,
                    hl: cpu.hl,
                    ix: cpu.ix,
                    iy: cpu.iy,
                    af_: (cpu.a_ << 8) | cpu.f_,
                    bc_: (cpu.b_ << 8) | cpu.c_,
                    de_: (cpu.d_ << 8) | cpu.e_,
                    hl_: (cpu.h_ << 8) | cpu.l_,
                    i: cpu.i,
                    r: (cpu.r7 & 0x80) | (cpu.r & 0x7f),
                    iff1: cpu.iff1,
                    iff2: cpu.iff2,
                    im: cpu.im,
                    tStates: cpu.tStates,
                    // Store instruction bytes at PC (up to 4 bytes for longest instruction)
                    bytes: [
                        memory.read(pc & 0xffff),
                        memory.read((pc + 1) & 0xffff),
                        memory.read((pc + 2) & 0xffff),
                        memory.read((pc + 3) & 0xffff)
                    ],
                    // Port I/O operations during this instruction
                    ports: portOps && portOps.length > 0 ? portOps.slice() : null,
                    // Memory write operations during this instruction
                    mem: memOps && memOps.length > 0 ? memOps.slice() : null
                };

                this.history.push(entry);
                if (this.history.length > this.maxHistory) {
                    this.history.shift();
                }
                this.position = -1; // Reset to live view
            }

            getEntry(index) {
                if (index < 0 || index >= this.history.length) return null;
                return this.history[index];
            }

            getRecent(count = 50) {
                const start = Math.max(0, this.history.length - count);
                return this.history.slice(start);
            }

            // Get entries around a specific position (for navigation view)
            getEntriesAround(pos, count = 20) {
                if (pos < 0 || pos >= this.history.length) {
                    return { entries: [], startIdx: 0, viewIdx: -1 };
                }
                const half = Math.floor(count / 2);
                let start = Math.max(0, pos - half);
                let end = Math.min(this.history.length, start + count);
                // Adjust start if we hit the end
                if (end - start < count) {
                    start = Math.max(0, end - count);
                }
                return {
                    entries: this.history.slice(start, end),
                    startIdx: start,
                    viewIdx: pos - start  // Index within returned array
                };
            }

            get length() {
                return this.history.length;
            }

            clear() {
                this.history = [];
                this.position = -1;
            }

            goBack() {
                if (this.history.length === 0) return null;
                if (this.position === -1) {
                    this.position = this.history.length - 1;
                } else if (this.position > 0) {
                    this.position--;
                }
                return this.history[this.position];
            }

            goForward() {
                if (this.position === -1 || this.history.length === 0) return null;
                if (this.position < this.history.length - 1) {
                    this.position++;
                    return this.history[this.position];
                } else {
                    this.position = -1; // Back to live
                    return null;
                }
            }

            goToLive() {
                this.position = -1;
            }

            isViewingHistory() {
                return this.position !== -1;
            }

            getCurrentPosition() {
                return this.position;
            }
        }

        const traceManager = new TraceManager();

        // ========== Navigation History ==========
        const navHistory = [];
        let navHistoryIndex = -1;
        const NAV_HISTORY_MAX = 50;

        function navPushHistory(addr) {
            if (addr === null || addr === undefined) return;
            addr = addr & 0xffff;
            // Don't push if same as current
            if (navHistoryIndex >= 0 && navHistory[navHistoryIndex] === addr) return;
            // Truncate forward history
            navHistory.length = navHistoryIndex + 1;
            navHistory.push(addr);
            // Limit size
            if (navHistory.length > NAV_HISTORY_MAX) {
                navHistory.shift();
            }
            navHistoryIndex = navHistory.length - 1;
            updateNavButtons();
        }

        function navBack() {
            if (navHistoryIndex > 0) {
                navHistoryIndex--;
                const addr = navHistory[navHistoryIndex];
                goToAddressNoHistory(addr);
                updateNavButtons();
            }
        }

        function navForward() {
            if (navHistoryIndex < navHistory.length - 1) {
                navHistoryIndex++;
                const addr = navHistory[navHistoryIndex];
                goToAddressNoHistory(addr);
                updateNavButtons();
            }
        }

        function updateNavButtons() {
            const btnBack = document.getElementById('btnNavBack');
            const btnFwd = document.getElementById('btnNavForward');
            if (btnBack) btnBack.disabled = navHistoryIndex <= 0;
            if (btnFwd) btnFwd.disabled = navHistoryIndex >= navHistory.length - 1;
        }

        // ========== Region Parsing Helpers ==========
        // Shared constants for region display
        const REGION_MAX_TEXT = 50;   // sjasmplus compatible
        const REGION_MAX_BYTES = 8;   // bytes per DB line
        const REGION_MAX_WORDS = 4;   // words per DW line

        // Parse text region, returns {text, bytes, bit7Terminated, nextAddr}
        function parseTextRegion(memory, startAddr, endAddr, maxChars = REGION_MAX_TEXT) {
            let text = '';
            let bytes = [];
            let bit7Terminated = false;
            let addr = startAddr;

            while (addr <= endAddr && text.length < maxChars && addr <= 0xffff) {
                const byte = memory.read(addr);
                bytes.push(byte);

                const hasBit7 = (byte & 0x80) !== 0;
                const charByte = hasBit7 ? (byte & 0x7F) : byte;

                if (charByte >= 32 && charByte < 127 && charByte !== 34) {
                    text += String.fromCharCode(charByte);
                    if (hasBit7) {
                        bit7Terminated = true;
                        addr++;
                        break;
                    }
                } else if (charByte === 34) {
                    text += '""'; // Escape quote
                    if (hasBit7) {
                        bit7Terminated = true;
                        addr++;
                        break;
                    }
                } else if (byte === 0) {
                    text += '\\0';
                } else if (byte === 10) {
                    text += '\\n';
                } else if (byte === 13) {
                    text += '\\r';
                } else {
                    // Non-printable - stop here
                    if (text.length === 0) {
                        // Return single byte as non-text
                        return { text: '', bytes: [byte], bit7Terminated: false, nextAddr: addr + 1, singleByte: true };
                    }
                    bytes.pop(); // Don't include this byte
                    break;
                }
                addr++;
            }

            return { text, bytes, bit7Terminated, nextAddr: addr, singleByte: false };
        }

        // Parse byte region (DB), returns {byteStrs, bytes, nextAddr}
        function parseByteRegion(memory, startAddr, endAddr, maxBytes = REGION_MAX_BYTES) {
            let byteStrs = [];
            let bytes = [];
            let addr = startAddr;

            while (addr <= endAddr && byteStrs.length < maxBytes && addr <= 0xffff) {
                const byte = memory.read(addr);
                byteStrs.push(`$${hex8(byte)}`);
                bytes.push(byte);
                addr++;
            }

            return { byteStrs, bytes, nextAddr: addr };
        }

        // Parse word region (DW), returns {wordStrs, bytes, nextAddr}
        function parseWordRegion(memory, startAddr, endAddr, maxWords = REGION_MAX_WORDS) {
            let wordStrs = [];
            let bytes = [];
            let addr = startAddr;

            while (addr <= endAddr && wordStrs.length < maxWords && addr < 0xffff) {
                const lo = memory.read(addr);
                const hi = memory.read((addr + 1) & 0xffff);
                const word = lo | (hi << 8);
                wordStrs.push(`$${hex16(word)}`);
                bytes.push(lo, hi);
                addr += 2;
                if (addr > endAddr + 1) break;
            }

            return { wordStrs, bytes, nextAddr: addr };
        }
        // ========== End Region Parsing Helpers ==========

        // ROM storage
        let rom48Data = null;
        let rom128Data = null;
        let romPentagonData = null;
        let romTrdosData = null;  // Separate TR-DOS ROM (16KB)

        // Try to auto-load ROMs from roms/ directory
        async function tryLoadRomsFromDirectory() {
            const romPaths = [
                { path: 'roms/48.rom', type: '48k' },
                { path: 'roms/128.rom', type: '128k' },
                { path: 'roms/pentagon.rom', type: 'pentagon' },
                { path: 'roms/trdos.rom', type: 'trdos' }
            ];

            for (const rom of romPaths) {
                try {
                    const response = await fetch(rom.path);
                    if (response.ok) {
                        const data = await response.arrayBuffer();
                        if (rom.type === '48k') rom48Data = data;
                        else if (rom.type === '128k') rom128Data = data;
                        else if (rom.type === 'pentagon') romPentagonData = data;
                        else if (rom.type === 'trdos') romTrdosData = data;
                        console.log(`Loaded ${rom.path}`);
                    }
                } catch (e) {
                    // ROM not found, continue
                }
            }

            // Try to load ROM labels
            await tryLoadRomLabels();

            updateRomStatus();

            if (rom48Data) {
                // ROMs found, initialize directly
                initializeEmulator();
            } else {
                // No 48K ROM, show dialog
                romModal.classList.remove('hidden');
            }
        }

        // Try to load ROM labels from labels/ directory
        async function tryLoadRomLabels() {
            const labelPaths = [
                'labels/48k.json',
                'labels/rom48.json',
                'labels/spectrum48.json'
            ];

            for (const path of labelPaths) {
                try {
                    const response = await fetch(path);
                    if (response.ok) {
                        const jsonStr = await response.text();
                        const count = labelManager.loadRomLabels(jsonStr);
                        if (count > 0) {
                            console.log(`Loaded ${count} ROM labels from ${path}`);
                            return;
                        }
                    }
                } catch (e) {
                    // Labels file not found, continue
                }
            }
        }

        // UI Elements
        const canvas = document.getElementById('screen');
        const overlayCanvas = document.getElementById('overlayCanvas');
        const romModal = document.getElementById('romModal');
        const btnSelect48Rom = document.getElementById('btnSelect48Rom');
        const btnSelect128Rom = document.getElementById('btnSelect128Rom');
        const btnSelectPentagonRom = document.getElementById('btnSelectPentagonRom');
        const btnSelectTrdosRom = document.getElementById('btnSelectTrdosRom');
        const btnStartEmulator = document.getElementById('btnStartEmulator');
        const status48Rom = document.getElementById('status48Rom');
        const status128Rom = document.getElementById('status128Rom');
        const statusPentagonRom = document.getElementById('statusPentagonRom');
        const rom48Input = document.getElementById('rom48Input');
        const rom128Input = document.getElementById('rom128Input');
        const romPentagonInput = document.getElementById('romPentagonInput');
        const romTrdosInput = document.getElementById('romTrdosInput');
        
        const btnRun = document.getElementById('btnRun');
        const btnReset = document.getElementById('btnReset');
        const btnLoadFile = document.getElementById('btnLoadFile');
        const btnSaveSnapshot = document.getElementById('btnSaveSnapshot');
        const machineSelect = document.getElementById('machineSelect');
        const speedSelect = document.getElementById('speedSelect');
        const chkKempston = document.getElementById('chkKempston');
        const chkFullBorder = document.getElementById('chkFullBorder');
        const fileInput = document.getElementById('fileInput');
        const statusEl = document.getElementById('status');
        const fpsEl = document.getElementById('fps');
        const machineEl = document.getElementById('machine');
        const dropZone = document.getElementById('dropZone');

        // RZX playback UI
        const rzxInfo = document.getElementById('rzxInfo');
        const rzxStatus = document.getElementById('rzxStatus');
        const btnRzxStop = document.getElementById('btnRzxStop');

        // ZIP selection modal
        const zipModal = document.getElementById('zipModal');
        const zipFileList = document.getElementById('zipFileList');
        const btnZipCancel = document.getElementById('btnZipCancel');
        const btnBootTrdos = document.getElementById('btnBootTrdos');
        let pendingZipResult = null;  // Stores ZIP result while user selects file
        
        // Create emulator
        const savedMachineType = localStorage.getItem('zx-machine-type') || '48k';
        let spectrum = new Spectrum(canvas, {
            machineType: savedMachineType,
            tapeTrapsEnabled: true,
            overlayCanvas: overlayCanvas
        });
        window.spectrum = spectrum;

        // Apply default full border mode
        spectrum.ula.setFullBorder(true);
        spectrum.updateDisplayDimensions();

        function showMessage(text, type = 'success') {
            const msg = document.createElement('div');
            msg.className = `message ${type}`;
            msg.textContent = text;
            document.body.appendChild(msg);
            setTimeout(() => msg.remove(), 3000);
        }
        
        function updateStatus() {
            statusEl.textContent = spectrum.isRunning() ? 'Running' : 'Stopped';
            fpsEl.textContent = spectrum.getFps();
            machineEl.textContent = spectrum.machineType.toUpperCase();
            machineSelect.value = spectrum.machineType;
            btnRun.textContent = spectrum.isRunning() ? 'Pause' : 'Run';
            btnRun.disabled = !spectrum.romLoaded;
            
            // Update debugger if open (or in landscape mode where it's always visible)
            if (debuggerPanel.classList.contains('open') || window.innerWidth >= 1400) {
                updateDebugger();
            }

            // Update RZX status
            updateRZXStatus();
        }

        function updateRZXStatus() {
            if (spectrum.isRZXPlaying()) {
                rzxInfo.style.display = 'inline-block';
                const frame = spectrum.getRZXFrame();
                const total = spectrum.getRZXTotalFrames();
                const percent = Math.round((frame / total) * 100);
                rzxStatus.textContent = `${frame}/${total} (${percent}%)`;
            } else {
                rzxInfo.style.display = 'none';
            }
        }

        // RZX stop button handler
        btnRzxStop.addEventListener('click', () => {
            spectrum.rzxStop();
            updateRZXStatus();
            showMessage('RZX playback stopped');
        });

        // RZX end callback
        spectrum.onRZXEnd = () => {
            updateRZXStatus();
            showMessage('RZX playback finished');
        };

        // Debugger functionality
        const debuggerPanel = document.getElementById('debuggerPanel');
        const mainRegisters = document.getElementById('mainRegisters');
        const altRegisters = document.getElementById('altRegisters');
        const ixiyRegisters = document.getElementById('ixiyRegisters');
        const indexRegisters = document.getElementById('indexRegisters');
        const flagsDisplay = document.getElementById('flagsDisplay');
        const statusRegisters = document.getElementById('statusRegisters');
        const stackView = document.getElementById('stackView');
        const pagesGroup = document.getElementById('pagesGroup');
        const pagesInfo = document.getElementById('pagesInfo');
        const disassemblyView = document.getElementById('disassemblyView');

        // Register edit functionality
        let isEditingRegister = false;

        function startRegisterEdit(valueSpan) {
            if (!spectrum.cpu || isEditingRegister) return;

            isEditingRegister = true;
            const reg = valueSpan.dataset.reg;
            const bits = parseInt(valueSpan.dataset.bits) || 16;
            const originalValue = valueSpan.textContent;

            // Calculate max length based on register type
            // IFF is special: "1/1" format needs 3 chars
            // T-states: up to 5 digits (69888)
            // IM: 0-2 needs 1 char, I/R: 00-FF needs 2, 16-bit: 0000-FFFF needs 4
            const maxLen = reg === 'iff' ? 3 : reg === 'tstates' ? 5 : (bits <= 3 ? 1 : (bits <= 8 ? 2 : 4));

            // Lock width to prevent UI shift
            const originalWidth = valueSpan.offsetWidth;
            valueSpan.style.width = originalWidth + 'px';

            // Make span editable in place
            valueSpan.contentEditable = 'true';
            valueSpan.classList.add('editing');
            valueSpan.focus();

            // Select all text
            const range = document.createRange();
            range.selectNodeContents(valueSpan);
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);

            // Limit input length
            function limitInput() {
                const text = valueSpan.textContent;
                if (text.length > maxLen) {
                    valueSpan.textContent = text.slice(0, maxLen);
                    // Move cursor to end
                    const range = document.createRange();
                    range.selectNodeContents(valueSpan);
                    range.collapse(false);
                    const sel = window.getSelection();
                    sel.removeAllRanges();
                    sel.addRange(range);
                }
            }
            valueSpan.addEventListener('input', limitInput);

            function finishEdit(save) {
                if (!isEditingRegister) return;
                isEditingRegister = false;
                valueSpan.removeEventListener('input', limitInput);
                valueSpan.contentEditable = 'false';
                valueSpan.classList.remove('editing');
                valueSpan.style.width = '';
                if (save) {
                    applyRegisterValue(reg, valueSpan.textContent.trim(), bits);
                } else {
                    valueSpan.textContent = originalValue;
                }
                updateDebugger();
            }

            valueSpan.addEventListener('blur', () => finishEdit(true), { once: true });
            valueSpan.addEventListener('keydown', function handler(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    valueSpan.removeEventListener('keydown', handler);
                    finishEdit(true);
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    valueSpan.removeEventListener('keydown', handler);
                    finishEdit(false);
                }
            });
        }

        function applyRegisterValue(reg, valueStr, bits) {
            const cpu = spectrum.cpu;
            if (!cpu) return;

            // Parse value (hex or decimal)
            let value;
            valueStr = valueStr.trim().toUpperCase();

            // Handle special cases for IFF and IM
            if (reg === 'iff') {
                // Toggle IFF1/IFF2: parse as "1/1", "0/0", "1/0", "0/1" or single value
                if (valueStr.includes('/')) {
                    const parts = valueStr.split('/');
                    cpu.iff1 = parts[0] === '1';
                    cpu.iff2 = parts[1] === '1';
                } else {
                    const v = valueStr === '1' || valueStr === 'ON' || valueStr === 'TRUE';
                    cpu.iff1 = v;
                    cpu.iff2 = v;
                }
                return;
            } else if (reg === 'im') {
                value = parseInt(valueStr, 10);
                if (value >= 0 && value <= 2) {
                    cpu.im = value;
                }
                return;
            } else if (reg === 'rambank') {
                value = parseInt(valueStr, 10);
                if (value >= 0 && value <= 7) {
                    spectrum.memory.setRamBank(value);
                }
                return;
            } else if (reg === 'scrbank') {
                value = parseInt(valueStr, 10);
                if (value === 0 || value === 1) {
                    spectrum.memory.setScreenBank(value === 0 ? 5 : 7);
                }
                return;
            } else if (reg === 'rombank') {
                value = parseInt(valueStr, 10);
                if (value >= 0 && value <= 1) {
                    spectrum.memory.setRomBank(value);
                }
                return;
            } else if (reg === 'paginglock') {
                value = valueStr === '1' || valueStr === 'ON' || valueStr === 'TRUE';
                spectrum.memory.setPagingDisabled(value);
                return;
            } else if (reg === 'tstates') {
                value = parseInt(valueStr, 10);
                if (!isNaN(value) && value >= 0) {
                    cpu.tStates = value;
                }
                return;
            }

            // Parse hex (with or without suffix) or decimal
            if (valueStr.endsWith('H')) {
                value = parseInt(valueStr.slice(0, -1), 16);
            } else if (valueStr.startsWith('$') || valueStr.startsWith('0X')) {
                value = parseInt(valueStr.replace('$', '').replace('0X', ''), 16);
            } else if (/^[0-9A-F]+$/.test(valueStr) && valueStr.length > 2) {
                // Likely hex if all hex chars and longer than 2 chars
                value = parseInt(valueStr, 16);
            } else if (/^[0-9]+$/.test(valueStr)) {
                value = parseInt(valueStr, 10);
            } else {
                value = parseInt(valueStr, 16);
            }

            if (isNaN(value)) return;

            // Mask to appropriate bits
            const mask = bits === 8 ? 0xFF : 0xFFFF;
            value = value & mask;

            // Apply to registers
            switch (reg) {
                case 'af': cpu.a = (value >> 8) & 0xFF; cpu.f = value & 0xFF; break;
                case 'bc': cpu.b = (value >> 8) & 0xFF; cpu.c = value & 0xFF; break;
                case 'de': cpu.d = (value >> 8) & 0xFF; cpu.e = value & 0xFF; break;
                case 'hl': cpu.h = (value >> 8) & 0xFF; cpu.l = value & 0xFF; break;
                case 'af_': cpu.a_ = (value >> 8) & 0xFF; cpu.f_ = value & 0xFF; break;
                case 'bc_': cpu.b_ = (value >> 8) & 0xFF; cpu.c_ = value & 0xFF; break;
                case 'de_': cpu.d_ = (value >> 8) & 0xFF; cpu.e_ = value & 0xFF; break;
                case 'hl_': cpu.h_ = (value >> 8) & 0xFF; cpu.l_ = value & 0xFF; break;
                case 'ix': cpu.ix = value; break;
                case 'iy': cpu.iy = value; break;
                case 'sp': cpu.sp = value; break;
                case 'pc': cpu.pc = value; break;
                case 'i': cpu.i = value; break;
                case 'r': cpu.r = value & 0x7F; cpu.r7 = value & 0x80; break;
            }
        }

        // Event delegation for register editing
        function handleRegisterClick(e) {
            const target = e.target;
            if (target.classList.contains('editable') && target.classList.contains('register-value')) {
                startRegisterEdit(target);
            }
        }

        mainRegisters.addEventListener('click', handleRegisterClick);
        altRegisters.addEventListener('click', handleRegisterClick);
        ixiyRegisters.addEventListener('click', handleRegisterClick);
        indexRegisters.addEventListener('click', handleRegisterClick);
        statusRegisters.addEventListener('click', handleRegisterClick);
        pagesInfo.addEventListener('click', handleRegisterClick);

        // Flag click handler - toggle individual flags
        flagsDisplay.addEventListener('click', (e) => {
            const target = e.target;
            if (target.classList.contains('flag-item') && target.classList.contains('editable')) {
                const bit = parseInt(target.dataset.bit);
                if (!isNaN(bit) && spectrum.cpu) {
                    spectrum.cpu.f ^= bit;  // Toggle the flag bit
                    updateDebugger();
                }
            }
        });

        // EXA/EXX buttons - use event delegation since buttons are recreated
        ixiyRegisters.addEventListener('click', (e) => {
            if (!spectrum.cpu) return;
            const btn = e.target.closest('.reg-swap-btn');
            if (!btn) return;

            const cpu = spectrum.cpu;

            if (btn.id === 'btnEXA') {
                // EX AF,AF' - swap A/A' and F/F'
                let tmp = cpu.a; cpu.a = cpu.a_; cpu.a_ = tmp;
                tmp = cpu.f; cpu.f = cpu.f_; cpu.f_ = tmp;
                updateDebugger();
            } else if (btn.id === 'btnEXX') {
                // EXX - swap BC,DE,HL with BC',DE',HL'
                let tmp = cpu.b; cpu.b = cpu.b_; cpu.b_ = tmp;
                tmp = cpu.c; cpu.c = cpu.c_; cpu.c_ = tmp;
                tmp = cpu.d; cpu.d = cpu.d_; cpu.d_ = tmp;
                tmp = cpu.e; cpu.e = cpu.e_; cpu.e_ = tmp;
                tmp = cpu.h; cpu.h = cpu.h_; cpu.h_ = tmp;
                tmp = cpu.l; cpu.l = cpu.l_; cpu.l_ = tmp;
                updateDebugger();
            }
        });
        
        // Unified Trigger UI elements
        const triggerList = document.getElementById('triggerList');
        const triggerType = document.getElementById('triggerType');
        const triggerAddrInput = document.getElementById('triggerAddrInput');
        const triggerCondInput = document.getElementById('triggerCondInput');
        const btnAddTrigger = document.getElementById('btnAddTrigger');
        const btnClearTriggers = document.getElementById('btnClearTriggers');

        // Labels panel UI elements
        const labelsList = document.getElementById('labelsList');
        const labelFilterInput = document.getElementById('labelFilterInput');
        const btnAddLabel = document.getElementById('btnAddLabel');
        const btnExportLabels = document.getElementById('btnExportLabels');
        const btnImportLabels = document.getElementById('btnImportLabels');
        const btnClearLabels = document.getElementById('btnClearLabels');
        const labelFileInput = document.getElementById('labelFileInput');
        const chkShowRomLabels = document.getElementById('chkShowRomLabels');

        // Memory View UI elements
        const memoryView = document.getElementById('memoryView');
        const memoryAddressInput = document.getElementById('memoryAddress');
        const btnMemoryGo = document.getElementById('btnMemoryGo');
        const btnMemoryPC = document.getElementById('btnMemoryPC');
        const btnMemorySP = document.getElementById('btnMemorySP');
        const btnMemoryHL = document.getElementById('btnMemoryHL');
        const btnMemoryPgUp = document.getElementById('btnMemoryPgUp');
        const btnMemoryPgDn = document.getElementById('btnMemoryPgDn');
        const btnMemorySnap = document.getElementById('btnMemorySnap');
        const btnMemoryClearSnap = document.getElementById('btnMemoryClearSnap');
        const chkRomEdit = document.getElementById('chkRomEdit');

        // Memory snapshot for diff
        let memorySnapshot = null;

        // POKE search
        const btnPokeSnap = document.getElementById('btnPokeSnap');
        const pokeSearchMode = document.getElementById('pokeSearchMode');
        const pokeSearchValue = document.getElementById('pokeSearchValue');
        const btnPokeSearch = document.getElementById('btnPokeSearch');
        const btnPokeReset = document.getElementById('btnPokeReset');
        const pokeStatus = document.getElementById('pokeStatus');
        const pokeResults = document.getElementById('pokeResults');

        let pokeSnapshot = null;  // Last snapshot for comparison
        let pokeCandidates = null;  // Set of candidate addresses (null = all RAM)

        // Auto-map UI elements
        const chkAutoMap = document.getElementById('chkAutoMap');
        const btnAutoMapApply = document.getElementById('btnAutoMapApply');
        const btnAutoMapClear = document.getElementById('btnAutoMapClear');
        const autoMapStats = document.getElementById('autoMapStats');

        // Memory search UI elements
        const memSearchInput = document.getElementById('memSearchInput');
        const memSearchType = document.getElementById('memSearchType');
        const btnMemSearch = document.getElementById('btnMemSearch');
        const btnMemSearchNext = document.getElementById('btnMemSearchNext');
        const searchResults = document.getElementById('searchResults');
        const chkSearchCase = document.getElementById('chkSearchCase');
        const chkSearch7bit = document.getElementById('chkSearch7bit');
        
        // Search state
        let searchPattern = null;
        let searchResultAddrs = [];
        let searchResultIndex = -1;
        
        // Disassembly navigation elements
        const disasmAddressInput = document.getElementById('disasmAddress');
        const btnDisasmGo = document.getElementById('btnDisasmGo');
        const btnDisasmPC = document.getElementById('btnDisasmPC');
        const btnDisasmPgUp = document.getElementById('btnDisasmPgUp');
        const btnDisasmPgDn = document.getElementById('btnDisasmPgDn');
        const btnDisasmExport = document.getElementById('btnDisasmExport');
        const btnDisasmExportRange = document.getElementById('btnDisasmExportRange');

        // Export dialog elements
        const exportDisasmDialog = document.getElementById('exportDisasmDialog');
        const exportStartAddr = document.getElementById('exportStartAddr');
        const exportEndAddr = document.getElementById('exportEndAddr');
        const exportWithOrg = document.getElementById('exportWithOrg');
        const exportWithAddr = document.getElementById('exportWithAddr');
        const exportWithBytes = document.getElementById('exportWithBytes');
        const exportWithTstates = document.getElementById('exportWithTstates');
        const btnExportCancel = document.getElementById('btnExportCancel');
        const btnExportSave = document.getElementById('btnExportSave');

        // Bookmarks
        const disasmBookmarksBar = document.getElementById('disasmBookmarks');
        const memoryBookmarksBar = document.getElementById('memoryBookmarks');
        let disasmBookmarks = [null, null, null, null, null];  // 5 bookmark slots
        let memoryBookmarks = [null, null, null, null, null];  // 5 bookmark slots

        // Memory view state
        let memoryViewAddress = 0;
        let memoryEditingAddr = null;
        const MEMORY_LINES = 21;
        const BYTES_PER_LINE = 16;
        
        // Disassembly view state
        let disasmViewAddress = null; // null = follow PC
        let disasmLastLineAddr = 0;
        let traceViewAddress = null; // Address being viewed in trace history (null = live)
        const DISASM_LINES = 38;
        const DISASM_PC_POSITION = 4; // Show PC at 5th line (0-indexed)
        const chkShowTstates = document.getElementById('chkShowTstates');
        const labelDisplayMode = document.getElementById('labelDisplayMode');

        // Format address with label based on display mode
        function formatAddrWithLabel(addr, mode) {
            const label = labelManager.get(addr);
            if (!label) return hex16(addr);

            switch (mode) {
                case 'addr': return hex16(addr);
                case 'label': return label.name;
                case 'both': return `${label.name}`;
                default: return hex16(addr);
            }
        }

        // Format address column (may include both address and label)
        // Returns { html, isLong, labelHtml } where isLong means label needs its own row
        const LABEL_MAX_CHARS = 12; // Max chars before wrapping to own row
        function formatAddrColumn(addr, mode) {
            const label = labelManager.get(addr);
            if (!label) return { html: hex16(addr), isLong: false, labelHtml: null };

            switch (mode) {
                case 'addr':
                    return { html: hex16(addr), isLong: false, labelHtml: null };
                case 'label': {
                    const isLong = label.name.length > LABEL_MAX_CHARS;
                    return {
                        html: isLong ? hex16(addr) : `<span class="label-name">${label.name}</span>`,
                        isLong,
                        labelHtml: isLong ? `<span class="label-name">${label.name}:</span>` : null
                    };
                }
                case 'both': {
                    const combined = `${hex16(addr)} ${label.name}`;
                    const isLong = combined.length > LABEL_MAX_CHARS + 5; // +5 for "XXXX "
                    return {
                        html: isLong ? hex16(addr) : `${hex16(addr)} <span class="label-name">${label.name}</span>`,
                        isLong,
                        labelHtml: isLong ? `<span class="label-name">${label.name}:</span>` : null
                    };
                }
                default:
                    return { html: hex16(addr), isLong: false, labelHtml: null };
            }
        }

        // Apply operand format to mnemonic based on instruction address
        function applyOperandFormat(mnemonic, instrAddr) {
            const format = operandFormatManager.get(instrAddr);
            if (format === OPERAND_FORMATS.HEX) {
                return mnemonic; // Default format, no change
            }

            // Replace 16-bit hex values first (4 digits), then 8-bit (2 digits)
            // Match 4-digit hex addresses (e.g., 1234h)
            let result = mnemonic.replace(/\b([0-9A-F]{4})h\b/gi, (match, hexVal) => {
                const val = parseInt(hexVal, 16);
                return operandFormatManager.formatValue(val, format, true);
            });

            // Match 2-digit hex values (e.g., FFh) but not in addresses we already converted
            result = result.replace(/\b([0-9A-F]{2})h\b/gi, (match, hexVal) => {
                const val = parseInt(hexVal, 16);
                return operandFormatManager.formatValue(val, format, false);
            });

            return result;
        }

        // Replace addresses in mnemonic with labels and make them clickable
        function replaceMnemonicAddresses(mnemonic, mode, instrAddr) {
            // First apply operand format if set
            let processed = applyOperandFormat(mnemonic, instrAddr);

            // Match 4-digit hex addresses (e.g., 1234h or 0010h)
            processed = processed.replace(/\b([0-9A-F]{4})h\b/gi, (match, hexAddr) => {
                const addr = parseInt(hexAddr, 16);
                const label = labelManager.get(addr);

                if (mode === 'addr' || !label) {
                    // No label mode or no label - show address as clickable
                    return `<span class="disasm-operand-addr" data-addr="${addr}">${match}</span>`;
                }

                // Label mode - show label as clickable
                return `<span class="disasm-label-operand disasm-operand-addr" data-addr="${addr}">${label.name}</span>`;
            });

            // Also make decimal addresses clickable (for dec format)
            // Match standalone numbers that could be addresses (4-5 digits, likely to be 256-65535)
            processed = processed.replace(/\b(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[0-9]{1,4})\b/g, (match, num) => {
                const addr = parseInt(num, 10);
                // Only make clickable if it's a reasonable address (not a small immediate)
                // and the format is decimal
                const format = operandFormatManager.get(instrAddr);
                if (format === OPERAND_FORMATS.DEC && addr >= 256) {
                    const label = labelManager.get(addr);
                    if (mode !== 'addr' && label) {
                        return `<span class="disasm-label-operand disasm-operand-addr" data-addr="${addr}">${label.name}</span>`;
                    }
                    return `<span class="disasm-operand-addr" data-addr="${addr}">${match}</span>`;
                }
                return match;
            });

            return processed;
        }

        // Debugger control buttons
        const btnStepInto = document.getElementById('btnStepInto');
        const btnStepOver = document.getElementById('btnStepOver');
        const btnRunTo = document.getElementById('btnRunTo');
        const btnRunToInt = document.getElementById('btnRunToInt');
        const btnRunToRet = document.getElementById('btnRunToRet');
        const btnRunTstates = document.getElementById('btnRunTstates');
        const tstatesInput = document.getElementById('tstatesInput');
        
        let disasm = null;
        let runToTarget = null; // For Run to Cursor
        
        // Check if in landscape mode (side-by-side layout)
        function isLandscapeMode() {
            return window.innerWidth >= 1400;
        }

        // Check if debugger panel is visible
        function isDebuggerVisible() {
            return debuggerPanel.classList.contains('open') || isLandscapeMode();
        }

        // Auto-expand tabs in landscape mode
        function checkLandscapeMode() {
            if (isLandscapeMode() && tabContainer.classList.contains('collapsed')) {
                tabContainer.classList.remove('collapsed');
            }
        }

        // Check on page load and resize
        checkLandscapeMode();
        window.addEventListener('resize', checkLandscapeMode);

        
        function hex8(val) {
            return (val & 0xff).toString(16).toUpperCase().padStart(2, '0');
        }
        
        function hex16(val) {
            return (val & 0xffff).toString(16).toUpperCase().padStart(4, '0');
        }
        
        function createRegisterItem(name, value, editable = null, bits = 16) {
            const editClass = editable ? ' editable' : '';
            const dataAttr = editable ? ` data-reg="${editable}" data-bits="${bits}"` : '';
            return `<div class="register-item"><span class="register-name">${name}</span><br><span class="register-value${editClass}"${dataAttr}>${value}</span></div>`;
        }

        // Generate disassembly lines with region support
        // Returns array of {addr, bytes, mnemonic, isData}
        function disassembleWithRegions(startAddr, numLines) {
            if (!disasm || !spectrum.memory) return [];

            const lines = [];
            let addr = startAddr & 0xffff;

            while (lines.length < numLines && addr <= 0xffff) {
                const region = regionManager.get(addr);
                const lineAddr = addr;

                if (!region || region.type === REGION_TYPES.CODE || region.type === REGION_TYPES.SMC) {
                    // Normal disassembly
                    const instr = disasm.disassemble(addr);
                    lines.push({
                        addr: addr,
                        bytes: instr.bytes,
                        mnemonic: instr.mnemonic,
                        isData: false
                    });
                    addr = (addr + instr.bytes.length) & 0xffff;
                } else if (region.type === REGION_TYPES.TEXT) {
                    // Text region using helper
                    const result = parseTextRegion(spectrum.memory, addr, region.end);
                    if (result.singleByte) {
                        lines.push({
                            addr: lineAddr,
                            bytes: result.bytes,
                            mnemonic: `DB $${hex8(result.bytes[0])}`,
                            isData: true
                        });
                    } else if (result.text.length > 0) {
                        const suffix = result.bit7Terminated ? '+$80' : '';
                        lines.push({
                            addr: lineAddr,
                            bytes: result.bytes,
                            mnemonic: `DB "${result.text}"${suffix}`,
                            isData: true
                        });
                    }
                    addr = result.nextAddr & 0xffff;
                } else if (region.type === REGION_TYPES.DW) {
                    // Word data using helper
                    const result = parseWordRegion(spectrum.memory, addr, region.end);
                    if (result.wordStrs.length > 0) {
                        lines.push({
                            addr: lineAddr,
                            bytes: result.bytes,
                            mnemonic: `DW ${result.wordStrs.join(', ')}`,
                            isData: true
                        });
                    }
                    addr = result.nextAddr & 0xffff;
                } else if (region.type === REGION_TYPES.DB || region.type === REGION_TYPES.GRAPHICS) {
                    // Byte data using helper
                    const result = parseByteRegion(spectrum.memory, addr, region.end);
                    if (result.byteStrs.length > 0) {
                        lines.push({
                            addr: lineAddr,
                            bytes: result.bytes,
                            mnemonic: `DB ${result.byteStrs.join(', ')}`,
                            isData: true
                        });
                    }
                    addr = result.nextAddr & 0xffff;
                } else {
                    // Unknown region type - fallback to normal disassembly
                    const instr = disasm.disassemble(addr);
                    lines.push({
                        addr: addr,
                        bytes: instr.bytes,
                        mnemonic: instr.mnemonic,
                        isData: false
                    });
                    addr = (addr + instr.bytes.length) & 0xffff;
                }

                // Safety check for infinite loops
                if (lines.length > 1000) break;
            }

            return lines;
        }

        function updateDebugger() {
            if (!spectrum.cpu) return;
            if (isEditingRegister) return; // Don't update while editing
            const cpu = spectrum.cpu;

            // Check if viewing trace history
            const tracePos = traceManager.getCurrentPosition();
            const traceEntry = tracePos >= 0 ? traceManager.getEntry(tracePos) : null;

            // Use trace entry values if viewing history, otherwise use current CPU state
            const regAF = traceEntry ? traceEntry.af : cpu.af;
            const regBC = traceEntry ? traceEntry.bc : cpu.bc;
            const regDE = traceEntry ? traceEntry.de : cpu.de;
            const regHL = traceEntry ? traceEntry.hl : cpu.hl;
            const regIX = traceEntry ? traceEntry.ix : cpu.ix;
            const regIY = traceEntry ? traceEntry.iy : cpu.iy;
            const regSP = traceEntry ? traceEntry.sp : cpu.sp;
            const regPC = traceEntry ? traceEntry.pc : cpu.pc;
            const regI = traceEntry ? traceEntry.i : cpu.i;
            const regR = traceEntry ? traceEntry.r : cpu.rFull;
            const regIM = traceEntry ? traceEntry.im : cpu.im;
            const regIFF1 = traceEntry ? traceEntry.iff1 : cpu.iff1;
            const regIFF2 = traceEntry ? traceEntry.iff2 : cpu.iff2;
            const regTstates = traceEntry ? traceEntry.tStates : cpu.tStates;
            const regAF_ = traceEntry ? traceEntry.af_ : (cpu.a_ << 8) | cpu.f_;
            const regBC_ = traceEntry ? traceEntry.bc_ : (cpu.b_ << 8) | cpu.c_;
            const regDE_ = traceEntry ? traceEntry.de_ : (cpu.d_ << 8) | cpu.e_;
            const regHL_ = traceEntry ? traceEntry.hl_ : (cpu.h_ << 8) | cpu.l_;

            // Main registers (editable when not viewing trace history)
            const canEdit = !traceEntry;
            mainRegisters.innerHTML =
                createRegisterItem('AF', hex16(regAF), canEdit ? 'af' : null) +
                createRegisterItem('BC', hex16(regBC), canEdit ? 'bc' : null) +
                createRegisterItem('DE', hex16(regDE), canEdit ? 'de' : null) +
                createRegisterItem('HL', hex16(regHL), canEdit ? 'hl' : null);

            // Alternate registers
            altRegisters.innerHTML =
                createRegisterItem("AF'", hex16(regAF_), canEdit ? 'af_' : null) +
                createRegisterItem("BC'", hex16(regBC_), canEdit ? 'bc_' : null) +
                createRegisterItem("DE'", hex16(regDE_), canEdit ? 'de_' : null) +
                createRegisterItem("HL'", hex16(regHL_), canEdit ? 'hl_' : null);

            // IX, IY and swap buttons in same row
            ixiyRegisters.innerHTML =
                createRegisterItem('IX', hex16(regIX), canEdit ? 'ix' : null) +
                createRegisterItem('IY', hex16(regIY), canEdit ? 'iy' : null) +
                `<button class="reg-swap-btn" id="btnEXA" title="EX AF,AF'">exa</button>` +
                `<button class="reg-swap-btn" id="btnEXX" title="EXX">exx</button>`;

            // Index registers
            indexRegisters.innerHTML =
                createRegisterItem('SP', hex16(regSP), canEdit ? 'sp' : null) +
                createRegisterItem('PC', hex16(regPC), canEdit ? 'pc' : null) +
                createRegisterItem('T-st', regTstates.toString(), canEdit ? 'tstates' : null, 17);

            // Flags (clickable to toggle when not viewing trace)
            const f = regAF & 0xFF;
            const flags = [
                { name: 'S', bit: 0x80, desc: 'Sign' },
                { name: 'Z', bit: 0x40, desc: 'Zero' },
                { name: 'y', bit: 0x20, desc: 'Undocumented (bit 5)' },
                { name: 'H', bit: 0x10, desc: 'Half Carry' },
                { name: 'x', bit: 0x08, desc: 'Undocumented (bit 3)' },
                { name: 'P/V', bit: 0x04, desc: 'Parity/Overflow' },
                { name: 'N', bit: 0x02, desc: 'Subtract' },
                { name: 'C', bit: 0x01, desc: 'Carry' }
            ];
            flagsDisplay.innerHTML = flags.map(flag =>
                `<div class="flag-item ${(f & flag.bit) ? 'set' : ''}${canEdit ? ' editable' : ''}" title="${flag.desc} (click to toggle)" data-bit="${flag.bit}">${flag.name}</div>`
            ).join('');

            // Status registers (including T-states)
            statusRegisters.innerHTML =
                createRegisterItem('I', hex8(regI), canEdit ? 'i' : null, 8) +
                createRegisterItem('R', hex8(regR), canEdit ? 'r' : null, 8) +
                createRegisterItem('IM', regIM.toString(), canEdit ? 'im' : null, 2) +
                createRegisterItem('IFF', (regIFF1 ? '1' : '0') + '/' + (regIFF2 ? '1' : '0'), canEdit ? 'iff' : null, 2);

            // Paging info (128K/Pentagon only)
            if (spectrum.memory.machineType !== '48k') {
                pagesGroup.style.display = '';
                const paging = spectrum.memory.getPagingState();
                const screenNum = paging.screenBank === 5 ? '0' : '1';
                pagesInfo.innerHTML =
                    createRegisterItem('C000', paging.ramBank.toString(), canEdit ? 'rambank' : null, 3) +
                    createRegisterItem('Scr', screenNum, canEdit ? 'scrbank' : null, 1) +
                    createRegisterItem('ROM', paging.romBank.toString(), canEdit ? 'rombank' : null, 1) +
                    (paging.pagingDisabled ? createRegisterItem('Lock', '1', canEdit ? 'paginglock' : null, 1) : '');
            } else {
                pagesGroup.style.display = 'none';
            }

            // Disassembly view
            if (!disasm) {
                disasm = new Disassembler(spectrum.memory);
            }
            
            const pc = cpu.pc;
            let viewAddr;
            const chkFollowPC = document.getElementById('chkFollowPC');

            if (chkFollowPC.checked) {
                // Follow PC - show PC at position from top
                viewAddr = disasm.findStartForPosition(pc, DISASM_PC_POSITION, DISASM_LINES);
                disasmViewAddress = null;
            } else if (disasmViewAddress !== null) {
                // Follow is off, use stored address
                viewAddr = disasmViewAddress;
            } else {
                // Follow is off but no address set - stay at current PC, store it
                viewAddr = disasm.findStartForPosition(pc, DISASM_PC_POSITION, DISASM_LINES);
                disasmViewAddress = viewAddr;
            }
            
            const lines = disassembleWithRegions(viewAddr, DISASM_LINES);
            
            // Store last line address for page down
            if (lines.length > 0) {
                disasmLastLineAddr = lines[lines.length - 1].addr;
            }
            
            const showTstates = chkShowTstates.checked;
            const labelMode = labelDisplayMode.value;

            disassemblyView.innerHTML = lines.map((line, idx) => {
                const bytesStr = line.bytes.map(b => hex8(b)).join(' ');
                const isCurrent = line.addr === pc;
                const isTrace = traceViewAddress !== null && line.addr === traceViewAddress;
                const hasBp = spectrum.hasBreakpoint(line.addr);
                const classes = ['disasm-line'];
                if (isCurrent) classes.push('current');
                if (isTrace) classes.push('trace');
                if (hasBp) classes.push('breakpoint');
                if (line.isData) classes.push('data-line');

                // Add spacing after flow control instructions
                const mnemUpper = line.mnemonic.toUpperCase();
                if (mnemUpper.startsWith('CALL') || mnemUpper.startsWith('JP') ||
                    mnemUpper.startsWith('JR') || mnemUpper.startsWith('RST') ||
                    mnemUpper.startsWith('RET') || mnemUpper.startsWith('RETI') ||
                    mnemUpper.startsWith('RETN') || mnemUpper === 'DJNZ' ||
                    mnemUpper === 'HALT') {
                    classes.push('flow-break');
                }

                // Don't show T-states for data lines
                const timing = (showTstates && !line.isData) ? disasm.getTiming(line.bytes) : '';
                const timingHtml = timing ? `<span class="disasm-tstates">${timing}</span>` : '';

                // Apply label formatting to address and mnemonic (not for data lines)
                const addrInfo = formatAddrColumn(line.addr, labelMode);
                const mnemonicWithLabels = line.isData ? line.mnemonic : replaceMnemonicAddresses(line.mnemonic, labelMode, line.addr);

                // Region type indicator
                const region = regionManager.get(line.addr);
                let regionMarker = '';
                if (region && region.type !== REGION_TYPES.CODE) {
                    const markers = {
                        [REGION_TYPES.DB]: 'B',
                        [REGION_TYPES.DW]: 'W',
                        [REGION_TYPES.TEXT]: 'T',
                        [REGION_TYPES.GRAPHICS]: 'G',
                        [REGION_TYPES.SMC]: 'S'
                    };
                    const marker = markers[region.type] || '?';
                    regionMarker = `<span class="disasm-region region-type-${region.type}" title="${region.type.toUpperCase()}${region.comment ? ': ' + region.comment : ''}">${marker}</span>`;
                }

                // Get comments for this address
                const comment = commentManager.get(line.addr);
                let beforeHtml = '';
                let inlineHtml = '';
                let afterHtml = '';

                if (comment) {
                    // Separator line
                    if (comment.separator) {
                        beforeHtml += `<span class="disasm-separator">; ----------</span>`;
                    }
                    // Before comments (each line prefixed with ;)
                    if (comment.before) {
                        const beforeLines = comment.before.split('\n').map(l => `; ${l}`).join('\n');
                        beforeHtml += `<span class="disasm-comment-line">${escapeHtml(beforeLines)}</span>`;
                    }
                    // Inline comment
                    if (comment.inline) {
                        inlineHtml = `<span class="disasm-inline-comment">; ${escapeHtml(comment.inline)}</span>`;
                    }
                    // After comments
                    if (comment.after) {
                        const afterLines = comment.after.split('\n').map(l => `; ${l}`).join('\n');
                        afterHtml = `<span class="disasm-comment-line">${escapeHtml(afterLines)}</span>`;
                    }
                }

                if (addrInfo.isLong) {
                    classes.push('has-long-label');
                    return `${beforeHtml}<div class="${classes.join(' ')}" data-addr="${line.addr}">
                        <div class="disasm-label-row">${addrInfo.labelHtml}</div>
                        <span class="disasm-bp ${hasBp ? 'active' : ''}" data-addr="${line.addr}" title="Toggle breakpoint">•</span>
                        ${regionMarker}
                        <span class="disasm-addr">${addrInfo.html}</span>
                        <span class="disasm-bytes">${bytesStr}</span>
                        ${timingHtml}
                        <span class="disasm-mnemonic">${formatMnemonic(mnemonicWithLabels)}</span>${inlineHtml}
                    </div>${afterHtml}`;
                }

                return `${beforeHtml}<div class="${classes.join(' ')}" data-addr="${line.addr}">
                    <span class="disasm-bp ${hasBp ? 'active' : ''}" data-addr="${line.addr}" title="Toggle breakpoint">•</span>
                    ${regionMarker}
                    <span class="disasm-addr">${addrInfo.html}</span>
                    <span class="disasm-bytes">${bytesStr}</span>
                    ${timingHtml}
                    <span class="disasm-mnemonic">${formatMnemonic(mnemonicWithLabels)}</span>${inlineHtml}
                </div>${afterHtml}`;
            }).join('');
            
            // Update breakpoint list
            updateBreakpointList();
            
            // Update watchpoint list
            updateWatchpointList();
            
            // Update port breakpoint list
            updatePortBreakpointList();

            // Update labels list
            updateLabelsList();

            // Update memory view
            updateMemoryView();

            // Update stack view
            updateStackView();

            // Update trace status (functions defined later, check existence)
            if (typeof window.updateTraceStatus === 'function') {
                window.updateTraceStatus();
                window.updateTraceList();
            }

            // Update watches (function defined later, check existence)
            if (typeof updateWatchValues === 'function') {
                updateWatchValues();
            }
        }
        
        // Stack view state
        let previousSP = null;
        let previousStackValues = {};
        
        function updateStackView() {
            if (!spectrum.cpu) {
                stackView.innerHTML = '<div class="stack-entry">No CPU</div>';
                return;
            }

            // Check if viewing trace history - use historical SP
            const tracePos = traceManager.getCurrentPosition();
            const traceEntry = tracePos >= 0 ? traceManager.getEntry(tracePos) : null;
            const sp = traceEntry ? traceEntry.sp : spectrum.cpu.sp;
            const spChanged = previousSP !== null && previousSP !== sp;
            
            let html = '';
            // Show 3 entries before SP, SP itself, and 3 entries after
            for (let offset = -6; offset <= 6; offset += 2) {
                const addr = (sp + offset) & 0xffff;
                const lo = spectrum.memory.read(addr);
                const hi = spectrum.memory.read((addr + 1) & 0xffff);
                const value = lo | (hi << 8);
                
                const isCurrent = offset === 0;
                const valueKey = addr.toString();
                const valueChanged = previousStackValues[valueKey] !== undefined && 
                                    previousStackValues[valueKey] !== value;
                
                let classes = 'stack-entry';
                if (isCurrent) classes += ' current';
                if (valueChanged && !spChanged) classes += ' changed';
                
                const pointer = isCurrent ? '<span class="stack-pointer">◄</span>' : '';
                
                html += `<div class="${classes}" data-addr="${addr}" data-value="${value}">` +
                        `<span class="stack-addr">${hex16(addr)}</span>` +
                        `<span class="stack-value">${hex16(value)}</span>` +
                        `${pointer}</div>`;
                
                previousStackValues[valueKey] = value;
            }
            
            stackView.innerHTML = html;
            previousSP = sp;
        }
        
        // Stack view context menu
        let stackContextMenu = null;
        
        stackView.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            const entry = e.target.closest('.stack-entry');
            if (!entry) return;
            
            const addr = parseInt(entry.dataset.addr, 10);
            const value = parseInt(entry.dataset.value, 10);
            
            // Remove existing menu
            if (stackContextMenu) {
                stackContextMenu.remove();
            }
            
            stackContextMenu = document.createElement('div');
            stackContextMenu.className = 'stack-context-menu';
            stackContextMenu.innerHTML = `
                <div data-action="disasm-addr">Disassembly → ${hex16(addr)}</div>
                <div data-action="disasm-value">Disassembly → ${hex16(value)}</div>
                <div data-action="memory-addr">Memory → ${hex16(addr)}</div>
                <div data-action="memory-value">Memory → ${hex16(value)}</div>
            `;
            stackContextMenu.style.left = e.clientX + 'px';
            stackContextMenu.style.top = e.clientY + 'px';
            document.body.appendChild(stackContextMenu);
            
            stackContextMenu.addEventListener('click', (ev) => {
                const action = ev.target.dataset.action;
                if (action === 'disasm-addr') {
                    disasmViewAddress = addr;
                    updateDebugger();
                } else if (action === 'disasm-value') {
                    disasmViewAddress = value;
                    updateDebugger();
                } else if (action === 'memory-addr') {
                    goToMemoryAddress(addr);
                } else if (action === 'memory-value') {
                    goToMemoryAddress(value);
                }
                stackContextMenu.remove();
                stackContextMenu = null;
            });
        });
        
        // Close context menu on click elsewhere
        document.addEventListener('click', (e) => {
            if (stackContextMenu && !stackContextMenu.contains(e.target)) {
                stackContextMenu.remove();
                stackContextMenu = null;
            }
        });
        
        function updateTriggerList() {
            const triggers = spectrum.getTriggers();
            if (triggers.length === 0) {
                triggerList.innerHTML = '<div class="no-breakpoints">No breakpoints</div>';
            } else {
                triggerList.innerHTML = triggers.map(t => {
                    const icon = spectrum.getTriggerIcon(t.type);
                    const label = spectrum.getTriggerLabel(t.type);
                    const desc = spectrum.formatTrigger(t);
                    const disabledClass = t.enabled ? '' : ' disabled';
                    const iconClass = t.type.startsWith('port') ? 'port' : t.type;
                    const skipInfo = t.skipCount > 0 ? ` <span class="trigger-skip" title="Hit ${t.hitCount}/${t.skipCount + 1}">[${t.hitCount}/${t.skipCount + 1}]</span>` : '';
                    return `<div class="trigger-item${disabledClass}" data-index="${t.index}">
                        <span class="trigger-icon ${iconClass}" title="${label}">${icon}</span>
                        <span class="trigger-desc" data-index="${t.index}">${desc}${skipInfo}</span>
                        <span class="trigger-toggle" data-index="${t.index}" title="${t.enabled ? 'Disable' : 'Enable'}">⏻</span>
                        <span class="trigger-remove" data-index="${t.index}" title="Remove">×</span>
                    </div>`;
                }).join('');
            }
        }

        // Legacy function names for compatibility
        function updateBreakpointList() { updateTriggerList(); }
        function updateWatchpointList() { updateTriggerList(); }
        function updatePortBreakpointList() { updateTriggerList(); }

        function updateLabelsList() {
            const filter = labelFilterInput.value.toLowerCase().trim();

            // Get user labels
            const userLabels = labelManager.getAll().map(l => ({ ...l, isRom: false }));

            // Get ROM labels if enabled
            let romLabels = [];
            if (labelManager.showRomLabels) {
                for (const label of labelManager.romLabels.values()) {
                    // Don't show ROM label if user has a label at same address
                    if (!labelManager.labels.has(labelManager._key(label.address, label.page))) {
                        romLabels.push({ ...label, isRom: true });
                    }
                }
            }

            // Combine and sort
            const allLabels = [...userLabels, ...romLabels].sort((a, b) => a.address - b.address);

            // Filter
            const labels = filter
                ? allLabels.filter(l => l.name.toLowerCase().includes(filter) ||
                                        (l.comment && l.comment.toLowerCase().includes(filter)))
                : allLabels;

            if (labels.length === 0) {
                labelsList.innerHTML = filter
                    ? '<div class="no-breakpoints">No matching labels</div>'
                    : '<div class="no-breakpoints">No labels</div>';
                return;
            }

            labelsList.innerHTML = labels.map(label => {
                const addrStr = label.page !== null ? `${label.page}:${hex16(label.address)}` : hex16(label.address);
                const commentHtml = label.comment ? `<span class="label-comment">${escapeHtml(label.comment)}</span>` : '';
                const itemClass = label.isRom ? 'label-item rom-label' : 'label-item';
                const actionsHtml = label.isRom ? '' : `
                    <div class="label-actions">
                        <button class="label-btn label-edit" data-addr="${label.address}" data-page="${label.page}" title="Edit">✎</button>
                        <button class="label-btn label-remove" data-addr="${label.address}" data-page="${label.page}" title="Remove">×</button>
                    </div>`;
                return `<div class="${itemClass}" data-addr="${label.address}" data-page="${label.page}">
                    <div class="label-info">
                        <span class="label-addr">${addrStr}</span>
                        <span class="label-item-name">${escapeHtml(label.name)}</span>
                        ${commentHtml}
                    </div>
                    ${actionsHtml}
                </div>`;
            }).join('');
        }

        function escapeHtml(str) {
            return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
        }

        function downloadFile(filename, content) {
            const blob = new Blob([content], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        function updateMemoryView() {
            if (!spectrum.memory || memoryEditingAddr !== null) return;

            let html = '';
            for (let line = 0; line < MEMORY_LINES; line++) {
                const lineAddr = (memoryViewAddress + line * BYTES_PER_LINE) & 0xffff;

                // Address
                html += `<div class="memory-line"><span class="memory-addr">${hex16(lineAddr)}</span>`;

                // Hex bytes
                html += '<span class="memory-hex">';
                for (let i = 0; i < BYTES_PER_LINE; i++) {
                    const addr = (lineAddr + i) & 0xffff;
                    const byte = spectrum.memory.read(addr);
                    const changed = memorySnapshot && memorySnapshot[addr] !== byte;
                    let cls = changed ? 'memory-byte changed' : 'memory-byte';
                    // Check for breakpoints
                    if (spectrum.hasBreakpointAt(addr)) {
                        cls += ' has-bp';
                    }
                    // Check for watchpoints
                    const wps = spectrum.getWatchpoints();
                    for (const wp of wps) {
                        if (addr >= wp.start && addr <= wp.end) {
                            if (wp.read && wp.write) cls += ' has-wp';
                            else if (wp.read) cls += ' has-wp-r';
                            else if (wp.write) cls += ' has-wp-w';
                            break;
                        }
                    }
                    // Check for memory regions
                    const region = regionManager.get(addr);
                    if (region && region.type !== REGION_TYPES.CODE) {
                        cls += ` region-${region.type}`;
                    }
                    const lowByte = byte & 0x7F;
                    const isPrintableLow = lowByte >= 32 && lowByte < 127;
                    let asciiChar = '';
                    if (byte >= 32 && byte < 127) {
                        asciiChar = ` '${String.fromCharCode(byte)}'`;
                    } else if ((byte & 0x80) && isPrintableLow) {
                        asciiChar = ` '${String.fromCharCode(lowByte)}'+$80`;
                    }
                    let tip = `Addr: ${hex16(addr)} (${addr})\nValue: ${hex8(byte)} (${byte})${asciiChar}`;
                    if (region && region.type !== REGION_TYPES.CODE) {
                        tip += `\nRegion: ${region.type}${region.comment ? ' - ' + region.comment : ''}`;
                    }
                    // Add disassembly
                    const instr = disasm.disassemble(addr);
                    const bytes = instr.bytes.map(b => hex8(b)).join(' ');
                    tip += `\n${instr.mnemonic} [${bytes}]`;
                    html += `<span class="${cls}" data-addr="${addr}" title="${tip}">${hex8(byte)}</span>`;
                }
                html += '</span>';

                // ASCII representation
                html += '<span class="memory-ascii">';
                for (let i = 0; i < BYTES_PER_LINE; i++) {
                    const addr = (lineAddr + i) & 0xffff;
                    const byte = spectrum.memory.read(addr);
                    const isPrintable = byte >= 32 && byte < 127;
                    const char = isPrintable ? String.fromCharCode(byte) : '.';
                    const changed = memorySnapshot && memorySnapshot[addr] !== byte;
                    const asciiRegion = regionManager.get(addr);
                    let cls = isPrintable ? 'printable' : '';
                    if (changed) cls += ' changed';
                    if (asciiRegion && asciiRegion.type === REGION_TYPES.TEXT) {
                        cls += ' region-text';
                    }
                    html += `<span class="${cls.trim()}">${char}</span>`;
                }
                html += '</span></div>';
            }

            memoryView.innerHTML = html;

            // Reapply selection if active
            if (memSelectionStart !== null) {
                updateMemSelection();
            }
        }
        
        function goToMemoryAddress(addr) {
            memoryViewAddress = addr & 0xffff;
            memoryAddressInput.value = hex16(memoryViewAddress);
            updateMemoryView();
        }

        function goToAddressNoHistory(addr) {
            // Navigate disasm without adding to history
            addr = addr & 0xffff;
            if (disasm) {
                disasmViewAddress = disasm.findStartForPosition(addr, DISASM_PC_POSITION, DISASM_LINES);
            } else {
                disasmViewAddress = addr;
            }
            disasmAddressInput.value = hex16(addr);
            updateDebugger();
        }

        function goToAddress(addr) {
            // Navigate disasm to show addr at DISASM_PC_POSITION (3 lines from top)
            addr = addr & 0xffff;
            // If history is empty, save current position first so user can go back
            if (navHistory.length === 0) {
                const currentInput = disasmAddressInput.value;
                if (currentInput) {
                    const currentAddr = parseInt(currentInput, 16);
                    if (!isNaN(currentAddr)) {
                        navPushHistory(currentAddr);
                    }
                } else if (disasmViewAddress !== null) {
                    navPushHistory(disasmViewAddress);
                } else if (spectrum && spectrum.cpu) {
                    navPushHistory(spectrum.cpu.pc);
                }
            }
            navPushHistory(addr);
            if (disasm) {
                disasmViewAddress = disasm.findStartForPosition(addr, DISASM_PC_POSITION, DISASM_LINES);
            } else {
                disasmViewAddress = addr;
            }
            disasmAddressInput.value = hex16(addr);
        }

        let activeEditInput = null;
        
        function finishCurrentEdit(save = true) {
            if (activeEditInput && memoryEditingAddr !== null) {
                if (save) {
                    const newValue = parseInt(activeEditInput.value, 16);
                    if (!isNaN(newValue) && newValue >= 0 && newValue <= 255) {
                        spectrum.memory.writeDebug(memoryEditingAddr, newValue);
                    }
                }
                activeEditInput = null;
                memoryEditingAddr = null;
                updateDebugger(); // Refresh both memory and disassembly
            }
        }
        
        function startByteEdit(byteElement) {
            // Finish any current edit first
            finishCurrentEdit(true);
            
            const addr = parseInt(byteElement.dataset.addr);
            memoryEditingAddr = addr;
            const currentValue = spectrum.memory.read(addr);
            
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'memory-edit-input';
            input.value = hex8(currentValue);
            input.maxLength = 2;
            activeEditInput = input;
            
            byteElement.textContent = '';
            byteElement.appendChild(input);
            
            // Use setTimeout to ensure focus happens after DOM update
            setTimeout(() => {
                input.focus();
                input.select();
            }, 0);
            
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    finishCurrentEdit(true);
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    finishCurrentEdit(false);
                } else if (e.key === 'Tab') {
                    e.preventDefault();
                    const nextAddr = e.shiftKey ? (addr - 1) & 0xffff : (addr + 1) & 0xffff;
                    finishCurrentEdit(true);
                    setTimeout(() => {
                        const nextByte = memoryView.querySelector(`[data-addr="${nextAddr}"]`);
                        if (nextByte) startByteEdit(nextByte);
                    }, 0);
                }
            });
        }
        
        // Memory view event handlers - use mousedown for immediate response
        // Memory selection state
        let memSelectionStart = null;
        let memSelectionEnd = null;
        let memIsSelecting = false;

        function clearMemSelection() {
            memSelectionStart = null;
            memSelectionEnd = null;
            memIsSelecting = false;
            memoryView.querySelectorAll('.memory-byte.selected').forEach(el => {
                el.classList.remove('selected');
            });
        }

        function updateMemSelection() {
            if (memSelectionStart === null) return;

            const start = Math.min(memSelectionStart, memSelectionEnd ?? memSelectionStart);
            const end = Math.max(memSelectionStart, memSelectionEnd ?? memSelectionStart);

            memoryView.querySelectorAll('.memory-byte').forEach(el => {
                const addr = parseInt(el.dataset.addr, 10);
                if (addr >= start && addr <= end) {
                    el.classList.add('selected');
                } else {
                    el.classList.remove('selected');
                }
            });
        }

        memoryView.addEventListener('mousedown', (e) => {
            const byteEl = e.target.closest('.memory-byte');
            if (byteEl && !e.target.classList.contains('memory-edit-input')) {
                // Right-click: don't start selection, let context menu handle it
                if (e.button === 2) return;

                // Left-click: start selection or edit on double-click
                if (e.button === 0) {
                    e.preventDefault();
                    const addr = parseInt(byteEl.dataset.addr, 10);

                    // Start selection
                    memSelectionStart = addr;
                    memSelectionEnd = addr;
                    memIsSelecting = true;
                    updateMemSelection();
                }
            }
        });

        memoryView.addEventListener('mousemove', (e) => {
            if (!memIsSelecting) return;

            const byteEl = e.target.closest('.memory-byte');
            if (byteEl) {
                const addr = parseInt(byteEl.dataset.addr, 10);
                memSelectionEnd = addr;
                updateMemSelection();
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (memIsSelecting) {
                memIsSelecting = false;
                // If single click (no drag), treat as edit
                if (memSelectionStart === memSelectionEnd && e.button === 0) {
                    const byteEl = memoryView.querySelector(`[data-addr="${memSelectionStart}"]`);
                    if (byteEl && !e.target.classList.contains('memory-edit-input')) {
                        clearMemSelection();
                        startByteEdit(byteEl);
                    }
                }
            }
        });

        // Memory view context menu
        let memContextMenu = null;
        function closeMemContextMenu() {
            if (memContextMenu) {
                memContextMenu.remove();
                memContextMenu = null;
            }
        }

        memoryView.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            closeMemContextMenu();

            const byteEl = e.target.closest('.memory-byte');
            if (!byteEl) return;

            const clickedAddr = parseInt(byteEl.dataset.addr, 10);

            // Determine selection range
            let hasSelection = memSelectionStart !== null && memSelectionEnd !== null &&
                               memSelectionStart !== memSelectionEnd;
            let selStart, selEnd;

            if (hasSelection) {
                selStart = Math.min(memSelectionStart, memSelectionEnd);
                selEnd = Math.max(memSelectionStart, memSelectionEnd);
                // Check if right-clicked inside selection
                if (clickedAddr < selStart || clickedAddr > selEnd) {
                    // Clicked outside selection, use single address
                    hasSelection = false;
                }
            }

            const addr = hasSelection ? selStart : clickedAddr;
            const endAddr = hasSelection ? selEnd : null;
            const existingLabel = labelManager.get(addr);
            const existingRegion = regionManager.get(addr);

            memContextMenu = document.createElement('div');
            memContextMenu.className = 'label-context-menu';

            let menuHtml = `<div data-action="goto">Go to ${hex16(addr)}</div>`;
            menuHtml += `<div data-action="disasm">Disasm at ${hex16(addr)}</div>`;
            if (existingLabel) {
                menuHtml += `<div data-action="edit-label">Edit Label "${existingLabel.name}"</div>`;
                menuHtml += `<div data-action="delete-label" class="danger">Delete Label</div>`;
            } else {
                menuHtml += `<div data-action="add-label">Add Label</div>`;
            }
            menuHtml += `<div class="menu-separator"></div>`;

            // Show selection range or single address
            const rangeText = hasSelection ?
                `${hex16(selStart)}-${hex16(selEnd)} (${selEnd - selStart + 1} bytes)` :
                `from ${hex16(addr)}`;
            menuHtml += `<div class="menu-submenu">Mark ${rangeText} as...
                <div class="menu-submenu-items">
                    <div data-action="mark-code">Code</div>
                    <div data-action="mark-db">DB (bytes)</div>
                    <div data-action="mark-dw">DW (words)</div>
                    <div data-action="mark-text">Text (ASCII)</div>
                    <div data-action="mark-gfx">Graphics</div>
                    <div data-action="mark-smc">SMC (self-mod)</div>
                </div>
            </div>`;
            if (existingRegion) {
                menuHtml += `<div data-action="remove-region" class="danger">Remove region mark</div>`;
            }
            memContextMenu.innerHTML = menuHtml;

            memContextMenu.style.left = e.clientX + 'px';
            memContextMenu.style.top = e.clientY + 'px';
            document.body.appendChild(memContextMenu);

            // Adjust submenu position if it would overflow viewport
            const submenu = memContextMenu.querySelector('.menu-submenu');
            if (submenu) {
                const menuRect = memContextMenu.getBoundingClientRect();
                const submenuItems = submenu.querySelector('.menu-submenu-items');
                if (submenuItems) {
                    // Temporarily show to measure
                    submenuItems.style.display = 'block';
                    const subRect = submenuItems.getBoundingClientRect();
                    submenuItems.style.display = '';

                    // Check horizontal overflow
                    if (menuRect.right + subRect.width > window.innerWidth) {
                        submenu.classList.add('submenu-left');
                    }
                    // Check vertical overflow
                    if (menuRect.top + subRect.height > window.innerHeight) {
                        submenu.classList.add('submenu-up');
                    }
                }
            }

            memContextMenu.addEventListener('click', (menuE) => {
                const action = menuE.target.dataset.action;
                if (action === 'goto') {
                    goToMemoryAddress(addr);
                } else if (action === 'disasm') {
                    goToAddress(addr);
                    updateDebugger();
                } else if (action === 'add-label') {
                    showLabelDialog(addr);
                } else if (action === 'edit-label') {
                    showLabelDialog(addr, existingLabel);
                } else if (action === 'delete-label') {
                    const oldLabel = existingLabel;
                    labelManager.remove(addr);
                    undoManager.push({
                        type: 'label',
                        description: `Delete label "${oldLabel.name}"`,
                        undo: () => {
                            labelManager.add(oldLabel);
                            updateLabelsList();
                        },
                        redo: () => {
                            labelManager.remove(addr);
                            updateLabelsList();
                        }
                    });
                    showMessage(`Label "${existingLabel.name}" deleted`);
                    updateDebugger();
                } else if (action === 'mark-code') {
                    showRegionDialog(addr, REGION_TYPES.CODE, endAddr);
                } else if (action === 'mark-db') {
                    showRegionDialog(addr, REGION_TYPES.DB, endAddr);
                } else if (action === 'mark-dw') {
                    showRegionDialog(addr, REGION_TYPES.DW, endAddr);
                } else if (action === 'mark-text') {
                    showRegionDialog(addr, REGION_TYPES.TEXT, endAddr);
                } else if (action === 'mark-gfx') {
                    showRegionDialog(addr, REGION_TYPES.GRAPHICS, endAddr);
                } else if (action === 'mark-smc') {
                    showRegionDialog(addr, REGION_TYPES.SMC, endAddr);
                } else if (action === 'remove-region') {
                    const oldRegion = regionManager.get(addr);
                    if (oldRegion) {
                        regionManager.remove(addr);
                        undoManager.push({
                            type: 'region',
                            description: `Remove region ${hex16(oldRegion.start)}-${hex16(oldRegion.end)}`,
                            undo: () => {
                                regionManager.add(oldRegion, true);  // allowOverwrite for undo
                            },
                            redo: () => {
                                regionManager.remove(addr);
                            }
                        });
                        showMessage('Region mark removed');
                        updateDebugger();
                    }
                }
                clearMemSelection();
                closeMemContextMenu();
            });
        });

        document.addEventListener('click', (e) => {
            if (memContextMenu && !memContextMenu.contains(e.target)) {
                closeMemContextMenu();
            }
            // Clear memory selection when clicking outside memory view
            if (memSelectionStart !== null && !memoryView.contains(e.target) &&
                (!memContextMenu || !memContextMenu.contains(e.target))) {
                clearMemSelection();
            }
        });

        // Finish edit when clicking outside memory view
        document.addEventListener('mousedown', (e) => {
            if (memoryEditingAddr !== null && !memoryView.contains(e.target)) {
                finishCurrentEdit(true);
            }
        });
        
        btnMemoryGo.addEventListener('click', () => {
            const addr = parseInt(memoryAddressInput.value, 16);
            if (!isNaN(addr)) goToMemoryAddress(addr);
        });
        
        memoryAddressInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const addr = parseInt(memoryAddressInput.value, 16);
                if (!isNaN(addr)) goToMemoryAddress(addr);
            }
        });
        
        btnMemoryPC.addEventListener('click', () => {
            if (spectrum.cpu) goToMemoryAddress(spectrum.cpu.pc);
        });
        
        btnMemorySP.addEventListener('click', () => {
            if (spectrum.cpu) goToMemoryAddress(spectrum.cpu.sp);
        });
        
        btnMemoryHL.addEventListener('click', () => {
            if (spectrum.cpu) goToMemoryAddress(spectrum.cpu.hl);
        });
        
        btnMemoryPgUp.addEventListener('click', () => {
            goToMemoryAddress(memoryViewAddress - MEMORY_LINES * BYTES_PER_LINE);
        });
        
        btnMemoryPgDn.addEventListener('click', () => {
            goToMemoryAddress(memoryViewAddress + MEMORY_LINES * BYTES_PER_LINE);
        });

        // Memory scroll wheel navigation
        memoryView.addEventListener('wheel', (e) => {
            e.preventDefault();
            // Scroll by 3 lines per wheel tick
            const scrollLines = e.deltaY > 0 ? 3 : -3;
            goToMemoryAddress(memoryViewAddress + scrollLines * BYTES_PER_LINE);
        }, { passive: false });

        // Bookmarks handling
        function updateBookmarkButtons(bar, bookmarks) {
            const buttons = bar.querySelectorAll('.bookmark-btn');
            buttons.forEach((btn, i) => {
                const addr = bookmarks[i];
                if (addr !== null) {
                    btn.textContent = hex16(addr);
                    btn.classList.add('set');
                } else {
                    btn.textContent = '-';
                    btn.classList.remove('set');
                }
            });
        }

        function setupBookmarkHandlers(bar, bookmarks, goToFn, getCurrentAddrFn, bookmarkType) {
            const buttons = bar.querySelectorAll('.bookmark-btn');
            buttons.forEach((btn) => {
                const idx = parseInt(btn.dataset.index);

                // Left click: navigate to bookmark
                btn.addEventListener('click', () => {
                    if (bookmarks[idx] !== null) {
                        goToFn(bookmarks[idx]);
                    }
                });

                // Right click: set bookmark to current address
                btn.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    const addr = getCurrentAddrFn();
                    if (addr !== null) {
                        const oldAddr = bookmarks[idx];
                        bookmarks[idx] = addr;
                        updateBookmarkButtons(bar, bookmarks);

                        undoManager.push({
                            type: 'bookmark',
                            description: oldAddr !== null
                                ? `Update ${bookmarkType} bookmark ${idx + 1}`
                                : `Set ${bookmarkType} bookmark ${idx + 1}`,
                            undo: () => {
                                bookmarks[idx] = oldAddr;
                                updateBookmarkButtons(bar, bookmarks);
                            },
                            redo: () => {
                                bookmarks[idx] = addr;
                                updateBookmarkButtons(bar, bookmarks);
                            }
                        });
                    }
                });
            });
        }

        // Setup disasm bookmarks
        setupBookmarkHandlers(
            disasmBookmarksBar,
            disasmBookmarks,
            goToAddress,
            () => disasmViewAddress !== null ? disasmViewAddress : (spectrum.cpu ? spectrum.cpu.pc : null),
            'disasm'
        );

        // Setup memory bookmarks
        setupBookmarkHandlers(
            memoryBookmarksBar,
            memoryBookmarks,
            goToMemoryAddress,
            () => memoryViewAddress,
            'memory'
        );

        // Memory snapshot for diff
        btnMemorySnap.addEventListener('click', () => {
            if (!spectrum.memory) return;
            memorySnapshot = new Uint8Array(0x10000);
            for (let addr = 0; addr < 0x10000; addr++) {
                memorySnapshot[addr] = spectrum.memory.read(addr);
            }
            btnMemorySnap.style.display = 'none';
            btnMemoryClearSnap.style.display = '';
            showMessage('Memory snapshot taken');
            updateMemoryView();
        });

        btnMemoryClearSnap.addEventListener('click', () => {
            memorySnapshot = null;
            btnMemorySnap.style.display = '';
            btnMemoryClearSnap.style.display = 'none';
            showMessage('Snapshot cleared');
            updateMemoryView();
        });

        // ROM edit checkbox
        chkRomEdit.addEventListener('change', () => {
            if (spectrum.memory) {
                spectrum.memory.allowRomEdit = chkRomEdit.checked;
            }
        });
        
        // Memory search functions
        // Returns {pattern: number[], mask: number[]} where mask[i]=0xFF for exact, 0x00 for wildcard
        function parseSearchPattern(input, type) {
            if (type === 'hex') {
                // Parse hex bytes like "CD 21 00" with wildcards ?? or **
                const tokens = input.trim().split(/\s+/).filter(s => s.length > 0);
                if (tokens.length === 0) return null;

                const pattern = [];
                const mask = [];

                for (const token of tokens) {
                    if (token === '?' || token === '??' || token === '*' || token === '**') {
                        // Wildcard - match any byte
                        pattern.push(0);
                        mask.push(0x00);
                    } else if (/^[0-9A-Fa-f]{2}$/.test(token)) {
                        // Single hex byte
                        pattern.push(parseInt(token, 16));
                        mask.push(0xFF);
                    } else if (/^[0-9A-Fa-f]+$/.test(token) && token.length % 2 === 0) {
                        // Concatenated hex bytes like "CD21" - split them
                        for (let i = 0; i < token.length; i += 2) {
                            pattern.push(parseInt(token.substr(i, 2), 16));
                            mask.push(0xFF);
                        }
                    } else {
                        return null; // Invalid token
                    }
                }
                return pattern.length > 0 ? { pattern, mask } : null;
            } else if (type === 'dec') {
                // Parse decimal bytes like "205 33 0" or "205,33,0"
                const parts = input.split(/[\s,]+/).filter(s => s.length > 0);
                if (parts.length === 0) return null;
                const pattern = [];
                const mask = [];
                for (const part of parts) {
                    const val = parseInt(part, 10);
                    if (isNaN(val) || val < 0 || val > 255) return null;
                    pattern.push(val);
                    mask.push(0xFF);
                }
                return pattern.length > 0 ? { pattern, mask } : null;
            } else {
                // Text search - convert to bytes
                if (input.length === 0) return null;
                const pattern = Array.from(input).map(c => c.charCodeAt(0) & 0xff);
                const mask = pattern.map(() => 0xFF);
                return { pattern, mask };
            }
        }
        
        function searchMemory(searchData, startAddr = 0, options = {}) {
            if (!spectrum.memory || !searchData) return [];

            // Support both old format (array) and new format ({pattern, mask})
            const pattern = Array.isArray(searchData) ? searchData : searchData.pattern;
            const mask = Array.isArray(searchData) ? null : searchData.mask;

            if (!pattern || pattern.length === 0) return [];

            const { caseInsensitive = false, lastChar7bit = false } = options;
            const results = [];
            const maxResults = 100;
            const memSize = 0x10000;
            const patternLen = pattern.length;

            // Prepare pattern for matching
            const matchPattern = caseInsensitive
                ? pattern.map(b => (b >= 0x41 && b <= 0x5a) ? b | 0x20 : (b >= 0x61 && b <= 0x7a) ? b : b)
                : pattern;

            for (let addr = startAddr; addr < memSize && results.length < maxResults; addr++) {
                let match = true;
                for (let i = 0; i < patternLen && match; i++) {
                    // Skip wildcards (mask = 0x00)
                    if (mask && mask[i] === 0x00) continue;

                    let memByte = spectrum.memory.read((addr + i) & 0xffff);
                    let patByte = matchPattern[i];

                    // Last character with 7-bit set: match both normal and +128 versions
                    if (lastChar7bit && i === patternLen - 1) {
                        const memByteLow = memByte & 0x7f;
                        if (caseInsensitive) {
                            const memLower = (memByteLow >= 0x41 && memByteLow <= 0x5a) ? memByteLow | 0x20 : memByteLow;
                            const patLower = (patByte >= 0x41 && patByte <= 0x5a) ? patByte | 0x20 : patByte;
                            if (memLower !== patLower) match = false;
                        } else {
                            if (memByteLow !== patByte) match = false;
                        }
                    } else if (caseInsensitive) {
                        // Case-insensitive: convert both to lowercase for comparison
                        const memLower = (memByte >= 0x41 && memByte <= 0x5a) ? memByte | 0x20 : memByte;
                        const patLower = (patByte >= 0x41 && patByte <= 0x5a) ? patByte | 0x20 : patByte;
                        if (memLower !== patLower) match = false;
                    } else {
                        if (memByte !== patByte) match = false;
                    }
                }
                if (match) {
                    results.push(addr);
                }
            }
            return results;
        }
        
        function displaySearchResults(results, searchData) {
            if (results.length === 0) {
                searchResults.innerHTML = '<div class="search-info">No results found</div>';
                return;
            }

            const patternLen = searchData.pattern ? searchData.pattern.length : searchData.length;
            searchResults.innerHTML = results.slice(0, 20).map((addr, idx) => {
                // Show preview of bytes at this address
                let preview = '';
                for (let i = 0; i < Math.min(8, patternLen + 4); i++) {
                    preview += hex8(spectrum.memory.read((addr + i) & 0xffff)) + ' ';
                }
                return `<div class="search-result" data-addr="${addr}" data-idx="${idx}">
                    <span class="addr">${hex16(addr)}</span>
                    <span class="preview">${preview.trim()}</span>
                </div>`;
            }).join('') + (results.length > 20 ? `<div class="search-info">...and ${results.length - 20} more</div>` : '');
        }

        function doSearch() {
            const input = memSearchInput.value.trim();
            if (!input) {
                searchResults.innerHTML = '';
                return;
            }

            searchPattern = parseSearchPattern(input, memSearchType.value);
            if (!searchPattern) {
                searchResults.innerHTML = '<div class="search-info">Invalid pattern (hex: use ? for wildcard)</div>';
                return;
            }

            const searchOptions = {
                caseInsensitive: chkSearchCase.checked,
                lastChar7bit: chkSearch7bit.checked
            };
            
            searchResultAddrs = searchMemory(searchPattern, 0, searchOptions);
            searchResultIndex = searchResultAddrs.length > 0 ? 0 : -1;
            
            displaySearchResults(searchResultAddrs, searchPattern);
            
            if (searchResultAddrs.length > 0) {
                goToMemoryAddress(searchResultAddrs[0]);
                showMessage(`Found ${searchResultAddrs.length} result(s)`);
            } else {
                showMessage('No results found', 'error');
            }
        }
        
        function doSearchNext() {
            if (searchResultAddrs.length === 0) {
                doSearch();
                return;
            }
            
            searchResultIndex = (searchResultIndex + 1) % searchResultAddrs.length;
            goToMemoryAddress(searchResultAddrs[searchResultIndex]);
            showMessage(`Result ${searchResultIndex + 1} of ${searchResultAddrs.length}`);
        }
        
        btnMemSearch.addEventListener('click', doSearch);
        
        btnMemSearchNext.addEventListener('click', doSearchNext);
        
        memSearchInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                if (e.shiftKey) {
                    doSearchNext();
                } else {
                    doSearch();
                }
            }
        });
        
        // Show/hide text search options and update placeholder based on search type
        const searchOptionsDiv = document.querySelector('.search-options');
        function updateSearchOptions() {
            const mode = memSearchType.value;
            searchOptionsDiv.style.display = mode === 'text' ? 'flex' : 'none';

            // Update placeholder and tooltip based on mode
            if (mode === 'hex') {
                memSearchInput.placeholder = 'CD ? 00...';
                memSearchInput.title = 'Hex bytes, use ? for wildcard';
            } else if (mode === 'dec') {
                memSearchInput.placeholder = '205 33 0...';
                memSearchInput.title = 'Decimal bytes (0-255)';
            } else {
                memSearchInput.placeholder = 'text...';
                memSearchInput.title = 'Text string to search';
            }
        }
        memSearchType.addEventListener('change', updateSearchOptions);
        updateSearchOptions(); // Initial state
        
        searchResults.addEventListener('click', (e) => {
            const resultEl = e.target.closest('.search-result');
            if (resultEl) {
                const addr = parseInt(resultEl.dataset.addr);
                const idx = parseInt(resultEl.dataset.idx);
                searchResultIndex = idx;
                goToMemoryAddress(addr);
            }
        });

        // POKE search handlers
        pokeSearchMode.addEventListener('change', () => {
            pokeSearchValue.style.display = pokeSearchMode.value === 'equals' ? '' : 'none';
        });

        function updatePokeStatus() {
            if (pokeCandidates === null) {
                pokeStatus.textContent = pokeSnapshot ? '(snap taken)' : '';
            } else {
                pokeStatus.textContent = `(${pokeCandidates.size} candidates)`;
            }
        }

        function updatePokeResults() {
            if (pokeCandidates === null || pokeCandidates.size === 0) {
                pokeResults.innerHTML = '';
                return;
            }
            // Show first 100 candidates
            const addrs = [...pokeCandidates].slice(0, 100);
            pokeResults.innerHTML = addrs.map(addr => {
                const val = spectrum.memory.read(addr);
                return `<span class="poke-result" data-addr="${addr}"><span class="addr">${hex16(addr)}</span><span class="val">${hex8(val)}</span></span>`;
            }).join('');
            if (pokeCandidates.size > 100) {
                pokeResults.innerHTML += `<span class="poke-status">...and ${pokeCandidates.size - 100} more</span>`;
            }
        }

        btnPokeSnap.addEventListener('click', () => {
            if (!spectrum.memory) return;
            pokeSnapshot = new Uint8Array(0x10000);
            for (let addr = 0; addr < 0x10000; addr++) {
                pokeSnapshot[addr] = spectrum.memory.read(addr);
            }
            showMessage('POKE snapshot taken');
            updatePokeStatus();
        });

        btnPokeSearch.addEventListener('click', () => {
            if (!spectrum.memory || !pokeSnapshot) {
                showMessage('Take a snapshot first', 'error');
                return;
            }

            const mode = pokeSearchMode.value;
            let targetValue = 0;
            if (mode === 'equals') {
                const valStr = pokeSearchValue.value.trim();
                if (!/^[0-9A-Fa-f]{1,2}$/.test(valStr)) {
                    showMessage('Enter hex value (00-FF)', 'error');
                    return;
                }
                targetValue = parseInt(valStr, 16);
            }

            // Start with all RAM addresses or existing candidates
            const searchSet = pokeCandidates !== null ? pokeCandidates : new Set();
            if (pokeCandidates === null) {
                // First search: all RAM (0x4000-0xFFFF)
                for (let addr = 0x4000; addr < 0x10000; addr++) {
                    searchSet.add(addr);
                }
            }

            const newCandidates = new Set();
            for (const addr of searchSet) {
                const oldVal = pokeSnapshot[addr];
                const newVal = spectrum.memory.read(addr);
                let match = false;

                switch (mode) {
                    case 'dec1': match = newVal === ((oldVal - 1) & 0xff); break;
                    case 'inc1': match = newVal === ((oldVal + 1) & 0xff); break;
                    case 'decreased': match = newVal < oldVal; break;
                    case 'increased': match = newVal > oldVal; break;
                    case 'changed': match = newVal !== oldVal; break;
                    case 'unchanged': match = newVal === oldVal; break;
                    case 'equals': match = newVal === targetValue; break;
                }

                if (match) {
                    newCandidates.add(addr);
                }
            }

            pokeCandidates = newCandidates;

            // Update snapshot to current state for next comparison
            for (let addr = 0; addr < 0x10000; addr++) {
                pokeSnapshot[addr] = spectrum.memory.read(addr);
            }

            showMessage(`${pokeCandidates.size} candidate(s) found`);
            updatePokeStatus();
            updatePokeResults();
        });

        btnPokeReset.addEventListener('click', () => {
            pokeSnapshot = null;
            pokeCandidates = null;
            pokeResults.innerHTML = '';
            updatePokeStatus();
            showMessage('POKE search reset');
        });

        pokeResults.addEventListener('click', (e) => {
            const resultEl = e.target.closest('.poke-result');
            if (resultEl) {
                const addr = parseInt(resultEl.dataset.addr);
                goToMemoryAddress(addr);
            }
        });

        // ========== Text Scanner ==========
        const btnTextScan = document.getElementById('btnTextScan');
        const textScanMode = document.getElementById('textScanMode');
        const textScanCustom = document.getElementById('textScanCustom');
        const textScanMinLen = document.getElementById('textScanMinLen');
        const textScanROM = document.getElementById('textScanROM');
        const textScanAllBanks = document.getElementById('textScanAllBanks');
        const textScanMax = document.getElementById('textScanMax');
        const textScanStatus = document.getElementById('textScanStatus');
        const textScanResults = document.getElementById('textScanResults');
        const textScanPagination = document.getElementById('textScanPagination');
        const textScanPrev = document.getElementById('textScanPrev');
        const textScanNext = document.getElementById('textScanNext');
        const textScanPage = document.getElementById('textScanPage');

        let textScanAllResults = [];  // Store all results for pagination
        let textScanCurrentPage = 0;

        // Dictionary of common ZX Spectrum game/computer words
        const TEXT_DICTIONARY = [
            // Game terms
            'SCORE', 'LIVES', 'LEVEL', 'LIFE', 'TIME', 'BONUS', 'POINTS', 'ENERGY',
            'GAME', 'OVER', 'PLAYER', 'PRESS', 'START', 'PLAY', 'PAUSE', 'CONTINUE',
            'HIGH', 'ENTER', 'NAME', 'TABLE', 'BEST', 'TOP', 'NEW', 'RECORD',
            // Controls
            'FIRE', 'JUMP', 'LEFT', 'RIGHT', 'UP', 'DOWN', 'SPACE', 'ENTER',
            'KEYBOARD', 'JOYSTICK', 'KEMPSTON', 'SINCLAIR', 'CURSOR', 'KEYS',
            'CONTROL', 'SELECT', 'OPTION', 'MENU', 'QUIT', 'EXIT', 'ABORT',
            // Messages
            'LOADING', 'SAVING', 'LOAD', 'SAVE', 'BYTES', 'READY', 'ERROR',
            'PRESS ANY KEY', 'WAIT', 'PLEASE', 'INSERT', 'TAPE', 'DISK',
            'CONGRATULATIONS', 'WELL DONE', 'TRY AGAIN', 'GET READY',
            // Credits
            'COPYRIGHT', 'WRITTEN', 'PROGRAMMED', 'GRAPHICS', 'MUSIC', 'SOUND',
            'PRESENTS', 'PRODUCTIONS', 'SOFTWARE', 'GAMES', 'CODE',
            // Status
            'SHIELD', 'AMMO', 'FUEL', 'POWER', 'HEALTH', 'MAGIC', 'GOLD', 'COINS',
            'WEAPON', 'ARMOR', 'ITEM', 'INVENTORY', 'MAP', 'STAGE', 'ROUND', 'WAVE',
            // Common words
            'THE', 'AND', 'YOU', 'ARE', 'FOR', 'NOT', 'ALL', 'CAN', 'HAS', 'HER',
            'WAS', 'ONE', 'OUR', 'OUT', 'DAY', 'HAD', 'HOT', 'HIS', 'HOW', 'ITS',
            'MAY', 'OLD', 'SEE', 'NOW', 'WAY', 'WHO', 'DID', 'GET', 'HIM', 'HIS',
            'LET', 'PUT', 'SAY', 'SHE', 'TOO', 'USE', 'YES', 'FROM', 'HAVE', 'INTO',
            'KILL', 'DEAD', 'DIED', 'HELP', 'FIND', 'OPEN', 'DOOR', 'ROOM', 'LOCK',
            'TAKE', 'DROP', 'GIVE', 'LOOK', 'WALK', 'MOVE', 'STOP', 'TURN', 'BACK',
            'NORTH', 'SOUTH', 'EAST', 'WEST', 'EXAMINE', 'ATTACK', 'DEFEND',
            // ZX Spectrum specific
            'SPECTRUM', 'SINCLAIR', 'BASIC', 'RETURN', 'BREAK', 'STOP',
            'PRINT', 'INPUT', 'GOTO', 'GOSUB', 'THEN', 'ELSE', 'NEXT', 'DATA',
            'POKE', 'PEEK', 'BEEP', 'BORDER', 'PAPER', 'INK', 'FLASH', 'BRIGHT'
        ];

        // Convert dictionary to lowercase Set for fast lookup
        const dictSet = new Set(TEXT_DICTIONARY.map(w => w.toLowerCase()));

        textScanMode.addEventListener('change', () => {
            textScanCustom.style.display = textScanMode.value === 'custom' ? '' : 'none';
        });

        function renderTextScanPage() {
            const perPage = parseInt(textScanMax.value) || 0;  // 0 = all
            const total = textScanAllResults.length;

            if (total === 0) {
                textScanResults.innerHTML = '<div style="color:var(--text-secondary);padding:5px;">No strings found</div>';
                textScanPagination.style.display = 'none';
                return;
            }

            let startIdx, endIdx, totalPages;
            if (perPage === 0) {
                // Show all
                startIdx = 0;
                endIdx = total;
                totalPages = 1;
                textScanCurrentPage = 0;
                textScanPagination.style.display = 'none';
            } else {
                totalPages = Math.ceil(total / perPage);
                if (textScanCurrentPage >= totalPages) textScanCurrentPage = totalPages - 1;
                if (textScanCurrentPage < 0) textScanCurrentPage = 0;
                startIdx = textScanCurrentPage * perPage;
                endIdx = Math.min(startIdx + perPage, total);
                textScanPagination.style.display = totalPages > 1 ? '' : 'none';
                textScanPage.textContent = `${textScanCurrentPage + 1}/${totalPages}`;
                textScanPrev.disabled = textScanCurrentPage === 0;
                textScanNext.disabled = textScanCurrentPage >= totalPages - 1;
            }

            let html = '';
            for (let i = startIdx; i < endIdx; i++) {
                const r = textScanAllResults[i];
                let textHtml = escapeHtml(r.text);
                // Highlight dictionary matches
                if (r.dictMatches.length > 0) {
                    for (const word of r.dictMatches) {
                        const re = new RegExp('(' + word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + ')', 'gi');
                        textHtml = textHtml.replace(re, '<span class="dict-match">$1</span>');
                    }
                }
                const termIcon = r.termType === 'bit7' ? '⁷' : r.termType === 'null' ? '∅' : '';
                const bankLabel = r.bank ? `<span class="bank">${r.bank}</span>` : '';
                html += `<div class="text-scan-result" data-addr="${r.addr}" data-bank="${r.bank || ''}" title="${r.termType}-terminated${r.bank ? ' (' + r.bank + ')' : ''}">
                    <span class="addr">${hex16(r.addr)}</span>${bankLabel}
                    <span class="len">${r.len}${termIcon}</span>
                    <span class="text">${textHtml}</span>
                </div>`;
            }
            textScanResults.innerHTML = html;
        }

        textScanPrev.addEventListener('click', () => {
            if (textScanCurrentPage > 0) {
                textScanCurrentPage--;
                renderTextScanPage();
            }
        });

        textScanNext.addEventListener('click', () => {
            const perPage = parseInt(textScanMax.value) || 0;
            const totalPages = perPage > 0 ? Math.ceil(textScanAllResults.length / perPage) : 1;
            if (textScanCurrentPage < totalPages - 1) {
                textScanCurrentPage++;
                renderTextScanPage();
            }
        });

        textScanMax.addEventListener('change', () => {
            textScanCurrentPage = 0;
            renderTextScanPage();
        });

        // Extract string from raw buffer at offset
        function extractStringFromBuffer(buffer, startOffset, minLen) {
            let text = '';
            let offset = startOffset;
            let termType = null;

            while (offset < buffer.length) {
                const byte = buffer[offset];

                if (byte === 0) {
                    if (text.length >= minLen) {
                        termType = 'null';
                        return { text, len: offset - startOffset + 1, termType };
                    }
                    return null;
                }

                const char = byte & 0x7F;
                const bit7set = (byte & 0x80) !== 0;

                const isLetter = (char >= 65 && char <= 90) || (char >= 97 && char <= 122);
                const isPunct = char === 32 || char === 33 || char === 44 || char === 45 ||
                                char === 58 || char === 59 || char === 63;
                if (isLetter || isPunct) {
                    text += String.fromCharCode(char);
                    offset++;

                    if (bit7set) {
                        if (text.length >= minLen) {
                            termType = 'bit7';
                            return { text, len: offset - startOffset, termType };
                        }
                        return null;
                    }

                } else {
                    if (text.length >= minLen) {
                        termType = 'nonprint';
                        return { text, len: offset - startOffset, termType };
                    }
                    return null;
                }
            }

            if (text.length >= minLen) {
                termType = 'eof';
                return { text, len: offset - startOffset, termType };
            }
            return null;
        }

        // Scan a buffer for strings and add to results
        function scanBufferForStrings(buffer, baseAddr, bankLabel, mode, minLen, customSearch) {
            let offset = 0;
            while (offset < buffer.length) {
                const str = extractStringFromBuffer(buffer, offset, minLen);
                if (str) {
                    let include = false;
                    let dictMatches = [];

                    if (mode === 'all') {
                        include = true;
                        dictMatches = findDictWords(str.text);
                    } else if (mode === 'dict') {
                        dictMatches = findDictWords(str.text);
                        include = dictMatches.length > 0;
                    } else if (mode === 'custom') {
                        include = str.text.toLowerCase().includes(customSearch);
                    }

                    if (include) {
                        textScanAllResults.push({
                            addr: baseAddr + offset,
                            text: str.text,
                            len: str.len,
                            termType: str.termType,
                            dictMatches: dictMatches,
                            bank: bankLabel
                        });
                    }
                    offset += str.len;
                } else {
                    offset++;
                }
            }
        }

        btnTextScan.addEventListener('click', () => {
            if (!spectrum.memory) {
                showMessage('No memory available');
                return;
            }

            const mode = textScanMode.value;
            const minLen = parseInt(textScanMinLen.value) || 4;
            const customSearch = textScanCustom.value.toLowerCase();
            const includeROM = textScanROM.checked;
            const scanAllBanks = textScanAllBanks.checked && spectrum.memory.machineType !== '48k';
            textScanAllResults = [];

            if (scanAllBanks) {
                // Scan all 8 RAM banks directly (128K mode)
                for (let bank = 0; bank < 8; bank++) {
                    const buffer = spectrum.memory.getRamBank(bank);
                    scanBufferForStrings(buffer, 0xC000, `bank${bank}`, mode, minLen, customSearch);
                }
                // Optionally scan ROM
                if (includeROM) {
                    const rom0 = spectrum.memory.rom[0];
                    if (rom0) scanBufferForStrings(rom0, 0x0000, 'ROM0', mode, minLen, customSearch);
                    const rom1 = spectrum.memory.rom[1];
                    if (rom1) scanBufferForStrings(rom1, 0x0000, 'ROM1', mode, minLen, customSearch);
                }
            } else {
                // Scan mapped memory only
                let addr = includeROM ? 0x0000 : 0x4000;
                while (addr < 0x10000) {
                    const str = extractString(addr, minLen);
                    if (str) {
                        let include = false;
                        let dictMatches = [];

                        if (mode === 'all') {
                            include = true;
                            dictMatches = findDictWords(str.text);
                        } else if (mode === 'dict') {
                            dictMatches = findDictWords(str.text);
                            include = dictMatches.length > 0;
                        } else if (mode === 'custom') {
                            include = str.text.toLowerCase().includes(customSearch);
                        }

                        if (include) {
                            textScanAllResults.push({
                                addr: addr,
                                text: str.text,
                                len: str.len,
                                termType: str.termType,
                                dictMatches: dictMatches,
                                bank: null
                            });
                        }
                        addr += str.len;
                    } else {
                        addr++;
                    }
                }
            }

            // Display results
            textScanStatus.textContent = `(${textScanAllResults.length} strings)`;
            textScanCurrentPage = 0;
            renderTextScanPage();

            showMessage(`Found ${textScanAllResults.length} text strings`);
        });

        textScanResults.addEventListener('click', (e) => {
            const resultEl = e.target.closest('.text-scan-result');
            if (resultEl) {
                const addr = parseInt(resultEl.dataset.addr);
                goToMemoryAddress(addr);
            }
        });

        // Extract a string from memory address
        // Returns {text, len, termType} or null if not a valid string
        function extractString(startAddr, minLen) {
            let text = '';
            let addr = startAddr;
            let termType = null;

            while (addr < 0x10000) {
                const byte = spectrum.memory.read(addr);

                // Check for null terminator
                if (byte === 0) {
                    if (text.length >= minLen) {
                        termType = 'null';
                        return { text, len: addr - startAddr + 1, termType };
                    }
                    return null;
                }

                // Check for bit 7 set (last char marker)
                const char = byte & 0x7F;
                const bit7set = (byte & 0x80) !== 0;

                // Check if letter or limited punctuation
                const isLetter = (char >= 65 && char <= 90) || (char >= 97 && char <= 122);
                // Only: space(32), !(33), ,(44), -(45), :(58), ;(59), ?(63)
                const isPunct = char === 32 || char === 33 || char === 44 || char === 45 ||
                                char === 58 || char === 59 || char === 63;
                if (isLetter || isPunct) {
                    text += String.fromCharCode(char);
                    addr++;

                    if (bit7set) {
                        // Bit 7 terminator
                        if (text.length >= minLen) {
                            termType = 'bit7';
                            return { text, len: addr - startAddr, termType };
                        }
                        return null;
                    }

                } else {
                    // Non-printable character
                    if (text.length >= minLen) {
                        termType = 'nonprint';
                        return { text, len: addr - startAddr, termType };
                    }
                    return null;
                }
            }

            // End of memory
            if (text.length >= minLen) {
                termType = 'eof';
                return { text, len: addr - startAddr, termType };
            }
            return null;
        }

        // Find dictionary words in a string
        function findDictWords(text) {
            const found = [];
            const textLower = text.toLowerCase();
            const words = textLower.split(/[^a-z]+/);

            for (const word of words) {
                if (word.length >= 3 && dictSet.has(word)) {
                    found.push(word);
                }
            }

            // Also check for multi-word matches without spaces
            for (const dictWord of TEXT_DICTIONARY) {
                const lower = dictWord.toLowerCase();
                if (lower.length >= 4 && textLower.includes(lower) && !found.includes(lower)) {
                    found.push(lower);
                }
            }

            return found;
        }

        // ========== Watches ==========
        const watchesList = document.getElementById('watchesList');
        const watchAddrInput = document.getElementById('watchAddrInput');
        const watchNameInput = document.getElementById('watchNameInput');
        const btnWatchAdd = document.getElementById('btnWatchAdd');
        const btnWatchClear = document.getElementById('btnWatchClear');
        let watches = []; // Array of {addr: number, name: string, prevBytes: Uint8Array}
        const MAX_WATCHES = 10;
        const WATCH_BYTES = 8;

        function loadWatches() {
            const saved = localStorage.getItem('zx_watches');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    // Support old format (number), intermediate (addr only), and new format (addr+name+page)
                    watches = data.map(item => {
                        if (typeof item === 'number') {
                            return { addr: item, name: '', page: null, prevBytes: new Uint8Array(WATCH_BYTES) };
                        }
                        return {
                            addr: item.addr,
                            name: item.name || '',
                            page: item.page !== undefined ? item.page : null,
                            prevBytes: new Uint8Array(WATCH_BYTES)
                        };
                    });
                } catch (e) {
                    watches = [];
                }
            }
        }

        function saveWatches() {
            const data = watches.map(w => ({ addr: w.addr, name: w.name, page: w.page }));
            localStorage.setItem('zx_watches', JSON.stringify(data));
        }

        function readWatchByte(watch, offset) {
            const addr = (watch.addr + offset) & 0xFFFF;
            // If page specified and address is in C000-FFFF range, read from specific bank
            if (watch.page !== null && addr >= 0xC000 && spectrum.memory.machineType !== '48k') {
                const bank = spectrum.memory.getRamBank(watch.page);
                if (bank) {
                    return bank[addr - 0xC000] & 0xFF;
                }
            }
            return spectrum.memory.read(addr) & 0xFF;
        }

        function getWatchDisplayName(watch) {
            // Check if address matches a label
            const label = labelManager.get(watch.addr);
            if (label) {
                return { text: label.name, isLabel: true };
            }
            return { text: watch.name || '', isLabel: false };
        }

        function sortWatches() {
            watches.sort((a, b) => a.addr - b.addr);
        }

        function renderWatches() {
            watchesList.innerHTML = '';
            if (watches.length === 0) {
                watchesList.innerHTML = '<div class="no-breakpoints">No watches</div>';
                return;
            }
            sortWatches();
            watches.forEach((watch, index) => {
                const entry = document.createElement('div');
                entry.className = 'watch-entry';

                // Address display (with page if specified)
                const addrSpan = document.createElement('span');
                addrSpan.className = 'watch-addr';
                const pagePrefix = watch.page !== null ? `${watch.page}:` : '';
                addrSpan.textContent = pagePrefix + watch.addr.toString(16).toUpperCase().padStart(4, '0');

                // Name/label display
                const nameSpan = document.createElement('span');
                nameSpan.dataset.index = index;
                const displayName = getWatchDisplayName(watch);
                nameSpan.className = 'watch-name' + (displayName.isLabel ? ' label' : '');
                nameSpan.textContent = displayName.text;
                nameSpan.title = displayName.isLabel ? 'Label: ' + displayName.text : (watch.name || 'No name');

                const bytesSpan = document.createElement('span');
                bytesSpan.className = 'watch-bytes';
                bytesSpan.dataset.index = index;
                bytesSpan.textContent = '-- -- -- -- -- -- -- --';

                const asciiSpan = document.createElement('span');
                asciiSpan.className = 'watch-ascii';
                asciiSpan.dataset.index = index;
                asciiSpan.textContent = '........';

                const removeBtn = document.createElement('button');
                removeBtn.className = 'watch-remove';
                removeBtn.textContent = '×';
                removeBtn.title = 'Remove watch';
                removeBtn.addEventListener('click', () => {
                    watches.splice(index, 1);
                    saveWatches();
                    renderWatches();
                });

                entry.appendChild(removeBtn);
                entry.appendChild(addrSpan);
                entry.appendChild(nameSpan);
                entry.appendChild(bytesSpan);
                entry.appendChild(asciiSpan);
                watchesList.appendChild(entry);
            });
            updateWatchValues();
        }

        function updateWatchValues() {
            if (!spectrum || !spectrum.memory) return;
            watches.forEach((watch, index) => {
                const bytesSpan = watchesList.querySelector(`.watch-bytes[data-index="${index}"]`);
                const asciiSpan = watchesList.querySelector(`.watch-ascii[data-index="${index}"]`);
                const nameSpan = watchesList.querySelector(`.watch-name[data-index="${index}"]`);
                if (!bytesSpan || !asciiSpan) return;

                // Update name/label (may change after labels load)
                if (nameSpan) {
                    const displayName = getWatchDisplayName(watch);
                    nameSpan.className = 'watch-name' + (displayName.isLabel ? ' label' : '');
                    nameSpan.textContent = displayName.text;
                    nameSpan.title = displayName.isLabel ? 'Label: ' + displayName.text : (watch.name || 'No name');
                }

                let bytesHtml = '';
                let asciiStr = '';
                const currentBytes = new Uint8Array(WATCH_BYTES);

                for (let i = 0; i < WATCH_BYTES; i++) {
                    const byte = readWatchByte(watch, i);
                    currentBytes[i] = byte;
                    const changed = watch.prevBytes[i] !== byte;
                    const hex = byte.toString(16).toUpperCase().padStart(2, '0');
                    if (changed) {
                        bytesHtml += `<span class="changed">${hex}</span> `;
                    } else {
                        bytesHtml += hex + ' ';
                    }
                    asciiStr += (byte >= 32 && byte < 127) ? String.fromCharCode(byte) : '.';
                }

                bytesSpan.innerHTML = bytesHtml;
                asciiSpan.textContent = asciiStr;
                watch.prevBytes = currentBytes;
            });
        }

        if (btnWatchAdd) {
            btnWatchAdd.addEventListener('click', () => {
                if (watches.length >= MAX_WATCHES) {
                    showMessage(`Maximum ${MAX_WATCHES} watches allowed`);
                    return;
                }
                // Parse address from input (supports P:ADDR format)
                const addrStr = watchAddrInput.value.trim();
                if (!addrStr) {
                    showMessage('Enter address', 'error');
                    watchAddrInput.focus();
                    return;
                }

                let addr, page = null;
                const parsed = spectrum.parseAddressSpec(addrStr);
                if (parsed) {
                    addr = parsed.start;
                    page = parsed.page;
                } else {
                    // Fallback: try simple hex parse
                    addr = parseInt(addrStr, 16);
                    if (isNaN(addr) || addr < 0 || addr > 0xFFFF) {
                        showMessage('Invalid address', 'error');
                        watchAddrInput.focus();
                        return;
                    }
                }

                const name = watchNameInput.value.trim();
                watches.push({
                    addr: addr,
                    name: name,
                    page: page,
                    prevBytes: new Uint8Array(WATCH_BYTES)
                });
                saveWatches();
                renderWatches();
                // Clear inputs
                watchAddrInput.value = '';
                watchNameInput.value = '';
                const pageStr = page !== null ? `${page}:` : '';
                showMessage(`Watch added: ${pageStr}${addr.toString(16).toUpperCase().padStart(4, '0')}${name ? ' (' + name + ')' : ''}`);
            });
        } else {
            console.error('btnWatchAdd not found');
        }

        if (btnWatchClear) {
            btnWatchClear.addEventListener('click', () => {
                if (watches.length === 0) return;
                watches = [];
                saveWatches();
                renderWatches();
                showMessage('All watches cleared');
            });
        } else {
            console.error('btnWatchClear not found');
        }

        // Load watches on startup
        loadWatches();
        renderWatches();

        // ========== Assembler ==========
        const asmEditor = document.getElementById('asmEditor');
        const asmHighlight = document.getElementById('asmHighlight');
        const asmLineNumbers = document.getElementById('asmLineNumbers');
        const asmOutput = document.getElementById('asmOutput');
        // asmStatus removed - status shown in output log
        const btnAsmAssemble = document.getElementById('btnAsmAssemble');
        const btnAsmClear = document.getElementById('btnAsmClear');
        const btnAsmNew = document.getElementById('btnAsmNew');
        const btnAsmLoad = document.getElementById('btnAsmLoad');
        const asmFileInput = document.getElementById('asmFileInput');
        const btnAsmInject = document.getElementById('btnAsmInject');
        const btnAsmDebug = document.getElementById('btnAsmDebug');
        const btnAsmDownload = document.getElementById('btnAsmDownload');
        const chkAsmUnusedLabels = document.getElementById('chkAsmUnusedLabels');
        const chkAsmShowCompiled = document.getElementById('chkAsmShowCompiled');
        const asmDefinesInput = document.getElementById('asmDefines');
        const asmDetectedDefines = document.getElementById('asmDetectedDefines');
        const btnAsmExport = document.getElementById('btnAsmExport');
        const asmFileTabs = document.getElementById('asmFileTabs');
        const asmMainFileLabel = document.getElementById('asmMainFileLabel');
        const asmFilesDropdown = document.querySelector('.asm-files-dropdown');
        const btnAsmFiles = document.getElementById('btnAsmFiles');
        const asmFilesList = document.getElementById('asmFilesList');
        const fileSelectorDialog = document.getElementById('fileSelectorDialog');
        const fileSelectorBody = document.getElementById('fileSelectorBody');
        const fileSelectorTitle = document.getElementById('fileSelectorTitle');
        const btnFileSelectorClose = document.getElementById('btnFileSelectorClose');

        // Current project state
        let currentProjectMainFile = null;  // Main file for compilation
        let currentOpenFile = null;         // Currently displayed file in editor
        let openTabs = [];                  // List of open tab paths
        let fileModified = {};              // Track modified state per file

        // Show/hide buttons based on project state
        function updateProjectButtons() {
            const fileCount = Object.keys(VFS.files).length;
            const hasFiles = fileCount > 0;
            const hasMultipleFiles = fileCount > 1;
            const hasContent = asmEditor && asmEditor.value.trim().length > 0;

            if (btnAsmExport) {
                btnAsmExport.style.display = hasFiles ? 'inline-block' : 'none';
            }
            // Files button: always visible, disabled when 0 or 1 file
            if (btnAsmFiles) {
                btnAsmFiles.disabled = !hasMultipleFiles;
            }
            if (asmMainFileLabel) {
                if (currentProjectMainFile && hasFiles) {
                    asmMainFileLabel.style.display = 'inline';
                    asmMainFileLabel.textContent = currentProjectMainFile.split('/').pop();
                } else {
                    asmMainFileLabel.style.display = 'none';
                }
            }
            // Enable Assemble if there's content in editor or files in VFS
            if (btnAsmAssemble) {
                btnAsmAssemble.disabled = !(hasContent || hasFiles);
            }
        }

        // Update files dropdown list
        function updateFilesList() {
            if (!asmFilesList) return;
            asmFilesList.innerHTML = '';

            const files = VFS.listFiles();

            // Sort by directory then filename
            files.sort((a, b) => {
                const dirA = a.includes('/') ? a.substring(0, a.lastIndexOf('/')) : '';
                const dirB = b.includes('/') ? b.substring(0, b.lastIndexOf('/')) : '';
                const nameA = a.split('/').pop().toLowerCase();
                const nameB = b.split('/').pop().toLowerCase();

                // First compare directories
                if (dirA !== dirB) {
                    // Root files (no directory) come first
                    if (!dirA) return -1;
                    if (!dirB) return 1;
                    return dirA.localeCompare(dirB);
                }
                // Then compare filenames
                return nameA.localeCompare(nameB);
            });

            for (const path of files) {
                const file = VFS.files[path];
                const name = path.split('/').pop();
                const dir = path.includes('/') ? path.substring(0, path.lastIndexOf('/') + 1) : '';
                const isBinary = file.binary;
                const isMain = path === currentProjectMainFile;
                const isOpen = openTabs.includes(path);
                const size = isBinary ? file.content.length : file.content.length;

                const item = document.createElement('div');
                item.className = 'asm-files-list-item';
                if (isMain) item.classList.add('main');
                if (isBinary) item.classList.add('binary');
                if (isOpen) item.classList.add('open');

                const icon = isBinary ? '📦' : (isMain ? '▶' : '📄');
                const sizeStr = size < 1024 ? `${size}b` : `${(size/1024).toFixed(1)}K`;
                const dirHtml = dir ? `<span class="file-dir">${dir}</span>` : '';

                item.innerHTML = `
                    <span class="file-icon">${icon}</span>
                    <span class="file-name" title="${path}">${dirHtml}${name}</span>
                    <span class="file-size">${sizeStr}</span>
                `;

                item.addEventListener('click', () => {
                    openFileTab(path);
                    asmFilesList.classList.remove('show');
                });

                asmFilesList.appendChild(item);
            }
        }

        // Open a file in a tab
        function openFileTab(path) {
            const file = VFS.files[path];
            if (!file) {
                console.warn('openFileTab: file not found:', path);
                return;
            }

            // Save current editor content to previous file (only if it's a text file)
            if (currentOpenFile && VFS.files[currentOpenFile] && !VFS.files[currentOpenFile].binary) {
                VFS.files[currentOpenFile].content = asmEditor.value;
            }

            // Add to open tabs if not already open
            if (!openTabs.includes(path)) {
                openTabs.push(path);
            }

            // Load file content into editor
            if (file.binary) {
                asmEditor.value = `; Binary file: ${path}\n; Size: ${file.content.length} bytes\n; Cannot edit binary files`;
                asmEditor.disabled = true;
            } else {
                asmEditor.value = file.content || '';
                asmEditor.disabled = false;
            }

            currentOpenFile = path;
            updateLineNumbers();
            updateHighlight();
            updateFileTabs();

            // Update defines dropdown when opening main file
            if (path === currentProjectMainFile || !currentProjectMainFile) {
                updateDefinesDropdown();
            }
            console.log('openFileTab: switched to', path);
        }

        // Close a file tab
        function closeFileTab(path) {
            const idx = openTabs.indexOf(path);
            if (idx === -1) return;

            openTabs.splice(idx, 1);
            delete fileModified[path];

            // If closing current file, switch to another
            if (currentOpenFile === path) {
                if (openTabs.length > 0) {
                    openFileTab(openTabs[Math.min(idx, openTabs.length - 1)]);
                } else {
                    currentOpenFile = null;
                    asmEditor.value = '';
                    asmEditor.disabled = false;
                    updateLineNumbers();
                    updateHighlight();
                }
            }

            updateFileTabs();
        }

        // Update file tabs display
        function updateFileTabs() {
            if (!asmFileTabs) return;
            asmFileTabs.innerHTML = '';

            for (const path of openTabs) {
                const file = VFS.files[path];
                if (!file) continue;

                const tab = document.createElement('div');
                tab.className = 'asm-file-tab';
                if (path === currentOpenFile) tab.classList.add('active');
                if (path === currentProjectMainFile) tab.classList.add('main');
                if (file.binary) tab.classList.add('binary');
                if (fileModified[path]) tab.classList.add('modified');

                const name = path.split('/').pop();
                tab.innerHTML = `<span class="tab-name" title="${path}">${name}</span><span class="tab-close">×</span>`;

                // Click on tab (anywhere except close button) to switch
                tab.addEventListener('click', (e) => {
                    if (!e.target.classList.contains('tab-close')) {
                        openFileTab(path);
                    }
                });

                // Close button
                tab.querySelector('.tab-close').addEventListener('click', (e) => {
                    e.stopPropagation();
                    closeFileTab(path);
                });

                // Right-click to set as main file
                tab.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    if (!file.binary) {
                        currentProjectMainFile = path;
                        updateFileTabs();
                        updateProjectButtons();
                        showMessage(`Main file set to: ${name}`);
                    }
                });

                asmFileTabs.appendChild(tab);
            }
        }

        // Show main file selection dialog (returns a Promise)
        function showMainFileDialog(files, title = 'Select Main File') {
            return new Promise((resolve) => {
                const asmFiles = files.filter(f => {
                    const ext = '.' + f.split('.').pop().toLowerCase();
                    return ['.asm', '.z80', '.s', '.a80'].includes(ext);
                });

                if (asmFiles.length === 0) {
                    showMessage('No assembly files found');
                    resolve(null);
                    return;
                }

                if (asmFiles.length === 1) {
                    resolve(asmFiles[0]);
                    return;
                }

                // Auto-detect main file
                const detected = VFS.findMainFile();

                // Sort files: detected main file first, then alphabetically
                asmFiles.sort((a, b) => a.localeCompare(b));
                if (detected) {
                    // Find detected file (exact match or case-insensitive)
                    let idx = asmFiles.indexOf(detected);
                    if (idx === -1) {
                        const detectedLower = detected.toLowerCase();
                        idx = asmFiles.findIndex(f => f.toLowerCase() === detectedLower);
                    }
                    if (idx > 0) {
                        const mainFile = asmFiles.splice(idx, 1)[0];
                        asmFiles.unshift(mainFile);
                    }
                }

                // Build dialog content
                fileSelectorTitle.textContent = title;
                fileSelectorBody.innerHTML = '';

                for (const path of asmFiles) {
                    const name = path.split('/').pop();
                    const isDetected = path === detected;

                    const item = document.createElement('div');
                    item.className = 'file-selector-item';
                    if (isDetected) item.classList.add('detected');

                    item.innerHTML = `
                        <span class="item-icon">📄</span>
                        <span class="item-name">${path}</span>
                        ${isDetected ? '<span class="item-hint">detected</span>' : ''}
                    `;

                    item.addEventListener('click', () => {
                        fileSelectorDialog.classList.add('hidden');
                        resolve(path);
                    });

                    fileSelectorBody.appendChild(item);
                }

                // Show dialog
                fileSelectorDialog.classList.remove('hidden');

                // Handle close button - use detected or first file
                const closeHandler = () => {
                    fileSelectorDialog.classList.add('hidden');
                    resolve(detected || asmFiles[0]);
                };
                btnFileSelectorClose.onclick = closeHandler;

                // Click outside to close
                fileSelectorDialog.onclick = (e) => {
                    if (e.target === fileSelectorDialog) {
                        closeHandler();
                    }
                };
            });
        }

        // Z80 instructions set for highlighting
        const Z80_INSTRUCTIONS = new Set([
            'ADC', 'ADD', 'AND', 'BIT', 'CALL', 'CCF', 'CP', 'CPD', 'CPDR', 'CPI', 'CPIR',
            'CPL', 'DAA', 'DEC', 'DI', 'DJNZ', 'EI', 'EX', 'EXX', 'HALT', 'IM', 'IN',
            'INC', 'IND', 'INDR', 'INI', 'INIR', 'JP', 'JR', 'LD', 'LDD', 'LDDR', 'LDI',
            'LDIR', 'NEG', 'NOP', 'OR', 'OTDR', 'OTIR', 'OUT', 'OUTD', 'OUTI', 'POP',
            'PUSH', 'RES', 'RET', 'RETI', 'RETN', 'RL', 'RLA', 'RLC', 'RLCA', 'RLD',
            'RR', 'RRA', 'RRC', 'RRCA', 'RRD', 'RST', 'SBC', 'SCF', 'SET', 'SLA', 'SLL',
            'SRA', 'SRL', 'SUB', 'XOR', 'DEFB', 'DEFW', 'DEFS', 'DB', 'DW', 'DS', 'DEFM',
            'DM', 'BYTE', 'WORD', 'BLOCK'
        ]);

        const Z80_DIRECTIVES = new Set([
            'ORG', 'EQU', 'INCLUDE', 'INCBIN', 'MACRO', 'ENDM', 'REPT', 'ENDR',
            'IF', 'ELSE', 'ENDIF', 'IFDEF', 'IFNDEF', 'ALIGN', 'PHASE', 'DEPHASE',
            'END', 'ASSERT', 'DEVICE', 'SLOT', 'PAGE', 'MODULE', 'ENDMODULE',
            'STRUCT', 'ENDS', 'SECTION', 'ENDSECTION', 'OUTPUT', 'LABELSLIST',
            'DISPLAY', 'SHELLEXEC', 'DEFINE', 'UNDEFINE', 'DUP', 'EDUP', 'PROC', 'ENDP'
        ]);

        const Z80_REGISTERS = new Set([
            'A', 'B', 'C', 'D', 'E', 'H', 'L', 'F', 'I', 'R',
            'AF', 'BC', 'DE', 'HL', 'IX', 'IY', 'SP', 'PC',
            'IXH', 'IXL', 'IYH', 'IYL', "AF'"
        ]);

        const Z80_CONDITIONS = new Set(['Z', 'NZ', 'C', 'NC', 'PE', 'PO', 'P', 'M']);

        // Simple tokenizer for syntax highlighting
        function tokenizeAsmLine(line) {
            const tokens = [];
            let pos = 0;

            while (pos < line.length) {
                const ch = line[pos];

                // Whitespace
                if (ch === ' ' || ch === '\t') {
                    let start = pos;
                    while (pos < line.length && (line[pos] === ' ' || line[pos] === '\t')) {
                        pos++;
                    }
                    tokens.push({ type: 'whitespace', value: line.slice(start, pos) });
                    continue;
                }

                // Comment (;)
                if (ch === ';') {
                    tokens.push({ type: 'comment', value: line.slice(pos) });
                    break;
                }

                // String
                if (ch === '"' || ch === "'") {
                    const quote = ch;
                    let start = pos;
                    pos++;
                    while (pos < line.length && line[pos] !== quote) {
                        if (line[pos] === '\\' && pos + 1 < line.length) pos++;
                        pos++;
                    }
                    if (pos < line.length) pos++; // closing quote
                    tokens.push({ type: 'string', value: line.slice(start, pos) });
                    continue;
                }

                // Number: $hex, #hex, 0x, %, binary, decimal, or suffix-based
                if (/[0-9$#%]/.test(ch)) {
                    let start = pos;
                    if (ch === '$' || ch === '#') {
                        pos++;
                        while (pos < line.length && /[0-9a-fA-F_]/.test(line[pos])) pos++;
                    } else if (ch === '%') {
                        pos++;
                        while (pos < line.length && /[01_]/.test(line[pos])) pos++;
                    } else if (ch === '0' && pos + 1 < line.length && (line[pos + 1] === 'x' || line[pos + 1] === 'X')) {
                        pos += 2;
                        while (pos < line.length && /[0-9a-fA-F_]/.test(line[pos])) pos++;
                    } else {
                        while (pos < line.length && /[0-9a-fA-F_]/.test(line[pos])) pos++;
                        if (pos < line.length && /[hHbBoOdDqQ]/.test(line[pos])) pos++;
                    }
                    tokens.push({ type: 'number', value: line.slice(start, pos) });
                    continue;
                }

                // Identifier (label, instruction, register)
                if (/[a-zA-Z_.]/.test(ch) || ch === '@') {
                    let start = pos;
                    pos++;
                    while (pos < line.length && /[a-zA-Z0-9_]/.test(line[pos])) pos++;
                    if (pos < line.length && line[pos] === "'") pos++; // AF'
                    const value = line.slice(start, pos);
                    const upper = value.toUpperCase();

                    // Check for colon after (label definition)
                    let isLabel = false;
                    let colonPos = pos;
                    while (colonPos < line.length && (line[colonPos] === ' ' || line[colonPos] === '\t')) colonPos++;
                    if (colonPos < line.length && line[colonPos] === ':') {
                        isLabel = true;
                    }
                    // Also check if starts with . (local label)
                    if (value.startsWith('.')) isLabel = true;

                    if (Z80_INSTRUCTIONS.has(upper)) {
                        tokens.push({ type: 'instruction', value });
                    } else if (Z80_DIRECTIVES.has(upper)) {
                        tokens.push({ type: 'directive', value });
                    } else if (Z80_REGISTERS.has(upper) || Z80_CONDITIONS.has(upper)) {
                        tokens.push({ type: 'register', value });
                    } else if (isLabel || start === 0) {
                        tokens.push({ type: 'label', value });
                    } else {
                        tokens.push({ type: 'identifier', value });
                    }
                    continue;
                }

                // Operators and punctuation
                if (ch === '(' || ch === ')' || ch === '[' || ch === ']') {
                    tokens.push({ type: 'paren', value: ch });
                    pos++;
                    continue;
                }

                if (ch === ':') {
                    tokens.push({ type: 'colon', value: ch });
                    pos++;
                    continue;
                }

                if (ch === ',') {
                    tokens.push({ type: 'comma', value: ch });
                    pos++;
                    continue;
                }

                if (/[+\-*\/%&|^~<>=!]/.test(ch)) {
                    let start = pos;
                    pos++;
                    // Handle two-char operators
                    if (pos < line.length && /[<>=&|]/.test(line[pos])) pos++;
                    tokens.push({ type: 'operator', value: line.slice(start, pos) });
                    continue;
                }

                // Unknown char
                tokens.push({ type: 'text', value: ch });
                pos++;
            }

            return tokens;
        }

        function escapeHtml(text) {
            return text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;');
        }

        function highlightAsmCode(code) {
            const lines = code.split('\n');
            return lines.map(line => {
                const tokens = tokenizeAsmLine(line);
                return tokens.map(token => {
                    const escaped = escapeHtml(token.value);
                    switch (token.type) {
                        case 'instruction':
                            return `<span class="asm-hl-instruction">${escaped}</span>`;
                        case 'directive':
                            return `<span class="asm-hl-directive">${escaped}</span>`;
                        case 'register':
                            return `<span class="asm-hl-register">${escaped}</span>`;
                        case 'number':
                            return `<span class="asm-hl-number">${escaped}</span>`;
                        case 'string':
                            return `<span class="asm-hl-string">${escaped}</span>`;
                        case 'label':
                            return `<span class="asm-hl-label">${escaped}</span>`;
                        case 'comment':
                            return `<span class="asm-hl-comment">${escaped}</span>`;
                        case 'paren':
                            return `<span class="asm-hl-paren">${escaped}</span>`;
                        case 'operator':
                            return `<span class="asm-hl-operator">${escaped}</span>`;
                        default:
                            return escaped;
                    }
                }).join('');
            }).join('\n');
        }

        function updateLineNumbers() {
            const lines = asmEditor.value.split('\n');
            const lineCount = lines.length;
            let html = '';
            for (let i = 1; i <= lineCount; i++) {
                html += i + '\n';
            }
            asmLineNumbers.textContent = html;
        }

        function updateHighlight() {
            try {
                // Add newline at end to prevent highlighting collapse
                const code = asmEditor.value + (asmEditor.value.endsWith('\n') ? '' : '\n');
                asmHighlight.innerHTML = highlightAsmCode(code);
                asmEditor.classList.add('highlighting');
            } catch (e) {
                console.error('Highlight error:', e);
                asmEditor.classList.remove('highlighting');
            }
        }

        function syncScroll() {
            asmHighlight.scrollTop = asmEditor.scrollTop;
            asmHighlight.scrollLeft = asmEditor.scrollLeft;
            asmLineNumbers.scrollTop = asmEditor.scrollTop;
        }

        // Sync editor to VFS when in project mode
        function syncEditorToVFS() {
            if (currentOpenFile && VFS.files[currentOpenFile] && !VFS.files[currentOpenFile].binary) {
                VFS.files[currentOpenFile].content = asmEditor.value;
            }
        }

        // Editor event listeners
        if (asmEditor) {
            // Debounce timer for defines detection
            let definesUpdateTimer = null;

            asmEditor.addEventListener('input', () => {
                updateLineNumbers();
                updateHighlight();
                syncEditorToVFS();
                updateProjectButtons();

                // Debounced update of defines dropdown (only when editing main file)
                if (!currentOpenFile || currentOpenFile === currentProjectMainFile) {
                    clearTimeout(definesUpdateTimer);
                    definesUpdateTimer = setTimeout(updateDefinesDropdown, 500);
                }
            });

            asmEditor.addEventListener('scroll', syncScroll);

            asmEditor.addEventListener('keydown', (e) => {
                // Tab inserts actual tab
                if (e.key === 'Tab') {
                    e.preventDefault();
                    const start = asmEditor.selectionStart;
                    const end = asmEditor.selectionEnd;
                    asmEditor.value = asmEditor.value.substring(0, start) + '\t' + asmEditor.value.substring(end);
                    asmEditor.selectionStart = asmEditor.selectionEnd = start + 1;
                    updateLineNumbers();
                    updateHighlight();
                }
                // Ctrl+F - Find
                if (e.ctrlKey && e.key === 'f') {
                    e.preventDefault();
                    openSearchBar(false);
                }
                // Ctrl+H or Ctrl+R - Replace
                if (e.ctrlKey && (e.key === 'h' || e.key === 'r')) {
                    e.preventDefault();
                    openSearchBar(true);
                }
                // F3 - Find Next
                if (e.key === 'F3' && !e.shiftKey) {
                    e.preventDefault();
                    findNext();
                }
                // Shift+F3 - Find Previous
                if (e.key === 'F3' && e.shiftKey) {
                    e.preventDefault();
                    findPrev();
                }
                // Escape - Close search
                if (e.key === 'Escape' && asmSearchBar.style.display !== 'none') {
                    closeSearchBar();
                }
            });

            // Drag & drop file loading
            const asmEditorContainer = asmEditor.parentElement;

            asmEditorContainer.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                asmEditorContainer.classList.add('drag-over');
            });

            asmEditorContainer.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                asmEditorContainer.classList.remove('drag-over');
            });

            asmEditorContainer.addEventListener('drop', async (e) => {
                e.preventDefault();
                e.stopPropagation();
                asmEditorContainer.classList.remove('drag-over');

                const files = e.dataTransfer.files;
                if (files && files.length > 0) {
                    await loadAsmFiles(files);
                }
            });

            // Initial update
            updateLineNumbers();
            updateHighlight();
        }

        // Find existing files in VFS with the same basename
        function findFilesByBasename(basename) {
            const matches = [];
            const basenameLower = basename.toLowerCase();
            for (const path of VFS.listFiles()) {
                const pathBasename = path.split('/').pop().toLowerCase();
                if (pathBasename === basenameLower) {
                    matches.push(path);
                }
            }
            return matches;
        }

        // Show dialog to choose where to put a file
        async function showFileReplaceDialog(filename, existingPaths) {
            return new Promise((resolve) => {
                const overlay = document.createElement('div');
                overlay.className = 'modal-overlay';
                overlay.innerHTML = `
                    <div class="modal" style="max-width: 400px;">
                        <h3 style="margin-top:0;">File already exists</h3>
                        <p>A file named "<b>${filename}</b>" already exists in the project.</p>
                        <p>Where should the new file be placed?</p>
                        <div id="fileReplaceOptions" style="margin: 15px 0;"></div>
                        <div style="text-align: right;">
                            <button id="fileReplaceCancel" style="margin-right: 10px;">Cancel</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(overlay);

                const optionsDiv = overlay.querySelector('#fileReplaceOptions');

                // Add option to replace each existing file
                for (const path of existingPaths) {
                    const btn = document.createElement('button');
                    btn.style.cssText = 'display: block; width: 100%; margin: 5px 0; text-align: left; padding: 8px;';
                    btn.textContent = `Replace: ${path}`;
                    btn.onclick = () => {
                        document.body.removeChild(overlay);
                        resolve({ action: 'replace', path: path });
                    };
                    optionsDiv.appendChild(btn);
                }

                // Add option to create new file at root
                const rootPath = filename.toLowerCase();
                if (!existingPaths.includes(rootPath)) {
                    const btn = document.createElement('button');
                    btn.style.cssText = 'display: block; width: 100%; margin: 5px 0; text-align: left; padding: 8px;';
                    btn.textContent = `Add as new: ${filename}`;
                    btn.onclick = () => {
                        document.body.removeChild(overlay);
                        resolve({ action: 'new', path: filename });
                    };
                    optionsDiv.appendChild(btn);
                }

                overlay.querySelector('#fileReplaceCancel').onclick = () => {
                    document.body.removeChild(overlay);
                    resolve({ action: 'cancel' });
                };
            });
        }

        // Reusable file loading function (for Load button and drag & drop)
        async function loadAsmFiles(files) {
            const textExtensions = ['.asm', '.z80', '.s', '.a80', '.inc', '.txt', '.def', '.h'];
            let totalAdded = 0;
            let lastAddedFile = null;
            let needsMainFile = !currentProjectMainFile;

            try {
                for (const file of files) {
                    const arrayBuffer = await file.arrayBuffer();

                    // Check if it's a ZIP file
                    if (file.name.toLowerCase().endsWith('.zip') && ZipLoader.isZip(arrayBuffer)) {
                        const zipFiles = await ZipLoader.extract(arrayBuffer);

                        // Track which files from ZIP will update open tabs
                        const updatedPaths = [];

                        for (const f of zipFiles) {
                            if (f.name.endsWith('/') || f.name.startsWith('.') || f.name.includes('/.')) continue;

                            const ext = '.' + f.name.split('.').pop().toLowerCase();
                            const isText = textExtensions.includes(ext);
                            const normalizedPath = VFS.normalizePath(f.name);

                            // Check if this file is already open in a tab
                            if (openTabs.includes(normalizedPath)) {
                                updatedPaths.push(normalizedPath);
                            }

                            if (isText) {
                                const decoder = new TextDecoder('utf-8');
                                VFS.addFile(f.name, decoder.decode(f.data));
                                if (['.asm', '.z80', '.s', '.a80'].includes(ext)) {
                                    lastAddedFile = normalizedPath;
                                }
                            } else {
                                VFS.addBinaryFile(f.name, f.data);
                            }
                            totalAdded++;
                        }

                        // Remove updated files from open tabs so they get refreshed
                        for (const path of updatedPaths) {
                            const idx = openTabs.indexOf(path);
                            if (idx !== -1) {
                                openTabs.splice(idx, 1);
                            }
                        }

                        // If current file was updated, clear it to prevent old content being saved back
                        if (currentOpenFile && updatedPaths.includes(currentOpenFile)) {
                            currentOpenFile = null;
                        }

                        // Prefer opening the main file if it exists in the ZIP
                        if (currentProjectMainFile && updatedPaths.includes(currentProjectMainFile)) {
                            lastAddedFile = currentProjectMainFile;
                        }
                    } else {
                        // Single file - check for duplicates
                        const ext = '.' + file.name.split('.').pop().toLowerCase();
                        const isText = textExtensions.includes(ext);
                        const basename = file.name.split('/').pop();
                        const existingFiles = findFilesByBasename(basename);

                        let targetPath = file.name;

                        if (existingFiles.length > 0) {
                            // Check if exact path match exists
                            const normalizedInput = VFS.normalizePath(file.name);
                            const exactMatch = existingFiles.find(p => p === normalizedInput);

                            if (exactMatch) {
                                // Exact match - just replace
                                targetPath = exactMatch;
                                // If this file is currently open, clear currentOpenFile
                                // to prevent openFileTab from saving old content back
                                if (currentOpenFile === exactMatch) {
                                    currentOpenFile = null;
                                }
                                // Remove from open tabs (will reopen with new content)
                                const oldTabIdx = openTabs.indexOf(exactMatch);
                                if (oldTabIdx !== -1) {
                                    openTabs.splice(oldTabIdx, 1);
                                }
                            } else {
                                // Same basename but different path - ask user
                                const result = await showFileReplaceDialog(basename, existingFiles);
                                if (result.action === 'cancel') {
                                    continue; // Skip this file
                                } else if (result.action === 'replace') {
                                    targetPath = result.path;
                                    // If this file is currently open, clear currentOpenFile
                                    // to prevent openFileTab from saving old content back
                                    if (currentOpenFile === result.path) {
                                        currentOpenFile = null;
                                    }
                                    // Close old tab if open (will reopen with new content)
                                    const oldTabIdx = openTabs.indexOf(result.path);
                                    if (oldTabIdx !== -1) {
                                        openTabs.splice(oldTabIdx, 1);
                                    }
                                } else {
                                    targetPath = result.path;
                                }
                            }
                        }

                        if (isText) {
                            const decoder = new TextDecoder('utf-8');
                            VFS.addFile(targetPath, decoder.decode(new Uint8Array(arrayBuffer)));
                            if (['.asm', '.z80', '.s', '.a80'].includes(ext)) {
                                lastAddedFile = VFS.normalizePath(targetPath);
                            }
                        } else {
                            VFS.addBinaryFile(targetPath, new Uint8Array(arrayBuffer));
                        }
                        totalAdded++;
                    }
                }

                // If no main file set and we added source files, ask to select
                if (needsMainFile && lastAddedFile) {
                    const allFiles = VFS.listFiles();
                    const mainFile = await showMainFileDialog(allFiles);
                    if (mainFile) {
                        currentProjectMainFile = mainFile;
                        openFileTab(mainFile);
                    }
                } else if (lastAddedFile) {
                    // Open the last added source file
                    openFileTab(lastAddedFile);
                }

                updateProjectButtons();
                updateDefinesDropdown();
                updateFileTabs();
                showMessage(totalAdded > 0 ? `Added/updated ${totalAdded} file(s)` : 'No files added');

            } catch (err) {
                console.error('Load error:', err);
                showMessage('Error loading: ' + err.message);
            }
        }

        // Search/Replace functionality
        const asmSearchBar = document.getElementById('asmSearchBar');
        const asmSearchInput = document.getElementById('asmSearchInput');
        const asmReplaceInput = document.getElementById('asmReplaceInput');
        const asmReplaceRow = document.getElementById('asmReplaceRow');
        const asmSearchCount = document.getElementById('asmSearchCount');
        const chkAsmSearchCase = document.getElementById('chkAsmSearchCase');
        const btnAsmFindNext = document.getElementById('btnAsmFindNext');
        const btnAsmFindPrev = document.getElementById('btnAsmFindPrev');
        const btnAsmReplace = document.getElementById('btnAsmReplace');
        const btnAsmReplaceAll = document.getElementById('btnAsmReplaceAll');
        const btnAsmSearchAll = document.getElementById('btnAsmSearchAll');
        const btnAsmSearchClose = document.getElementById('btnAsmSearchClose');
        const asmSearchResults = document.getElementById('asmSearchResults');

        let searchMatches = [];
        let currentMatchIndex = -1;

        function openSearchBar(showReplace) {
            asmSearchBar.style.display = 'flex';
            asmReplaceRow.style.display = showReplace ? 'flex' : 'none';
            asmSearchResults.style.display = 'none';
            asmSearchInput.focus();
            // Pre-fill with selected text
            const selected = asmEditor.value.substring(asmEditor.selectionStart, asmEditor.selectionEnd);
            if (selected && !selected.includes('\n')) {
                asmSearchInput.value = selected;
            }
            asmSearchInput.select();
            updateSearchMatches();
        }

        function closeSearchBar() {
            asmSearchBar.style.display = 'none';
            asmSearchResults.style.display = 'none';
            asmEditor.focus();
        }

        function searchAllFiles() {
            const query = asmSearchInput.value;
            if (!query) {
                asmSearchResults.style.display = 'none';
                return;
            }

            const caseSensitive = chkAsmSearchCase.checked;
            const results = [];

            // Get all files from VFS
            const files = VFS.listFiles();
            if (files.length === 0) {
                // Just search current editor
                const currentResults = searchInText(asmEditor.value, query, caseSensitive, currentOpenFile || 'untitled');
                results.push(...currentResults);
            } else {
                // Save current editor to VFS first
                if (currentOpenFile && VFS.files[currentOpenFile] && !VFS.files[currentOpenFile].binary) {
                    VFS.files[currentOpenFile].content = asmEditor.value;
                }
                // Search all files (skip binary files)
                for (const filename of files) {
                    const file = VFS.files[filename];
                    if (file && !file.binary) {
                        const fileResults = searchInText(file.content, query, caseSensitive, filename);
                        results.push(...fileResults);
                    }
                }
            }

            // Display results
            if (results.length === 0) {
                asmSearchResults.innerHTML = '<div class="asm-search-results-header">No results found</div>';
            } else {
                let html = `<div class="asm-search-results-header">Found ${results.length} result${results.length !== 1 ? 's' : ''} in ${new Set(results.map(r => r.file)).size} file${new Set(results.map(r => r.file)).size !== 1 ? 's' : ''}</div>`;
                for (const r of results) {
                    const escapedText = escapeHtml(r.lineText);
                    const highlightedText = highlightMatch(escapedText, query, caseSensitive);
                    html += `<div class="asm-search-result-item" data-file="${escapeHtml(r.file)}" data-line="${r.lineNum}" data-col="${r.col}">`;
                    html += `<span class="asm-search-result-file">${escapeHtml(r.file)}</span>`;
                    html += `<span class="asm-search-result-line">${r.lineNum}</span>`;
                    html += `<span class="asm-search-result-text">${highlightedText}</span>`;
                    html += `</div>`;
                }
                asmSearchResults.innerHTML = html;

                // Add click handlers
                asmSearchResults.querySelectorAll('.asm-search-result-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const file = item.dataset.file;
                        const line = parseInt(item.dataset.line);
                        const col = parseInt(item.dataset.col);
                        goToSearchResult(file, line, col, query.length);
                    });
                });
            }
            asmSearchResults.style.display = 'block';
        }

        function searchInText(text, query, caseSensitive, filename) {
            const results = [];
            const lines = text.split('\n');
            const searchQuery = caseSensitive ? query : query.toLowerCase();

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const searchLine = caseSensitive ? line : line.toLowerCase();
                let col = 0;
                while ((col = searchLine.indexOf(searchQuery, col)) !== -1) {
                    results.push({
                        file: filename,
                        lineNum: i + 1,
                        col: col,
                        lineText: line.trim()
                    });
                    col += searchQuery.length;
                }
            }
            return results;
        }

        function highlightMatch(text, query, caseSensitive) {
            const flags = caseSensitive ? 'g' : 'gi';
            const regex = new RegExp(query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), flags);
            return text.replace(regex, match => `<span class="asm-search-result-match">${match}</span>`);
        }

        function goToSearchResult(file, lineNum, col, matchLen) {
            // If different file, switch to it
            if (file !== currentOpenFile && VFS.listFiles().length > 0) {
                // Save current file first
                if (currentOpenFile && VFS.files[currentOpenFile] && !VFS.files[currentOpenFile].binary) {
                    VFS.files[currentOpenFile].content = asmEditor.value;
                }
                // Open target file
                const targetFile = VFS.files[file];
                if (targetFile && !targetFile.binary) {
                    if (!openTabs.includes(file)) {
                        openTabs.push(file);
                    }
                    currentOpenFile = file;
                    asmEditor.value = targetFile.content;
                    updateFileTabs();
                    updateLineNumbers();
                    updateHighlight();
                }
            }

            // Go to line and select match
            const lines = asmEditor.value.split('\n');
            let pos = 0;
            for (let i = 0; i < lineNum - 1 && i < lines.length; i++) {
                pos += lines[i].length + 1;
            }
            pos += col;
            asmEditor.focus();
            asmEditor.setSelectionRange(pos, pos + matchLen);
            // Scroll into view
            const lineHeight = 18;
            const scrollTop = (lineNum - 5) * lineHeight;
            asmEditor.scrollTop = Math.max(0, scrollTop);
        }

        function updateSearchMatches() {
            const query = asmSearchInput.value;
            searchMatches = [];
            currentMatchIndex = -1;

            if (!query) {
                asmSearchCount.textContent = '';
                return;
            }

            const text = asmEditor.value;
            const caseSensitive = chkAsmSearchCase.checked;
            const searchText = caseSensitive ? text : text.toLowerCase();
            const searchQuery = caseSensitive ? query : query.toLowerCase();

            let pos = 0;
            while ((pos = searchText.indexOf(searchQuery, pos)) !== -1) {
                searchMatches.push(pos);
                pos += searchQuery.length;
            }

            if (searchMatches.length > 0) {
                // Find closest match to cursor
                const cursor = asmEditor.selectionStart;
                currentMatchIndex = 0;
                for (let i = 0; i < searchMatches.length; i++) {
                    if (searchMatches[i] >= cursor) {
                        currentMatchIndex = i;
                        break;
                    }
                }
                asmSearchCount.textContent = `${currentMatchIndex + 1} of ${searchMatches.length}`;
            } else {
                asmSearchCount.textContent = 'No results';
            }
        }

        function findNext() {
            if (searchMatches.length === 0) {
                updateSearchMatches();
                if (searchMatches.length === 0) return;
            }

            currentMatchIndex = (currentMatchIndex + 1) % searchMatches.length;
            selectMatch();
        }

        function findPrev() {
            if (searchMatches.length === 0) {
                updateSearchMatches();
                if (searchMatches.length === 0) return;
            }

            currentMatchIndex = (currentMatchIndex - 1 + searchMatches.length) % searchMatches.length;
            selectMatch();
        }

        function selectMatch() {
            if (currentMatchIndex < 0 || currentMatchIndex >= searchMatches.length) return;

            const pos = searchMatches[currentMatchIndex];
            const len = asmSearchInput.value.length;
            asmEditor.focus();
            asmEditor.setSelectionRange(pos, pos + len);

            // Scroll to selection
            const lineHeight = 16;
            const lines = asmEditor.value.substring(0, pos).split('\n').length - 1;
            asmEditor.scrollTop = Math.max(0, lines * lineHeight - asmEditor.clientHeight / 2);

            asmSearchCount.textContent = `${currentMatchIndex + 1} of ${searchMatches.length}`;
        }

        function replaceOne() {
            if (searchMatches.length === 0 || currentMatchIndex < 0) return;

            const pos = searchMatches[currentMatchIndex];
            const len = asmSearchInput.value.length;
            const replacement = asmReplaceInput.value;

            const before = asmEditor.value.substring(0, pos);
            const after = asmEditor.value.substring(pos + len);
            asmEditor.value = before + replacement + after;

            updateLineNumbers();
            updateHighlight();
            syncEditorToVFS();

            // Update matches and find next
            updateSearchMatches();
            if (searchMatches.length > 0) {
                if (currentMatchIndex >= searchMatches.length) {
                    currentMatchIndex = 0;
                }
                selectMatch();
            }
        }

        function replaceAll() {
            const query = asmSearchInput.value;
            if (!query) return;

            const replacement = asmReplaceInput.value;
            const caseSensitive = chkAsmSearchCase.checked;

            let text = asmEditor.value;
            let count = 0;

            if (caseSensitive) {
                while (text.includes(query)) {
                    text = text.replace(query, replacement);
                    count++;
                }
            } else {
                const regex = new RegExp(query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
                const matches = text.match(regex);
                count = matches ? matches.length : 0;
                text = text.replace(regex, replacement);
            }

            asmEditor.value = text;
            updateLineNumbers();
            updateHighlight();
            syncEditorToVFS();
            updateSearchMatches();

            asmSearchCount.textContent = `Replaced ${count}`;
        }

        // Search bar event listeners
        if (asmSearchInput) {
            asmSearchInput.addEventListener('input', updateSearchMatches);
            asmSearchInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    if (e.shiftKey) findPrev();
                    else findNext();
                }
                if (e.key === 'Escape') closeSearchBar();
            });
        }
        if (asmReplaceInput) {
            asmReplaceInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    replaceOne();
                }
                if (e.key === 'Escape') closeSearchBar();
            });
        }
        if (chkAsmSearchCase) {
            chkAsmSearchCase.addEventListener('change', updateSearchMatches);
        }
        if (btnAsmFindNext) btnAsmFindNext.addEventListener('click', findNext);
        if (btnAsmFindPrev) btnAsmFindPrev.addEventListener('click', findPrev);
        if (btnAsmReplace) btnAsmReplace.addEventListener('click', replaceOne);
        if (btnAsmReplaceAll) btnAsmReplaceAll.addEventListener('click', replaceAll);
        if (btnAsmSearchClose) btnAsmSearchClose.addEventListener('click', closeSearchBar);
        if (btnAsmSearchAll) btnAsmSearchAll.addEventListener('click', searchAllFiles);

        updateProjectButtons();

        // Button handlers
        if (btnAsmClear) {
            btnAsmClear.addEventListener('click', () => {
                asmEditor.value = '';
                asmOutput.innerHTML = '<span class="asm-hint">Press Assemble to compile</span>';
                updateLineNumbers();
                updateHighlight();
                // Close any open project and reset tabs
                VFS.reset();
                currentProjectMainFile = null;
                currentOpenFile = null;
                openTabs = [];
                fileModified = {};
                updateFileTabs();
                updateProjectButtons();
                updateDefinesDropdown();
                // Disable inject since nothing is assembled
                assembledBytes = null;
                btnAsmInject.disabled = true;
                btnAsmDebug.disabled = true;
                btnAsmDownload.disabled = true;
            });
        }

        if (btnAsmNew) {
            btnAsmNew.addEventListener('click', () => {
                // Prompt for filename
                const defaultName = `file${Object.keys(VFS.files).length + 1}.asm`;
                const filename = prompt('Enter filename:', defaultName);
                if (!filename) return;

                // Ensure it has an extension
                let finalName = filename.trim();
                if (!finalName.includes('.')) {
                    finalName += '.asm';
                }

                // Check if file already exists
                const normalized = finalName.replace(/\\/g, '/').toLowerCase();
                for (const path in VFS.files) {
                    if (path.toLowerCase() === normalized) {
                        showMessage(`File already exists: ${finalName}`);
                        return;
                    }
                }

                // Create empty file in VFS
                const template = `; ${finalName}\n; Created: ${new Date().toLocaleDateString()}\n\n        ORG $8000\n\nstart:\n        ret\n`;
                VFS.addFile(finalName, template);

                // Set as main file if no main file yet
                if (!currentProjectMainFile) {
                    currentProjectMainFile = finalName;
                }

                // Open in tab
                openFileTab(finalName);
                updateProjectButtons();
                showMessage(`Created: ${finalName}`);
            });
        }

        if (btnAsmLoad) {
            btnAsmLoad.addEventListener('click', () => {
                asmFileInput.click();
            });
        }

        // Files dropdown handler
        if (btnAsmFiles) {
            btnAsmFiles.addEventListener('click', (e) => {
                e.stopPropagation();
                updateFilesList();
                asmFilesList.classList.toggle('show');
            });

            // Close dropdown when clicking outside
            document.addEventListener('click', (e) => {
                if (asmFilesList && !asmFilesDropdown.contains(e.target)) {
                    asmFilesList.classList.remove('show');
                }
            });
        }

        // Click handler for main file label - allows changing main file
        if (asmMainFileLabel) {
            asmMainFileLabel.addEventListener('click', async () => {
                const allFiles = VFS.listFiles();
                const newMain = await showMainFileDialog(allFiles, 'Change Main File');
                if (newMain) {
                    currentProjectMainFile = newMain;
                    updateFileTabs();
                    updateProjectButtons();
                    showMessage(`Main file set to: ${newMain.split('/').pop()}`);
                }
            });
        }

        // File loader - always adds/merges files (never resets VFS)
        if (asmFileInput) {
            asmFileInput.addEventListener('change', async (e) => {
                const files = e.target.files;
                if (!files || files.length === 0) return;
                await loadAsmFiles(files);
                asmFileInput.value = '';
            });
        }

        // Export source files as ZIP
        if (btnAsmExport) {
            btnAsmExport.addEventListener('click', () => {
                // Sync current editor to VFS first
                syncEditorToVFS();

                // Collect source files only (skip binary)
                const sourceFiles = [];
                const textExtensions = ['.asm', '.z80', '.s', '.a80', '.inc', '.txt', '.def', '.h'];

                for (const path in VFS.files) {
                    const file = VFS.files[path];
                    if (!file.binary) {
                        const ext = '.' + path.split('.').pop().toLowerCase();
                        if (textExtensions.includes(ext) || !path.includes('.')) {
                            sourceFiles.push({ name: path, content: file.content });
                        }
                    }
                }

                if (sourceFiles.length === 0) {
                    showMessage('No source files to export');
                    return;
                }

                // Create simple uncompressed ZIP
                const zipParts = [];
                const centralDir = [];
                let offset = 0;

                for (const file of sourceFiles) {
                    const nameBytes = new TextEncoder().encode(file.name);
                    const contentBytes = new TextEncoder().encode(file.content);

                    // CRC-32 calculation
                    let crc = 0xFFFFFFFF;
                    for (const byte of contentBytes) {
                        crc ^= byte;
                        for (let i = 0; i < 8; i++) {
                            crc = (crc >>> 1) ^ (crc & 1 ? 0xEDB88320 : 0);
                        }
                    }
                    crc ^= 0xFFFFFFFF;

                    // Local file header
                    const localHeader = new Uint8Array(30 + nameBytes.length);
                    const lhView = new DataView(localHeader.buffer);
                    lhView.setUint32(0, 0x04034b50, true);  // Signature
                    lhView.setUint16(4, 20, true);          // Version needed
                    lhView.setUint16(6, 0, true);           // Flags
                    lhView.setUint16(8, 0, true);           // Compression (0=store)
                    lhView.setUint16(10, 0, true);          // Mod time
                    lhView.setUint16(12, 0, true);          // Mod date
                    lhView.setUint32(14, crc >>> 0, true);  // CRC-32
                    lhView.setUint32(18, contentBytes.length, true);  // Compressed size
                    lhView.setUint32(22, contentBytes.length, true);  // Uncompressed size
                    lhView.setUint16(26, nameBytes.length, true);     // Name length
                    lhView.setUint16(28, 0, true);          // Extra length
                    localHeader.set(nameBytes, 30);

                    // Central directory entry
                    const cdEntry = new Uint8Array(46 + nameBytes.length);
                    const cdView = new DataView(cdEntry.buffer);
                    cdView.setUint32(0, 0x02014b50, true);  // Signature
                    cdView.setUint16(4, 20, true);          // Version made by
                    cdView.setUint16(6, 20, true);          // Version needed
                    cdView.setUint16(8, 0, true);           // Flags
                    cdView.setUint16(10, 0, true);          // Compression
                    cdView.setUint16(12, 0, true);          // Mod time
                    cdView.setUint16(14, 0, true);          // Mod date
                    cdView.setUint32(16, crc >>> 0, true);  // CRC-32
                    cdView.setUint32(20, contentBytes.length, true);  // Compressed
                    cdView.setUint32(24, contentBytes.length, true);  // Uncompressed
                    cdView.setUint16(28, nameBytes.length, true);     // Name length
                    cdView.setUint16(30, 0, true);          // Extra length
                    cdView.setUint16(32, 0, true);          // Comment length
                    cdView.setUint16(34, 0, true);          // Disk start
                    cdView.setUint16(36, 0, true);          // Internal attrs
                    cdView.setUint32(38, 0, true);          // External attrs
                    cdView.setUint32(42, offset, true);     // Local header offset
                    cdEntry.set(nameBytes, 46);

                    zipParts.push(localHeader);
                    zipParts.push(contentBytes);
                    centralDir.push(cdEntry);
                    offset += localHeader.length + contentBytes.length;
                }

                // Central directory
                const cdOffset = offset;
                let cdSize = 0;
                for (const entry of centralDir) {
                    zipParts.push(entry);
                    cdSize += entry.length;
                }

                // End of central directory
                const eocd = new Uint8Array(22);
                const eocdView = new DataView(eocd.buffer);
                eocdView.setUint32(0, 0x06054b50, true);    // Signature
                eocdView.setUint16(4, 0, true);             // Disk number
                eocdView.setUint16(6, 0, true);             // CD disk
                eocdView.setUint16(8, sourceFiles.length, true);   // Entries on disk
                eocdView.setUint16(10, sourceFiles.length, true);  // Total entries
                eocdView.setUint32(12, cdSize, true);       // CD size
                eocdView.setUint32(16, cdOffset, true);     // CD offset
                eocdView.setUint16(20, 0, true);            // Comment length
                zipParts.push(eocd);

                // Combine all parts
                const totalSize = zipParts.reduce((sum, p) => sum + p.length, 0);
                const zipData = new Uint8Array(totalSize);
                let pos = 0;
                for (const part of zipParts) {
                    zipData.set(part, pos);
                    pos += part.length;
                }

                // Download
                const blob = new Blob([zipData], { type: 'application/zip' });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = 'project_source.zip';
                a.click();
                URL.revokeObjectURL(a.href);

                showMessage(`Exported ${sourceFiles.length} source file(s)`);
            });
        }

        // Simple assembler - enough for basic code
        if (btnAsmAssemble) {
            btnAsmAssemble.addEventListener('click', assembleCode);
        }

        // Assembled bytes storage
        let assembledBytes = null;
        let assembledOrg = 0;
        let assembledOrgAddresses = [];  // All ORG addresses from assembly
        let assembledSaveCommands = [];  // SAVESNA/SAVETAP commands from assembly

        // Navigate to file:line in editor
        function goToFileLine(file, line) {
            // Normalize file path
            const normalizedFile = file ? file.replace(/\\/g, '/').toLowerCase() : null;

            // Find the file in VFS
            let targetPath = null;
            if (normalizedFile) {
                for (const path in VFS.files) {
                    if (path.toLowerCase() === normalizedFile ||
                        path.toLowerCase().endsWith('/' + normalizedFile) ||
                        normalizedFile.endsWith('/' + path.toLowerCase())) {
                        targetPath = path;
                        break;
                    }
                }
            }

            // If file found and it's different from current, open it
            if (targetPath && targetPath !== currentOpenFile) {
                openFileTab(targetPath);
            }

            // Go to line in editor
            if (line && asmEditor) {
                const lines = asmEditor.value.split('\n');
                const lineIndex = Math.max(0, Math.min(line - 1, lines.length - 1));
                let charPos = 0;
                for (let i = 0; i < lineIndex; i++) {
                    charPos += lines[i].length + 1;
                }
                asmEditor.focus();
                asmEditor.setSelectionRange(charPos, charPos + lines[lineIndex].length);
                // Scroll to make the line visible
                const lineHeight = parseInt(getComputedStyle(asmEditor).lineHeight) || 18;
                asmEditor.scrollTop = Math.max(0, (lineIndex - 5) * lineHeight);
            }
        }

        // Format error/warning location as clickable HTML
        function formatErrorLocation(file, line, message, isError) {
            const cssClass = isError ? 'asm-error' : 'asm-warning';
            const prefix = isError ? 'Error' : 'Warning';
            let location = '';

            if (file) {
                const shortFile = file.split('/').pop();
                location = `${shortFile}:${line || '?'}`;
            } else if (line) {
                location = `Line ${line}`;
            }

            const escapedMsg = escapeHtml(message);
            const dataFile = file ? `data-file="${escapeHtml(file)}"` : '';
            const dataLine = line ? `data-line="${line}"` : '';

            return `<div class="${cssClass} asm-clickable" ${dataFile} ${dataLine} style="cursor:pointer" title="Click to go to location">${prefix}: ${location}: ${escapedMsg}</div>`;
        }

        // Scan source file header for @define markers (first 50 lines)
        // Format: ; @define NAME or ; @define NAME=VALUE
        function detectDefinesFromSource() {
            const defines = [];

            // Get content from main file in project mode, or current editor
            let content = '';
            const mainFile = currentProjectMainFile || currentOpenFile;
            if (mainFile && VFS.files[mainFile] && !VFS.files[mainFile].binary) {
                content = VFS.files[mainFile].content;
            } else if (asmEditor) {
                content = asmEditor.value;
            }

            if (!content) return defines;

            // Only check first 50 lines for @define markers
            const lines = content.split('\n').slice(0, 50);
            for (const line of lines) {
                const match = line.match(/^\s*;\s*@define\s+(\w+)(?:\s*=\s*(.+))?/i);
                if (match) {
                    defines.push({
                        name: match[1],
                        value: match[2] !== undefined ? match[2].trim() : '1'
                    });
                }
            }

            return defines;
        }

        // Update defines dropdown based on @define markers in source
        function updateDefinesDropdown() {
            if (!asmDetectedDefines) return;

            const defines = detectDefinesFromSource();

            if (defines.length === 0) {
                asmDetectedDefines.style.display = 'none';
                return;
            }

            // Build options
            asmDetectedDefines.innerHTML = defines.map(d =>
                `<option value="${d.name}" data-value="${d.value}">${d.name}${d.value !== '1' ? '=' + d.value : ''}</option>`
            ).join('');

            // Adjust size based on count
            asmDetectedDefines.size = Math.min(defines.length, 4);
            asmDetectedDefines.style.display = 'inline-block';
            asmDetectedDefines.title = `Available defines from @define markers (${defines.length})\nCtrl+click to select multiple`;
        }

        // Get selected defines from dropdown
        function getSelectedDefinesFromDropdown() {
            if (!asmDetectedDefines) return [];

            const selected = [];
            for (const opt of asmDetectedDefines.selectedOptions) {
                const valueStr = opt.dataset.value;
                // Parse value
                let value = 1;
                if (valueStr && valueStr !== '1') {
                    if (/^-?\d+$/.test(valueStr)) {
                        value = parseInt(valueStr, 10);
                    } else if (/^[\$0x]/i.test(valueStr)) {
                        value = parseInt(valueStr.replace(/^[\$0x]/i, ''), 16);
                    } else {
                        value = valueStr; // Keep as string
                    }
                }
                selected.push({ name: opt.value, value });
            }
            return selected;
        }

        function assembleCode() {
            // Show "Assembling..." immediately and let browser repaint
            asmOutput.innerHTML = '<span class="asm-hint">Assembling...</span>';
            setTimeout(doAssemble, 0);
        }

        function doAssemble() {
            // Sync current editor to VFS before assembly
            if (currentOpenFile && VFS.files[currentOpenFile] && !VFS.files[currentOpenFile].binary) {
                VFS.files[currentOpenFile].content = asmEditor.value;
            }

            // Use the project main file name if available, otherwise default to current file or 'editor.asm'
            const filename = currentProjectMainFile || currentOpenFile || 'editor.asm';

            // Check if we have a multi-file project (files already in VFS)
            const hasProject = Object.keys(VFS.files).length > 0;

            // Parse command-line defines from input (format: "NAME,NAME=value,...")
            const cmdDefines = [];
            if (asmDefinesInput && asmDefinesInput.value.trim()) {
                const defParts = asmDefinesInput.value.split(',').map(s => s.trim()).filter(s => s);
                for (const part of defParts) {
                    const eqIdx = part.indexOf('=');
                    if (eqIdx > 0) {
                        const name = part.substring(0, eqIdx).trim();
                        const valueStr = part.substring(eqIdx + 1).trim();
                        // Parse value as number if possible, otherwise use 1
                        const value = /^-?\d+$/.test(valueStr) ? parseInt(valueStr, 10) :
                                      /^[\$0x]/i.test(valueStr) ? parseInt(valueStr.replace(/^[\$0x]/i, ''), 16) : 1;
                        cmdDefines.push({ name, value });
                    } else {
                        cmdDefines.push({ name: part, value: 1 });
                    }
                }
            }

            // Add selected defines from @define markers dropdown
            const dropdownDefines = getSelectedDefinesFromDropdown();
            for (const def of dropdownDefines) {
                // Only add if not already in cmdDefines (manual input takes priority)
                if (!cmdDefines.some(d => d.name === def.name)) {
                    cmdDefines.push(def);
                }
            }

            // Use sjasmplus-js assembler
            try {
                let result;
                if (hasProject && VFS.files[filename]) {
                    // Multi-file project - use assembleProject to preserve VFS
                    result = Assembler.assembleProject(filename, cmdDefines);
                } else {
                    // Single file mode - use assemble
                    const code = asmEditor.value;
                    result = Assembler.assemble(code, filename, cmdDefines);
                }

                assembledBytes = result.output;
                assembledOrg = result.outputStart;
                assembledOrgAddresses = result.orgAddresses || [result.outputStart];
                assembledSaveCommands = result.saveCommands || [];

                // Check for errors
                const errors = ErrorCollector.errors || [];
                const warnings = result.warnings || [];

                let html = '';

                if (errors.length > 0) {
                    const statusMsg = `${errors.length} error(s)`;
                    html += `<div class="asm-status-line error">${statusMsg}</div>`;
                    errors.forEach(e => {
                        html += formatErrorLocation(e.file, e.line, e.message, true);
                    });
                    assembledBytes = null;
                    btnAsmInject.disabled = true;
                    btnAsmDebug.disabled = true;
                    btnAsmDownload.disabled = true;
                } else {
                    // Show assembled output with addresses and bytes (if enabled)
                    const output = result.output;
                    const startAddr = result.outputStart;
                    const statusMsg = `OK: ${output.length} bytes at ${startAddr.toString(16).toUpperCase()}h (${result.passes} pass${result.passes > 1 ? 'es' : ''})`;
                    html += `<div class="asm-status-line success">${statusMsg}</div>`;

                    // Show warnings (filter unused labels based on checkbox)
                    const showUnused = chkAsmUnusedLabels && chkAsmUnusedLabels.checked;
                    const realWarnings = warnings.filter(w =>
                        showUnused || !w.message.startsWith('Unused label:')
                    );
                    realWarnings.forEach(w => {
                        html += formatErrorLocation(w.file, w.line, w.message, false);
                    });

                    const showCompiled = chkAsmShowCompiled && chkAsmShowCompiled.checked;

                    if (showCompiled && output.length > 0) {
                        // Show hex dump grouped by 8 bytes per line
                        for (let i = 0; i < output.length; i += 8) {
                            const addr = startAddr + i;
                            const chunk = output.slice(i, Math.min(i + 8, output.length));
                            const bytesHex = chunk.map(b => b.toString(16).toUpperCase().padStart(2, '0')).join(' ');
                            html += `<div class="asm-line">`;
                            html += `<span class="asm-addr">${addr.toString(16).toUpperCase().padStart(4, '0')}</span>`;
                            html += `<span class="asm-bytes">${bytesHex}</span>`;
                            html += `</div>`;
                        }
                    }

                    // Show generated files list (grouped by filename)
                    const saveCommands = assembledSaveCommands.filter(c =>
                        c.type === 'bin' || c.type === 'sna' || c.type === 'tap' ||
                        c.type === 'emptytap' || c.type === 'trd' || c.type === 'emptytrd'
                    );
                    // Group by filename
                    const fileMap = new Map();
                    for (const cmd of saveCommands) {
                        const fn = cmd.filename || cmd.trdFilename;
                        if (!fn) continue;
                        if (!fileMap.has(fn)) {
                            fileMap.set(fn, { commands: [], totalSize: 0, type: cmd.type });
                        }
                        const entry = fileMap.get(fn);
                        entry.commands.push(cmd);
                        if (cmd.capturedData) entry.totalSize += cmd.capturedData.length;
                        else if (cmd.length) entry.totalSize += cmd.length;
                        // Update type if we have a real command (not empty)
                        if (cmd.type !== 'emptytap' && cmd.type !== 'emptytrd') {
                            entry.type = cmd.type;
                        }
                    }

                    if (fileMap.size > 0) {
                        html += `<div class="asm-files-section">`;
                        html += `<div class="asm-files-header">Generated files:</div>`;
                        for (const [filename, info] of fileMap) {
                            let fileSize = 0;
                            let md5Hash = '';
                            let expectedMD5 = null;
                            let blockCount = 0;

                            // Get expected MD5 from first command with it
                            for (const cmd of info.commands) {
                                if (cmd.expectedMD5) {
                                    expectedMD5 = cmd.expectedMD5.toLowerCase();
                                    break;
                                }
                            }

                            if (info.type === 'tap') {
                                const tapCmds = info.commands.filter(c => c.type === 'tap');
                                blockCount = tapCmds.length;
                                // Generate TAP data to get accurate size and MD5
                                const allBlocks = [];
                                for (const cmd of tapCmds) {
                                    const blockData = generateTAPBlocks(cmd);
                                    if (blockData) allBlocks.push(blockData);
                                }
                                if (allBlocks.length > 0) {
                                    const totalLen = allBlocks.reduce((sum, b) => sum + b.length, 0);
                                    const tapData = new Uint8Array(totalLen);
                                    let offset = 0;
                                    for (const block of allBlocks) {
                                        tapData.set(block, offset);
                                        offset += block.length;
                                    }
                                    fileSize = tapData.length;
                                    md5Hash = MD5.hash(tapData);
                                }
                            } else if (info.type === 'bin') {
                                const cmd = info.commands.find(c => c.type === 'bin');
                                if (cmd && cmd.capturedData) {
                                    fileSize = cmd.capturedData.length;
                                    md5Hash = MD5.hash(cmd.capturedData);
                                }
                            } else if (info.type === 'sna') {
                                const cmd = info.commands.find(c => c.type === 'sna');
                                if (cmd) {
                                    const snaData = generateSNAFile(cmd);
                                    fileSize = snaData.length;
                                    md5Hash = MD5.hash(snaData);
                                }
                            } else {
                                fileSize = info.totalSize;
                            }

                            // Format details
                            let details = '';
                            if (info.type === 'tap' && blockCount > 1) {
                                details = `${blockCount} blocks, ${fileSize} bytes`;
                            } else if (fileSize > 0) {
                                details = `${fileSize} bytes`;
                            }

                            // MD5 verification
                            let md5Status = '';
                            if (expectedMD5 && md5Hash) {
                                if (md5Hash === expectedMD5) {
                                    md5Status = '<span class="asm-md5-pass">MD5 OK</span>';
                                } else {
                                    md5Status = `<span class="asm-md5-fail">MD5 MISMATCH (expected: ${expectedMD5})</span>`;
                                }
                            }

                            html += `<div class="asm-file-item">`;
                            html += `${escapeHtml(filename)}`;
                            if (details) html += ` <span class="asm-file-details">(${details})</span>`;
                            if (md5Hash) html += ` <span class="asm-file-md5">[${md5Hash}]</span>`;
                            if (md5Status) html += ` ${md5Status}`;
                            html += `</div>`;
                        }
                        html += `</div>`;
                    }

                    btnAsmInject.disabled = false;
                    btnAsmDebug.disabled = false;
                    btnAsmDownload.disabled = fileMap.size === 0;
                }

                asmOutput.innerHTML = html;

                // Add click handlers for error/warning navigation
                asmOutput.querySelectorAll('.asm-clickable').forEach(el => {
                    el.addEventListener('click', () => {
                        const file = el.dataset.file || null;
                        const line = el.dataset.line ? parseInt(el.dataset.line) : null;
                        goToFileLine(file, line);
                    });
                });

            } catch (e) {
                // Handle AssemblerError with file/line info
                const statusMsg = 'Assembly failed';
                let html = `<div class="asm-status-line error">${statusMsg}</div>`;
                if (e.file || e.line) {
                    html += formatErrorLocation(e.file, e.line, e.message, true);
                } else {
                    html += `<div class="asm-error">${escapeHtml(e.message || e.toString())}</div>`;
                }
                asmOutput.innerHTML = html;

                // Add click handlers for error navigation
                asmOutput.querySelectorAll('.asm-clickable').forEach(el => {
                    el.addEventListener('click', () => {
                        const file = el.dataset.file || null;
                        const line = el.dataset.line ? parseInt(el.dataset.line) : null;
                        goToFileLine(file, line);
                    });
                });

                assembledBytes = null;
                btnAsmInject.disabled = true;
                btnAsmDebug.disabled = true;
                btnAsmDownload.disabled = true;
            }
        }

        // Inject assembled code into memory (supports 128K paging)
        if (btnAsmInject) {
            btnAsmInject.addEventListener('click', () => {
                if (!spectrum.memory) {
                    showMessage('Emulator not ready');
                    return;
                }

                const deviceName = AsmMemory.getDeviceName();
                const emulatorIs128K = spectrum.memory.machineType === '128k' || spectrum.memory.machineType === 'pentagon';

                // Check if we have paged assembly (DEVICE directive used)
                if (deviceName === 'ZXSPECTRUM128' || deviceName === 'ZXSPECTRUM512' || deviceName === 'ZXSPECTRUM1024') {
                    // 128K paged assembly
                    if (!emulatorIs128K) {
                        showMessage('Warning: 128K code cannot be fully injected to 48K machine. Only pages 5, 2, 0 will be injected.');
                    }

                    let totalBytes = 0;
                    const pagesInjected = [];

                    // For 128K emulator: inject all 8 pages to RAM banks
                    // For 48K emulator: inject pages 5,2,0 to corresponding addresses
                    const pagesToInject = emulatorIs128K ? [0, 1, 2, 3, 4, 5, 6, 7] : [5, 2, 0];

                    for (const pageNum of pagesToInject) {
                        const pageData = AsmMemory.getPage(pageNum);
                        if (!pageData) continue;

                        // Check if page has any non-zero content
                        let hasContent = false;
                        for (let i = 0; i < pageData.length; i++) {
                            if (pageData[i] !== 0) {
                                hasContent = true;
                                break;
                            }
                        }

                        if (hasContent) {
                            if (emulatorIs128K) {
                                // Direct bank copy for 128K
                                const ramBank = spectrum.memory.getRamBank(pageNum);
                                if (ramBank) {
                                    ramBank.set(pageData);
                                    totalBytes += pageData.length;
                                    pagesInjected.push(pageNum);
                                }
                            } else {
                                // 48K emulator - map pages to addresses
                                // Page 5 -> $4000, Page 2 -> $8000, Page 0 -> $C000
                                const addrMap = { 5: 0x4000, 2: 0x8000, 0: 0xC000 };
                                const baseAddr = addrMap[pageNum];
                                if (baseAddr !== undefined) {
                                    for (let i = 0; i < pageData.length; i++) {
                                        spectrum.memory.write(baseAddr + i, pageData[i]);
                                    }
                                    totalBytes += pageData.length;
                                    pagesInjected.push(pageNum);
                                }
                            }
                        }
                    }

                    if (pagesInjected.length > 0) {
                        showMessage(`Injected ${totalBytes} bytes from pages [${pagesInjected.join(', ')}]`);
                    } else {
                        showMessage('No content to inject');
                    }

                } else if (deviceName === 'ZXSPECTRUM48') {
                    // 48K paged assembly - pages 1,2,3 map to $4000,$8000,$C000
                    let totalBytes = 0;
                    const addrMap = { 1: 0x4000, 2: 0x8000, 3: 0xC000 };

                    for (const pageNum of [1, 2, 3]) {
                        const pageData = AsmMemory.getPage(pageNum);
                        if (!pageData) continue;

                        // Check if page has any non-zero content
                        let hasContent = false;
                        for (let i = 0; i < pageData.length; i++) {
                            if (pageData[i] !== 0) {
                                hasContent = true;
                                break;
                            }
                        }

                        if (hasContent) {
                            const baseAddr = addrMap[pageNum];
                            if (emulatorIs128K) {
                                // 128K emulator - map 48K pages to 128K banks
                                // Page 1 -> Bank 5, Page 2 -> Bank 2, Page 3 -> Bank 0
                                const bankMap = { 1: 5, 2: 2, 3: 0 };
                                const ramBank = spectrum.memory.getRamBank(bankMap[pageNum]);
                                if (ramBank) {
                                    ramBank.set(pageData);
                                    totalBytes += pageData.length;
                                }
                            } else {
                                // 48K emulator - direct address write
                                for (let i = 0; i < pageData.length; i++) {
                                    spectrum.memory.write(baseAddr + i, pageData[i]);
                                }
                                totalBytes += pageData.length;
                            }
                        }
                    }

                    if (totalBytes > 0) {
                        showMessage(`Injected ${totalBytes} bytes (48K device)`);
                    } else {
                        showMessage('No content to inject');
                    }

                } else {
                    // No DEVICE - use linear output
                    if (!assembledBytes || assembledBytes.length === 0) {
                        showMessage('No assembled code to inject');
                        return;
                    }

                    for (let i = 0; i < assembledBytes.length; i++) {
                        spectrum.memory.write(assembledOrg + i, assembledBytes[i]);
                    }

                    showMessage(`Injected ${assembledBytes.length} bytes at ${assembledOrg.toString(16).toUpperCase()}h`);
                }

                updateDebugger();
            });
        }

        // Debug button - inject code and start debugging
        if (btnAsmDebug) {
            btnAsmDebug.addEventListener('click', async () => {
                if (!spectrum.memory) {
                    showMessage('Emulator not ready');
                    return;
                }

                // First, trigger the inject
                btnAsmInject.click();

                // Determine entry point - priority: SAVESNA > single ORG > multiple ORGs (ask)
                let entryPoint = assembledOrg;

                // Check if there's a SAVESNA command - use its start address
                const snaCommand = assembledSaveCommands.find(c => c.type === 'sna');
                if (snaCommand) {
                    entryPoint = snaCommand.start;
                } else if (assembledOrgAddresses.length > 1) {
                    // Multiple ORGs - ask user to select
                    entryPoint = await showOrgSelectionDialog(assembledOrgAddresses);
                    if (entryPoint === null) return;  // User cancelled
                } else if (assembledOrgAddresses.length === 1) {
                    entryPoint = assembledOrgAddresses[0];
                }

                // Set PC to entry point
                spectrum.cpu.pc = entryPoint;

                // Switch to debugger tab
                const debuggerTab = document.querySelector('.tab-btn[data-tab="debugger"]');
                if (debuggerTab) {
                    debuggerTab.click();
                }

                // Update debugger view
                updateDebugger();
                updateStatus();

                showMessage(`Ready to debug at ${entryPoint.toString(16).toUpperCase()}h - press F7 to step`);
            });
        }

        // Download generated files
        if (btnAsmDownload) {
            btnAsmDownload.addEventListener('click', async () => {
                const saveCommands = assembledSaveCommands.filter(c =>
                    c.type === 'bin' || c.type === 'sna' || c.type === 'tap' ||
                    c.type === 'emptytap' || c.type === 'trd' || c.type === 'emptytrd'
                );

                if (saveCommands.length === 0) {
                    showMessage('No files to download');
                    return;
                }

                // Group commands by filename - multiple SAVETAP to same file = one TAP with multiple blocks
                const fileGroups = new Map();
                for (const cmd of saveCommands) {
                    const filename = cmd.filename || cmd.trdFilename;
                    if (!filename) continue;

                    if (!fileGroups.has(filename)) {
                        fileGroups.set(filename, []);
                    }
                    fileGroups.get(filename).push(cmd);
                }

                // Generate file data for each unique filename
                const files = [];
                for (const [filename, commands] of fileGroups) {
                    let data = null;

                    // Determine file type from first non-empty command
                    const firstCmd = commands.find(c => c.type !== 'emptytap' && c.type !== 'emptytrd') || commands[0];
                    const fileType = firstCmd.type === 'emptytap' ? 'tap' :
                                     firstCmd.type === 'emptytrd' ? 'trd' : firstCmd.type;

                    if (fileType === 'bin') {
                        // Binary file - use captured data directly
                        data = firstCmd.capturedData;
                    } else if (fileType === 'sna') {
                        // SNA snapshot - generate from assembler memory state
                        data = generateSNAFile(firstCmd);
                    } else if (fileType === 'tap') {
                        // TAP file - concatenate all blocks from all SAVETAP commands to this file
                        const tapCommands = commands.filter(c => c.type === 'tap');
                        if (tapCommands.length > 0) {
                            const allBlocks = [];
                            for (const cmd of tapCommands) {
                                const blockData = generateTAPBlocks(cmd);
                                if (blockData) allBlocks.push(blockData);
                            }
                            // Concatenate all blocks
                            const totalLen = allBlocks.reduce((sum, b) => sum + b.length, 0);
                            data = new Uint8Array(totalLen);
                            let offset = 0;
                            for (const block of allBlocks) {
                                data.set(block, offset);
                                offset += block.length;
                            }
                        }
                    } else if (fileType === 'trd') {
                        // TRD file - not yet implemented
                        console.log('TRD export not yet implemented:', filename);
                        continue;
                    }

                    if (data && data.length > 0) {
                        files.push({ filename, data });
                    }
                }

                if (files.length === 0) {
                    showMessage('No valid files to download');
                    return;
                }

                if (files.length === 1) {
                    // Single file - download directly
                    downloadBinaryFile(files[0].filename, files[0].data);
                    showMessage(`Downloaded: ${files[0].filename}`);
                } else {
                    // Multiple files - create ZIP
                    const zipData = await createZipFromFiles(files);
                    const zipName = currentProjectMainFile
                        ? currentProjectMainFile.replace(/\.[^.]+$/, '.zip')
                        : 'output.zip';
                    downloadBinaryFile(zipName, zipData);
                    showMessage(`Downloaded ${files.length} files as ${zipName}`);
                }
            });
        }

        // Generate SNA file from assembler memory state
        function generateSNAFile(cmd) {
            const snaData = new Uint8Array(49179); // 48K SNA size

            // SNA header (27 bytes)
            // I register
            snaData[0] = 0x3F;
            // HL', DE', BC', AF' (alternate registers)
            snaData[1] = 0; snaData[2] = 0;  // HL'
            snaData[3] = 0; snaData[4] = 0;  // DE'
            snaData[5] = 0; snaData[6] = 0;  // BC'
            snaData[7] = 0; snaData[8] = 0;  // AF'
            // HL, DE, BC (main registers)
            snaData[9] = 0; snaData[10] = 0;  // HL
            snaData[11] = 0; snaData[12] = 0; // DE
            snaData[13] = 0; snaData[14] = 0; // BC
            // IY, IX
            snaData[15] = 0x5C; snaData[16] = 0x3A; // IY = 5C3Ah (standard)
            snaData[17] = 0; snaData[18] = 0;        // IX
            // Interrupt (bit 2 = IFF2)
            snaData[19] = 0x04; // IFF2 enabled
            // R register
            snaData[20] = 0;
            // AF, SP
            snaData[21] = 0; snaData[22] = 0;         // AF
            // SP - place PC on stack so RET will jump to start address
            const sp = 0xFFFE;
            snaData[23] = sp & 0xFF;
            snaData[24] = (sp >> 8) & 0xFF;
            // Interrupt mode
            snaData[25] = 1; // IM 1
            // Border color
            snaData[26] = 7; // White border

            // RAM dump (48K starting at 0x4000)
            // Fill with 0xFF first (like real hardware)
            for (let i = 27; i < 49179; i++) {
                snaData[i] = 0;
            }

            // Copy assembled data
            if (AsmMemory.device) {
                // 128K mode - read from page memory
                // Pages 5, 2, 0 map to 0x4000-0xFFFF
                const pageMap = [5, 2, 0]; // Page at 4000, 8000, C000
                for (let page = 0; page < 3; page++) {
                    const pageData = AsmMemory.getPage(pageMap[page]);
                    if (pageData) {
                        for (let i = 0; i < 0x4000; i++) {
                            snaData[27 + page * 0x4000 + i] = pageData[i];
                        }
                    }
                }
            } else {
                // 48K mode - copy from output
                const startAddr = Assembler.outputStart;
                const output = Assembler.output;
                for (let i = 0; i < output.length; i++) {
                    const addr = startAddr + i;
                    if (addr >= 0x4000 && addr <= 0xFFFF) {
                        snaData[27 + (addr - 0x4000)] = output[i];
                    }
                }
            }

            // Place start address on stack for RET
            const startAddr = cmd.start;
            snaData[27 + (sp - 0x4000)] = startAddr & 0xFF;
            snaData[27 + (sp - 0x4000) + 1] = (startAddr >> 8) & 0xFF;

            return snaData;
        }

        // Generate TAP blocks for a single SAVETAP command (may include header + data blocks)
        function generateTAPBlocks(cmd) {
            if (cmd.blockType === 'HEADLESS') {
                // Headless block - just data with flag byte
                const flagByte = cmd.param1 !== undefined ? cmd.param1 : 0xFF;
                return createTAPBlock(cmd.capturedData, flagByte);
            }

            // Standard block with header
            const blocks = [];

            if (cmd.blockType === 'CODE') {
                // Header block (type 3 = CODE)
                const header = new Uint8Array(17);
                header[0] = 3; // CODE
                // Filename (10 chars, space padded)
                const name = (cmd.blockName || 'CODE').substring(0, 10).padEnd(10, ' ');
                for (let i = 0; i < 10; i++) {
                    header[1 + i] = name.charCodeAt(i);
                }
                const len = cmd.capturedData ? cmd.capturedData.length : cmd.length;
                header[11] = len & 0xFF;
                header[12] = (len >> 8) & 0xFF;
                header[13] = cmd.start & 0xFF;
                header[14] = (cmd.start >> 8) & 0xFF;
                const codeParam2 = (cmd.param2 >= 0) ? cmd.param2 : 32768;
                header[15] = codeParam2 & 0xFF;
                header[16] = (codeParam2 >> 8) & 0xFF;

                blocks.push(createTAPBlock(header, 0x00)); // Flag 0 = header
                blocks.push(createTAPBlock(cmd.capturedData, 0xFF)); // Flag FF = data
            } else if (cmd.blockType === 'BASIC') {
                // BASIC program header (type 0)
                const header = new Uint8Array(17);
                header[0] = 0; // BASIC
                const name = (cmd.blockName || 'PROGRAM').substring(0, 10).padEnd(10, ' ');
                for (let i = 0; i < 10; i++) {
                    header[1 + i] = name.charCodeAt(i);
                }
                const len = cmd.capturedData ? cmd.capturedData.length : cmd.length;
                header[11] = len & 0xFF;
                header[12] = (len >> 8) & 0xFF;
                const autorun = cmd.param1 !== undefined ? cmd.param1 : 0x8000;
                header[13] = autorun & 0xFF;
                header[14] = (autorun >> 8) & 0xFF;
                const varsOffset = (cmd.param2 >= 0) ? cmd.param2 : len;
                header[15] = varsOffset & 0xFF;
                header[16] = (varsOffset >> 8) & 0xFF;

                blocks.push(createTAPBlock(header, 0x00));
                blocks.push(createTAPBlock(cmd.capturedData, 0xFF));
            } else {
                // Default - just data block
                blocks.push(createTAPBlock(cmd.capturedData, 0xFF));
            }

            // Concatenate all blocks
            const totalLen = blocks.reduce((sum, b) => sum + b.length, 0);
            const tapData = new Uint8Array(totalLen);
            let offset = 0;
            for (const block of blocks) {
                tapData.set(block, offset);
                offset += block.length;
            }
            return tapData;
        }

        // Create a single TAP block with length prefix, flag, data, and checksum
        function createTAPBlock(data, flagByte) {
            const blockLen = data.length + 2; // +1 flag, +1 checksum
            const block = new Uint8Array(blockLen + 2); // +2 for length prefix
            block[0] = blockLen & 0xFF;
            block[1] = (blockLen >> 8) & 0xFF;
            block[2] = flagByte;
            block.set(data, 3);
            // Calculate checksum (XOR of flag and all data bytes)
            let checksum = flagByte;
            for (let i = 0; i < data.length; i++) {
                checksum ^= data[i];
            }
            block[block.length - 1] = checksum;
            return block;
        }

        // Create ZIP file from multiple files
        async function createZipFromFiles(files) {
            // Simple ZIP creation without compression (STORE method)
            const entries = [];
            let offset = 0;

            // Build local file headers and file data
            for (const file of files) {
                const nameBytes = new TextEncoder().encode(file.filename);
                const localHeader = new Uint8Array(30 + nameBytes.length);

                // Local file header signature
                localHeader[0] = 0x50; localHeader[1] = 0x4B;
                localHeader[2] = 0x03; localHeader[3] = 0x04;
                // Version needed (2.0)
                localHeader[4] = 20; localHeader[5] = 0;
                // Flags
                localHeader[6] = 0; localHeader[7] = 0;
                // Compression (0 = store)
                localHeader[8] = 0; localHeader[9] = 0;
                // Mod time/date (use fixed value)
                localHeader[10] = 0; localHeader[11] = 0;
                localHeader[12] = 0x21; localHeader[13] = 0;
                // CRC32
                const crc = crc32(file.data);
                localHeader[14] = crc & 0xFF;
                localHeader[15] = (crc >> 8) & 0xFF;
                localHeader[16] = (crc >> 16) & 0xFF;
                localHeader[17] = (crc >> 24) & 0xFF;
                // Compressed size
                localHeader[18] = file.data.length & 0xFF;
                localHeader[19] = (file.data.length >> 8) & 0xFF;
                localHeader[20] = (file.data.length >> 16) & 0xFF;
                localHeader[21] = (file.data.length >> 24) & 0xFF;
                // Uncompressed size
                localHeader[22] = file.data.length & 0xFF;
                localHeader[23] = (file.data.length >> 8) & 0xFF;
                localHeader[24] = (file.data.length >> 16) & 0xFF;
                localHeader[25] = (file.data.length >> 24) & 0xFF;
                // Filename length
                localHeader[26] = nameBytes.length & 0xFF;
                localHeader[27] = (nameBytes.length >> 8) & 0xFF;
                // Extra field length
                localHeader[28] = 0; localHeader[29] = 0;
                // Filename
                localHeader.set(nameBytes, 30);

                entries.push({
                    filename: file.filename,
                    nameBytes,
                    data: file.data,
                    localHeader,
                    offset,
                    crc
                });
                offset += localHeader.length + file.data.length;
            }

            // Build central directory
            const centralDir = [];
            for (const entry of entries) {
                const cdEntry = new Uint8Array(46 + entry.nameBytes.length);
                // Central directory signature
                cdEntry[0] = 0x50; cdEntry[1] = 0x4B;
                cdEntry[2] = 0x01; cdEntry[3] = 0x02;
                // Version made by
                cdEntry[4] = 20; cdEntry[5] = 0;
                // Version needed
                cdEntry[6] = 20; cdEntry[7] = 0;
                // Flags
                cdEntry[8] = 0; cdEntry[9] = 0;
                // Compression
                cdEntry[10] = 0; cdEntry[11] = 0;
                // Mod time/date
                cdEntry[12] = 0; cdEntry[13] = 0;
                cdEntry[14] = 0x21; cdEntry[15] = 0;
                // CRC32
                cdEntry[16] = entry.crc & 0xFF;
                cdEntry[17] = (entry.crc >> 8) & 0xFF;
                cdEntry[18] = (entry.crc >> 16) & 0xFF;
                cdEntry[19] = (entry.crc >> 24) & 0xFF;
                // Compressed size
                cdEntry[20] = entry.data.length & 0xFF;
                cdEntry[21] = (entry.data.length >> 8) & 0xFF;
                cdEntry[22] = (entry.data.length >> 16) & 0xFF;
                cdEntry[23] = (entry.data.length >> 24) & 0xFF;
                // Uncompressed size
                cdEntry[24] = entry.data.length & 0xFF;
                cdEntry[25] = (entry.data.length >> 8) & 0xFF;
                cdEntry[26] = (entry.data.length >> 16) & 0xFF;
                cdEntry[27] = (entry.data.length >> 24) & 0xFF;
                // Filename length
                cdEntry[28] = entry.nameBytes.length & 0xFF;
                cdEntry[29] = (entry.nameBytes.length >> 8) & 0xFF;
                // Extra, comment, disk start, internal/external attrs
                for (let i = 30; i < 42; i++) cdEntry[i] = 0;
                // Local header offset
                cdEntry[42] = entry.offset & 0xFF;
                cdEntry[43] = (entry.offset >> 8) & 0xFF;
                cdEntry[44] = (entry.offset >> 16) & 0xFF;
                cdEntry[45] = (entry.offset >> 24) & 0xFF;
                // Filename
                cdEntry.set(entry.nameBytes, 46);
                centralDir.push(cdEntry);
            }

            const cdSize = centralDir.reduce((sum, e) => sum + e.length, 0);
            const cdOffset = offset;

            // End of central directory
            const eocd = new Uint8Array(22);
            eocd[0] = 0x50; eocd[1] = 0x4B;
            eocd[2] = 0x05; eocd[3] = 0x06;
            // Disk numbers
            eocd[4] = 0; eocd[5] = 0;
            eocd[6] = 0; eocd[7] = 0;
            // Entry counts
            eocd[8] = entries.length & 0xFF;
            eocd[9] = (entries.length >> 8) & 0xFF;
            eocd[10] = entries.length & 0xFF;
            eocd[11] = (entries.length >> 8) & 0xFF;
            // Central directory size
            eocd[12] = cdSize & 0xFF;
            eocd[13] = (cdSize >> 8) & 0xFF;
            eocd[14] = (cdSize >> 16) & 0xFF;
            eocd[15] = (cdSize >> 24) & 0xFF;
            // Central directory offset
            eocd[16] = cdOffset & 0xFF;
            eocd[17] = (cdOffset >> 8) & 0xFF;
            eocd[18] = (cdOffset >> 16) & 0xFF;
            eocd[19] = (cdOffset >> 24) & 0xFF;
            // Comment length
            eocd[20] = 0; eocd[21] = 0;

            // Assemble final ZIP
            const totalSize = offset + cdSize + 22;
            const zipData = new Uint8Array(totalSize);
            let pos = 0;

            for (const entry of entries) {
                zipData.set(entry.localHeader, pos);
                pos += entry.localHeader.length;
                zipData.set(entry.data, pos);
                pos += entry.data.length;
            }
            for (const cd of centralDir) {
                zipData.set(cd, pos);
                pos += cd.length;
            }
            zipData.set(eocd, pos);

            return zipData;
        }

        // CRC32 calculation
        function crc32(data) {
            const table = [];
            for (let i = 0; i < 256; i++) {
                let c = i;
                for (let j = 0; j < 8; j++) {
                    c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
                }
                table[i] = c >>> 0;
            }
            let crc = 0xFFFFFFFF;
            for (let i = 0; i < data.length; i++) {
                crc = table[(crc ^ data[i]) & 0xFF] ^ (crc >>> 8);
            }
            return (crc ^ 0xFFFFFFFF) >>> 0;
        }

        // Download binary file
        function downloadBinaryFile(filename, data) {
            const blob = new Blob([data], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Dialog for selecting ORG address when multiple are present
        async function showOrgSelectionDialog(addresses) {
            return new Promise((resolve) => {
                const dialog = document.createElement('div');
                dialog.className = 'file-selector-dialog';
                dialog.innerHTML = `
                    <div class="file-selector-content" style="max-width: 300px;">
                        <div class="file-selector-header">
                            <h3>Select Entry Point</h3>
                            <button class="file-selector-close">&times;</button>
                        </div>
                        <div class="file-selector-body" style="max-height: 200px;">
                            ${addresses.map(addr =>
                                `<div class="file-item" data-addr="${addr}" style="cursor:pointer;padding:8px;">
                                    ${addr.toString(16).toUpperCase().padStart(4, '0')}h
                                </div>`
                            ).join('')}
                            <div class="file-item" data-custom="true" style="cursor:pointer;padding:8px;color:var(--cyan);">
                                Custom address...
                            </div>
                        </div>
                    </div>
                `;

                document.body.appendChild(dialog);

                const close = () => {
                    dialog.remove();
                    resolve(null);
                };

                dialog.querySelector('.file-selector-close').addEventListener('click', close);
                dialog.addEventListener('click', (e) => {
                    if (e.target === dialog) close();
                });

                dialog.querySelectorAll('.file-item').forEach(item => {
                    item.addEventListener('click', () => {
                        if (item.dataset.custom) {
                            const addr = prompt('Enter entry point address (hex):', addresses[0].toString(16).toUpperCase());
                            if (addr) {
                                const parsed = parseInt(addr, 16);
                                if (!isNaN(parsed) && parsed >= 0 && parsed <= 0xFFFF) {
                                    dialog.remove();
                                    resolve(parsed);
                                } else {
                                    showMessage('Invalid address', 'error');
                                }
                            }
                        } else {
                            dialog.remove();
                            resolve(parseInt(item.dataset.addr));
                        }
                    });
                });
            });
        }

        // Auto-map handlers
        function updateAutoMapStats() {
            const stats = spectrum.getAutoMapStats();
            if (stats.executed === 0 && stats.read === 0 && stats.written === 0) {
                autoMapStats.textContent = '';
                autoMapStats.classList.remove('active');
            } else {
                autoMapStats.textContent = `E:${stats.executed} R:${stats.read} W:${stats.written}`;
                autoMapStats.classList.add('active');
            }
        }

        chkAutoMap.addEventListener('change', () => {
            spectrum.setAutoMapEnabled(chkAutoMap.checked);
            if (chkAutoMap.checked) {
                showMessage('Auto-map tracking enabled');
            }
        });

        btnAutoMapClear.addEventListener('click', () => {
            spectrum.clearAutoMap();
            updateAutoMapStats();
            showMessage('Auto-map tracking cleared');
        });

        document.getElementById('btnClearRegions').addEventListener('click', () => {
            const count = regionManager.getAll().length;
            if (count === 0) {
                showMessage('No regions to clear');
                return;
            }
            regionManager.clear();
            updateDebugger();
            showMessage(`Cleared ${count} regions`);
        });

        // XRef controls
        const btnXrefScan = document.getElementById('btnXrefScan');
        const btnXrefScanAll = document.getElementById('btnXrefScanAll');
        const btnXrefClear = document.getElementById('btnXrefClear');
        const chkXrefRuntime = document.getElementById('chkXrefRuntime');
        const xrefStats = document.getElementById('xrefStats');

        function updateXrefStats() {
            const count = xrefManager.getCount();
            if (count > 0) {
                xrefStats.textContent = `${count} refs`;
                xrefStats.classList.add('active');
            } else {
                xrefStats.textContent = '';
                xrefStats.classList.remove('active');
            }
        }

        btnXrefScan.addEventListener('click', () => {
            // Scan visible range (approximate 4KB from current disasm view)
            const startAddr = disasmViewAddress || 0;
            const endAddr = (startAddr + 0x1000) & 0xffff;
            const count = xrefManager.scanRange(startAddr, endAddr);
            updateXrefStats();
            showMessage(`Scanned ${hex16(startAddr)}-${hex16(endAddr)}: ${count} refs found`);
        });

        btnXrefScanAll.addEventListener('click', () => {
            const count = xrefManager.scanRange(0x0000, 0xFFFF);
            updateXrefStats();
            showMessage(`Full scan: ${count} refs found`);
        });

        btnXrefClear.addEventListener('click', () => {
            xrefManager.clear();
            updateXrefStats();
            showMessage('XRefs cleared');
        });

        chkXrefRuntime.addEventListener('change', () => {
            xrefRuntimeEnabled = chkXrefRuntime.checked;
            spectrum.xrefTrackingEnabled = xrefRuntimeEnabled;
            if (xrefRuntimeEnabled) {
                showMessage('XRef runtime tracking enabled');
            }
        });

        // Set up xref tracking callback
        spectrum.onInstructionExecuted = (pc) => {
            if (!xrefRuntimeEnabled || !disasm) return;
            const instr = disasm.disassemble(pc, true);
            if (instr.refs) {
                for (const ref of instr.refs) {
                    xrefManager.add(ref.target, pc, ref.type, null);
                }
            }
        };

        // Trace controls
        const chkTraceEnabled = document.getElementById('chkTraceEnabled');
        const chkTraceRuntime = document.getElementById('chkTraceRuntime');
        const btnTraceBack = document.getElementById('btnTraceBack');
        const btnTraceForward = document.getElementById('btnTraceForward');
        const btnTraceLive = document.getElementById('btnTraceLive');
        const btnTraceClear = document.getElementById('btnTraceClear');
        const traceStatus = document.getElementById('traceStatus');
        const traceList = document.getElementById('traceList');

        // Set up trace recording callback
        spectrum.onBeforeStep = (cpu, memory, instrPC, portOps, memOps) => {
            try {
                traceManager.record(cpu, memory, instrPC, portOps, memOps);
            } catch (e) {
                console.error('Trace record error:', e);
            }
        };
        spectrum.traceEnabled = true;

        window.updateTraceStatus = function updateTraceStatus() {
            const len = traceManager.length;
            const pos = traceManager.getCurrentPosition();
            if (pos === -1) {
                traceStatus.textContent = `${len} instr`;
                traceStatus.classList.toggle('active', len > 0);
            } else {
                traceStatus.textContent = `${pos + 1}/${len}`;
                traceStatus.classList.add('active');
            }
            btnTraceBack.disabled = len === 0 || pos === 0;
            btnTraceForward.disabled = pos === -1;
            btnTraceLive.disabled = pos === -1;
        }

        window.updateTraceList = function updateTraceList() {
            if (!traceList.classList.contains('visible')) return;

            const currentPos = traceManager.getCurrentPosition();
            const totalLen = traceManager.length;

            // Get entries: either around current position or most recent
            let entries, startIdx, viewIdxInList;
            if (currentPos >= 0) {
                // Navigating history - show entries around current position
                const result = traceManager.getEntriesAround(currentPos, 20);
                entries = result.entries;
                startIdx = result.startIdx;
                viewIdxInList = result.viewIdx;
            } else {
                // Live view - show most recent entries
                entries = traceManager.getRecent(20);
                startIdx = totalLen - entries.length;
                viewIdxInList = -1;
            }

            if (entries.length === 0) {
                traceList.innerHTML = '<div style="padding:4px;color:var(--text-secondary)">No trace data</div>';
                return;
            }

            let html = '';
            for (let i = 0; i < entries.length; i++) {
                const entry = entries[i];
                const globalIdx = startIdx + i;
                const isViewing = currentPos === globalIdx;
                const isCurrent = currentPos === -1 && i === entries.length - 1;

                // Disassemble the instruction (use stored bytes as hex if disasm unavailable)
                let instrText = '';
                if (disasm) {
                    const instr = disasm.disassemble(entry.pc);
                    instrText = instr.text;
                } else {
                    instrText = entry.bytes.slice(0, 3).map(b => hex8(b)).join(' ');
                }

                const classes = ['trace-entry'];
                if (isViewing) classes.push('viewing');
                if (isCurrent) classes.push('current');

                // Format port operations if present
                let portsHtml = '';
                if (entry.ports && entry.ports.length > 0) {
                    const portStrs = entry.ports.map(p =>
                        `${p.dir === 'in' ? 'IN' : 'OUT'}(${hex16(p.port)})=${hex8(p.val)}`
                    );
                    portsHtml = `<span class="ports">${portStrs.join(' ')}</span>`;
                }

                // Format memory operations if present
                let memHtml = '';
                if (entry.mem && entry.mem.length > 0) {
                    const memStrs = entry.mem.map(m => `[${hex16(m.addr)}]=${hex8(m.val)}`);
                    const suffix = entry.mem.length >= 8 ? '...' : '';
                    memHtml = `<span class="memops">${memStrs.join(' ')}${suffix}</span>`;
                }

                html += `<div class="${classes.join(' ')}" data-idx="${globalIdx}">` +
                    `<span class="addr">${hex16(entry.pc)}</span>` +
                    `<span class="instr">${instrText}</span>` +
                    `<span class="regs">AF=${hex16(entry.af)} BC=${hex16(entry.bc)} HL=${hex16(entry.hl)}</span>` +
                    portsHtml + memHtml +
                    `</div>`;
            }
            traceList.innerHTML = html;

            // Scroll to show the relevant entry
            if (viewIdxInList >= 0) {
                // Navigating history - scroll to viewed entry
                const viewedEl = traceList.querySelector('.trace-entry.viewing');
                if (viewedEl) {
                    viewedEl.scrollIntoView({ block: 'center', behavior: 'auto' });
                }
            } else {
                // Live view - scroll to bottom
                traceList.scrollTop = traceList.scrollHeight;
            }
        }

        function showTraceEntry(entry) {
            if (!entry) return;
            // Set trace cursor address for highlighting
            traceViewAddress = entry.pc;
            // Show the trace list panel if hidden
            if (!traceList.classList.contains('visible')) {
                traceList.classList.add('visible');
            }
            // Update displays to show historical state
            updateTraceStatus();
            updateTraceList();
            updateDebugger();  // Update registers to show trace entry values
            // Navigate disasm to the traced PC
            goToAddress(entry.pc);
            showMessage(`Viewing trace: ${hex16(entry.pc)}`);
        }

        chkTraceEnabled.addEventListener('change', () => {
            traceManager.enabled = chkTraceEnabled.checked;
            spectrum.traceEnabled = chkTraceEnabled.checked;
            if (chkTraceEnabled.checked) {
                showMessage('Step trace enabled');
            } else {
                showMessage('Step trace disabled');
            }
        });

        chkTraceRuntime.addEventListener('change', () => {
            spectrum.runtimeTraceEnabled = chkTraceRuntime.checked;
            if (chkTraceRuntime.checked) {
                showMessage('Runtime trace enabled');
            } else {
                showMessage('Runtime trace disabled');
            }
        });

        btnTraceBack.addEventListener('click', () => {
            const entry = traceManager.goBack();
            if (entry) {
                showTraceEntry(entry);
            }
        });

        btnTraceForward.addEventListener('click', () => {
            const entry = traceManager.goForward();
            if (entry) {
                showTraceEntry(entry);
            } else {
                // Returned to live
                traceManager.goToLive();
                traceViewAddress = null;  // Clear trace cursor
                updateTraceStatus();
                updateTraceList();
                updateDebugger();
                showMessage('Returned to live view');
            }
        });

        btnTraceLive.addEventListener('click', () => {
            traceManager.goToLive();
            traceViewAddress = null;  // Clear trace cursor
            updateTraceStatus();
            updateTraceList();
            updateDebugger();
            showMessage('Returned to live view');
        });

        btnTraceClear.addEventListener('click', () => {
            traceManager.clear();
            updateTraceStatus();
            updateTraceList();
            showMessage('Trace cleared');
        });

        // Toggle trace list visibility on status click
        traceStatus.addEventListener('click', () => {
            traceList.classList.toggle('visible');
            if (traceList.classList.contains('visible')) {
                updateTraceList();
            }
        });

        // Click on trace entry to navigate
        traceList.addEventListener('click', (e) => {
            const entryEl = e.target.closest('.trace-entry');
            if (entryEl) {
                const idx = parseInt(entryEl.dataset.idx, 10);
                const entry = traceManager.getEntry(idx);
                if (entry) {
                    traceManager.position = idx;
                    showTraceEntry(entry);
                }
            }
        });

        // Memory Map Dialog
        const memmapDialog = document.getElementById('memmapDialog');
        const memmapCanvas = document.getElementById('memmapCanvas');
        const memmapCtx = memmapCanvas.getContext('2d');
        const memmapTooltip = document.getElementById('memmapTooltip');
        const memmapStats = document.getElementById('memmapStats');
        const memmapBar = document.getElementById('memmapBar');
        const memmapAddrInfo = document.getElementById('memmapAddrInfo');

        const MEMMAP_COLORS = {
            code: '#4080ff',
            smc: '#ff4040',
            db: '#ffcc00',
            dw: '#ff8800',
            text: '#40cc40',
            graphics: '#cc40cc',
            unmapped: '#606060',
            zero: '#000000'
        };

        let memmapViewMode = 'regions'; // 'regions' or 'heatmap'
        let memmapBankMode = '64k'; // '64k' or '128k'
        const btnMemmapRegions = document.getElementById('btnMemmapRegions');
        const btnMemmapHeatmap = document.getElementById('btnMemmapHeatmap');
        const memmapLegendRegions = document.getElementById('memmapLegendRegions');
        const memmapLegendHeatmap = document.getElementById('memmapLegendHeatmap');
        const memmapBankToggle = document.getElementById('memmapBankToggle');
        const btnMemmap64K = document.getElementById('btnMemmap64K');
        const btnMemmap128K = document.getElementById('btnMemmap128K');
        const memmapScale = document.querySelector('.memmap-scale');

        function updateMemmapScale() {
            const romLabel = document.getElementById('memmapRomLabel');
            const bankLabel = document.getElementById('memmapBankLabel');
            if (!spectrum) return;

            // Show/hide 128K toggle based on machine type
            if (spectrum.memory.machineType === '48k') {
                memmapBankToggle.style.display = 'none';
                memmapBankMode = '64k';
            } else {
                memmapBankToggle.style.display = 'flex';
            }

            // Update scale visibility based on bank mode
            memmapScale.style.display = (memmapBankMode === '128k') ? 'none' : 'flex';

            if (spectrum.memory.machineType === '48k') {
                romLabel.textContent = 'ROM';
                bankLabel.textContent = 'RAM';
            } else {
                romLabel.textContent = 'ROM ' + spectrum.memory.currentRomBank;
                bankLabel.textContent = 'Bank ' + spectrum.memory.currentRamBank;
            }
        }

        function openMemoryMap() {
            memmapDialog.classList.remove('hidden');
            updateMemmapScale();
            renderCurrentMemmapView();
        }

        function renderCurrentMemmapView() {
            if (memmapBankMode === '128k') {
                render128KMap();
            } else if (memmapViewMode === 'heatmap') {
                renderHeatmap();
            } else {
                renderMemoryMap();
            }
        }

        function closeMemoryMap() {
            memmapDialog.classList.add('hidden');
        }

        function setMemmapView(mode) {
            memmapViewMode = mode;
            btnMemmapRegions.classList.toggle('active', mode === 'regions');
            btnMemmapHeatmap.classList.toggle('active', mode === 'heatmap');
            memmapLegendRegions.classList.toggle('hidden', mode !== 'regions');
            memmapLegendHeatmap.classList.toggle('hidden', mode !== 'heatmap');
            renderCurrentMemmapView();
        }

        function setMemmapBankMode(mode) {
            memmapBankMode = mode;
            btnMemmap64K.classList.toggle('active', mode === '64k');
            btnMemmap128K.classList.toggle('active', mode === '128k');
            memmapScale.style.display = (mode === '128k') ? 'none' : 'flex';
            // Show legends in both modes
            memmapLegendRegions.classList.toggle('hidden', memmapViewMode !== 'regions');
            memmapLegendHeatmap.classList.toggle('hidden', memmapViewMode !== 'heatmap');
            renderCurrentMemmapView();
        }

        btnMemmapRegions.addEventListener('click', () => setMemmapView('regions'));
        btnMemmapHeatmap.addEventListener('click', () => setMemmapView('heatmap'));
        btnMemmap64K.addEventListener('click', () => setMemmapBankMode('64k'));
        btnMemmap128K.addEventListener('click', () => setMemmapBankMode('128k'));

        function getMemoryMapData() {
            const data = new Array(65536);
            const stats = {
                code: 0, smc: 0, db: 0, dw: 0, text: 0, graphics: 0, unmapped: 0, zero: 0
            };

            // First pass: mark all addresses based on memory content
            for (let addr = 0; addr < 65536; addr++) {
                const val = spectrum.memory.read(addr);
                const region = regionManager.get(addr);

                if (region) {
                    data[addr] = region.type;
                    stats[region.type]++;
                } else if (val === 0) {
                    data[addr] = 'zero';
                    stats.zero++;
                } else {
                    data[addr] = 'unmapped';
                    stats.unmapped++;
                }
            }

            return { data, stats };
        }

        function renderMemoryMap() {
            const { data, stats } = getMemoryMapData();
            const imageData = memmapCtx.createImageData(512, 512);

            // Render 512x512 grid (2x2 pixels per byte, row-major)
            for (let addr = 0; addr < 65536; addr++) {
                const type = data[addr];
                const color = MEMMAP_COLORS[type] || MEMMAP_COLORS.unmapped;

                // Parse hex color
                const r = parseInt(color.slice(1, 3), 16);
                const g = parseInt(color.slice(3, 5), 16);
                const b = parseInt(color.slice(5, 7), 16);

                // Calculate 2x2 pixel position
                const srcX = addr & 0xFF;
                const srcY = addr >> 8;
                const dstX = srcX * 2;
                const dstY = srcY * 2;

                // Draw 2x2 block
                for (let dy = 0; dy < 2; dy++) {
                    for (let dx = 0; dx < 2; dx++) {
                        const idx = ((dstY + dy) * 512 + (dstX + dx)) * 4;
                        imageData.data[idx] = r;
                        imageData.data[idx + 1] = g;
                        imageData.data[idx + 2] = b;
                        imageData.data[idx + 3] = 255;
                    }
                }
            }

            memmapCtx.putImageData(imageData, 0, 0);

            // Update statistics
            const total = 65536;
            const mapped = stats.code + stats.smc + stats.db + stats.dw + stats.text + stats.graphics;

            memmapStats.innerHTML = `
                <table>
                    <tr><td>Code</td><td>${stats.code.toLocaleString()}</td><td>${(stats.code/total*100).toFixed(1)}%</td></tr>
                    <tr><td>SMC</td><td>${stats.smc.toLocaleString()}</td><td>${(stats.smc/total*100).toFixed(1)}%</td></tr>
                    <tr><td>DB</td><td>${stats.db.toLocaleString()}</td><td>${(stats.db/total*100).toFixed(1)}%</td></tr>
                    <tr><td>DW</td><td>${stats.dw.toLocaleString()}</td><td>${(stats.dw/total*100).toFixed(1)}%</td></tr>
                    <tr><td>Text</td><td>${stats.text.toLocaleString()}</td><td>${(stats.text/total*100).toFixed(1)}%</td></tr>
                    <tr><td>Graphics</td><td>${stats.graphics.toLocaleString()}</td><td>${(stats.graphics/total*100).toFixed(1)}%</td></tr>
                    <tr><td>Unmapped</td><td>${stats.unmapped.toLocaleString()}</td><td>${(stats.unmapped/total*100).toFixed(1)}%</td></tr>
                    <tr><td>Zeroes</td><td>${stats.zero.toLocaleString()}</td><td>${(stats.zero/total*100).toFixed(1)}%</td></tr>
                    <tr class="total"><td>Mapped</td><td>${mapped.toLocaleString()}</td><td>${(mapped/total*100).toFixed(1)}%</td></tr>
                </table>
            `;

            // Update bar
            const barParts = [
                { type: 'code', width: stats.code / total * 100 },
                { type: 'smc', width: stats.smc / total * 100 },
                { type: 'db', width: stats.db / total * 100 },
                { type: 'dw', width: stats.dw / total * 100 },
                { type: 'text', width: stats.text / total * 100 },
                { type: 'graphics', width: stats.graphics / total * 100 },
                { type: 'unmapped', width: stats.unmapped / total * 100 },
                { type: 'zero', width: stats.zero / total * 100 }
            ];

            memmapBar.innerHTML = '<div class="memmap-bar-fill">' +
                barParts.map(p => `<div style="width:${p.width}%;background:${MEMMAP_COLORS[p.type]}"></div>`).join('') +
                '</div>';
        }

        // Heatmap data for tooltip access
        let heatmapData = null;

        function renderHeatmap() {
            const autoMapData = spectrum.getAutoMapData();
            const imageData = memmapCtx.createImageData(512, 512);

            // Find max counts for normalization
            let maxExec = 0, maxRead = 0, maxWrite = 0;
            for (const count of autoMapData.executed.values()) maxExec = Math.max(maxExec, count);
            for (const count of autoMapData.read.values()) maxRead = Math.max(maxRead, count);
            for (const count of autoMapData.written.values()) maxWrite = Math.max(maxWrite, count);

            // Use log scale for better visualization
            const logScale = (count, max) => {
                if (count === 0 || max === 0) return 0;
                return Math.log(count + 1) / Math.log(max + 1);
            };

            // Store heatmap data for tooltip
            heatmapData = {
                executed: autoMapData.executed,
                read: autoMapData.read,
                written: autoMapData.written,
                maxExec, maxRead, maxWrite
            };

            // Stats for display
            const stats = {
                executed: autoMapData.executed.size,
                read: autoMapData.read.size,
                written: autoMapData.written.size,
                totalExec: 0, totalRead: 0, totalWrite: 0
            };
            for (const count of autoMapData.executed.values()) stats.totalExec += count;
            for (const count of autoMapData.read.values()) stats.totalRead += count;
            for (const count of autoMapData.written.values()) stats.totalWrite += count;

            // Render heatmap
            // Color channels: B=execute, G=read, R=write
            for (let addr = 0; addr < 65536; addr++) {
                const key = spectrum.getAutoMapKey(addr);
                const execCount = autoMapData.executed.get(key) || 0;
                const readCount = autoMapData.read.get(key) || 0;
                const writeCount = autoMapData.written.get(key) || 0;

                // Calculate intensity using log scale
                const execIntensity = logScale(execCount, maxExec);
                const readIntensity = logScale(readCount, maxRead);
                const writeIntensity = logScale(writeCount, maxWrite);

                // Map to RGB: R=write (orange), G=read (green), B=execute (blue)
                let r = Math.floor(writeIntensity * 255);
                let g = Math.floor(readIntensity * 255);
                let b = Math.floor(execIntensity * 255);

                // Calculate 2x2 pixel position
                const srcX = addr & 0xFF;
                const srcY = addr >> 8;
                const dstX = srcX * 2;
                const dstY = srcY * 2;

                // Draw 2x2 block
                for (let dy = 0; dy < 2; dy++) {
                    for (let dx = 0; dx < 2; dx++) {
                        const idx = ((dstY + dy) * 512 + (dstX + dx)) * 4;
                        imageData.data[idx] = r;
                        imageData.data[idx + 1] = g;
                        imageData.data[idx + 2] = b;
                        imageData.data[idx + 3] = 255;
                    }
                }
            }

            memmapCtx.putImageData(imageData, 0, 0);

            // Update statistics for heatmap
            memmapStats.innerHTML = `
                <table>
                    <tr><td>Executed addrs</td><td>${stats.executed.toLocaleString()}</td></tr>
                    <tr><td>Total executions</td><td>${stats.totalExec.toLocaleString()}</td></tr>
                    <tr><td>Read addrs</td><td>${stats.read.toLocaleString()}</td></tr>
                    <tr><td>Total reads</td><td>${stats.totalRead.toLocaleString()}</td></tr>
                    <tr><td>Written addrs</td><td>${stats.written.toLocaleString()}</td></tr>
                    <tr><td>Total writes</td><td>${stats.totalWrite.toLocaleString()}</td></tr>
                    <tr class="total"><td>Max exec</td><td>${maxExec.toLocaleString()}</td></tr>
                    <tr class="total"><td>Max read</td><td>${maxRead.toLocaleString()}</td></tr>
                    <tr class="total"><td>Max write</td><td>${maxWrite.toLocaleString()}</td></tr>
                </table>
            `;

            // Update bar for heatmap (show proportions of exec/read/write)
            const totalAccesses = stats.executed + stats.read + stats.written;
            if (totalAccesses > 0) {
                const execWidth = stats.executed / totalAccesses * 100;
                const readWidth = stats.read / totalAccesses * 100;
                const writeWidth = stats.written / totalAccesses * 100;
                memmapBar.innerHTML = `<div class="memmap-bar-fill">
                    <div style="width:${execWidth}%;background:#0066ff" title="Execute"></div>
                    <div style="width:${readWidth}%;background:#00ff66" title="Read"></div>
                    <div style="width:${writeWidth}%;background:#ff6600" title="Write"></div>
                </div>`;
            } else {
                memmapBar.innerHTML = '<div class="memmap-bar-fill"><div style="width:100%;background:#333">No data</div></div>';
            }
        }

        // 128K view: Show all 8 banks in a 2x4 grid with x2 horizontal scale
        function render128KMap() {
            if (!spectrum || spectrum.memory.machineType === '48k') return;

            const imageData = memmapCtx.createImageData(512, 512);
            // Layout: 2 columns x 4 rows, each cell is 256x128 pixels showing 16KB
            // Each byte = 2x1 pixels (x2 horizontal scale)
            const cellWidth = 256;  // pixels
            const cellHeight = 128; // pixels
            const bytesPerRow = 128; // bytes per row in each cell

            // Get heatmap data if in heatmap mode
            let heatData = null, maxExec = 0, maxRead = 0, maxWrite = 0;
            if (memmapViewMode === 'heatmap') {
                const autoMapData = spectrum.getAutoMapData();
                heatData = autoMapData;
                for (const count of autoMapData.executed.values()) maxExec = Math.max(maxExec, count);
                for (const count of autoMapData.read.values()) maxRead = Math.max(maxRead, count);
                for (const count of autoMapData.written.values()) maxWrite = Math.max(maxWrite, count);
            }

            const logScale = (count, max) => {
                if (count === 0 || max === 0) return 0;
                return Math.log(count + 1) / Math.log(max + 1);
            };

            for (let bank = 0; bank < 8; bank++) {
                const col = bank % 2;
                const row = Math.floor(bank / 2);
                const baseX = col * cellWidth;
                const baseY = row * cellHeight;
                const ramBank = spectrum.memory.ram[bank];

                for (let addr = 0; addr < 0x4000; addr++) {
                    const val = ramBank[addr];
                    let r, g, b;

                    // Calculate the CPU address for this bank+offset
                    // Bank 5 is always at 4000-7FFF, Bank 2 at 8000-BFFF
                    // Other banks page into C000-FFFF
                    let cpuAddr;
                    if (bank === 5) cpuAddr = 0x4000 + addr;
                    else if (bank === 2) cpuAddr = 0x8000 + addr;
                    else cpuAddr = 0xC000 + addr;

                    if (memmapViewMode === 'heatmap' && heatData) {
                        // Heatmap mode: show execution/read/write as RGB
                        // Use same key format as getAutoMapKey:
                        // 4000-BFFF: just address string
                        // C000-FFFF: "${addr}:${bank}"
                        let key;
                        if (bank === 5 || bank === 2) {
                            key = cpuAddr.toString();
                        } else {
                            key = `${cpuAddr}:${bank}`;
                        }
                        const execCount = heatData.executed.get(key) || 0;
                        const readCount = heatData.read.get(key) || 0;
                        const writeCount = heatData.written.get(key) || 0;
                        r = Math.floor(logScale(writeCount, maxWrite) * 255);
                        g = Math.floor(logScale(readCount, maxRead) * 255);
                        b = Math.floor(logScale(execCount, maxExec) * 255);
                    } else {
                        // Regions mode: lookup region at CPU address
                        const region = regionManager.get(cpuAddr);
                        let color;
                        if (region) {
                            color = MEMMAP_COLORS[region.type];
                        } else if (val === 0) {
                            color = MEMMAP_COLORS.zero;
                        } else {
                            color = MEMMAP_COLORS.unmapped;
                        }
                        r = parseInt(color.slice(1, 3), 16);
                        g = parseInt(color.slice(3, 5), 16);
                        b = parseInt(color.slice(5, 7), 16);
                    }

                    // Calculate pixel position with x2 horizontal scale
                    const localX = addr % bytesPerRow;
                    const localY = Math.floor(addr / bytesPerRow);
                    const px = baseX + localX * 2;
                    const py = baseY + localY;

                    // Draw 2x1 pixel block
                    for (let dx = 0; dx < 2; dx++) {
                        if ((px + dx) < 512 && py < 512) {
                            const idx = (py * 512 + px + dx) * 4;
                            imageData.data[idx] = r;
                            imageData.data[idx + 1] = g;
                            imageData.data[idx + 2] = b;
                            imageData.data[idx + 3] = 255;
                        }
                    }
                }
            }

            memmapCtx.putImageData(imageData, 0, 0);

            // Draw grid lines
            memmapCtx.strokeStyle = '#444';
            memmapCtx.lineWidth = 1;
            // Vertical line (center)
            memmapCtx.beginPath();
            memmapCtx.moveTo(cellWidth, 0);
            memmapCtx.lineTo(cellWidth, 512);
            memmapCtx.stroke();
            // Horizontal lines
            for (let i = 1; i < 4; i++) {
                memmapCtx.beginPath();
                memmapCtx.moveTo(0, i * cellHeight);
                memmapCtx.lineTo(512, i * cellHeight);
                memmapCtx.stroke();
            }

            // Draw bank labels
            memmapCtx.font = '11px monospace';
            for (let bank = 0; bank < 8; bank++) {
                const col = bank % 2;
                const row = Math.floor(bank / 2);
                const x = col * cellWidth + 4;
                const y = row * cellHeight + 14;
                const isCurrentBank = (bank === spectrum.memory.currentRamBank);
                memmapCtx.fillStyle = isCurrentBank ? '#00ff00' : '#888';
                memmapCtx.fillText('Bank ' + bank, x, y);
            }

            // Update stats
            let totalZero = 0, totalNonZero = 0;
            for (let bank = 0; bank < 8; bank++) {
                const ramBank = spectrum.memory.ram[bank];
                for (let addr = 0; addr < 0x4000; addr++) {
                    if (ramBank[addr] === 0) totalZero++;
                    else totalNonZero++;
                }
            }
            const total = 128 * 1024;
            memmapStats.innerHTML = `
                <table>
                    <tr><td>Total RAM</td><td>128 KB</td></tr>
                    <tr><td>Non-zero</td><td>${totalNonZero.toLocaleString()}</td><td>${(totalNonZero/total*100).toFixed(1)}%</td></tr>
                    <tr><td>Zeroes</td><td>${totalZero.toLocaleString()}</td><td>${(totalZero/total*100).toFixed(1)}%</td></tr>
                    <tr class="total"><td>Current</td><td colspan="2">Bank ${spectrum.memory.currentRamBank}</td></tr>
                </table>
            `;
            memmapBar.innerHTML = '';
        }

        function getAddrFromCanvasPos(x, y) {
            const rect = memmapCanvas.getBoundingClientRect();
            const scaleX = 512 / rect.width;
            const scaleY = 512 / rect.height;
            const px = Math.floor((x - rect.left) * scaleX / 2);  // Divide by 2 for 2x scale
            const py = Math.floor((y - rect.top) * scaleY / 2);
            if (px < 0 || px >= 256 || py < 0 || py >= 256) return -1;
            return py * 256 + px;
        }

        memmapCanvas.addEventListener('mousemove', (e) => {
            const addr = getAddrFromCanvasPos(e.clientX, e.clientY);
            if (addr < 0) {
                memmapTooltip.style.display = 'none';
                return;
            }

            const val = spectrum.memory.read(addr);
            const label = labelManager.get(addr);
            let info, infoText;

            if (memmapViewMode === 'heatmap' && heatmapData) {
                // Heatmap tooltip
                const key = spectrum.getAutoMapKey(addr);
                const execCount = heatmapData.executed.get(key) || 0;
                const readCount = heatmapData.read.get(key) || 0;
                const writeCount = heatmapData.written.get(key) || 0;

                info = `${hex16(addr)}: E:${execCount} R:${readCount} W:${writeCount}`;
                if (label) info += ` [${label.name}]`;

                const addrHi = (addr >> 8).toString(16).toUpperCase().padStart(2, '0');
                const addrLo = (addr & 0xFF).toString(16).toUpperCase().padStart(2, '0');
                infoText = `Address: ${hex16(addr)} (${addrHi}xx + ${addrLo})\nValue: ${hex8(val)} (${val})`;
                infoText += `\nExecuted: ${execCount.toLocaleString()} times`;
                infoText += `\nRead: ${readCount.toLocaleString()} times`;
                infoText += `\nWritten: ${writeCount.toLocaleString()} times`;
                if (label) infoText += `\nLabel: ${label.name}`;
            } else {
                // Region tooltip
                const region = regionManager.get(addr);
                const type = region ? region.type : (val === 0 ? 'Zero' : 'Unmapped');

                info = `${hex16(addr)}: ${hex8(val)} - ${type}`;
                if (label) info += ` [${label.name}]`;

                const addrHi = (addr >> 8).toString(16).toUpperCase().padStart(2, '0');
                const addrLo = (addr & 0xFF).toString(16).toUpperCase().padStart(2, '0');
                infoText = `Address: ${hex16(addr)} (${addrHi}xx + ${addrLo})\nValue: ${hex8(val)} (${val})\nType: ${type}`;
                if (region && region.comment) infoText += `\n${region.comment}`;
                if (label) infoText += `\nLabel: ${label.name}`;
            }

            memmapTooltip.textContent = info;
            memmapTooltip.style.display = 'block';
            memmapTooltip.style.left = (e.clientX - memmapCanvas.getBoundingClientRect().left + 10) + 'px';
            memmapTooltip.style.top = (e.clientY - memmapCanvas.getBoundingClientRect().top - 20) + 'px';
            memmapAddrInfo.textContent = infoText;
        });

        memmapCanvas.addEventListener('mouseleave', () => {
            memmapTooltip.style.display = 'none';
        });

        memmapCanvas.addEventListener('click', (e) => {
            const addr = getAddrFromCanvasPos(e.clientX, e.clientY);
            if (addr >= 0) {
                closeMemoryMap();
                // Navigate disassembly (includes history)
                goToAddress(addr);
                // Navigate memory dump
                goToMemoryAddress(addr);
                updateDebugger();
            }
        });

        document.getElementById('btnMemoryMap').addEventListener('click', openMemoryMap);
        document.getElementById('btnMemmapClose').addEventListener('click', closeMemoryMap);
        memmapDialog.addEventListener('click', (e) => {
            if (e.target === memmapDialog) closeMemoryMap();
        });

        btnAutoMapApply.addEventListener('click', () => {
            const data = spectrum.getAutoMapData();
            if (data.executed.size === 0) {
                showMessage('No execution data to apply', 'error');
                return;
            }

            // Merge consecutive addresses into regions
            function mergeToRegions(addrMap, type) {
                // Parse all addresses and group by page
                const byPage = new Map(); // page -> sorted addresses
                for (const key of addrMap.keys()) {
                    const { addr, page } = spectrum.parseAutoMapKey(key);
                    const pageKey = page || '';
                    if (!byPage.has(pageKey)) byPage.set(pageKey, []);
                    byPage.get(pageKey).push(addr);
                }

                const regions = [];
                for (const [pageKey, addrs] of byPage) {
                    addrs.sort((a, b) => a - b);
                    let start = addrs[0];
                    let end = addrs[0];

                    for (let i = 1; i < addrs.length; i++) {
                        if (addrs[i] === end + 1) {
                            end = addrs[i];
                        } else {
                            // Gap - finish this region
                            regions.push({
                                start,
                                end,
                                type,
                                page: pageKey || null
                            });
                            start = addrs[i];
                            end = addrs[i];
                        }
                    }
                    // Add final region
                    regions.push({
                        start,
                        end,
                        type,
                        page: pageKey || null
                    });
                }
                return regions;
            }

            // Find SMC: addresses that are both executed AND written
            const smcAddrs = new Map();
            for (const [key, count] of data.executed) {
                if (data.written.has(key)) {
                    smcAddrs.set(key, count);
                }
            }

            // Find CODE: addresses executed but NOT written (pure code)
            const codeAddrs = new Map();
            for (const [key, count] of data.executed) {
                if (!data.written.has(key)) {
                    codeAddrs.set(key, count);
                }
            }

            // Find DATA: addresses read but NOT executed
            const dataAddrs = new Map();
            for (const [key, count] of data.read) {
                if (!data.executed.has(key)) {
                    dataAddrs.set(key, count);
                }
            }

            // Generate regions
            const smcRegions = mergeToRegions(smcAddrs, REGION_TYPES.SMC);
            const codeRegions = mergeToRegions(codeAddrs, REGION_TYPES.CODE);
            const dataRegions = mergeToRegions(dataAddrs, REGION_TYPES.DB);

            // Apply to region manager (skip overlapping regions)
            let added = 0, skipped = 0;
            for (const region of smcRegions) {
                const result = regionManager.add(region);
                if (result.error) skipped++; else added++;
            }
            for (const region of codeRegions) {
                const result = regionManager.add(region);
                if (result.error) skipped++; else added++;
            }
            for (const region of dataRegions) {
                const result = regionManager.add(region);
                if (result.error) skipped++; else added++;
            }

            updateDebugger();
            const msg = `Applied ${added} regions` + (skipped ? `, skipped ${skipped} overlapping` : '');
            showMessage(msg);
        });

        // Update auto-map stats periodically
        setInterval(updateAutoMapStats, 1000);

        // Disassembly navigation handlers
        btnDisasmGo.addEventListener('click', () => {
            const addr = parseInt(disasmAddressInput.value, 16);
            if (!isNaN(addr)) {
                // If history is empty, save current view position first
                if (navHistory.length === 0 && disasmViewAddress !== null) {
                    navPushHistory(disasmViewAddress);
                }
                navPushHistory(addr & 0xffff);
                disasmViewAddress = addr & 0xffff;
                updateDebugger();
            }
        });

        disasmAddressInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const addr = parseInt(disasmAddressInput.value, 16);
                if (!isNaN(addr)) {
                    // If history is empty, save current view position first
                    if (navHistory.length === 0 && disasmViewAddress !== null) {
                        navPushHistory(disasmViewAddress);
                    }
                    navPushHistory(addr & 0xffff);
                    disasmViewAddress = addr & 0xffff;
                    updateDebugger();
                }
            }
        });
        
        btnDisasmPC.addEventListener('click', () => {
            disasmViewAddress = null; // Follow PC
            disasmAddressInput.value = '';
            updateDebugger();
        });

        // Keyboard shortcuts for navigation (Alt+Left/Right)
        document.addEventListener('keydown', (e) => {
            if (e.altKey && e.key === 'ArrowLeft') {
                e.preventDefault();
                navBack();
            } else if (e.altKey && e.key === 'ArrowRight') {
                e.preventDefault();
                navForward();
            }
        });

        btnDisasmPgUp.addEventListener('click', () => {
            if (disasmViewAddress === null && spectrum.cpu) {
                disasmViewAddress = spectrum.cpu.pc;
            }
            if (disasmViewAddress !== null) {
                // Go back ~DISASM_LINES instructions (estimate 3 bytes per instruction)
                disasmViewAddress = (disasmViewAddress - DISASM_LINES * 3) & 0xffff;
                disasmAddressInput.value = hex16(disasmViewAddress);
                updateDebugger();
            }
        });
        
        btnDisasmPgDn.addEventListener('click', () => {
            disasmViewAddress = (disasmLastLineAddr + 1) & 0xffff;
            disasmAddressInput.value = hex16(disasmViewAddress);
            updateDebugger();
        });

        // Generate assembly output for sjasmplus
        function generateAssemblyOutput(startAddr, endAddr, options = {}) {
            if (!disasm || !spectrum.memory) return '';

            const withOrg = options.withOrg !== false;
            const withAddr = options.withAddr !== false;
            const withBytes = options.withBytes === true;
            const withTstates = options.withTstates === true;

            // Format current datetime
            const now = new Date();
            const datetime = now.getFullYear() + '-' +
                String(now.getMonth() + 1).padStart(2, '0') + '-' +
                String(now.getDate()).padStart(2, '0') + ' ' +
                String(now.getHours()).padStart(2, '0') + ':' +
                String(now.getMinutes()).padStart(2, '0') + ':' +
                String(now.getSeconds()).padStart(2, '0');

            let output = '; Disassembly exported from ZX-M8XXX\n';
            output += `; Date: ${datetime}\n`;
            if (labelManager.currentFile) {
                output += `; Source: ${labelManager.currentFile}\n`;
            }
            output += `; Range: $${hex16(startAddr)} - $${hex16(endAddr)}\n\n`;

            if (withOrg) {
                output += `        ORG $${hex16(startAddr)}\n\n`;
            }

            let addr = startAddr;
            while (addr <= endAddr && addr < 0x10000) {
                const region = regionManager.get(addr);
                const label = labelManager.get(addr);
                const comment = commentManager.get(addr);
                const instrStartAddr = addr;

                // Output comments before instruction
                if (comment) {
                    if (comment.separator) {
                        output += `; ----------\n`;
                    }
                    if (comment.before) {
                        const beforeLines = comment.before.split('\n');
                        for (const line of beforeLines) {
                            output += `; ${line}\n`;
                        }
                    }
                }

                // Output label on its own line if exists
                if (label) {
                    output += `${label.name}:\n`;
                }

                let mnemonic = '';
                let bytes = [];
                let isData = false;
                let addBlankAfter = false;

                if (!region || region.type === REGION_TYPES.CODE || region.type === REGION_TYPES.SMC) {
                    // Normal disassembly
                    const instr = disasm.disassemble(addr);
                    if (!instr) break;

                    mnemonic = instr.mnemonic;
                    bytes = instr.bytes;

                    // Check for flow control
                    const mnemonicUpper = mnemonic.toUpperCase();
                    if (mnemonicUpper.startsWith('RET') || mnemonicUpper.startsWith('JP ') ||
                        mnemonicUpper.startsWith('JR ') || mnemonicUpper.startsWith('CALL ') ||
                        mnemonicUpper.startsWith('DJNZ') || mnemonicUpper.startsWith('RST') ||
                        mnemonicUpper === 'HALT') {
                        addBlankAfter = true;
                    }

                    addr += bytes.length;
                } else if (region.type === REGION_TYPES.TEXT) {
                    // Text region - use shared helper
                    const regionEnd = Math.min(region.end, endAddr);
                    const result = parseTextRegion(spectrum.memory, addr, regionEnd);
                    bytes = result.bytes;

                    if (result.singleByte) {
                        mnemonic = `DB $${hex8(bytes[0])}`;
                    } else if (result.text.length > 0) {
                        const suffix = result.bit7Terminated ? '+$80' : '';
                        mnemonic = `DB "${result.text}"${suffix}`;
                    }
                    addr = result.nextAddr;
                    isData = true;
                } else if (region.type === REGION_TYPES.DW) {
                    // Word data - use shared helper
                    const regionEnd = Math.min(region.end, endAddr);
                    const result = parseWordRegion(spectrum.memory, addr, regionEnd);
                    bytes = result.bytes;
                    mnemonic = `DW ${result.wordStrs.join(', ')}`;
                    addr = result.nextAddr;
                    isData = true;
                } else if (region.type === REGION_TYPES.DB || region.type === REGION_TYPES.GRAPHICS) {
                    // Byte data - use shared helper
                    const regionEnd = Math.min(region.end, endAddr);
                    const result = parseByteRegion(spectrum.memory, addr, regionEnd);
                    bytes = result.bytes;
                    mnemonic = `DB ${result.byteStrs.join(', ')}`;
                    addr = result.nextAddr;
                    isData = true;
                } else {
                    // Unknown region - fallback
                    const instr = disasm.disassemble(addr);
                    if (!instr) break;
                    mnemonic = instr.mnemonic;
                    bytes = instr.bytes;
                    addr += bytes.length;
                }

                // Build instruction line
                let line = '        '; // 8 spaces for indentation

                // Convert mnemonic to sjasmplus format (for code lines)
                if (!isData) {
                    mnemonic = mnemonic.replace(/([0-9A-F]{4})h/gi, (m, hex) => `$${hex}`);
                    mnemonic = mnemonic.replace(/([0-9A-F]{2})h/gi, (m, hex) => `$${hex}`);
                }

                line += mnemonic;

                // Add aligned comments
                const hasMetaComments = withAddr || withBytes || (withTstates && !isData);
                if (hasMetaComments) {
                    line = line.padEnd(40);
                    line += '; ';

                    if (withAddr) {
                        line += `$${hex16(instrStartAddr)} `;
                    }
                    if (withBytes) {
                        const bytesStr = bytes.map(b => hex8(b)).join(' ');
                        if (withAddr) line += '| ';
                        line += bytesStr.padEnd(24);
                    }
                    if (withTstates && !isData) {
                        const timing = disasm.getTiming(bytes);
                        if (timing) {
                            if (withAddr || withBytes) line += '| ';
                            line += timing;
                        }
                    }
                }

                // Add inline comment
                if (comment && comment.inline) {
                    if (!hasMetaComments) {
                        line = line.padEnd(40);
                    }
                    line += (hasMetaComments ? ' | ' : '; ') + comment.inline;
                }

                output += line + '\n';

                // Add after comments
                if (comment && comment.after) {
                    const afterLines = comment.after.split('\n');
                    for (const afterLine of afterLines) {
                        output += `; ${afterLine}\n`;
                    }
                }

                if (addBlankAfter) {
                    output += '\n';
                }
            }

            return output;
        }

        // Export visible disassembly
        btnDisasmExport.addEventListener('click', () => {
            if (!disasm) return;

            // Get visible range
            let startAddr = disasmViewAddress;
            if (startAddr === null && spectrum.cpu) {
                startAddr = disasm.findStartForPosition(spectrum.cpu.pc, DISASM_PC_POSITION, DISASM_LINES);
            }
            if (startAddr === null) startAddr = 0;

            const endAddr = (disasmLastLineAddr) & 0xffff;

            const output = generateAssemblyOutput(startAddr, endAddr, {
                withOrg: true,
                withAddr: true,
                withBytes: false
            });

            downloadFile(`disasm_${hex16(startAddr)}_${hex16(endAddr)}.asm`, output);
            showMessage(`Exported ${hex16(startAddr)}-${hex16(endAddr)}`);
        });

        // Show export range dialog
        btnDisasmExportRange.addEventListener('click', () => {
            let startAddr = disasmViewAddress;
            if (startAddr === null && spectrum.cpu) {
                startAddr = spectrum.cpu.pc;
            }
            if (startAddr === null) startAddr = 0;

            exportStartAddr.value = hex16(startAddr);
            exportEndAddr.value = hex16((startAddr + 0x100) & 0xffff);
            exportDisasmDialog.classList.remove('hidden');
            exportStartAddr.focus();
            exportStartAddr.select();
        });

        btnExportCancel.addEventListener('click', () => {
            exportDisasmDialog.classList.add('hidden');
        });

        btnExportSave.addEventListener('click', () => {
            const startAddr = parseInt(exportStartAddr.value, 16);
            const endAddr = parseInt(exportEndAddr.value, 16);

            if (isNaN(startAddr) || isNaN(endAddr)) {
                showMessage('Invalid address', 'error');
                return;
            }

            const output = generateAssemblyOutput(startAddr & 0xffff, endAddr & 0xffff, {
                withOrg: exportWithOrg.checked,
                withAddr: exportWithAddr.checked,
                withBytes: exportWithBytes.checked,
                withTstates: exportWithTstates.checked
            });

            downloadFile(`disasm_${hex16(startAddr)}_${hex16(endAddr)}.asm`, output);
            exportDisasmDialog.classList.add('hidden');
            showMessage(`Exported ${hex16(startAddr)}-${hex16(endAddr)}`);
        });

        // Close export dialog on Escape
        exportStartAddr.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') exportDisasmDialog.classList.add('hidden');
            if (e.key === 'Enter') exportEndAddr.focus();
        });
        exportEndAddr.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') exportDisasmDialog.classList.add('hidden');
            if (e.key === 'Enter') btnExportSave.click();
        });

        // Disasm scroll wheel navigation
        disassemblyView.addEventListener('wheel', (e) => {
            e.preventDefault();
            if (!disasm) return;

            // Scroll by ~3 instructions per wheel tick
            const scrollLines = e.deltaY > 0 ? 3 : -3;

            if (disasmViewAddress === null && spectrum.cpu) {
                disasmViewAddress = spectrum.cpu.pc;
            }
            if (disasmViewAddress !== null) {
                if (scrollLines > 0) {
                    // Scroll down - move forward by approximate bytes
                    disasmViewAddress = (disasmViewAddress + scrollLines * 2) & 0xffff;
                } else {
                    // Scroll up - move back by approximate bytes
                    disasmViewAddress = (disasmViewAddress + scrollLines * 2) & 0xffff;
                }
                disasmAddressInput.value = hex16(disasmViewAddress);
                updateDebugger();
            }
        }, { passive: false });

        chkShowTstates.addEventListener('change', () => {
            updateDebugger();
        });

        labelDisplayMode.addEventListener('change', () => {
            updateDebugger();
        });

        chkShowRomLabels.addEventListener('change', () => {
            labelManager.showRomLabels = chkShowRomLabels.checked;
            updateDebugger();
        });

        function formatMnemonic(mnemonic) {
            // Split into opcode and operands
            const spaceIdx = mnemonic.indexOf(' ');
            if (spaceIdx === -1) {
                return `<span class="op">${mnemonic}</span>`;
            }

            const opcode = mnemonic.substring(0, spaceIdx);
            let operands = mnemonic.substring(spaceIdx + 1);

            // Tokenize operands to avoid replacing inside HTML tags
            // Process each comma-separated operand
            const parts = operands.split(',');
            const coloredParts = parts.map(part => {
                let p = part.trim();

                // Character literals ('X' or "X")
                if (/^'.'$/.test(p) || /^".*"$/.test(p)) {
                    return `<span class="disasm-char">${p}</span>`;
                }

                // Binary numbers (%...)
                if (p.startsWith('%')) {
                    return `<span class="disasm-bin">${p}</span>`;
                }

                // Check for indirect addressing (...)
                const indirectMatch = p.match(/^\((.+)\)$/);
                if (indirectMatch) {
                    const inner = colorOperand(indirectMatch[1]);
                    return `<span class="disasm-ptr">(</span>${inner}<span class="disasm-ptr">)</span>`;
                }

                return colorOperand(p);
            });

            function colorOperand(p) {
                // Already has HTML (from replaceMnemonicAddresses)
                if (p.includes('<span')) {
                    return p;
                }

                // Hex numbers (XXh or XXXXh)
                if (/^[0-9A-F]+h$/i.test(p)) {
                    return `<span class="disasm-num">${p}</span>`;
                }

                // Decimal numbers
                if (/^\d+$/.test(p)) {
                    return `<span class="disasm-num">${p}</span>`;
                }

                // IX+d or IY+d patterns
                const ixMatch = p.match(/^(IX|IY)([+-])(.+)$/i);
                if (ixMatch) {
                    const reg = ixMatch[1].toUpperCase();
                    const sign = ixMatch[2];
                    const disp = colorOperand(ixMatch[3]);
                    return `<span class="disasm-reg">${reg}</span>${sign}${disp}`;
                }

                // 16-bit registers
                if (/^(AF'|BC'|DE'|HL'|AF|BC|DE|HL|SP|IX|IY|PC)$/i.test(p)) {
                    return `<span class="disasm-reg">${p}</span>`;
                }

                // 8-bit registers
                if (/^(A|B|C|D|E|H|L|I|R|IXH|IXL|IYH|IYL)$/i.test(p)) {
                    return `<span class="disasm-reg">${p}</span>`;
                }

                // Condition flags
                if (/^(NZ|NC|PO|PE|Z|C|P|M)$/i.test(p)) {
                    return `<span class="disasm-reg">${p}</span>`;
                }

                return p;
            }

            return `<span class="op">${opcode}</span> ${coloredParts.join(',')}`;
        }
        
        function updateRomStatus() {
            const statusTrdosRom = document.getElementById('statusTrdosRom');

            if (rom48Data) {
                status48Rom.textContent = '✓ Loaded (' + (rom48Data.byteLength / 1024) + 'KB)';
                status48Rom.classList.add('loaded');
            } else {
                status48Rom.textContent = 'Not loaded';
                status48Rom.classList.remove('loaded');
            }

            if (rom128Data) {
                status128Rom.textContent = '✓ Loaded (' + (rom128Data.byteLength / 1024) + 'KB)';
                status128Rom.classList.add('loaded');
            } else {
                status128Rom.textContent = 'Not loaded (128K mode unavailable)';
                status128Rom.classList.remove('loaded');
            }

            if (romPentagonData) {
                statusPentagonRom.textContent = '✓ Loaded (' + (romPentagonData.byteLength / 1024) + 'KB)';
                statusPentagonRom.classList.add('loaded');
            } else {
                statusPentagonRom.textContent = 'Not loaded (Pentagon mode unavailable)';
                statusPentagonRom.classList.remove('loaded');
            }

            if (statusTrdosRom) {
                if (romTrdosData) {
                    statusTrdosRom.textContent = '✓ Loaded (' + (romTrdosData.byteLength / 1024) + 'KB)';
                    statusTrdosRom.classList.add('loaded');
                } else {
                    statusTrdosRom.textContent = 'Not loaded (required for TRD/SCL disk images)';
                    statusTrdosRom.classList.remove('loaded');
                }
            }

            btnStartEmulator.disabled = !rom48Data;
        }
        
        async function loadRomFile(data, type) {
            if (type === '48k') {
                rom48Data = data;
            } else if (type === '128k') {
                rom128Data = data;
            } else if (type === 'pentagon') {
                romPentagonData = data;
            } else if (type === 'trdos') {
                romTrdosData = data;
            }
            updateRomStatus();
        }

        function applyRomsToEmulator() {
            if (spectrum.machineType === '48k') {
                spectrum.memory.loadRom(rom48Data, 0);
            } else if (spectrum.machineType === '128k' && rom128Data) {
                spectrum.memory.loadRom(rom128Data.slice(0, 16384), 0);
                spectrum.memory.loadRom(rom128Data.slice(16384, 32768), 1);
            } else if (spectrum.machineType === 'pentagon' && romPentagonData) {
                spectrum.memory.loadRom(romPentagonData.slice(0, 16384), 0);
                spectrum.memory.loadRom(romPentagonData.slice(16384, 32768), 1);
                // Load TR-DOS ROM if available (separate 16KB ROM for Beta Disk)
                if (romTrdosData) {
                    spectrum.memory.loadTrdosRom(romTrdosData);
                }
            }
            spectrum.romLoaded = true;
        }
        
        function initializeEmulator() {
            // Validate saved machine type has required ROM, fallback to 48k if not
            if (spectrum.machineType === '128k' && !rom128Data) {
                spectrum.setMachineType('48k');
            } else if (spectrum.machineType === 'pentagon' && !romPentagonData) {
                spectrum.setMachineType('48k');
            }

            applyRomsToEmulator();
            romModal.classList.add('hidden');

            // Reset and start emulator immediately
            spectrum.reset();
            spectrum.start();

            showMessage('Emulator started');
        }
        
        // ROM Modal handlers
        btnSelect48Rom.addEventListener('click', () => rom48Input.click());
        btnSelect128Rom.addEventListener('click', () => rom128Input.click());
        btnSelectPentagonRom.addEventListener('click', () => romPentagonInput.click());
        if (btnSelectTrdosRom) btnSelectTrdosRom.addEventListener('click', () => romTrdosInput.click());
        
        rom48Input.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                const data = await file.arrayBuffer();
                await loadRomFile(data, '48k');
                showMessage('48K ROM loaded');
            }
            rom48Input.value = '';
        });
        
        rom128Input.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                const data = await file.arrayBuffer();
                await loadRomFile(data, '128k');
                showMessage('128K ROM loaded');
            }
            rom128Input.value = '';
        });
        
        romPentagonInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                const data = await file.arrayBuffer();
                await loadRomFile(data, 'pentagon');
                showMessage('Pentagon ROM loaded');
            }
            romPentagonInput.value = '';
        });

        romTrdosInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                const data = await file.arrayBuffer();
                await loadRomFile(data, 'trdos');
                showMessage('TR-DOS ROM loaded');
            }
            romTrdosInput.value = '';
        });

        btnStartEmulator.addEventListener('click', () => {
            initializeEmulator();
        });
        
        // Allow dropping ROMs on modal
        romModal.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
        });
        
        romModal.addEventListener('drop', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            const file = e.dataTransfer.files[0];
            if (!file) return;

            const data = await file.arrayBuffer();
            const name = file.name.toLowerCase();

            if (name.includes('trdos') || name === 'trdos.rom') {
                await loadRomFile(data, 'trdos');
                showMessage('TR-DOS ROM loaded');
            } else if (name.includes('pentagon')) {
                await loadRomFile(data, 'pentagon');
                showMessage('Pentagon ROM loaded');
            } else if (name.includes('128') || (data.byteLength >= 32768 && !name.includes('48') && !name.includes('trdos'))) {
                await loadRomFile(data, '128k');
                showMessage('128K ROM loaded');
            } else {
                await loadRomFile(data, '48k');
                showMessage('48K ROM loaded');
            }
        });
        
        setInterval(updateStatus, 500);
        
        btnRun.addEventListener('click', () => {
            if (!spectrum.romLoaded) {
                romModal.classList.remove('hidden');
                return;
            }
            spectrum.toggle();
            updateStatus();
        });
        
        // Step Into button
        const chkAutoComment = document.getElementById('chkAutoComment');
        btnStepInto.addEventListener('click', () => {
            if (!spectrum.romLoaded) {
                showMessage('ROM not loaded', 'error');
                return;
            }
            if (spectrum.isRunning()) {
                spectrum.stop();
            }
            // Auto-comment feature: add separator comment before stepping
            if (chkAutoComment.checked) {
                const pc = spectrum.cpu.pc;
                commentManager.set(pc, { before: '--------------------' });
            }
            // Return to live view when stepping
            traceManager.goToLive();
            traceViewAddress = null;
            spectrum.stepInto();
            openDebuggerPanel();
            updateDebugger();
            updateStatus();
        });

        // Step Over button
        btnStepOver.addEventListener('click', () => {
            if (!spectrum.romLoaded) {
                showMessage('ROM not loaded', 'error');
                return;
            }
            if (spectrum.isRunning()) {
                spectrum.stop();
            }
            // Return to live view when stepping
            traceManager.goToLive();
            traceViewAddress = null;
            spectrum.stepOver();
            openDebuggerPanel();
            updateDebugger();
            updateStatus();
        });
        
        function openDebuggerPanel() {
            // Expand tabs and switch to debugger tab
            tabContainer.classList.remove('collapsed');
            tabBtns.forEach(b => b.classList.remove('active'));
            tabContents.forEach(c => c.classList.remove('active'));
            document.querySelector('[data-tab="debugger"]').classList.add('active');
            document.getElementById('tab-debugger').classList.add('active');
        }
        
        // Disassembly view click handler
        disassemblyView.addEventListener('click', (e) => {
            // Check if clicking on breakpoint marker
            const bpMarker = e.target.closest('.disasm-bp');
            if (bpMarker) {
                const addr = parseInt(bpMarker.dataset.addr, 10);
                const isSet = spectrum.toggleBreakpoint(addr);
                showMessage(isSet ? `Breakpoint set at ${hex16(addr)}` : `Breakpoint removed at ${hex16(addr)}`);
                updateDebugger();
                return;
            }

            // Check if clicking on address column
            // Click = go to memory, Ctrl+Click = center disasm on that line
            const addrSpan = e.target.closest('.disasm-addr');
            if (addrSpan) {
                const line = addrSpan.closest('.disasm-line');
                if (line) {
                    const addr = parseInt(line.dataset.addr, 10);
                    if (e.ctrlKey) {
                        goToAddress(addr);
                        updateDebugger();
                        showMessage(`Disasm: ${hex16(addr)}`);
                    } else {
                        goToMemoryAddress(addr);
                        showMessage(`Memory: ${hex16(addr)}`);
                    }
                }
                return;
            }

            // Check if clicking on operand address (e.g., JP 4000h)
            // Click = go to disasm, Ctrl+Click = go to memory
            const operandAddr = e.target.closest('.disasm-operand-addr');
            if (operandAddr) {
                const addr = parseInt(operandAddr.dataset.addr, 10);
                if (e.ctrlKey) {
                    goToMemoryAddress(addr);
                    showMessage(`Memory: ${hex16(addr)}`);
                } else {
                    goToAddress(addr);
                    updateDebugger();
                    showMessage(`Disasm: ${hex16(addr)}`);
                }
                return;
            }

            // Otherwise, set run target
            const line = e.target.closest('.disasm-line');
            if (line) {
                runToTarget = parseInt(line.dataset.addr, 10);
                // Highlight selected line
                disassemblyView.querySelectorAll('.disasm-line').forEach(el => {
                    el.classList.remove('target');
                });
                line.classList.add('target');
                showMessage(`Run target: ${hex16(runToTarget)}`);
            }
        });

        // XRef tooltip handlers
        const xrefTooltip = document.getElementById('xrefTooltip');
        let xrefTooltipTimeout = null;

        function showXRefTooltip(addr, refs, x, y) {
            const typeNames = {
                'call': 'CALL',
                'jp': 'JP',
                'jr': 'JR',
                'djnz': 'DJNZ',
                'rst': 'RST',
                'ld_imm': 'LD',
                'ld_ind': 'LD'
            };

            let html = `<div class="xref-tooltip-header">XRefs to ${hex16(addr)} (${refs.length})</div>`;

            // Sort by address
            refs.sort((a, b) => a.fromAddr - b.fromAddr);

            // Limit display
            const maxShow = 20;
            const shown = refs.slice(0, maxShow);

            for (const ref of shown) {
                const label = labelManager.get(ref.fromAddr);
                const labelStr = label ? ` [${label.name}]` : '';
                const typeClass = ref.type.startsWith('ld') ? 'ld' : ref.type;
                html += `<div class="xref-tooltip-item">
                    <span class="xref-type-${typeClass}">${typeNames[ref.type] || ref.type}</span>
                    from ${hex16(ref.fromAddr)}${labelStr}
                </div>`;
            }

            if (refs.length > maxShow) {
                html += `<div class="xref-tooltip-item">...and ${refs.length - maxShow} more</div>`;
            }

            xrefTooltip.innerHTML = html;
            xrefTooltip.style.display = 'block';
            xrefTooltip.style.left = (x + 15) + 'px';
            xrefTooltip.style.top = (y + 10) + 'px';

            // Adjust if off-screen
            const rect = xrefTooltip.getBoundingClientRect();
            if (rect.right > window.innerWidth) {
                xrefTooltip.style.left = (x - rect.width - 5) + 'px';
            }
            if (rect.bottom > window.innerHeight) {
                xrefTooltip.style.top = (y - rect.height - 5) + 'px';
            }
        }

        function hideXRefTooltip() {
            xrefTooltip.style.display = 'none';
            if (xrefTooltipTimeout) {
                clearTimeout(xrefTooltipTimeout);
                xrefTooltipTimeout = null;
            }
        }

        disassemblyView.addEventListener('mouseover', (e) => {
            const operandAddr = e.target.closest('.disasm-operand-addr');
            if (!operandAddr) return;

            const addr = parseInt(operandAddr.dataset.addr, 10);
            if (isNaN(addr)) return;

            const refs = xrefManager.get(addr);
            if (refs.length === 0) return;

            // Delay showing tooltip
            if (xrefTooltipTimeout) clearTimeout(xrefTooltipTimeout);
            xrefTooltipTimeout = setTimeout(() => {
                showXRefTooltip(addr, refs, e.clientX, e.clientY);
            }, 300);
        });

        disassemblyView.addEventListener('mouseout', (e) => {
            const operandAddr = e.target.closest('.disasm-operand-addr');
            if (operandAddr) {
                hideXRefTooltip();
            }
        });

        // Label context menu and dialog
        let labelContextMenu = null;
        let labelDialogAddr = null;
        const labelDialog = document.getElementById('labelDialog');
        const labelDialogTitle = document.getElementById('labelDialogTitle');
        const labelAddrInput = document.getElementById('labelAddrInput');
        const labelNameInput = document.getElementById('labelNameInput');
        const labelCommentInput = document.getElementById('labelCommentInput');
        const labelSizeInput = document.getElementById('labelSizeInput');
        const btnLabelCancel = document.getElementById('btnLabelCancel');
        const btnLabelSave = document.getElementById('btnLabelSave');

        function closeLabelContextMenu() {
            if (labelContextMenu) {
                labelContextMenu.remove();
                labelContextMenu = null;
            }
        }

        function showLabelDialog(addr, pageOrLabel = null) {
            // If addr is null, we're adding a new label with editable address
            // If pageOrLabel is an object, it's an existing label; if number/null, it's a page
            let existingLabel = null;
            let page = null;

            if (pageOrLabel !== null && typeof pageOrLabel === 'object') {
                existingLabel = pageOrLabel;
                page = existingLabel.page;
            } else if (addr !== null) {
                page = pageOrLabel;
                existingLabel = labelManager.get(addr, page);
            }

            labelDialogAddr = addr;
            labelAddrInput.value = addr !== null ? hex16(addr) : '';
            labelAddrInput.readOnly = addr !== null;
            labelDialogTitle.textContent = existingLabel ? 'Edit Label' : 'Add Label';

            if (existingLabel) {
                labelNameInput.value = existingLabel.name;
                labelCommentInput.value = existingLabel.comment || '';
                labelSizeInput.value = existingLabel.size || 1;
            } else {
                labelNameInput.value = '';
                labelCommentInput.value = '';
                labelSizeInput.value = 1;
            }

            labelDialog.classList.remove('hidden');
            if (addr === null) {
                labelAddrInput.focus();
                labelAddrInput.select();
            } else {
                labelNameInput.focus();
                labelNameInput.select();
            }
        }

        function closeLabelDialog() {
            labelDialog.classList.add('hidden');
            labelDialogAddr = null;
        }

        function saveLabelFromDialog() {
            let addr = labelDialogAddr;

            // If addr is null, parse from input
            if (addr === null) {
                const addrStr = labelAddrInput.value.trim().toUpperCase();
                if (!addrStr || !/^[0-9A-F]{1,4}$/.test(addrStr)) {
                    showMessage('Valid hex address required (0000-FFFF)', 'error');
                    labelAddrInput.focus();
                    return;
                }
                addr = parseInt(addrStr, 16);
            }

            const name = labelNameInput.value.trim();
            if (!name) {
                showMessage('Label name is required', 'error');
                labelNameInput.focus();
                return;
            }

            // Validate label name: must start with letter/underscore, contain only letters/digits/underscores
            if (!/^[A-Za-z_][A-Za-z0-9_]*$/.test(name)) {
                showMessage('Invalid label: use letters, digits, _ (start with letter or _)', 'error');
                labelNameInput.focus();
                return;
            }

            // Check for duplicate name (case-insensitive, different address)
            const existing = labelManager.findByName(name);
            if (existing && existing.address !== addr) {
                showMessage(`Label "${existing.name}" already exists at ${hex16(existing.address)}`, 'error');
                labelNameInput.focus();
                return;
            }

            // Capture old label for undo
            const oldLabel = labelManager.get(addr);
            const newLabel = {
                address: addr,
                name: name,
                comment: labelCommentInput.value.trim(),
                size: parseInt(labelSizeInput.value, 10) || 1
            };

            labelManager.add(newLabel);

            // Push undo action
            undoManager.push({
                type: 'label',
                description: oldLabel ? `Update label "${name}"` : `Add label "${name}"`,
                undo: () => {
                    if (oldLabel) {
                        labelManager.add(oldLabel);
                    } else {
                        labelManager.remove(addr);
                    }
                    updateLabelsList();
                },
                redo: () => {
                    labelManager.add(newLabel);
                    updateLabelsList();
                }
            });

            showMessage(`Label "${name}" saved at ${hex16(addr)}`);
            closeLabelDialog();
            updateLabelsList();
            updateDebugger();
        }

        btnLabelCancel.addEventListener('click', closeLabelDialog);
        btnLabelSave.addEventListener('click', saveLabelFromDialog);

        labelDialog.addEventListener('click', (e) => {
            if (e.target === labelDialog) closeLabelDialog();
        });

        labelNameInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') saveLabelFromDialog();
            if (e.key === 'Escape') closeLabelDialog();
        });

        // Region dialog
        const regionDialog = document.getElementById('regionDialog');
        const regionDialogTitle = document.getElementById('regionDialogTitle');
        const regionStartInput = document.getElementById('regionStartInput');
        const regionEndInput = document.getElementById('regionEndInput');
        const regionTypeSelect = document.getElementById('regionTypeSelect');
        const regionCommentInput = document.getElementById('regionCommentInput');
        const btnRegionSave = document.getElementById('btnRegionSave');
        const btnRegionCancel = document.getElementById('btnRegionCancel');
        let regionDialogStartAddr = null;

        function showRegionDialog(startAddr, type = REGION_TYPES.CODE, endAddr = null) {
            regionDialogStartAddr = startAddr;
            regionStartInput.value = hex16(startAddr);
            regionEndInput.value = hex16(endAddr !== null ? endAddr : startAddr);
            regionTypeSelect.value = type;
            regionCommentInput.value = '';

            const typeNames = {
                [REGION_TYPES.CODE]: 'Code',
                [REGION_TYPES.DB]: 'DB (bytes)',
                [REGION_TYPES.DW]: 'DW (words)',
                [REGION_TYPES.TEXT]: 'Text',
                [REGION_TYPES.GRAPHICS]: 'Graphics',
                [REGION_TYPES.SMC]: 'SMC'
            };
            regionDialogTitle.textContent = `Mark Region as ${typeNames[type] || 'Unknown'}`;

            regionDialog.classList.remove('hidden');
            regionEndInput.focus();
            regionEndInput.select();
        }

        function closeRegionDialog() {
            regionDialog.classList.add('hidden');
            regionDialogStartAddr = null;
        }

        function saveRegionFromDialog() {
            const startAddr = regionDialogStartAddr;
            const endStr = regionEndInput.value.trim().toUpperCase();

            if (!/^[0-9A-F]{1,4}$/.test(endStr)) {
                showMessage('Valid hex end address required', 'error');
                regionEndInput.focus();
                return;
            }

            const endAddr = parseInt(endStr, 16);

            if (endAddr < startAddr) {
                showMessage('End address must be >= start address', 'error');
                regionEndInput.focus();
                return;
            }

            // Check for overlapping regions
            const overlapping = regionManager.getOverlapping(startAddr, endAddr);
            if (overlapping.length > 0) {
                const r = overlapping[0];
                const existingRange = `${r.start.toString(16).toUpperCase()}-${r.end.toString(16).toUpperCase()}`;
                const existingType = r.type.toUpperCase();
                showMessage(`Overlap with existing ${existingType} region at ${existingRange}. Remove it first.`, 'error');
                return;
            }

            const newRegion = {
                start: startAddr,
                end: endAddr,
                type: regionTypeSelect.value,
                comment: regionCommentInput.value.trim()
            };

            regionManager.add(newRegion);

            undoManager.push({
                type: 'region',
                description: `Add region ${hex16(startAddr)}-${hex16(endAddr)}`,
                undo: () => {
                    regionManager.remove(startAddr);
                },
                redo: () => {
                    regionManager.add(newRegion, true);  // allowOverwrite for redo
                }
            });

            showMessage(`Region ${hex16(startAddr)}-${hex16(endAddr)} marked as ${regionTypeSelect.value}`);
            closeRegionDialog();
            updateDebugger();
        }

        btnRegionSave.addEventListener('click', saveRegionFromDialog);
        btnRegionCancel.addEventListener('click', closeRegionDialog);

        regionDialog.addEventListener('click', (e) => {
            if (e.target === regionDialog) closeRegionDialog();
        });

        regionEndInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') saveRegionFromDialog();
            if (e.key === 'Escape') closeRegionDialog();
        });

        // Comment dialog elements and state
        const commentDialog = document.getElementById('commentDialog');
        const commentDialogTitle = document.getElementById('commentDialogTitle');
        const commentAddrInput = document.getElementById('commentAddrInput');
        const commentSeparator = document.getElementById('commentSeparator');
        const commentBeforeInput = document.getElementById('commentBeforeInput');
        const commentInlineInput = document.getElementById('commentInlineInput');
        const commentAfterInput = document.getElementById('commentAfterInput');
        const btnCommentSave = document.getElementById('btnCommentSave');
        const btnCommentDelete = document.getElementById('btnCommentDelete');
        const btnCommentCancel = document.getElementById('btnCommentCancel');
        let commentDialogAddr = null;

        function showCommentDialog(addr) {
            commentDialogAddr = addr;
            commentAddrInput.value = hex16(addr);

            const existing = commentManager.get(addr);
            if (existing) {
                commentDialogTitle.textContent = 'Edit Comment';
                commentSeparator.checked = existing.separator || false;
                commentBeforeInput.value = existing.before || '';
                commentInlineInput.value = existing.inline || '';
                commentAfterInput.value = existing.after || '';
                btnCommentDelete.style.display = 'inline-block';
            } else {
                commentDialogTitle.textContent = 'Add Comment';
                commentSeparator.checked = false;
                commentBeforeInput.value = '';
                commentInlineInput.value = '';
                commentAfterInput.value = '';
                btnCommentDelete.style.display = 'none';
            }

            commentDialog.classList.remove('hidden');
            commentInlineInput.focus();
        }

        function closeCommentDialog() {
            commentDialog.classList.add('hidden');
            commentDialogAddr = null;
        }

        function saveCommentFromDialog() {
            const addr = commentDialogAddr;
            if (addr === null) return;

            const oldComment = commentManager.get(addr);
            const newComment = {
                separator: commentSeparator.checked,
                before: commentBeforeInput.value,
                inline: commentInlineInput.value,
                after: commentAfterInput.value
            };

            commentManager.set(addr, newComment);

            undoManager.push({
                type: 'comment',
                description: oldComment ? `Update comment at ${hex16(addr)}` : `Add comment at ${hex16(addr)}`,
                undo: () => {
                    if (oldComment) {
                        commentManager.set(addr, oldComment);
                    } else {
                        commentManager.remove(addr);
                    }
                },
                redo: () => {
                    commentManager.set(addr, newComment);
                }
            });

            showMessage(`Comment ${commentManager.get(addr) ? 'saved' : 'removed'} at ${hex16(addr)}`);
            closeCommentDialog();
            updateDebugger();
        }

        function deleteCommentFromDialog() {
            const addr = commentDialogAddr;
            if (addr === null) return;

            const oldComment = commentManager.get(addr);
            if (!oldComment) return;

            commentManager.remove(addr);

            undoManager.push({
                type: 'comment',
                description: `Delete comment at ${hex16(addr)}`,
                undo: () => {
                    commentManager.set(addr, oldComment);
                },
                redo: () => {
                    commentManager.remove(addr);
                }
            });

            showMessage(`Comment removed at ${hex16(addr)}`);
            closeCommentDialog();
            updateDebugger();
        }

        btnCommentSave.addEventListener('click', saveCommentFromDialog);
        btnCommentDelete.addEventListener('click', deleteCommentFromDialog);
        btnCommentCancel.addEventListener('click', closeCommentDialog);

        commentDialog.addEventListener('click', (e) => {
            if (e.target === commentDialog) closeCommentDialog();
        });

        commentInlineInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') saveCommentFromDialog();
            if (e.key === 'Escape') closeCommentDialog();
        });

        labelAddrInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                labelNameInput.focus();
                labelNameInput.select();
            }
            if (e.key === 'Escape') closeLabelDialog();
        });

        labelCommentInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') saveLabelFromDialog();
            if (e.key === 'Escape') closeLabelDialog();
        });

        // Disassembly right-click context menu for labels
        disassemblyView.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            closeLabelContextMenu();

            const line = e.target.closest('.disasm-line');
            if (!line) return;

            const lineAddr = parseInt(line.dataset.addr, 10);

            // Check if clicking on operand address (e.g., JP 4000h)
            const operandAddrEl = e.target.closest('.disasm-operand-addr');
            const targetAddr = operandAddrEl ? parseInt(operandAddrEl.dataset.addr, 10) : null;

            // Use target address if clicking on operand, otherwise use line address
            const addr = targetAddr !== null ? targetAddr : lineAddr;
            const existingLabel = labelManager.get(addr);

            labelContextMenu = document.createElement('div');
            labelContextMenu.className = 'label-context-menu';

            const existingRegion = regionManager.get(addr);

            let menuHtml = `<div data-action="goto-disasm">Go to disasm ${hex16(addr)}</div>`;
            menuHtml += `<div data-action="goto-mem">Go to memory ${hex16(addr)}</div>`;
            menuHtml += `<div class="menu-separator"></div>`;
            if (existingLabel) {
                menuHtml += `
                    <div data-action="edit">Edit Label "${existingLabel.name}"</div>
                    <div data-action="delete" class="danger">Delete Label</div>
                    <div data-action="add">Add Label at ${hex16(addr)}</div>
                `;
            } else {
                menuHtml += `
                    <div data-action="add">Add Label at ${hex16(addr)}</div>
                `;
            }
            // Comment option
            const existingComment = commentManager.get(addr);
            if (existingComment) {
                menuHtml += `<div data-action="edit-comment">Edit Comment</div>`;
                menuHtml += `<div data-action="delete-comment" class="danger">Delete Comment</div>`;
            } else {
                menuHtml += `<div data-action="add-comment">Add Comment</div>`;
            }
            menuHtml += `<div class="menu-separator"></div>`;
            // Operand format submenu (show for all lines - format applies to instruction)
            const currentFormat = operandFormatManager.get(lineAddr);
            menuHtml += `<div class="menu-submenu">Operand format...
                <div class="menu-submenu-items">
                    <div data-action="format-hex"${currentFormat === 'hex' ? ' class="selected"' : ''}>Hex (FFh)</div>
                    <div data-action="format-dec"${currentFormat === 'dec' ? ' class="selected"' : ''}>Decimal (255)</div>
                    <div data-action="format-bin"${currentFormat === 'bin' ? ' class="selected"' : ''}>Binary (%11111111)</div>
                    <div data-action="format-char"${currentFormat === 'char' ? ' class="selected"' : ''}>Char ('A')</div>
                </div>
            </div>`;
            menuHtml += `<div class="menu-submenu">Mark from ${hex16(addr)} as...
                <div class="menu-submenu-items">
                    <div data-action="mark-code">Code</div>
                    <div data-action="mark-db">DB (bytes)</div>
                    <div data-action="mark-dw">DW (words)</div>
                    <div data-action="mark-text">Text (ASCII)</div>
                    <div data-action="mark-gfx">Graphics</div>
                    <div data-action="mark-smc">SMC (self-mod)</div>
                </div>
            </div>`;
            if (existingRegion) {
                menuHtml += `<div data-action="remove-region" class="danger">Remove region mark</div>`;
            }
            labelContextMenu.innerHTML = menuHtml;

            labelContextMenu.style.left = e.clientX + 'px';
            labelContextMenu.style.top = e.clientY + 'px';
            document.body.appendChild(labelContextMenu);

            // Adjust submenu position if it would overflow viewport
            const submenu = labelContextMenu.querySelector('.menu-submenu');
            if (submenu) {
                const menuRect = labelContextMenu.getBoundingClientRect();
                const submenuItems = submenu.querySelector('.menu-submenu-items');
                if (submenuItems) {
                    // Temporarily show to measure
                    submenuItems.style.display = 'block';
                    const subRect = submenuItems.getBoundingClientRect();
                    submenuItems.style.display = '';

                    // Check horizontal overflow
                    if (menuRect.right + subRect.width > window.innerWidth) {
                        submenu.classList.add('submenu-left');
                    }
                    // Check vertical overflow
                    if (menuRect.top + subRect.height > window.innerHeight) {
                        submenu.classList.add('submenu-up');
                    }
                }
            }

            labelContextMenu.addEventListener('click', (menuE) => {
                const action = menuE.target.dataset.action;
                if (action === 'goto-disasm') {
                    goToAddress(addr);
                    updateDebugger();
                } else if (action === 'goto-mem') {
                    goToMemoryAddress(addr);
                } else if (action === 'add') {
                    showLabelDialog(addr);
                } else if (action === 'edit') {
                    showLabelDialog(addr, existingLabel);
                } else if (action === 'delete') {
                    const oldLabel = existingLabel;
                    labelManager.remove(addr);
                    undoManager.push({
                        type: 'label',
                        description: `Delete label "${oldLabel.name}"`,
                        undo: () => {
                            labelManager.add(oldLabel);
                            updateLabelsList();
                        },
                        redo: () => {
                            labelManager.remove(addr);
                            updateLabelsList();
                        }
                    });
                    showMessage(`Label "${existingLabel.name}" deleted`);
                    updateDebugger();
                } else if (action === 'format-hex') {
                    operandFormatManager.set(lineAddr, OPERAND_FORMATS.HEX);
                    updateDebugger();
                } else if (action === 'format-dec') {
                    operandFormatManager.set(lineAddr, OPERAND_FORMATS.DEC);
                    updateDebugger();
                } else if (action === 'format-bin') {
                    operandFormatManager.set(lineAddr, OPERAND_FORMATS.BIN);
                    updateDebugger();
                } else if (action === 'format-char') {
                    operandFormatManager.set(lineAddr, OPERAND_FORMATS.CHAR);
                    updateDebugger();
                } else if (action === 'mark-code') {
                    showRegionDialog(addr, REGION_TYPES.CODE);
                } else if (action === 'mark-db') {
                    showRegionDialog(addr, REGION_TYPES.DB);
                } else if (action === 'mark-dw') {
                    showRegionDialog(addr, REGION_TYPES.DW);
                } else if (action === 'mark-text') {
                    showRegionDialog(addr, REGION_TYPES.TEXT);
                } else if (action === 'mark-gfx') {
                    showRegionDialog(addr, REGION_TYPES.GRAPHICS);
                } else if (action === 'mark-smc') {
                    showRegionDialog(addr, REGION_TYPES.SMC);
                } else if (action === 'remove-region') {
                    const oldRegion = regionManager.get(addr);
                    if (oldRegion) {
                        regionManager.remove(addr);
                        undoManager.push({
                            type: 'region',
                            description: `Remove region ${hex16(oldRegion.start)}-${hex16(oldRegion.end)}`,
                            undo: () => {
                                regionManager.add(oldRegion, true);  // allowOverwrite for undo
                            },
                            redo: () => {
                                regionManager.remove(addr);
                            }
                        });
                        showMessage('Region mark removed');
                        updateDebugger();
                    }
                } else if (action === 'add-comment' || action === 'edit-comment') {
                    showCommentDialog(addr);
                } else if (action === 'delete-comment') {
                    const oldComment = commentManager.get(addr);
                    if (oldComment) {
                        commentManager.remove(addr);
                        undoManager.push({
                            type: 'comment',
                            description: `Delete comment at ${hex16(addr)}`,
                            undo: () => {
                                commentManager.set(addr, oldComment);
                            },
                            redo: () => {
                                commentManager.remove(addr);
                            }
                        });
                        showMessage(`Comment removed at ${hex16(addr)}`);
                        updateDebugger();
                    }
                }
                closeLabelContextMenu();
            });
        });

        // Close context menu on click elsewhere
        document.addEventListener('click', (e) => {
            if (labelContextMenu && !labelContextMenu.contains(e.target)) {
                closeLabelContextMenu();
            }
        });

        // Unified Trigger handlers
        triggerType.addEventListener('change', () => {
            const type = triggerType.value;
            if (type.startsWith('port')) {
                triggerAddrInput.placeholder = 'PORT[&MASK]';
            } else {
                triggerAddrInput.placeholder = '[P:]ADDR[-END]';
            }
        });

        btnAddTrigger.addEventListener('click', () => {
            const type = triggerType.value;
            const addrStr = triggerAddrInput.value.trim();
            if (!addrStr) return;
            const condition = triggerCondInput.value.trim();
            const skipCount = parseInt(document.getElementById('triggerSkipInput').value) || 0;

            // Parse address based on type
            let triggerSpec;
            if (type.startsWith('port')) {
                const parsed = spectrum.parsePortSpec(addrStr);
                if (!parsed) {
                    showMessage('Invalid port address', 'error');
                    return;
                }
                triggerSpec = { type, start: parsed.port, end: parsed.port, mask: parsed.mask };
            } else {
                const parsed = spectrum.parseAddressSpec(addrStr);
                if (!parsed) {
                    showMessage('Invalid address', 'error');
                    return;
                }
                triggerSpec = { type, start: parsed.start, end: parsed.end, page: parsed.page };
            }

            if (condition) triggerSpec.condition = condition;
            if (skipCount > 0) triggerSpec.skipCount = skipCount;

            if (spectrum.addTrigger(triggerSpec) < 0) {
                showMessage('Failed to add trigger', 'error');
                return;
            }

            triggerAddrInput.value = '';
            triggerCondInput.value = '';
            document.getElementById('triggerSkipInput').value = '0';
            const typeLabel = spectrum.getTriggerLabel(type);
            let msg = `${typeLabel} trigger set: ${addrStr.toUpperCase()}`;
            if (condition) msg += ` if ${condition}`;
            if (skipCount > 0) msg += ` (skip ${skipCount})`;
            showMessage(msg);
            updateDebugger();
        });

        triggerAddrInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') btnAddTrigger.click();
        });

        triggerCondInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') btnAddTrigger.click();
        });

        btnClearTriggers.addEventListener('click', () => {
            const count = spectrum.getTriggers().length;
            if (count === 0) {
                showMessage('No triggers to clear', 'error');
                return;
            }
            spectrum.clearTriggers();
            showMessage(`Cleared ${count} trigger(s)`);
            updateDebugger();
        });

        // Trigger list click handler (remove, toggle, navigate)
        triggerList.addEventListener('click', (e) => {
            const index = parseInt(e.target.dataset.index, 10);
            if (isNaN(index)) return;

            if (e.target.classList.contains('trigger-remove')) {
                const triggers = spectrum.getTriggers();
                const t = triggers.find(tr => tr.index === index);
                spectrum.removeTrigger(index);
                showMessage(`Trigger removed: ${t ? spectrum.formatTrigger(t) : index}`);
                updateDebugger();
            } else if (e.target.classList.contains('trigger-toggle')) {
                const enabled = spectrum.toggleTrigger(index);
                showMessage(`Trigger ${enabled ? 'enabled' : 'disabled'}`);
                updateDebugger();
            } else if (e.target.classList.contains('trigger-desc')) {
                // Navigate to address
                const triggers = spectrum.getTriggers();
                const t = triggers.find(tr => tr.index === index);
                if (t && !t.type.startsWith('port')) {
                    goToDisassembly(t.start);
                    goToMemoryAddress(t.start);
                    updateDebugger();
                }
            }
        });

        // Breakpoint/Watchpoint/Port hit callbacks (for compatibility)
        spectrum.onBreakpoint = (addr) => {
            showMessage(`Breakpoint hit at ${hex16(addr)}`);
            disasmViewAddress = null; // Force disasm to show PC
            openDebuggerPanel();
            updateDebugger();
            updateStatus();
        };

        spectrum.onWatchpoint = (wp) => {
            const typeStr = wp.type === 'read' ? 'Read' : 'Write';
            showMessage(`Watchpoint: ${typeStr} at ${hex16(wp.addr)} = ${hex8(wp.val)}`);
            disasmViewAddress = null; // Force disasm to show PC
            openDebuggerPanel();
            goToMemoryAddress(wp.addr);
            updateDebugger();
            updateStatus();
        };

        spectrum.onPortBreakpoint = (pb) => {
            const dirStr = pb.direction === 'in' ? 'IN' : 'OUT';
            const portHex = pb.port.toString(16).toUpperCase().padStart(4, '0');
            let msg = `Port breakpoint: ${dirStr} ${portHex}`;
            if (pb.val !== undefined) msg += ` = ${hex8(pb.val)}`;
            showMessage(msg);
            disasmViewAddress = null; // Force disasm to show PC
            openDebuggerPanel();
            updateDebugger();
            updateStatus();
        };

        // Unified trigger callback
        spectrum.onTrigger = (info) => {
            // Already handled by individual callbacks above
            // This is for future unified handling
            disasmViewAddress = null; // Force disasm to show PC
            updateDebugger();
        };

        // Labels panel handlers
        labelFilterInput.addEventListener('input', () => {
            updateLabelsList();
        });

        btnAddLabel.addEventListener('click', () => {
            showLabelDialog(null, null);
        });

        btnClearLabels.addEventListener('click', () => {
            const count = labelManager.getAll().length;
            if (count === 0) {
                showMessage('No labels to clear', 'error');
                return;
            }
            if (confirm(`Clear all ${count} label(s)?`)) {
                labelManager.labels.clear();
                labelManager._autoSave();
                showMessage(`Cleared ${count} label(s)`);
                updateLabelsList();
                updateDebugger();
            }
        });

        btnExportLabels.addEventListener('click', () => {
            const labels = labelManager.getAll();
            if (labels.length === 0) {
                showMessage('No labels to export', 'error');
                return;
            }
            try {
                const json = labelManager.exportJSON();
                const blob = new Blob([json], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const filename = labelManager.currentFile
                    ? labelManager.currentFile.replace(/\.[^.]+$/, '') + '_labels.json'
                    : 'labels.json';
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
                showMessage(`Exported ${labels.length} label(s)`);
            } catch (e) {
                showMessage('Export failed: ' + e.message, 'error');
            }
        });

        btnImportLabels.addEventListener('click', () => {
            labelFileInput.click();
        });

        labelFileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const merge = labelManager.getAll().length > 0 &&
                                  confirm('Merge with existing labels?\n(Cancel to replace all)');
                    const count = labelManager.importJSON(event.target.result, merge);
                    showMessage(`Imported ${count} label(s)${merge ? ' (merged)' : ''}`);
                    updateLabelsList();
                    updateDebugger();
                } catch (err) {
                    showMessage('Invalid labels file: ' + err.message, 'error');
                }
            };
            reader.readAsText(file);
            labelFileInput.value = '';
        });

        labelsList.addEventListener('click', (e) => {
            const removeBtn = e.target.closest('.label-remove');
            if (removeBtn) {
                const addr = parseInt(removeBtn.dataset.addr, 10);
                const page = removeBtn.dataset.page === 'null' ? null : parseInt(removeBtn.dataset.page, 10);
                const oldLabel = labelManager.get(addr, page);
                if (!oldLabel) return;
                labelManager.remove(addr, page);
                undoManager.push({
                    type: 'label',
                    description: `Delete label "${oldLabel.name}"`,
                    undo: () => {
                        labelManager.add(oldLabel);
                        updateLabelsList();
                    },
                    redo: () => {
                        labelManager.remove(addr, page);
                        updateLabelsList();
                    }
                });
                showMessage(`Label removed: ${oldLabel.name}`);
                updateLabelsList();
                updateDebugger();
                return;
            }

            const editBtn = e.target.closest('.label-edit');
            if (editBtn) {
                const addr = parseInt(editBtn.dataset.addr, 10);
                const page = editBtn.dataset.page === 'null' ? null : parseInt(editBtn.dataset.page, 10);
                const label = labelManager.get(addr, page);
                showLabelDialog(addr, label);
                return;
            }

            const item = e.target.closest('.label-item');
            if (item) {
                const addr = parseInt(item.dataset.addr, 10);
                goToAddress(addr);
                updateDebugger();
            }
        });

        btnRunTo.addEventListener('click', () => {
            if (!spectrum.romLoaded) return;
            if (runToTarget === null) {
                showMessage('Click a line in disassembly to set target', 'error');
                return;
            }
            if (spectrum.isRunning()) {
                spectrum.stop();
            }
            traceManager.goToLive();
            traceViewAddress = null;
            const reached = spectrum.runToAddress(runToTarget);
            if (reached) {
                showMessage(`Reached ${hex16(runToTarget)}`);
            } else {
                showMessage('Target not reached (max cycles)', 'error');
            }
            updateDebugger();
            updateStatus();
        });

        btnRunToInt.addEventListener('click', () => {
            if (!spectrum.romLoaded) return;
            if (spectrum.isRunning()) {
                spectrum.stop();
            }
            traceManager.goToLive();
            traceViewAddress = null;
            const reached = spectrum.runToInterrupt();
            if (reached) {
                showMessage('Interrupt reached');
            } else {
                showMessage('Interrupt not reached (max cycles)', 'error');
            }
            updateDebugger();
            updateStatus();
        });

        btnRunToRet.addEventListener('click', () => {
            if (!spectrum.romLoaded) return;
            if (spectrum.isRunning()) {
                spectrum.stop();
            }
            traceManager.goToLive();
            traceViewAddress = null;
            const reached = spectrum.runToRet();
            if (reached) {
                showMessage(`RET at ${hex16(spectrum.cpu.pc)}`);
            } else {
                showMessage('RET not reached (max cycles)', 'error');
            }
            updateDebugger();
            updateStatus();
        });

        btnRunTstates.addEventListener('click', () => {
            if (!spectrum.romLoaded) return;
            const tstates = parseInt(tstatesInput.value, 10);
            if (isNaN(tstates) || tstates <= 0) {
                showMessage('Invalid T-states value', 'error');
                return;
            }
            if (spectrum.isRunning()) {
                spectrum.stop();
            }
            traceManager.goToLive();
            traceViewAddress = null;
            const executed = spectrum.runTstates(tstates);
            // Auto-comment feature: add separator comment at stop address
            if (chkAutoComment.checked) {
                const pc = spectrum.cpu.pc;
                commentManager.set(pc, { before: '--------------------' });
            }
            showMessage(`Executed ${executed} T-states`);
            updateDebugger();
            updateStatus();
        });
        
        // Global hotkeys for debugger
        document.addEventListener('keydown', (e) => {
            // Don't capture if typing in input fields or editing registers
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            if (e.target.isContentEditable || isEditingRegister) return;

            // Ctrl+Z - Undo (only when emulator is paused to not interfere with BASIC)
            if (e.ctrlKey && e.key === 'z' && !spectrum.isRunning()) {
                e.preventDefault();
                undoManager.undo();
                return;
            }
            // Ctrl+Y - Redo (only when emulator is paused)
            if (e.ctrlKey && e.key === 'y' && !spectrum.isRunning()) {
                e.preventDefault();
                undoManager.redo();
                return;
            }

            // Alt+Left - Trace back
            if (e.altKey && e.key === 'ArrowLeft' && !spectrum.isRunning()) {
                e.preventDefault();
                const entry = traceManager.goBack();
                if (entry) {
                    showTraceEntry(entry);
                }
                return;
            }
            // Alt+Right - Trace forward
            if (e.altKey && e.key === 'ArrowRight' && !spectrum.isRunning()) {
                e.preventDefault();
                const entry = traceManager.goForward();
                if (entry) {
                    showTraceEntry(entry);
                } else {
                    traceManager.goToLive();
                    updateTraceStatus();
                    updateTraceList();
                    showMessage('Returned to live view');
                }
                return;
            }

            // F6 - Pause/Resume
            if (e.code === 'F6' || e.key === 'F6' || e.key === 'Pause') {
                e.preventDefault();
                if (spectrum.romLoaded) {
                    spectrum.toggle();
                    updateStatus();
                    showMessage(spectrum.isRunning() ? 'Resumed' : 'Paused');
                }
                return;
            }
            // F7 - Step Into
            if (e.code === 'F7' || e.key === 'F7') {
                e.preventDefault();
                if (!spectrum.romLoaded) return;
                if (spectrum.isRunning()) {
                    spectrum.stop();
                    updateStatus();
                }
                traceManager.goToLive();
                traceViewAddress = null;
                spectrum.stepInto();
                openDebuggerPanel();
                updateDebugger();
                updateStatus();
                return;
            }
            // F8 - Step Over
            if (e.code === 'F8' || e.key === 'F8') {
                e.preventDefault();
                if (!spectrum.romLoaded) return;
                if (spectrum.isRunning()) {
                    spectrum.stop();
                    updateStatus();
                }
                traceManager.goToLive();
                traceViewAddress = null;
                spectrum.stepOver();
                openDebuggerPanel();
                updateDebugger();
                updateStatus();
                return;
            }
            // F4 - Run to Cursor
            if (e.key === 'F4') {
                e.preventDefault();
                if (!spectrum.romLoaded) return;
                if (runToTarget === null) {
                    showMessage('Click a disassembly line first', 'error');
                    return;
                }
                if (spectrum.isRunning()) {
                    spectrum.stop();
                }
                traceManager.goToLive();
                traceViewAddress = null;
                const reached = spectrum.runToAddress(runToTarget);
                if (reached) {
                    showMessage(`Reached ${hex16(runToTarget)}`);
                } else {
                    showMessage('Target not reached', 'error');
                }
                openDebuggerPanel();
                updateDebugger();
                updateStatus();
                return;
            }
            // F9 - Toggle Breakpoint at PC
            if (e.key === 'F9') {
                e.preventDefault();
                if (!spectrum.romLoaded) return;
                const pc = spectrum.cpu.pc;
                const isSet = spectrum.toggleBreakpoint(pc);
                showMessage(isSet ? `Breakpoint set at ${hex16(pc)}` : `Breakpoint removed at ${hex16(pc)}`);
                openDebuggerPanel();
                updateDebugger();
                return;
            }
        });
        
        btnReset.addEventListener('click', () => {
            if (!confirm('Reset machine? This will lose current state.')) return;
            spectrum.reset();
            showMessage('Machine reset');
        });

        document.getElementById('btnScreenshot').addEventListener('click', () => {
            const canvas = document.getElementById('screen');
            canvas.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `screenshot_${spectrum.machineType}_${Date.now()}.png`;
                a.click();
                URL.revokeObjectURL(url);
                showMessage('Screenshot saved');
            }, 'image/png');
        });

        btnLoadFile.addEventListener('click', () => fileInput.click());
        
        btnSaveSnapshot.addEventListener('click', () => {
            try {
                const data = spectrum.saveSnapshot();
                const blob = new Blob([data], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `snapshot_${spectrum.machineType}_${Date.now()}.sna`;
                a.click();
                URL.revokeObjectURL(url);
                showMessage('Snapshot saved');
            } catch (e) {
                showMessage('Failed to save: ' + e.message, 'error');
            }
        });

        // Project save/load
        const btnSaveProject = document.getElementById('btnSaveProject');
        const btnLoadProject = document.getElementById('btnLoadProject');
        const projectFileInput = document.getElementById('projectFileInput');

        // Helper to convert array/Uint8Array to base64 (handles large arrays)
        function arrayToBase64(data) {
            // Ensure we have a Uint8Array
            const arr = data instanceof Uint8Array ? data : new Uint8Array(data);
            let binary = '';
            const chunkSize = 8192;
            for (let i = 0; i < arr.length; i += chunkSize) {
                const end = Math.min(i + chunkSize, arr.length);
                // Convert chunk to regular array for String.fromCharCode.apply
                const chunk = Array.from(arr.subarray(i, end));
                binary += String.fromCharCode.apply(null, chunk);
            }
            return btoa(binary);
        }

        function saveProject() {
            try {
                // Get emulator snapshot as base64
                const snapshotData = spectrum.saveSnapshot();
                const snapshotBase64 = arrayToBase64(snapshotData);

                // Collect all project state
                const project = {
                    version: 2,  // v2 adds media storage
                    timestamp: new Date().toISOString(),
                    machineType: spectrum.machineType,
                    snapshot: snapshotBase64,
                    debugger: {
                        disasmAddress: disasmViewAddress,
                        memoryAddress: memoryViewAddress,
                        disasmBookmarks: disasmBookmarks.slice(),
                        memoryBookmarks: memoryBookmarks.slice(),
                        // Unified triggers (new format)
                        triggers: spectrum.getTriggers().map(t => ({
                            type: t.type,
                            start: t.start,
                            end: t.end,
                            page: t.page,
                            mask: t.mask,
                            condition: t.condition || '',
                            enabled: t.enabled,
                            skipCount: t.skipCount || 0,
                            hitCount: t.hitCount || 0,
                            name: t.name || ''
                        })),
                        labels: JSON.parse(labelManager.exportJSON()),
                        regions: JSON.parse(regionManager.exportJSON()),
                        comments: JSON.parse(commentManager.exportJSON()),
                        xrefs: xrefManager.exportJSON() ? JSON.parse(xrefManager.exportJSON()) : [],
                        operandFormats: operandFormatManager.getAll(),
                        watches: watches.map(w => ({ addr: w.addr, name: w.name, page: w.page }))
                    },
                    settings: {
                        kempston: chkKempston.checked,
                        fullBorder: chkFullBorder.checked,
                        invertDisplay: chkInvertDisplay.checked,
                        speed: parseInt(speedSelect.value),
                        palette: paletteSelect.value,
                        labelDisplayMode: document.getElementById('labelDisplayMode').value,
                        showRomLabels: labelManager.showRomLabels,
                        darkTheme: darkTheme,
                        debuggerOpen: !tabContainer.classList.contains('collapsed'),
                        zoom: document.querySelector('.zoom-btn.active')?.textContent.replace('x', '') || '2',
                        running: spectrum.isRunning(),
                        overlayMode: overlayModes[currentOverlayMode].toLowerCase()
                    },
                    // CPU timing state (not stored in SNA format)
                    cpuTiming: {
                        tStates: spectrum.cpu.tStates,
                        halted: spectrum.cpu.halted,
                        iff1: spectrum.cpu.iff1,
                        iff2: spectrum.cpu.iff2
                    },
                    // ULA state for rainbow border graphics
                    ulaState: {
                        borderColor: spectrum.ula.borderColor,
                        borderChanges: spectrum.ula.borderChanges.slice()  // Copy of border change array
                    }
                };

                // Add source file name if loaded
                if (labelManager.currentFile) {
                    project.sourceFile = labelManager.currentFile;
                }

                // Add RZX state if RZX data exists (even if paused)
                if (spectrum.getRZXData()) {
                    const rzxData = spectrum.getRZXData();
                    project.rzx = {
                        data: arrayToBase64(rzxData),
                        frame: spectrum.getRZXFrame(),
                        tstates: spectrum.getRZXTstates(),
                        totalFrames: spectrum.getRZXTotalFrames()
                    };
                }

                // Add loaded media (TAP/TRD/SCL) for multi-file programs
                const media = spectrum.getLoadedMedia();
                if (media && media.data) {
                    project.media = {
                        type: media.type,
                        name: media.name,
                        data: arrayToBase64(media.data),
                        tapeBlock: spectrum.getTapeBlock()  // Current tape position
                    };
                }

                // Add assembler state (VFS and editor content)
                if (asmEditor && (asmEditor.value || Object.keys(VFS.files).length > 0)) {
                    // Sync current editor to VFS before saving
                    if (currentOpenFile && VFS.files[currentOpenFile] && !VFS.files[currentOpenFile].binary) {
                        VFS.files[currentOpenFile].content = asmEditor.value;
                    }

                    project.assembler = {
                        editorContent: asmEditor.value,
                        mainFile: currentProjectMainFile,
                        openTabs: openTabs,
                        currentOpenFile: currentOpenFile,
                        files: {},
                        binaryFiles: {}
                    };
                    // Save all files from VFS
                    for (const path in VFS.files) {
                        const file = VFS.files[path];
                        if (file.binary) {
                            // Binary files as base64
                            project.assembler.binaryFiles[path] = arrayToBase64(file.content);
                        } else {
                            project.assembler.files[path] = file.content;
                        }
                    }
                }

                const json = JSON.stringify(project, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const fileName = labelManager.currentFile ?
                    labelManager.currentFile.replace(/\.[^.]+$/, '') :
                    `project_${spectrum.machineType}`;
                a.download = `${fileName}_${Date.now()}.zxproj`;
                a.click();
                URL.revokeObjectURL(url);
                showMessage('Project saved');
            } catch (e) {
                showMessage('Failed to save project: ' + e.message, 'error');
                console.error(e);
            }
        }

        async function loadProject(jsonStr) {
            try {
                const project = JSON.parse(jsonStr);

                if (!project.version || !project.snapshot) {
                    throw new Error('Invalid project file');
                }

                // Stop emulator during load
                const wasRunning = spectrum.isRunning();
                spectrum.stop();

                // Switch machine type if needed
                if (project.machineType && project.machineType !== spectrum.machineType) {
                    spectrum.setMachineType(project.machineType);
                    applyRomsToEmulator();
                    machineSelect.value = project.machineType;
                }

                // Restore snapshot
                const snapshotBinary = Uint8Array.from(atob(project.snapshot), c => c.charCodeAt(0));
                spectrum.loadSnapshot(snapshotBinary);

                // Reset disassembler to use fresh memory reference
                disasm = null;

                // Clear existing debugger state
                spectrum.clearTriggers();
                labelManager.clear();

                // Restore debugger state
                if (project.debugger) {
                    // Restore addresses
                    if (project.debugger.disasmAddress !== undefined) {
                        disasmViewAddress = project.debugger.disasmAddress;
                        if (disasmViewAddress !== null) {
                            disasmAddressInput.value = hex16(disasmViewAddress);
                        }
                    }
                    if (project.debugger.memoryAddress !== undefined) {
                        memoryViewAddress = project.debugger.memoryAddress;
                        memoryAddressInput.value = hex16(memoryViewAddress);
                    }

                    // Restore bookmarks
                    if (project.debugger.disasmBookmarks) {
                        disasmBookmarks = project.debugger.disasmBookmarks.slice();
                        updateBookmarkButtons(disasmBookmarksBar, disasmBookmarks);
                    }
                    if (project.debugger.memoryBookmarks) {
                        memoryBookmarks = project.debugger.memoryBookmarks.slice();
                        updateBookmarkButtons(memoryBookmarksBar, memoryBookmarks);
                    }

                    // Restore triggers (new unified format)
                    if (project.debugger.triggers) {
                        for (const t of project.debugger.triggers) {
                            spectrum.addTrigger(t);
                        }
                    } else {
                        // Legacy format - convert breakpoints/watchpoints/portBreakpoints
                        if (project.debugger.breakpoints) {
                            for (const bp of project.debugger.breakpoints) {
                                spectrum.addTrigger({
                                    type: 'exec',
                                    start: bp.start,
                                    end: bp.end,
                                    page: bp.page,
                                    condition: bp.condition || ''
                                });
                            }
                        }
                        if (project.debugger.watchpoints) {
                            for (const wp of project.debugger.watchpoints) {
                                const wpType = wp.type === 'read' ? 'read' : wp.type === 'write' ? 'write' : 'rw';
                                spectrum.addTrigger({
                                    type: wpType,
                                    start: wp.start,
                                    end: wp.end,
                                    page: wp.page
                                });
                            }
                        }
                        if (project.debugger.portBreakpoints) {
                            for (const pb of project.debugger.portBreakpoints) {
                                const pbType = pb.direction === 'in' ? 'port_in' : pb.direction === 'out' ? 'port_out' : 'port_io';
                                spectrum.addTrigger({
                                    type: pbType,
                                    start: pb.port,
                                    mask: pb.mask
                                });
                            }
                        }
                    }

                    // Restore labels
                    if (project.debugger.labels && project.debugger.labels.length > 0) {
                        labelManager.importJSON(JSON.stringify(project.debugger.labels), false);
                    }

                    // Clear and restore regions
                    regionManager.clear();
                    if (project.debugger.regions && project.debugger.regions.length > 0) {
                        regionManager.importJSON(JSON.stringify(project.debugger.regions), false);
                    }

                    // Clear and restore comments
                    commentManager.clear();
                    if (project.debugger.comments && project.debugger.comments.length > 0) {
                        commentManager.importJSON(JSON.stringify(project.debugger.comments), false);
                    }

                    // Clear and restore xrefs
                    xrefManager.clear();
                    if (project.debugger.xrefs && project.debugger.xrefs.length > 0) {
                        xrefManager.importJSON(JSON.stringify(project.debugger.xrefs), false);
                    }
                    updateXrefStats();

                    // Clear and restore operand formats
                    operandFormatManager.clear();
                    if (project.debugger.operandFormats && project.debugger.operandFormats.length > 0) {
                        for (const f of project.debugger.operandFormats) {
                            operandFormatManager.formats.set(f.address, f.format);
                        }
                    }

                    // Restore watches
                    if (project.debugger.watches && Array.isArray(project.debugger.watches)) {
                        watches = project.debugger.watches.map(item => {
                            // Support old format (number) and new format (object with addr/name/page)
                            if (typeof item === 'number') {
                                return { addr: item, name: '', page: null, prevBytes: new Uint8Array(WATCH_BYTES) };
                            }
                            return {
                                addr: item.addr,
                                name: item.name || '',
                                page: item.page !== undefined ? item.page : null,
                                prevBytes: new Uint8Array(WATCH_BYTES)
                            };
                        });
                        saveWatches();
                        renderWatches();
                    }
                }

                // Restore settings
                if (project.settings) {
                    if (project.settings.kempston !== undefined) {
                        chkKempston.checked = project.settings.kempston;
                    }
                    if (project.settings.speed !== undefined) {
                        speedSelect.value = project.settings.speed;
                        spectrum.setSpeed(project.settings.speed);
                    }
                    if (project.settings.palette && loadedPalettes) {
                        paletteSelect.value = project.settings.palette;
                        applyPalette(project.settings.palette);
                    }
                    if (project.settings.labelDisplayMode) {
                        document.getElementById('labelDisplayMode').value = project.settings.labelDisplayMode;
                    }
                    if (project.settings.showRomLabels !== undefined) {
                        labelManager.showRomLabels = project.settings.showRomLabels;
                        document.getElementById('chkShowRomLabels').checked = project.settings.showRomLabels;
                    }
                    if (project.settings.darkTheme !== undefined) {
                        darkTheme = project.settings.darkTheme;
                        document.body.classList.toggle('light-theme', !darkTheme);
                        themeToggle.textContent = darkTheme ? '☀️' : '🌙';
                    }
                    if (project.settings.debuggerOpen !== undefined) {
                        tabContainer.classList.toggle('collapsed', !project.settings.debuggerOpen);
                    }
                    if (project.settings.zoom) {
                        const zoomLevel = parseInt(project.settings.zoom);
                        if (zoomLevel >= 1 && zoomLevel <= 3) {
                            // setZoom will be called after it's defined
                            setTimeout(() => setZoom(zoomLevel), 0);
                        }
                    }
                    // Load overlay mode (new) or grid (legacy)
                    if (project.settings.overlayMode !== undefined) {
                        const modeIndex = overlayModes.findIndex(m => m.toLowerCase() === project.settings.overlayMode);
                        if (modeIndex >= 0) {
                            currentOverlayMode = modeIndex;
                            btnOverlay.textContent = overlayModes[currentOverlayMode];  // Show current mode
                            spectrum.setOverlayMode(project.settings.overlayMode);
                        }
                    } else if (project.settings.grid !== undefined) {
                        // Legacy: convert grid boolean to overlay mode
                        currentOverlayMode = project.settings.grid ? 1 : 0;
                        btnOverlay.textContent = overlayModes[currentOverlayMode];  // Show current mode
                        spectrum.setOverlayMode(project.settings.grid ? 'grid' : 'none');
                    }
                    if (project.settings.fullBorder !== undefined) {
                        chkFullBorder.checked = project.settings.fullBorder;
                        spectrum.ula.setFullBorder(project.settings.fullBorder);
                        spectrum.updateDisplayDimensions();
                        // updateCanvasSize will be called after setZoom
                    }
                    if (project.settings.invertDisplay !== undefined) {
                        chkInvertDisplay.checked = project.settings.invertDisplay;
                        applyInvertDisplay(project.settings.invertDisplay);
                    }
                }

                // Restore CPU timing state (tStates, halted, IFF)
                if (project.cpuTiming) {
                    if (project.cpuTiming.tStates !== undefined) {
                        spectrum.cpu.tStates = project.cpuTiming.tStates;
                    }
                    if (project.cpuTiming.halted !== undefined) {
                        spectrum.cpu.halted = project.cpuTiming.halted;
                    }
                    if (project.cpuTiming.iff1 !== undefined) {
                        spectrum.cpu.iff1 = project.cpuTiming.iff1;
                    }
                    if (project.cpuTiming.iff2 !== undefined) {
                        spectrum.cpu.iff2 = project.cpuTiming.iff2;
                    }
                    // Safety: if CPU is halted but interrupts disabled, enable them
                    // Otherwise the CPU will be stuck forever
                    if (spectrum.cpu.halted && !spectrum.cpu.iff1) {
                        console.warn('[loadProject] CPU was halted with IFF=0, enabling interrupts');
                        spectrum.cpu.iff1 = true;
                        spectrum.cpu.iff2 = true;
                    }
                }

                // Restore ULA state (border changes for rainbow graphics)
                if (project.ulaState) {
                    if (project.ulaState.borderColor !== undefined) {
                        spectrum.ula.borderColor = project.ulaState.borderColor;
                    }
                    if (project.ulaState.borderChanges && project.ulaState.borderChanges.length > 0) {
                        spectrum.ula.borderChanges = project.ulaState.borderChanges.slice();
                    }
                }

                // Restore source file name and update status display
                if (project.sourceFile) {
                    labelManager.currentFile = project.sourceFile;
                    regionManager.currentFile = project.sourceFile;
                    commentManager.currentFile = project.sourceFile;
                    // Update filename in status bar
                    document.getElementById('filename').textContent = project.sourceFile;
                    document.getElementById('fileInfo').style.display = 'inline-block';
                } else {
                    // No source file - hide filename display
                    document.getElementById('fileInfo').style.display = 'none';
                }

                // Restore RZX state if present
                if (project.rzx && project.rzx.data) {
                    try {
                        const rzxBinary = Uint8Array.from(atob(project.rzx.data), c => c.charCodeAt(0));
                        // Load RZX but skip embedded snapshot (we already loaded project snapshot)
                        await spectrum.loadRZX(rzxBinary, true);
                        // Restore frame position and T-states
                        spectrum.setRZXFrame(project.rzx.frame || 0);
                        spectrum.setRZXTstates(project.rzx.tstates || 0);
                        updateRZXStatus();
                    } catch (e) {
                        console.warn('Failed to restore RZX state:', e);
                    }
                }

                // Restore loaded media (TAP/TRD/SCL) for multi-file programs
                if (project.media && project.media.data) {
                    try {
                        const mediaData = Uint8Array.from(atob(project.media.data), c => c.charCodeAt(0));
                        spectrum.setLoadedMedia({
                            type: project.media.type,
                            name: project.media.name,
                            data: mediaData
                        });
                        // Restore tape position
                        if (project.media.tapeBlock !== undefined) {
                            spectrum.setTapeBlock(project.media.tapeBlock);
                        }
                    } catch (e) {
                        console.warn('Failed to restore media:', e);
                    }
                }

                // Restore assembler state (VFS and editor content)
                if (project.assembler) {
                    try {
                        // Clear existing VFS
                        VFS.reset();

                        // Restore text files
                        if (project.assembler.files) {
                            for (const path in project.assembler.files) {
                                VFS.addFile(path, project.assembler.files[path]);
                            }
                        }

                        // Restore binary files
                        if (project.assembler.binaryFiles) {
                            for (const path in project.assembler.binaryFiles) {
                                const base64 = project.assembler.binaryFiles[path];
                                const binary = Uint8Array.from(atob(base64), c => c.charCodeAt(0));
                                VFS.addBinaryFile(path, binary);
                            }
                        }

                        // Restore main file reference
                        currentProjectMainFile = project.assembler.mainFile || null;

                        // Restore open tabs and current file
                        openTabs = project.assembler.openTabs || [];
                        currentOpenFile = project.assembler.currentOpenFile || null;
                        fileModified = {};

                        // If we have files but no tabs, open the main file
                        if (Object.keys(VFS.files).length > 0 && openTabs.length === 0) {
                            if (currentProjectMainFile) {
                                openTabs.push(currentProjectMainFile);
                                currentOpenFile = currentProjectMainFile;
                            }
                        }

                        // Restore editor content from current file or saved content
                        if (currentOpenFile && VFS.files[currentOpenFile]) {
                            asmEditor.value = VFS.files[currentOpenFile].content || '';
                        } else if (project.assembler.editorContent && asmEditor) {
                            asmEditor.value = project.assembler.editorContent;
                        }

                        updateLineNumbers();
                        updateHighlight();
                        updateFileTabs();
                        updateProjectButtons();
                        updateDefinesDropdown();
                    } catch (e) {
                        console.warn('Failed to restore assembler state:', e);
                    }
                }

                // Reset trace to live view and clear stale data
                traceManager.clear();
                traceManager.goToLive();
                traceViewAddress = null;

                // Update UI
                updateDebugger();
                updateMemoryView();
                updateBreakpointList();
                updateWatchpointList();
                updatePortBreakpointList();
                updateLabelsList();
                if (typeof updateGraphicsViewer === 'function') {
                    updateGraphicsViewer();
                }

                // Restore running state from project, or use previous state
                const shouldRun = project.settings?.running !== undefined ?
                    project.settings.running : wasRunning;

                console.log('[loadProject] shouldRun=', shouldRun, 'spectrum.running=', spectrum.running, 'romLoaded=', spectrum.romLoaded);
                if (shouldRun) {
                    // Force start to ensure loop begins even if state is inconsistent
                    spectrum.start(true);
                } else {
                    spectrum.stop();
                    // Render current state WITHOUT executing CPU (preserves tStates)
                    spectrum.renderToScreen();
                }
                console.log('[loadProject] after start, spectrum.running=', spectrum.running);

                // Update all status displays including RZX
                updateStatus();
                updateRZXStatus();

                showMessage(project.rzx ?
                    `Project loaded (RZX frame ${spectrum.getRZXFrame()}/${spectrum.getRZXTotalFrames()})` :
                    'Project loaded');
            } catch (e) {
                showMessage('Failed to load project: ' + e.message, 'error');
                console.error(e);
            }
        }

        btnSaveProject.addEventListener('click', saveProject);
        btnLoadProject.addEventListener('click', () => projectFileInput.click());

        projectFileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                loadProject(event.target.result);
            };
            reader.readAsText(file);
            projectFileInput.value = '';
        });
        
        machineSelect.addEventListener('change', () => {
            const type = machineSelect.value;
            
            // Check if we have the required ROM
            if (type === '128k' && !rom128Data) {
                showMessage('128K ROM not loaded.', 'error');
                machineSelect.value = spectrum.machineType;
                return;
            }
            if (type === 'pentagon' && !romPentagonData) {
                showMessage('Pentagon ROM not loaded.', 'error');
                machineSelect.value = spectrum.machineType;
                return;
            }
            
            const wasRunning = spectrum.isRunning();
            if (wasRunning) spectrum.stop();
            
            spectrum.setMachineType(type);
            localStorage.setItem('zx-machine-type', type);
            applyRomsToEmulator();
            // Re-apply full border mode setting to new ULA
            spectrum.ula.setFullBorder(chkFullBorder.checked);
            spectrum.updateDisplayDimensions();
            updateCanvasSize();
            spectrum.reset();
            disasm = null; // Reset to use fresh memory reference

            if (wasRunning) {
                spectrum.start();
            } else {
                spectrum.runFrame();
            }

            updateGraphicsViewer();
            showMessage(`Switched to ${type.toUpperCase()}`);
            updateStatus();
        });
        
        speedSelect.addEventListener('change', () => {
            const speed = parseInt(speedSelect.value, 10);
            spectrum.setSpeed(speed);
            const label = speed === 0 ? 'Max' : speed + '%';
            showMessage(`Speed: ${label}`);
        });
        
        chkKempston.addEventListener('change', () => {
            spectrum.kempstonEnabled = chkKempston.checked;
            showMessage(chkKempston.checked ? 'Kempston joystick enabled (Numpad)' : 'Kempston joystick disabled');
        });

        // Overlay mode button (cycles through modes, shows CURRENT mode)
        const btnOverlay = document.getElementById('btnOverlay');
        const overlayModes = ['Normal', 'Grid', 'Box', 'Screen', 'Reveal', 'Beam', 'BeamScreen'];
        let currentOverlayMode = 0;
        btnOverlay.textContent = overlayModes[currentOverlayMode];  // Show current mode initially
        btnOverlay.addEventListener('click', () => {
            currentOverlayMode = (currentOverlayMode + 1) % overlayModes.length;
            btnOverlay.textContent = overlayModes[currentOverlayMode];  // Show current mode
            spectrum.setOverlayMode(overlayModes[currentOverlayMode].toLowerCase());
            spectrum.redraw();
        });

        // Full Border toggle
        chkFullBorder.addEventListener('change', () => {
            if (spectrum.ula.setFullBorder(chkFullBorder.checked)) {
                spectrum.updateDisplayDimensions();
                updateCanvasSize();
                spectrum.redraw();
            }
            showMessage(chkFullBorder.checked ? 'Full border enabled' : 'Normal border');
        });

        // Invert display handling
        const chkInvertDisplay = document.getElementById('chkInvertDisplay');

        function applyInvertDisplay(invert) {
            canvas.style.filter = invert ? 'invert(1)' : '';
            if (overlayCanvas) overlayCanvas.style.filter = invert ? 'invert(1)' : '';
        }

        // Restore saved invert setting
        const savedInvert = localStorage.getItem('zxm8_invert') === 'true';
        chkInvertDisplay.checked = savedInvert;
        applyInvertDisplay(savedInvert);

        chkInvertDisplay.addEventListener('change', () => {
            applyInvertDisplay(chkInvertDisplay.checked);
            localStorage.setItem('zxm8_invert', chkInvertDisplay.checked);
            showMessage(chkInvertDisplay.checked ? 'Display inverted' : 'Display normal');
        });

        // Palette handling
        const paletteSelect = document.getElementById('paletteSelect');
        const palettePreview = document.getElementById('palettePreview');
        let loadedPalettes = null;

        async function loadPalettes() {
            try {
                const response = await fetch('palettes.json');
                const data = await response.json();
                loadedPalettes = data.palettes;

                // Populate dropdown
                paletteSelect.innerHTML = '';
                loadedPalettes.forEach(palette => {
                    const option = document.createElement('option');
                    option.value = palette.id;
                    option.textContent = palette.name;
                    paletteSelect.appendChild(option);
                });

                // Apply saved palette or default
                const savedPalette = localStorage.getItem('zxm8_palette') || 'default';
                paletteSelect.value = savedPalette;
                applyPalette(savedPalette);
            } catch (e) {
                console.error('Failed to load palettes:', e);
            }
        }

        function applyPalette(paletteId) {
            if (!loadedPalettes) return;

            const palette = loadedPalettes.find(p => p.id === paletteId);
            if (!palette) return;

            // Update ULA palette
            if (spectrum.ula) {
                spectrum.ula.palette = palette.colors.map(hex => {
                    const r = parseInt(hex.slice(1, 3), 16);
                    const g = parseInt(hex.slice(3, 5), 16);
                    const b = parseInt(hex.slice(5, 7), 16);
                    return [r, g, b, 255]; // [R, G, B, A] array format
                });
                spectrum.redraw();
            }

            // Update preview
            updatePalettePreview(palette.colors);
        }

        function updatePalettePreview(colors) {
            const colorElements = palettePreview.querySelectorAll('.palette-color');
            colorElements.forEach((el, i) => {
                if (colors[i]) {
                    el.style.backgroundColor = colors[i];
                    el.title = `${i}: ${colors[i]}`;
                }
            });
        }

        paletteSelect.addEventListener('change', () => {
            applyPalette(paletteSelect.value);
            localStorage.setItem('zxm8_palette', paletteSelect.value);
            showMessage(`Palette: ${paletteSelect.options[paletteSelect.selectedIndex].text}`);
        });

        // Load palettes on startup
        loadPalettes();

        // ========== Frame Export ==========
        const frameGrabState = {
            active: false,
            frames: [],
            wasRunning: false,
            startTime: 0
        };
        const frameGrabStatus = document.getElementById('frameGrabStatus');
        const btnFrameGrabStart = document.getElementById('btnFrameGrabStart');
        const btnFrameGrabStop = document.getElementById('btnFrameGrabStop');
        const btnFrameGrabCancel = document.getElementById('btnFrameGrabCancel');
        const frameExportFormat = document.getElementById('frameExportFormat');
        const frameExportSize = document.getElementById('frameExportSize');
        const spriteRegionRow = document.getElementById('spriteRegionRow');
        const sizeRow = document.getElementById('sizeRow');

        // Track last sprite mode for value conversion
        let lastSpriteMode = null;

        // Show/hide size row based on format selection (SCR/BSC/SCA have fixed sizes)
        function updateSizeRowVisibility() {
            const format = frameExportFormat.value;
            if (format === 'scr' || format === 'sca') {
                // SCR/SCA requires screen only (256x192)
                sizeRow.style.display = 'none';
                frameExportSize.value = 'screen';
                spriteRegionRow.style.display = 'none';
                clearSpriteRegionPreview();
            } else if (format === 'bsc') {
                // BSC requires full border
                sizeRow.style.display = 'none';
                frameExportSize.value = 'full';
                spriteRegionRow.style.display = 'none';
                clearSpriteRegionPreview();
            } else {
                sizeRow.style.display = 'flex';
            }
        }

        frameExportFormat.addEventListener('change', updateSizeRowVisibility);

        // Show/hide sprite region inputs and update labels based on size selection
        frameExportSize.addEventListener('change', () => {
            const sizeMode = frameExportSize.value;
            const isSprite = sizeMode.startsWith('sprite-');
            const isPixels = sizeMode === 'sprite-pixels';

            spriteRegionRow.style.display = isSprite ? 'flex' : 'none';

            if (isSprite) {
                const spriteXEl = document.getElementById('spriteX');
                const spriteYEl = document.getElementById('spriteY');
                const spriteWEl = document.getElementById('spriteW');
                const spriteHEl = document.getElementById('spriteH');

                // Update labels
                document.getElementById('spriteLabelX').textContent = isPixels ? 'X:' : 'Col:';
                document.getElementById('spriteLabelY').textContent = isPixels ? 'Y:' : 'Row:';

                // Convert values if switching between pixel and cell modes
                if (lastSpriteMode !== sizeMode) {
                    if (isPixels) {
                        if (lastSpriteMode) {
                            // Converting from cells to pixels
                            spriteXEl.value = Math.min(255, parseInt(spriteXEl.value) * 8);
                            spriteYEl.value = Math.min(191, parseInt(spriteYEl.value) * 8);
                            spriteWEl.value = Math.min(256, parseInt(spriteWEl.value) * 8);
                            spriteHEl.value = Math.min(192, parseInt(spriteHEl.value) * 8);
                        }
                        // else: first time pixels - keep HTML defaults (0, 0, 16, 16)
                    } else {
                        // Converting to cells (from pixels or first time)
                        spriteXEl.value = Math.min(31, Math.floor(parseInt(spriteXEl.value) / 8));
                        spriteYEl.value = Math.min(23, Math.floor(parseInt(spriteYEl.value) / 8));
                        spriteWEl.value = Math.max(1, Math.min(32, Math.ceil(parseInt(spriteWEl.value) / 8)));
                        spriteHEl.value = Math.max(1, Math.min(24, Math.ceil(parseInt(spriteHEl.value) / 8)));
                    }
                }

                // Update max values
                if (isPixels) {
                    spriteXEl.max = 255; spriteYEl.max = 191; spriteWEl.max = 256; spriteHEl.max = 192;
                } else {
                    spriteXEl.max = 31; spriteYEl.max = 23; spriteWEl.max = 32; spriteHEl.max = 24;
                }

                lastSpriteMode = sizeMode;
                updateSpriteRegionPreview();
            } else {
                clearSpriteRegionPreview();
            }
        });

        // Sprite region preview using CSS-positioned div (not canvas, which gets cleared by spectrum)
        const spriteOverlay = document.getElementById('spriteRegionOverlay');

        function updateSpriteRegionPreview() {
            if (frameGrabState.active) {
                spriteOverlay.style.display = 'none';
                return;
            }

            const sizeMode = frameExportSize.value;
            if (!sizeMode.startsWith('sprite-')) {
                spriteOverlay.style.display = 'none';
                return;
            }

            const isPixels = sizeMode === 'sprite-pixels';
            const multiplier = isPixels ? 1 : 8;

            let spriteX = (parseInt(document.getElementById('spriteX').value) || 0) * multiplier;
            let spriteY = (parseInt(document.getElementById('spriteY').value) || 0) * multiplier;
            let spriteW = (parseInt(document.getElementById('spriteW').value) || (isPixels ? 16 : 2)) * multiplier;
            let spriteH = (parseInt(document.getElementById('spriteH').value) || (isPixels ? 16 : 2)) * multiplier;

            // Clamp to screen bounds
            spriteX = Math.max(0, Math.min(255, spriteX));
            spriteY = Math.max(0, Math.min(191, spriteY));
            spriteW = Math.max(1, spriteW);
            spriteH = Math.max(1, spriteH);
            if (spriteX + spriteW > 256) spriteW = 256 - spriteX;
            if (spriteY + spriteH > 192) spriteH = 192 - spriteY;

            // Get screen dimensions - use defaults if ULA not ready
            let borderLeft = 32, borderTop = 24, screenWidth = 320;
            if (spectrum && spectrum.ula) {
                const dims = spectrum.ula.getDimensions();
                borderLeft = dims.borderLeft;
                borderTop = dims.borderTop;
                screenWidth = dims.width;
            }

            // Get zoom from screen canvas style
            const screenCanvas = document.getElementById('screen');
            const styleWidth = parseFloat(screenCanvas.style.width) || screenCanvas.width;
            const zoom = styleWidth / screenCanvas.width || 1;

            // Calculate pixel position (accounting for border and zoom)
            const x = (borderLeft + spriteX) * zoom;
            const y = (borderTop + spriteY) * zoom;
            const w = spriteW * zoom;
            const h = spriteH * zoom;

            // Position the overlay div
            spriteOverlay.style.left = x + 'px';
            spriteOverlay.style.top = y + 'px';
            spriteOverlay.style.width = w + 'px';
            spriteOverlay.style.height = h + 'px';
            spriteOverlay.style.display = 'block';
        }

        function clearSpriteRegionPreview() {
            spriteOverlay.style.display = 'none';
        }

        // Update preview when sprite inputs change
        ['spriteX', 'spriteY', 'spriteW', 'spriteH'].forEach(id => {
            document.getElementById(id).addEventListener('input', updateSpriteRegionPreview);
        });

        function updateFrameGrabStatus() {
            if (!frameGrabState.active) {
                frameGrabStatus.textContent = '';
                frameGrabStatus.classList.remove('recording');
                return;
            }
            const frameCount = frameGrabState.frames.length;
            const duration = (frameCount / 50).toFixed(2);
            frameGrabStatus.textContent = `Recording: ${frameCount} frames (${duration}s)`;
            frameGrabStatus.classList.add('recording');
        }

        function captureFrame() {
            if (!frameGrabState.active) return;

            const sizeMode = frameExportSize.value;
            const dims = spectrum.ula.getDimensions();

            let sx, sy, sw, sh;
            if (sizeMode === 'screen') {
                // Screen only: 256x192, centered
                sx = dims.borderLeft;
                sy = dims.borderTop;
                sw = 256;
                sh = 192;
            } else if (sizeMode === 'normal') {
                // Normal border (32px each side)
                sx = Math.max(0, dims.borderLeft - 32);
                sy = Math.max(0, dims.borderTop - 32);
                sw = 256 + 64;
                sh = 192 + 64;
            } else if (sizeMode.startsWith('sprite-')) {
                // Custom sprite region (relative to screen area)
                const isPixels = sizeMode === 'sprite-pixels';
                const multiplier = isPixels ? 1 : 8;

                // Get input values, default to valid ranges
                let spriteX = parseInt(document.getElementById('spriteX').value) || 0;
                let spriteY = parseInt(document.getElementById('spriteY').value) || 0;
                let spriteW = parseInt(document.getElementById('spriteW').value) || (isPixels ? 16 : 2);
                let spriteH = parseInt(document.getElementById('spriteH').value) || (isPixels ? 16 : 2);

                // Convert to pixels
                spriteX *= multiplier;
                spriteY *= multiplier;
                spriteW *= multiplier;
                spriteH *= multiplier;

                // Clamp position to screen bounds (0-255, 0-191)
                spriteX = Math.max(0, Math.min(255, spriteX));
                spriteY = Math.max(0, Math.min(191, spriteY));

                // Ensure width/height are at least 1 pixel
                spriteW = Math.max(1, spriteW);
                spriteH = Math.max(1, spriteH);

                // Clamp width/height to not exceed screen bounds
                if (spriteX + spriteW > 256) spriteW = 256 - spriteX;
                if (spriteY + spriteH > 192) spriteH = 192 - spriteY;

                sx = dims.borderLeft + spriteX;
                sy = dims.borderTop + spriteY;
                sw = spriteW;
                sh = spriteH;
            } else {
                // Full border
                sx = 0;
                sy = 0;
                sw = dims.width;
                sh = dims.height;
            }

            // Create a temporary canvas to capture the frame region
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = sw;
            tempCanvas.height = sh;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(canvas, sx, sy, sw, sh, 0, 0, sw, sh);

            // Store as data URL (PNG)
            frameGrabState.frames.push({
                dataUrl: tempCanvas.toDataURL('image/png'),
                width: sw,
                height: sh
            });

            updateFrameGrabStatus();

            // Check max frames limit
            const maxFrames = parseInt(document.getElementById('maxFrames').value) || 0;
            if (maxFrames > 0 && frameGrabState.frames.length >= maxFrames) {
                stopFrameGrab(false);
            }
        }

        function startFrameGrab() {
            frameGrabState.wasRunning = spectrum.isRunning();
            frameGrabState.active = true;
            frameGrabState.frames = [];
            frameGrabState.startTime = Date.now();

            // Clear sprite region preview during recording
            clearSpriteRegionPreview();

            // Set up frame callback
            spectrum.onFrame = () => {
                captureFrame();
            };

            // Start emulator if not running
            if (!frameGrabState.wasRunning) {
                spectrum.start();
            }

            // Update UI
            btnFrameGrabStart.disabled = true;
            btnFrameGrabStop.disabled = false;
            btnFrameGrabCancel.disabled = false;
            frameExportFormat.disabled = true;
            frameExportSize.disabled = true;
            document.getElementById('spriteX').disabled = true;
            document.getElementById('spriteY').disabled = true;
            document.getElementById('spriteW').disabled = true;
            document.getElementById('spriteH').disabled = true;
            document.getElementById('maxFrames').disabled = true;

            updateFrameGrabStatus();
            showMessage('Recording frames...');
        }

        function stopFrameGrab(cancel = false) {
            frameGrabState.active = false;
            spectrum.onFrame = null;

            // Stop emulator if it was paused before
            if (!frameGrabState.wasRunning) {
                spectrum.stop();
            }

            // Update UI
            btnFrameGrabStart.disabled = false;
            btnFrameGrabStop.disabled = true;
            btnFrameGrabCancel.disabled = true;
            frameExportFormat.disabled = false;
            frameExportSize.disabled = false;
            document.getElementById('spriteX').disabled = false;
            document.getElementById('spriteY').disabled = false;
            document.getElementById('spriteW').disabled = false;
            document.getElementById('spriteH').disabled = false;
            document.getElementById('maxFrames').disabled = false;

            // Restore sprite region preview if in sprite mode
            updateSpriteRegionPreview();

            if (cancel) {
                frameGrabState.frames = [];
                frameGrabStatus.textContent = 'Recording cancelled';
                frameGrabStatus.classList.remove('recording');
                showMessage('Frame recording cancelled');
                return;
            }

            // Export frames
            const frameCount = frameGrabState.frames.length;
            if (frameCount === 0) {
                frameGrabStatus.textContent = 'No frames captured';
                showMessage('No frames captured', 'error');
                return;
            }

            const format = frameExportFormat.value;
            const duration = (frameCount / 50).toFixed(2);
            frameGrabStatus.textContent = `Exporting ${frameCount} frames...`;

            if (format === 'zip') {
                exportFramesAsZip();
            } else if (format === 'scr') {
                exportFramesAsScr('scr');
            } else if (format === 'bsc') {
                exportFramesAsScr('bsc');
            } else if (format === 'sca') {
                exportFramesAsSca();
            } else {
                exportFramesAsGif();
            }
        }

        // Get base name for exports from loaded filename
        function getExportBaseName() {
            const filenameEl = document.getElementById('filename');
            const loadedName = filenameEl ? filenameEl.textContent.trim() : '';
            // Use loaded filename if available, otherwise 'frame'
            return loadedName || 'frame';
        }

        async function exportFramesAsZip() {
            const frames = frameGrabState.frames;
            const baseName = getExportBaseName();

            // Single frame - save as single PNG file, not ZIP
            if (frames.length === 1) {
                const frame = frames[0];
                const base64 = frame.dataUrl.split(',')[1];
                const binary = atob(base64);
                const bytes = new Uint8Array(binary.length);
                for (let j = 0; j < binary.length; j++) {
                    bytes[j] = binary.charCodeAt(j);
                }
                const blob = new Blob([bytes], { type: 'image/png' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${baseName}_0000.png`;
                a.click();
                URL.revokeObjectURL(url);
                frameGrabStatus.textContent = `Exported 1 frame as PNG`;
                frameGrabStatus.classList.remove('recording');
                showMessage(`Exported ${baseName}_0000.png`);
                frameGrabState.frames = [];
                return;
            }

            // Multiple frames - create ZIP
            const files = [];
            for (let i = 0; i < frames.length; i++) {
                const frame = frames[i];
                const filename = `${baseName}_${String(i).padStart(4, '0')}.png`;

                // Convert data URL to binary
                const base64 = frame.dataUrl.split(',')[1];
                const binary = atob(base64);
                const bytes = new Uint8Array(binary.length);
                for (let j = 0; j < binary.length; j++) {
                    bytes[j] = binary.charCodeAt(j);
                }

                files.push({ name: filename, data: bytes });
            }

            // Create ZIP using simple store method (no compression for PNGs - already compressed)
            const zipData = createZip(files);

            // Download
            const blob = new Blob([zipData], { type: 'application/zip' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${baseName}.zip`;
            a.click();
            URL.revokeObjectURL(url);

            frameGrabStatus.textContent = `Exported ${frames.length} frames to ZIP`;
            frameGrabStatus.classList.remove('recording');
            showMessage(`Exported ${frames.length} frames to ${baseName}.zip`);
            frameGrabState.frames = [];
        }

        function createZip(files) {
            // Simple ZIP file creator (store method, no compression)
            const localHeaders = [];
            const centralHeaders = [];
            let offset = 0;

            for (const file of files) {
                const nameBytes = new TextEncoder().encode(file.name);
                const data = file.data;

                // CRC32
                const crc = crc32(data);

                // Local file header
                const localHeader = new Uint8Array(30 + nameBytes.length);
                const lv = new DataView(localHeader.buffer);
                lv.setUint32(0, 0x04034b50, true);  // Local file header signature
                lv.setUint16(4, 20, true);          // Version needed
                lv.setUint16(6, 0, true);           // General purpose flag
                lv.setUint16(8, 0, true);           // Compression: store
                lv.setUint16(10, 0, true);          // Mod time
                lv.setUint16(12, 0, true);          // Mod date
                lv.setUint32(14, crc, true);        // CRC32
                lv.setUint32(18, data.length, true);// Compressed size
                lv.setUint32(22, data.length, true);// Uncompressed size
                lv.setUint16(26, nameBytes.length, true); // Filename length
                lv.setUint16(28, 0, true);          // Extra field length
                localHeader.set(nameBytes, 30);

                // Central directory header
                const centralHeader = new Uint8Array(46 + nameBytes.length);
                const cv = new DataView(centralHeader.buffer);
                cv.setUint32(0, 0x02014b50, true);  // Central file header signature
                cv.setUint16(4, 20, true);          // Version made by
                cv.setUint16(6, 20, true);          // Version needed
                cv.setUint16(8, 0, true);           // General purpose flag
                cv.setUint16(10, 0, true);          // Compression: store
                cv.setUint16(12, 0, true);          // Mod time
                cv.setUint16(14, 0, true);          // Mod date
                cv.setUint32(16, crc, true);        // CRC32
                cv.setUint32(20, data.length, true);// Compressed size
                cv.setUint32(24, data.length, true);// Uncompressed size
                cv.setUint16(28, nameBytes.length, true); // Filename length
                cv.setUint16(30, 0, true);          // Extra field length
                cv.setUint16(32, 0, true);          // Comment length
                cv.setUint16(34, 0, true);          // Disk number start
                cv.setUint16(36, 0, true);          // Internal attributes
                cv.setUint32(38, 0, true);          // External attributes
                cv.setUint32(42, offset, true);     // Relative offset
                centralHeader.set(nameBytes, 46);

                localHeaders.push({ header: localHeader, data: data });
                centralHeaders.push(centralHeader);
                offset += localHeader.length + data.length;
            }

            // End of central directory record
            const centralDirOffset = offset;
            let centralDirSize = 0;
            for (const ch of centralHeaders) {
                centralDirSize += ch.length;
            }

            const endRecord = new Uint8Array(22);
            const ev = new DataView(endRecord.buffer);
            ev.setUint32(0, 0x06054b50, true);      // End signature
            ev.setUint16(4, 0, true);               // Disk number
            ev.setUint16(6, 0, true);               // Start disk
            ev.setUint16(8, files.length, true);    // Entries on disk
            ev.setUint16(10, files.length, true);   // Total entries
            ev.setUint32(12, centralDirSize, true); // Central dir size
            ev.setUint32(16, centralDirOffset, true); // Central dir offset
            ev.setUint16(20, 0, true);              // Comment length

            // Combine all parts
            const totalSize = offset + centralDirSize + 22;
            const result = new Uint8Array(totalSize);
            let pos = 0;

            for (const lh of localHeaders) {
                result.set(lh.header, pos);
                pos += lh.header.length;
                result.set(lh.data, pos);
                pos += lh.data.length;
            }
            for (const ch of centralHeaders) {
                result.set(ch, pos);
                pos += ch.length;
            }
            result.set(endRecord, pos);

            return result;
        }

        function crc32(data) {
            let crc = 0xFFFFFFFF;
            const table = crc32.table || (crc32.table = (() => {
                const t = new Uint32Array(256);
                for (let i = 0; i < 256; i++) {
                    let c = i;
                    for (let j = 0; j < 8; j++) {
                        c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
                    }
                    t[i] = c;
                }
                return t;
            })());

            for (let i = 0; i < data.length; i++) {
                crc = table[(crc ^ data[i]) & 0xFF] ^ (crc >>> 8);
            }
            return (crc ^ 0xFFFFFFFF) >>> 0;
        }

        // ZX Spectrum standard palette (RGB values)
        const zxPalette = [
            [0, 0, 0],       // 0: black
            [0, 0, 215],     // 1: blue
            [215, 0, 0],     // 2: red
            [215, 0, 215],   // 3: magenta
            [0, 215, 0],     // 4: green
            [0, 215, 215],   // 5: cyan
            [215, 215, 0],   // 6: yellow
            [215, 215, 215], // 7: white
            [0, 0, 0],       // 8: black (bright)
            [0, 0, 255],     // 9: blue (bright)
            [255, 0, 0],     // 10: red (bright)
            [255, 0, 255],   // 11: magenta (bright)
            [0, 255, 0],     // 12: green (bright)
            [0, 255, 255],   // 13: cyan (bright)
            [255, 255, 0],   // 14: yellow (bright)
            [255, 255, 255]  // 15: white (bright)
        ];

        function rgbToZxColor(r, g, b) {
            // Find closest ZX Spectrum color
            let bestIdx = 0;
            let bestDist = Infinity;
            for (let i = 0; i < 16; i++) {
                const dr = r - zxPalette[i][0];
                const dg = g - zxPalette[i][1];
                const db = b - zxPalette[i][2];
                const dist = dr*dr + dg*dg + db*db;
                if (dist < bestDist) {
                    bestDist = dist;
                    bestIdx = i;
                }
            }
            return bestIdx;
        }

        function imageDataToScr(pixels, srcWidth, screenLeft, screenTop) {
            // Convert image to SCR format (6912 bytes)
            // SCR = 6144 bytes bitmap + 768 bytes attributes
            const scr = new Uint8Array(6912);

            // Process each 8x8 character cell
            for (let charY = 0; charY < 24; charY++) {
                for (let charX = 0; charX < 32; charX++) {
                    // Count colors in this cell
                    const colorCounts = new Map();

                    for (let py = 0; py < 8; py++) {
                        for (let px = 0; px < 8; px++) {
                            const sx = screenLeft + charX * 8 + px;
                            const sy = screenTop + charY * 8 + py;
                            const idx = (sy * srcWidth + sx) * 4;
                            const zxColor = rgbToZxColor(pixels[idx], pixels[idx+1], pixels[idx+2]);
                            colorCounts.set(zxColor, (colorCounts.get(zxColor) || 0) + 1);
                        }
                    }

                    // Find two most common colors
                    const sorted = [...colorCounts.entries()].sort((a, b) => b[1] - a[1]);
                    let ink = sorted[0] ? sorted[0][0] : 0;
                    let paper = sorted[1] ? sorted[1][0] : 7;

                    // Determine brightness (both colors should match)
                    const inkBright = ink >= 8;
                    const paperBright = paper >= 8;
                    const bright = inkBright || paperBright;

                    // Convert to base color (0-7)
                    ink = ink % 8;
                    paper = paper % 8;

                    // Make sure paper is different from ink
                    if (paper === ink) {
                        paper = (ink === 7) ? 0 : 7;
                    }

                    // Build attribute byte
                    const attr = (bright ? 0x40 : 0) | (paper << 3) | ink;
                    scr[6144 + charY * 32 + charX] = attr;

                    // Build bitmap for this cell
                    for (let py = 0; py < 8; py++) {
                        let byte = 0;
                        for (let px = 0; px < 8; px++) {
                            const sx = screenLeft + charX * 8 + px;
                            const sy = screenTop + charY * 8 + py;
                            const idx = (sy * srcWidth + sx) * 4;
                            const zxColor = rgbToZxColor(pixels[idx], pixels[idx+1], pixels[idx+2]) % 8;

                            // Pixel is set if closer to ink than paper
                            const inkDist = Math.abs(zxColor - ink);
                            const paperDist = Math.abs(zxColor - paper);
                            if (inkDist <= paperDist) {
                                byte |= (0x80 >> px);
                            }
                        }

                        // Calculate screen address (ZX Spectrum weird layout)
                        const third = Math.floor(charY / 8);
                        const charRow = charY % 8;
                        const addr = third * 2048 + py * 256 + charRow * 32 + charX;
                        scr[addr] = byte;
                    }
                }
            }

            return scr;
        }

        // BSC format constants
        const BSC_FORMAT = {
            TOTAL_SIZE: 11136,        // 6912 + 4224
            BORDER_OFFSET: 6912,
            BORDER_SIZE: 4224,
            BYTES_PER_FULL_LINE: 24,  // Top/bottom: 24 bytes per line (384px / 16px per byte)
            BYTES_PER_SIDE_LINE: 8,   // Side: 8 bytes per line (4 left + 4 right)
            FRAME_WIDTH: 384,
            FRAME_HEIGHT: 304,
            BORDER_LEFT_PX: 64,
            BORDER_TOP_LINES: 64,
            BORDER_BOTTOM_LINES: 48,
            SCREEN_LINES: 192
        };

        function extractBscBorder(pixels, srcWidth, srcHeight, screenLeft, screenTop) {
            // BSC border format:
            // - Top border: 64 lines × 24 bytes = 1536 bytes
            // - Side borders: 192 lines × 8 bytes = 1536 bytes (4 left + 4 right)
            // - Bottom border: 48 lines × 24 bytes = 1152 bytes
            // Each byte: bits 2-0 = first color (8px), bits 5-3 = second color (8px)
            const borderData = new Uint8Array(BSC_FORMAT.BORDER_SIZE);
            let offset = 0;

            // Helper: sample color at pixel position (clamped to frame bounds)
            const getColor = (x, y) => {
                x = Math.max(0, Math.min(srcWidth - 1, Math.floor(x)));
                y = Math.max(0, Math.min(srcHeight - 1, Math.floor(y)));
                const idx = (y * srcWidth + x) * 4;
                return rgbToZxColor(pixels[idx], pixels[idx+1], pixels[idx+2]) % 8;
            };

            // Helper: pack two 3-bit colors into one byte
            const packColors = (c1, c2) => (c1 & 7) | ((c2 & 7) << 3);

            // Calculate border sizes in captured frame
            const srcScreenRight = screenLeft + 256;
            const srcScreenBottom = screenTop + 192;
            const srcRightBorder = srcWidth - srcScreenRight;
            const srcBottomBorder = srcHeight - srcScreenBottom;

            // Top border: 64 lines × 24 bytes (384px width)
            // Map 64 BSC lines to srcTop lines of captured frame
            for (let line = 0; line < BSC_FORMAT.BORDER_TOP_LINES; line++) {
                const srcY = screenTop > 0 ? (line * screenTop / BSC_FORMAT.BORDER_TOP_LINES) : 0;
                for (let col = 0; col < BSC_FORMAT.BYTES_PER_FULL_LINE; col++) {
                    // Each byte covers 16 pixels (2 colors × 8 pixels)
                    // Map 384px BSC width to srcWidth
                    const bscX1 = col * 16;
                    const bscX2 = col * 16 + 8;
                    const srcX1 = bscX1 * srcWidth / BSC_FORMAT.FRAME_WIDTH;
                    const srcX2 = bscX2 * srcWidth / BSC_FORMAT.FRAME_WIDTH;
                    const c1 = getColor(srcX1, srcY);
                    const c2 = getColor(srcX2, srcY);
                    borderData[offset++] = packColors(c1, c2);
                }
            }

            // Side borders: 192 lines × 8 bytes (4 left + 4 right)
            for (let line = 0; line < BSC_FORMAT.SCREEN_LINES; line++) {
                const srcY = screenTop + line;

                // Left side: 4 bytes = 64 BSC pixels
                for (let col = 0; col < 4; col++) {
                    const bscX1 = col * 16;
                    const bscX2 = col * 16 + 8;
                    // Map 64px BSC left border to screenLeft pixels
                    const srcX1 = screenLeft > 0 ? (bscX1 * screenLeft / 64) : 0;
                    const srcX2 = screenLeft > 0 ? (bscX2 * screenLeft / 64) : 0;
                    const c1 = getColor(srcX1, srcY);
                    const c2 = getColor(srcX2, srcY);
                    borderData[offset++] = packColors(c1, c2);
                }

                // Right side: 4 bytes = 64 BSC pixels
                for (let col = 0; col < 4; col++) {
                    const bscX1 = col * 16;
                    const bscX2 = col * 16 + 8;
                    // Map 64px BSC right border to srcRightBorder pixels
                    const srcX1 = srcScreenRight + (srcRightBorder > 0 ? (bscX1 * srcRightBorder / 64) : 0);
                    const srcX2 = srcScreenRight + (srcRightBorder > 0 ? (bscX2 * srcRightBorder / 64) : 0);
                    const c1 = getColor(srcX1, srcY);
                    const c2 = getColor(srcX2, srcY);
                    borderData[offset++] = packColors(c1, c2);
                }
            }

            // Bottom border: 48 lines × 24 bytes (384px width)
            for (let line = 0; line < BSC_FORMAT.BORDER_BOTTOM_LINES; line++) {
                const srcY = srcScreenBottom + (srcBottomBorder > 0 ? (line * srcBottomBorder / BSC_FORMAT.BORDER_BOTTOM_LINES) : 0);
                for (let col = 0; col < BSC_FORMAT.BYTES_PER_FULL_LINE; col++) {
                    const bscX1 = col * 16;
                    const bscX2 = col * 16 + 8;
                    const srcX1 = bscX1 * srcWidth / BSC_FORMAT.FRAME_WIDTH;
                    const srcX2 = bscX2 * srcWidth / BSC_FORMAT.FRAME_WIDTH;
                    const c1 = getColor(srcX1, srcY);
                    const c2 = getColor(srcX2, srcY);
                    borderData[offset++] = packColors(c1, c2);
                }
            }

            return borderData;
        }

        async function exportFramesAsScr(ext) {
            const frames = frameGrabState.frames;
            const baseName = getExportBaseName();
            const files = [];
            const isBsc = ext === 'bsc';

            // Get border dimensions for proper extraction
            let borderLeft = 0, borderTop = 0;
            if (spectrum && spectrum.ula) {
                const dims = spectrum.ula.getDimensions();
                borderLeft = dims.borderLeft;
                borderTop = dims.borderTop;
            }

            for (let i = 0; i < frames.length; i++) {
                const frame = frames[i];
                const filename = `${baseName}_${String(i).padStart(4, '0')}.${ext}`;

                // Convert data URL to image
                const img = new Image();
                img.src = frame.dataUrl;
                await new Promise(resolve => img.onload = resolve);

                // Get image data
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = frame.width;
                tempCanvas.height = frame.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(img, 0, 0);
                const imageData = tempCtx.getImageData(0, 0, frame.width, frame.height);
                const pixels = imageData.data;

                // Determine screen position within captured frame
                let scrLeft = 0, scrTop = 0;
                if (frame.width > 256) {
                    // Frame includes border - calculate screen position
                    // For full capture (dims.width × dims.height): screen at (borderLeft, borderTop)
                    // For normal capture (320 × 256): screen at (32, 32)
                    // For other sizes: calculate based on the border we have
                    const dims = spectrum && spectrum.ula ? spectrum.ula.getDimensions() : null;
                    if (dims && frame.width >= dims.width && frame.height >= dims.height) {
                        // Full or larger capture
                        scrLeft = borderLeft;
                        scrTop = borderTop;
                    } else if (frame.width === 320 && frame.height === 256) {
                        // Normal capture mode (32px borders)
                        scrLeft = 32;
                        scrTop = 32;
                    } else {
                        // Calculate proportionally from what we have
                        scrLeft = (frame.width - 256) / 2;
                        scrTop = (frame.height - 192) / 2;
                    }
                }

                // Convert to SCR format
                const scrData = imageDataToScr(pixels, frame.width, scrLeft, scrTop);

                if (isBsc) {
                    // BSC format: SCR (6912) + border data (4224 bytes)
                    // Full frame: 384x304, border color packed 2 per byte
                    const borderData = extractBscBorder(pixels, frame.width, frame.height, scrLeft, scrTop);
                    const bscData = new Uint8Array(BSC_FORMAT.TOTAL_SIZE);
                    bscData.set(scrData, 0);
                    bscData.set(borderData, BSC_FORMAT.BORDER_OFFSET);
                    files.push({ name: filename, data: bscData });
                } else {
                    files.push({ name: filename, data: scrData });
                }
            }

            const frameCount = frames.length;
            const duration = (frameCount / 50).toFixed(2);

            // Single frame - save as single file, not ZIP
            if (files.length === 1) {
                const file = files[0];
                const mimeType = isBsc ? 'application/octet-stream' : 'application/octet-stream';
                const blob = new Blob([file.data], { type: mimeType });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${baseName}_0000.${ext}`;
                a.click();
                URL.revokeObjectURL(url);
                frameGrabStatus.textContent = `Exported 1 ${ext.toUpperCase()} frame`;
                frameGrabStatus.classList.remove('recording');
                showMessage(`Exported ${baseName}_0000.${ext}`);
                return;
            }

            // Multiple frames - create ZIP
            const zipData = createZip(files);
            const blob = new Blob([zipData], { type: 'application/zip' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = `${baseName}_${ext}.zip`;
            a.click();

            URL.revokeObjectURL(url);

            frameGrabStatus.textContent = `Exported ${frameCount} ${ext.toUpperCase()} frames (${duration}s)`;
            frameGrabStatus.classList.remove('recording');
            showMessage(`Exported ${frameCount} frames to ${baseName}_${ext}.zip`);
        }

        // SCA format: animation file with header + delay table + SCR frames
        // https://github.com/moroz1999/sca
        async function exportFramesAsSca() {
            const frames = frameGrabState.frames;
            const baseName = getExportBaseName();
            const frameCount = frames.length;

            // Get border dimensions for proper extraction
            let borderLeft = 0, borderTop = 0;
            if (spectrum && spectrum.ula) {
                const dims = spectrum.ula.getDimensions();
                borderLeft = dims.borderLeft;
                borderTop = dims.borderTop;
            }

            // SCA header: 14 bytes
            // 0-2: "SCA" marker
            // 3: version (0)
            // 4-5: width (256, little-endian)
            // 6-7: height (192, little-endian)
            // 8: border color (0)
            // 9-10: frame count (little-endian)
            // 11: payload type (0 = uncompressed SCR frames)
            // 12-13: payload position (14 = after header)
            const headerSize = 14;
            const delayTableSize = frameCount;
            const frameDataSize = frameCount * 6912;
            const totalSize = headerSize + delayTableSize + frameDataSize;

            const scaData = new Uint8Array(totalSize);

            // Write header
            scaData[0] = 0x53; // 'S'
            scaData[1] = 0x43; // 'C'
            scaData[2] = 0x41; // 'A'
            scaData[3] = 0;    // version
            scaData[4] = 256 & 0xFF;  // width low
            scaData[5] = (256 >> 8) & 0xFF; // width high
            scaData[6] = 192 & 0xFF;  // height low
            scaData[7] = (192 >> 8) & 0xFF; // height high
            scaData[8] = 0;    // border color
            scaData[9] = frameCount & 0xFF;  // frame count low
            scaData[10] = (frameCount >> 8) & 0xFF; // frame count high
            scaData[11] = 0;   // payload type (0 = uncompressed)
            scaData[12] = headerSize & 0xFF;  // payload position low
            scaData[13] = (headerSize >> 8) & 0xFF; // payload position high

            // Write delay table (1 byte per frame, all set to 1 = 1/50s = 50fps)
            for (let i = 0; i < frameCount; i++) {
                scaData[headerSize + i] = 1;
            }

            // Convert and write each frame
            const frameDataOffset = headerSize + delayTableSize;
            for (let i = 0; i < frames.length; i++) {
                const frame = frames[i];

                // Convert data URL to image
                const img = new Image();
                img.src = frame.dataUrl;
                await new Promise(resolve => img.onload = resolve);

                // Get image data
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = frame.width;
                tempCanvas.height = frame.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(img, 0, 0);
                const imageData = tempCtx.getImageData(0, 0, frame.width, frame.height);
                const pixels = imageData.data;

                // Determine screen position within captured frame
                let scrLeft = 0, scrTop = 0;
                if (frame.width > 256) {
                    const dims = spectrum && spectrum.ula ? spectrum.ula.getDimensions() : null;
                    if (dims && frame.width >= dims.width && frame.height >= dims.height) {
                        scrLeft = borderLeft;
                        scrTop = borderTop;
                    } else if (frame.width === 320 && frame.height === 256) {
                        scrLeft = 32;
                        scrTop = 32;
                    } else {
                        scrLeft = (frame.width - 256) / 2;
                        scrTop = (frame.height - 192) / 2;
                    }
                }

                // Convert to SCR format
                const scrData = imageDataToScr(pixels, frame.width, scrLeft, scrTop);

                // Copy SCR data to SCA buffer
                scaData.set(scrData, frameDataOffset + i * 6912);

                if (i % 10 === 0) {
                    frameGrabStatus.textContent = `Encoding SCA: ${Math.round(i / frames.length * 100)}%`;
                    await new Promise(r => setTimeout(r, 0));
                }
            }

            // Download
            const blob = new Blob([scaData], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${baseName}.sca`;
            a.click();
            URL.revokeObjectURL(url);

            const duration = (frameCount / 50).toFixed(2);
            frameGrabStatus.textContent = `Exported ${frameCount} frames to SCA (${duration}s)`;
            frameGrabStatus.classList.remove('recording');
            showMessage(`Exported ${frameCount} frames to ${baseName}.sca`);
            frameGrabState.frames = [];
        }

        async function exportFramesAsGif() {
            const frames = frameGrabState.frames;
            if (frames.length === 0) return;

            const width = frames[0].width;
            const height = frames[0].height;

            // Simple GIF encoder
            const gif = new GifEncoder(width, height);

            for (let i = 0; i < frames.length; i++) {
                // Convert data URL to image data
                const img = new Image();
                img.src = frames[i].dataUrl;
                await new Promise(resolve => img.onload = resolve);

                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = width;
                tempCanvas.height = height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(img, 0, 0);
                const imageData = tempCtx.getImageData(0, 0, width, height);

                gif.addFrame(imageData.data, 2); // 2 = 20ms delay (50fps)

                if (i % 10 === 0) {
                    frameGrabStatus.textContent = `Encoding GIF: ${Math.round(i / frames.length * 100)}%`;
                    await new Promise(r => setTimeout(r, 0)); // Allow UI update
                }
            }

            const gifData = gif.finish();
            const baseName = getExportBaseName();

            // Download
            const blob = new Blob([gifData], { type: 'image/gif' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${baseName}.gif`;
            a.click();
            URL.revokeObjectURL(url);

            frameGrabStatus.textContent = `Exported ${frames.length} frames to GIF`;
            frameGrabStatus.classList.remove('recording');
            showMessage(`Exported ${frames.length} frames to ${baseName}.gif`);
            frameGrabState.frames = [];
        }

        // Simple GIF Encoder (256-color, LZW compression)
        class GifEncoder {
            constructor(width, height) {
                this.width = width;
                this.height = height;
                this.frames = [];
                this.data = [];
            }

            addFrame(rgba, delay) {
                // Quantize to 256 colors and create indexed frame
                const { palette, indexed } = this.quantize(rgba);
                this.frames.push({ palette, indexed, delay });
            }

            quantize(rgba) {
                // Simple color quantization using a fixed palette
                // Use median-cut or popularity algorithm for better results
                const colorCounts = new Map();
                const pixels = [];

                for (let i = 0; i < rgba.length; i += 4) {
                    const r = rgba[i] & 0xF8;     // 5 bits
                    const g = rgba[i + 1] & 0xFC; // 6 bits
                    const b = rgba[i + 2] & 0xF8; // 5 bits
                    const key = (r << 16) | (g << 8) | b;
                    pixels.push(key);
                    colorCounts.set(key, (colorCounts.get(key) || 0) + 1);
                }

                // Get top 256 colors
                const sorted = [...colorCounts.entries()]
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 256);

                const palette = new Uint8Array(256 * 3);
                const colorToIndex = new Map();

                for (let i = 0; i < sorted.length; i++) {
                    const [color] = sorted[i];
                    const r = (color >> 16) & 0xFF;
                    const g = (color >> 8) & 0xFF;
                    const b = color & 0xFF;
                    palette[i * 3] = r;
                    palette[i * 3 + 1] = g;
                    palette[i * 3 + 2] = b;
                    colorToIndex.set(color, i);
                }

                // Map pixels to palette indices
                const indexed = new Uint8Array(pixels.length);
                for (let i = 0; i < pixels.length; i++) {
                    indexed[i] = colorToIndex.get(pixels[i]) || 0;
                }

                return { palette, indexed };
            }

            finish() {
                const out = [];

                // GIF Header
                out.push(...[0x47, 0x49, 0x46, 0x38, 0x39, 0x61]); // GIF89a

                // Logical Screen Descriptor
                out.push(this.width & 0xFF, (this.width >> 8) & 0xFF);
                out.push(this.height & 0xFF, (this.height >> 8) & 0xFF);
                out.push(0xF7); // Global color table, 256 colors (2^(7+1))
                out.push(0);    // Background color index
                out.push(0);    // Pixel aspect ratio

                // Global Color Table (use first frame's palette)
                if (this.frames.length > 0) {
                    for (let i = 0; i < 256 * 3; i++) {
                        out.push(this.frames[0].palette[i] || 0);
                    }
                }

                // Netscape Extension for looping
                out.push(0x21, 0xFF, 0x0B);
                out.push(...[0x4E, 0x45, 0x54, 0x53, 0x43, 0x41, 0x50, 0x45, 0x32, 0x2E, 0x30]); // NETSCAPE2.0
                out.push(0x03, 0x01, 0x00, 0x00, 0x00); // Loop forever

                // Frames
                for (const frame of this.frames) {
                    // Graphics Control Extension
                    out.push(0x21, 0xF9, 0x04);
                    out.push(0x00); // Disposal method
                    out.push(frame.delay & 0xFF, (frame.delay >> 8) & 0xFF); // Delay
                    out.push(0x00); // Transparent color index
                    out.push(0x00); // Block terminator

                    // Image Descriptor
                    out.push(0x2C);
                    out.push(0, 0, 0, 0); // Left, Top
                    out.push(this.width & 0xFF, (this.width >> 8) & 0xFF);
                    out.push(this.height & 0xFF, (this.height >> 8) & 0xFF);
                    out.push(0x00); // No local color table

                    // LZW Compressed Image Data
                    const lzw = this.lzwEncode(frame.indexed, 8);
                    out.push(8); // LZW minimum code size

                    // Output in sub-blocks
                    let pos = 0;
                    while (pos < lzw.length) {
                        const blockSize = Math.min(255, lzw.length - pos);
                        out.push(blockSize);
                        for (let i = 0; i < blockSize; i++) {
                            out.push(lzw[pos++]);
                        }
                    }
                    out.push(0x00); // Block terminator
                }

                // GIF Trailer
                out.push(0x3B);

                return new Uint8Array(out);
            }

            lzwEncode(data, minCodeSize) {
                const clearCode = 1 << minCodeSize;
                const eoiCode = clearCode + 1;
                let codeSize = minCodeSize + 1;
                let nextCode = eoiCode + 1;
                const maxCode = 4096;

                const table = new Map();
                for (let i = 0; i < clearCode; i++) {
                    table.set(String.fromCharCode(i), i);
                }

                const output = [];
                let bitBuffer = 0;
                let bitCount = 0;

                const writeBits = (code, size) => {
                    bitBuffer |= code << bitCount;
                    bitCount += size;
                    while (bitCount >= 8) {
                        output.push(bitBuffer & 0xFF);
                        bitBuffer >>= 8;
                        bitCount -= 8;
                    }
                };

                writeBits(clearCode, codeSize);

                let current = '';
                for (let i = 0; i < data.length; i++) {
                    const char = String.fromCharCode(data[i]);
                    const next = current + char;

                    if (table.has(next)) {
                        current = next;
                    } else {
                        writeBits(table.get(current), codeSize);

                        if (nextCode < maxCode) {
                            table.set(next, nextCode++);
                            if (nextCode > (1 << codeSize) && codeSize < 12) {
                                codeSize++;
                            }
                        } else {
                            // Reset table
                            writeBits(clearCode, codeSize);
                            table.clear();
                            for (let j = 0; j < clearCode; j++) {
                                table.set(String.fromCharCode(j), j);
                            }
                            codeSize = minCodeSize + 1;
                            nextCode = eoiCode + 1;
                        }

                        current = char;
                    }
                }

                if (current.length > 0) {
                    writeBits(table.get(current), codeSize);
                }

                writeBits(eoiCode, codeSize);

                if (bitCount > 0) {
                    output.push(bitBuffer & 0xFF);
                }

                return output;
            }
        }

        btnFrameGrabStart.addEventListener('click', startFrameGrab);
        btnFrameGrabStop.addEventListener('click', () => stopFrameGrab(false));
        btnFrameGrabCancel.addEventListener('click', () => stopFrameGrab(true));

        // Zoom controls (canvas already declared above)
        const zoomButtons = [
            document.getElementById('zoom1'),
            document.getElementById('zoom2'),
            document.getElementById('zoom3')
        ];

        let currentZoom = 1;

        function updateCanvasSize() {
            // Get current dimensions from ULA
            const dims = spectrum.ula.getDimensions();
            canvas.width = dims.width;
            canvas.height = dims.height;
            // Apply current zoom level to style
            canvas.style.width = (dims.width * currentZoom) + 'px';
            canvas.style.height = (dims.height * currentZoom) + 'px';
            // Overlay canvas: internal resolution = screen resolution (zoomed)
            // So 1px line = 1 screen pixel regardless of zoom
            overlayCanvas.width = dims.width * currentZoom;
            overlayCanvas.height = dims.height * currentZoom;
            overlayCanvas.style.width = (dims.width * currentZoom) + 'px';
            overlayCanvas.style.height = (dims.height * currentZoom) + 'px';
            // Tell spectrum about zoom for overlay drawing
            spectrum.setZoom(currentZoom);
        }

        function setZoom(level) {
            currentZoom = level;
            updateCanvasSize();

            // Update active button
            zoomButtons.forEach((btn, i) => {
                btn.classList.toggle('active', i + 1 === level);
            });

            // Re-render current frame after zoom change
            spectrum.renderToScreen();

            // Update sprite region preview if visible
            if (typeof updateSpriteRegionPreview === 'function') {
                updateSpriteRegionPreview();
            }
        }

        zoomButtons[0].addEventListener('click', () => setZoom(1));
        zoomButtons[1].addEventListener('click', () => setZoom(2));
        zoomButtons[2].addEventListener('click', () => setZoom(3));

        // Set initial zoom to x1
        setZoom(1);
        
        // Theme toggle
        const themeToggle = document.getElementById('themeToggle');
        let darkTheme = localStorage.getItem('zx-theme') !== 'light';
        document.body.classList.toggle('light-theme', !darkTheme);
        themeToggle.textContent = darkTheme ? '☀️' : '🌙';

        themeToggle.addEventListener('click', () => {
            darkTheme = !darkTheme;
            document.body.classList.toggle('light-theme', !darkTheme);
            themeToggle.textContent = darkTheme ? '☀️' : '🌙';
            localStorage.setItem('zx-theme', darkTheme ? 'dark' : 'light');
        });
        
        // Handle disk image insertion with machine switch if needed
        function handleDiskInserted(result, fileName) {
            // Switch to Pentagon mode if needed
            if (result.needsMachineSwitch && romPentagonData && romTrdosData) {
                spectrum.stop();
                spectrum.setMachineType('pentagon');
                spectrum.memory.loadRom(romPentagonData.slice(0, 16384), 0);
                spectrum.memory.loadRom(romPentagonData.slice(16384, 32768), 1);
                spectrum.memory.loadTrdosRom(romTrdosData);
                spectrum.romLoaded = true;
                spectrum.reset();

                // Re-load disk into Beta Disk (was cleared by reset)
                spectrum.betaDisk.loadDisk(result._diskData, result.diskType);
                // Re-setup TR-DOS trap handler
                spectrum.trdosTrap.setDisk(result._diskData, result._diskFiles, result.diskType);

                machineSelect.value = 'pentagon';
            } else if (result.needsMachineSwitch) {
                // Need Pentagon/TR-DOS ROM but don't have them
                showMessage('Pentagon and TR-DOS ROMs required for disk images', 'error');
                return;
            }

            handleLoadResult(result, fileName);
        }

        // Handle loaded result (shared between file input and ZIP selection)
        function handleLoadResult(result, fileName) {
            // Update filename display
            document.getElementById('filename').textContent = fileName;
            document.getElementById('fileInfo').style.display = 'inline-block';

            // Load labels, regions, comments, and xrefs for this file
            labelManager.setCurrentFile(fileName);
            regionManager.setCurrentFile(fileName);
            commentManager.setCurrentFile(fileName);
            xrefManager.setCurrentFile(fileName);
            operandFormatManager.setCurrentFile(fileName);
            updateXrefStats();

            // Check result type by properties
            if (result.diskInserted) {
                // TRD/SCL disk inserted into Beta Disk interface
                if (!spectrum.isRunning()) spectrum.start();

                const typeStr = result.diskType.toUpperCase();
                showMessage(`${typeStr} disk inserted: ${result.diskName} (${result.fileCount} files). Select TR-DOS from menu, use LIST/LOAD/RUN commands.`);
            } else if (result.diskFile) {
                // TRD/SCL disk file - ensure emulator is running
                if (!spectrum.isRunning()) spectrum.start();

                if (result.useTrdos) {
                    // TR-DOS mode - show instructions
                    if (result.manualBoot) {
                        showMessage(`Disk loaded. Select TR-DOS from Pentagon menu, then type ${result.trdosCommand}`);
                    } else {
                        showMessage(`TR-DOS: Type ${result.trdosCommand} to run ${result.fileName}`);
                    }
                } else {
                    const addrHex = result.start.toString(16).toUpperCase().padStart(4, '0');
                    if (result.fileType === 'code') {
                        showMessage(`${result.diskType.toUpperCase()}: ${result.fileName} loaded at ${addrHex}h (${result.length} bytes) - RANDOMIZE USR ${result.start} to run`);
                    } else if (result.fileType === 'basic') {
                        // BASIC program - auto-loading via injected LOAD ""
                        if (result.autoload) {
                            showMessage(`${result.diskType.toUpperCase()}: ${result.fileName} - Loading...`);
                        } else {
                            showMessage(`${result.diskType.toUpperCase()}: ${result.fileName} loaded - Type LOAD "" to load`);
                        }
                    } else {
                        showMessage(`${result.diskType.toUpperCase()}: Loaded ${result.fileName}`);
                    }
                }
            } else if (result.blocks !== undefined) {
                // TAP file
                showMessage(`TAP loaded: ${result.blocks} blocks. Type LOAD "" to load.`);
            } else if (result.frames !== undefined) {
                // RZX file - stop immediately and show debugger
                spectrum.stop();
                disasm = null;

                const creatorInfo = result.creator ? ` (${result.creator.name})` : '';
                const pc = spectrum.cpu ? spectrum.cpu.pc : 0;
                const pcHex = pc.toString(16).toUpperCase().padStart(4, '0');
                showMessage(`RZX loaded: ${result.frames} frames${creatorInfo} - PC: ${pcHex} (paused, press Resume to play)`);

                openDebuggerPanel();
                updateRZXStatus();
                updateStatus();
                updateDebugger();
            } else {
                // SNA/Z80 snapshot - machine type may have changed
                showMessage(`Snapshot loaded (${result.machineType.toUpperCase()}): ${fileName}`);

                // Re-apply appropriate ROM after machine switch
                if (result.machineType !== '48k' && rom128Data) {
                    spectrum.memory.loadRom(rom128Data.slice(0, 16384), 0);
                    spectrum.memory.loadRom(rom128Data.slice(16384, 32768), 1);
                } else if (result.machineType === '48k' && rom48Data) {
                    spectrum.memory.loadRom(rom48Data, 0);
                }

                // Reset disassembler to use fresh memory reference
                disasm = null;

                updateStatus();
                if (!spectrum.isRunning()) spectrum.start();
            }
        }
        
        // Show file selection modal (ZIP or disk image)
        async function showZipSelection(result, fileName) {
            pendingZipResult = { result, fileName };
            zipFileList.innerHTML = '';

            const isDisk = result.diskType;
            const modalTitle = zipModal.querySelector('h2');
            const modalDesc = zipModal.querySelector('p');

            // Handle machine switch for disk images (TRD/SCL need Pentagon + TR-DOS ROM)
            if (isDisk && result.needsMachineSwitch && romPentagonData && romTrdosData) {
                // Switch to Pentagon mode with TR-DOS ROM
                spectrum.stop();
                spectrum.setMachineType('pentagon');
                spectrum.memory.loadRom(romPentagonData.slice(0, 16384), 0);
                spectrum.memory.loadRom(romPentagonData.slice(16384, 32768), 1);
                spectrum.memory.loadTrdosRom(romTrdosData);
                spectrum.romLoaded = true;
                spectrum.reset();

                // Re-load disk into Beta Disk (was cleared by reset)
                spectrum.betaDisk.loadDisk(result._diskData, result.diskType);

                machineSelect.value = 'pentagon';
                showMessage('Switched to Pentagon mode for TR-DOS');
            } else if (isDisk && result.needsMachineSwitch && !romPentagonData) {
                showMessage('Pentagon ROM not loaded. Load pentagon.rom for disk support.', 'error');
            } else if (isDisk && result.needsMachineSwitch && !romTrdosData) {
                showMessage('TR-DOS ROM not loaded. Load trdos.rom (16KB) for disk support.', 'error');
            }

            if (isDisk) {
                modalTitle.textContent = `Select File from ${result.diskType.toUpperCase()}`;
                modalDesc.textContent = 'Select file to load, or boot TR-DOS for command prompt:';
                // Show Boot TR-DOS button only if in Pentagon mode with TR-DOS ROM loaded
                const hasTrdosRom = spectrum.memory.hasTrdosRom && spectrum.memory.hasTrdosRom();
                btnBootTrdos.style.display = (spectrum.machineType === 'pentagon' && hasTrdosRom) ? 'inline-block' : 'none';
            } else {
                modalTitle.textContent = 'Select File to Load';
                modalDesc.textContent = 'The archive contains multiple files. Select one to load:';
                btnBootTrdos.style.display = 'none';
            }

            // Create sorted list with original indices
            const sortedFiles = result.files
                .map((file, index) => ({ file, index: isDisk ? file.index : index }))
                .sort((a, b) => a.file.name.localeCompare(b.file.name));

            sortedFiles.forEach(({ file, index }) => {
                const item = document.createElement('div');
                item.className = 'zip-file-item';

                // For disk files, show more details
                if (isDisk) {
                    const isBoot = file.name.toLowerCase().startsWith('boot');
                    const typeLabel = file.type === 'basic' ? 'BASIC' :
                                     file.type === 'code' ? 'CODE' :
                                     file.type === 'data' ? 'DATA' : file.type.toUpperCase();
                    const startHex = file.start.toString(16).toUpperCase().padStart(4, '0');
                    const bootBadge = isBoot ? ' <span style="color: var(--success-color); font-weight: bold;">[BOOT]</span>' : '';
                    item.innerHTML = `
                        <span class="zip-file-name">${file.name}${bootBadge}</span>
                        <span class="zip-file-type">${typeLabel}</span>
                        <span class="zip-file-info">${startHex}h, ${file.length} bytes</span>
                    `;
                    if (isBoot) {
                        item.style.borderLeft = '3px solid var(--success-color)';
                    }
                } else {
                    item.innerHTML = `
                        <span class="zip-file-name">${file.name}</span>
                        <span class="zip-file-type">${file.type}</span>
                    `;
                }

                item.addEventListener('click', async () => {
                    zipModal.classList.add('hidden');
                    try {
                        let loadResult;
                        if (isDisk) {
                            // Load from disk image
                            loadResult = spectrum.loadFromDiskSelection(result, index);
                        } else if (file.type === 'rzx') {
                            // Handle RZX files specially (async loading)
                            const rzxData = result._zipFiles[index].data;
                            loadResult = await spectrum.loadRZX(rzxData);
                        } else if (file.type === 'trd' || file.type === 'scl') {
                            // Disk image inside ZIP - handle disk insertion
                            loadResult = spectrum.loadFromZipSelection(result, index);
                            if (loadResult.diskInserted) {
                                handleDiskInserted(loadResult, file.name);
                                pendingZipResult = null;
                                return;
                            }
                        } else {
                            loadResult = spectrum.loadFromZipSelection(result, index);
                        }
                        handleLoadResult(loadResult, file.name);
                    } catch (e) {
                        showMessage('Failed to load: ' + e.message, 'error');
                    }
                    pendingZipResult = null;
                });
                zipFileList.appendChild(item);
            });

            zipModal.classList.remove('hidden');
        }
        
        btnZipCancel.addEventListener('click', () => {
            zipModal.classList.add('hidden');
            pendingZipResult = null;
            btnBootTrdos.style.display = 'none';
            // Make sure emulator is running after dialog closes
            if (!spectrum.isRunning()) spectrum.start();
        });

        btnBootTrdos.addEventListener('click', () => {
            zipModal.classList.add('hidden');
            pendingZipResult = null;
            btnBootTrdos.style.display = 'none';

            // Boot into TR-DOS
            if (spectrum.bootTrdos()) {
                spectrum.start();
                showMessage('TR-DOS started. Type RUN or LOAD "filename" to run programs.');
            } else {
                // Determine what's missing
                if (spectrum.machineType !== 'pentagon') {
                    showMessage('Cannot boot TR-DOS: Pentagon mode required', 'error');
                } else if (!spectrum.memory.hasTrdosRom()) {
                    showMessage('Cannot boot TR-DOS: trdos.rom not loaded', 'error');
                } else {
                    showMessage('Cannot boot TR-DOS', 'error');
                }
            }
        });
        
        fileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            // Check if ROM loaded
            if (!spectrum.romLoaded) {
                showMessage('Please load ROM files first', 'error');
                romModal.classList.remove('hidden');
                fileInput.value = '';
                return;
            }

            try {
                const result = await spectrum.loadFile(file);

                // Check if ZIP needs file selection
                if (result.needsSelection) {
                    showZipSelection(result, file.name);
                } else if (result.diskInserted) {
                    // Handle disk image with machine switch if needed
                    handleDiskInserted(result, file.name);
                } else {
                    handleLoadResult(result, file.name);
                }
            } catch (e) {
                showMessage('Failed to load: ' + e.message, 'error');
            }
            fileInput.value = '';
        });
        
        // Check if assembler tab is active
        function isAssemblerTabActive() {
            const asmTab = document.getElementById('tab-assembler');
            return asmTab && asmTab.classList.contains('active');
        }

        document.addEventListener('dragover', (e) => {
            e.preventDefault();
            if (!romModal.classList.contains('hidden')) return;
            // Don't show drop zone overlay when assembler tab is active
            // (assembler has its own drop handling with visual feedback)
            if (isAssemblerTabActive()) return;
            dropZone.classList.add('active');
        });

        document.addEventListener('dragleave', (e) => {
            if (e.target === dropZone) dropZone.classList.remove('active');
        });

        document.addEventListener('drop', async (e) => {
            e.preventDefault();
            dropZone.classList.remove('active');
            if (!romModal.classList.contains('hidden')) return;
            // Skip if assembler tab is active (handled by assembler's own drop handler)
            if (isAssemblerTabActive()) return;
            
            const file = e.dataTransfer.files[0];
            if (!file) return;
            const ext = file.name.toLowerCase().split('.').pop();
            
            try {
                if (ext === 'rom' || ext === 'bin') {
                    const data = await file.arrayBuffer();
                    if (data.byteLength >= 32768) {
                        rom128Data = data;
                        if (spectrum.machineType !== '48k') {
                            spectrum.memory.loadRom(data.slice(0, 16384), 0);
                            spectrum.memory.loadRom(data.slice(16384, 32768), 1);
                        }
                    } else {
                        rom48Data = data;
                        spectrum.memory.loadRom(data, 0);
                    }
                    spectrum.romLoaded = true;
                    showMessage('ROM loaded: ' + file.name);
                } else if (ext === 'sna' || ext === 'tap' || ext === 'z80' || ext === 'zip' || ext === 'trd' || ext === 'scl' || ext === 'rzx') {
                    if (!spectrum.romLoaded) {
                        showMessage('Please load ROM files first', 'error');
                        romModal.classList.remove('hidden');
                        return;
                    }

                    const result = await spectrum.loadFile(file);

                    // Check if ZIP needs file selection
                    if (result.needsSelection) {
                        showZipSelection(result, file.name);
                    } else if (result.diskInserted) {
                        // Handle disk image with machine switch if needed
                        handleDiskInserted(result, file.name);
                    } else {
                        handleLoadResult(result, file.name);
                    }
                }
            } catch (e) {
                showMessage('Failed to load: ' + e.message, 'error');
            }
        });
        
        canvas.tabIndex = 0;
        
        const screenInfoPopup = document.getElementById('screenInfoPopup');
        
        canvas.addEventListener('click', (e) => {
            canvas.focus();
            
            // Only show popup when paused
            if (spectrum.isRunning()) return;
            
            // Get click position relative to canvas
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const canvasX = Math.floor((e.clientX - rect.left) * scaleX);
            const canvasY = Math.floor((e.clientY - rect.top) * scaleY);
            
            // Get ULA dimensions
            const dims = spectrum.ula.getDimensions();
            const borderLeft = dims.borderLeft;
            const borderTop = dims.borderTop;
            const screenWidth = dims.screenWidth;
            const screenHeight = dims.screenHeight;
            
            // Calculate position relative to screen area
            const screenX = canvasX - borderLeft;
            const screenY = canvasY - borderTop;
            
            // Check if in screen area
            const inScreen = screenX >= 0 && screenX < screenWidth && 
                             screenY >= 0 && screenY < screenHeight;
            
            let infoHtml = '';
            
            if (inScreen) {
                const col = Math.floor(screenX / 8);
                const row = Math.floor(screenY / 8);
                const pixelX = screenX;
                const pixelY = screenY;
                
                // Calculate base Y for this character row (top of char cell)
                const charBaseY = row * 8;
                
                // Read 8 bitmap bytes (one per scanline in char cell)
                const bitmapBytes = [];
                const bitmapAddrs = [];
                for (let line = 0; line < 8; line++) {
                    const y = charBaseY + line;
                    const addr = 0x4000 + 
                        ((y & 0xC0) << 5) + 
                        ((y & 0x07) << 8) + 
                        ((y & 0x38) << 2) + 
                        col;
                    bitmapAddrs.push(addr);
                    bitmapBytes.push(spectrum.memory.read(addr));
                }
                
                // Calculate attribute address
                const attrAddr = 0x5800 + row * 32 + col;
                
                // Read 8 attribute bytes for 8 consecutive rows (multicolor check)
                const attrBytes = [];
                const attrAddrs = [];
                for (let r = 0; r < 8; r++) {
                    const checkRow = row + r;
                    if (checkRow < 24) {
                        const addr = 0x5800 + checkRow * 32 + col;
                        attrAddrs.push(addr);
                        attrBytes.push(spectrum.memory.read(addr));
                    }
                }
                
                // Check if all attributes are the same
                const allSame = attrBytes.every(b => b === attrBytes[0]);
                
                // Format attribute byte as f_b_ppp_iii
                function formatAttr(b) {
                    const flash = (b >> 7) & 1;
                    const bright = (b >> 6) & 1;
                    const paper = (b >> 3) & 7;
                    const ink = b & 7;
                    return `${flash}_${bright}_${paper.toString(2).padStart(3,'0')}_${ink.toString(2).padStart(3,'0')}`;
                }
                
                infoHtml = `
                    <div><span class="info-label">X:</span> <span class="info-value">${hex8(pixelX)}</span> <span class="info-dec">(${pixelX})</span> &nbsp; <span class="info-label">Y:</span> <span class="info-value">${hex8(pixelY)}</span> <span class="info-dec">(${pixelY})</span></div>
                    <div><span class="info-label">Col:</span> <span class="info-value">${hex8(col)}</span> <span class="info-dec">(${col})</span> &nbsp; <span class="info-label">Row:</span> <span class="info-value">${hex8(row)}</span> <span class="info-dec">(${row})</span></div>
                    <div><span class="info-label">Bitmap:</span> <span class="info-value">${hex16(bitmapAddrs[0])}</span></div>
                `;
                
                // Format bitmap bytes as binary with hex/dec
                for (let i = 0; i < bitmapBytes.length; i++) {
                    const b = bitmapBytes[i];
                    const bin = b.toString(2).padStart(8, '0');
                    infoHtml += `<div><span class="info-value">${bin}</span> <span class="info-dec">(${hex8(b)}/${b})</span></div>`;
                }
                
                infoHtml += `<div><span class="info-label">Attr:</span> <span class="info-value">${hex16(attrAddr)}</span></div>`;
                
                if (allSame) {
                    // Single attribute
                    infoHtml += `<div><span class="info-value">${hex8(attrBytes[0])}</span> <span class="info-dec">${formatAttr(attrBytes[0])}</span></div>`;
                } else {
                    // Multicolor - show all 8
                    infoHtml += `<div class="info-dec">(multicolor)</div>`;
                    for (let i = 0; i < attrBytes.length; i++) {
                        infoHtml += `<div><span class="info-value">${hex8(attrBytes[i])}</span> <span class="info-dec">${formatAttr(attrBytes[i])}</span></div>`;
                    }
                }
            } else {
                // In border area - show position and border color at this scanline
                const borderColor = spectrum.ula.getBorderColorAtLine(canvasY);
                const colorNames = ['black', 'blue', 'red', 'magenta', 'green', 'cyan', 'yellow', 'white'];
                infoHtml = `
                    <div><span class="info-label">X:</span> <span class="info-value">${hex8(canvasX)}</span> <span class="info-dec">(${canvasX})</span> &nbsp; <span class="info-label">Y:</span> <span class="info-value">${hex8(canvasY)}</span> <span class="info-dec">(${canvasY})</span></div>
                    <div><span class="info-label">Border:</span> <span class="info-value">${borderColor}</span> <span class="info-dec">(${colorNames[borderColor]})</span></div>
                `;
            }
            
            screenInfoPopup.innerHTML = infoHtml;
            
            // Position popup off-screen first to measure, then position correctly
            screenInfoPopup.style.left = '-9999px';
            screenInfoPopup.style.top = '-9999px';
            screenInfoPopup.classList.remove('hidden');
            
            // Get popup dimensions after content is set
            const popupRect = screenInfoPopup.getBoundingClientRect();
            const popupWidth = popupRect.width;
            const popupHeight = popupRect.height;
            
            // Position popup near click, keep within container to avoid scrollbars
            const container = canvas.parentElement;
            const containerRect = container.getBoundingClientRect();
            
            let popupX = e.clientX - containerRect.left + 15;
            let popupY = e.clientY - containerRect.top + 15;
            
            // Adjust to keep popup within visible area
            const maxX = container.clientWidth - popupWidth - 5;
            const maxY = container.clientHeight - popupHeight - 5;
            
            if (popupX > maxX) popupX = Math.max(5, e.clientX - containerRect.left - popupWidth - 15);
            if (popupY > maxY) popupY = Math.max(5, e.clientY - containerRect.top - popupHeight - 15);
            
            screenInfoPopup.style.left = popupX + 'px';
            screenInfoPopup.style.top = popupY + 'px';
        });
        
        // Hide popup when mouse leaves canvas (with small delay)
        let hideTimeout = null;
        
        canvas.addEventListener('mouseleave', () => {
            hideTimeout = setTimeout(() => {
                screenInfoPopup.classList.add('hidden');
            }, 200);
        });
        
        canvas.addEventListener('mouseenter', () => {
            if (hideTimeout) {
                clearTimeout(hideTimeout);
                hideTimeout = null;
            }
        });
        
        // Hide popup when clicking elsewhere
        document.addEventListener('click', (e) => {
            if (e.target !== canvas && !screenInfoPopup.contains(e.target)) {
                screenInfoPopup.classList.add('hidden');
            }
        });
        
        // Initial black screen
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Try to auto-load ROMs, show dialog only if not found
        tryLoadRomsFromDirectory();
        
        console.log('');
        console.log('Usage:');
        console.log('1. Place ROMs in roms/ directory (48.rom, 128.rom, pentagon.rom, trdos.rom)');
        console.log('2. Or select ROM files in dialog if not found');
        console.log('3. Load SNA/Z80 snapshots, TAP tapes, or TRD/SCL disk images');
    </script>
</body>
</html>
