<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" id="metaColorScheme" content="dark">
    <script>if(localStorage.getItem('zx-theme')==='light')document.getElementById('metaColorScheme').content='light';</script>
    <title>ZX-M8XXX v0.9.31</title>
    <style>
        * { box-sizing: border-box; }
        .hidden { display: none !important; }

        /* Theme variables */
        :root {
            color-scheme: dark;
            --bg-primary: #1a1a2e;
            --bg-secondary: #2a2a4a;
            --bg-tertiary: #222238;
            --bg-button: #4a4a6a;
            --bg-button-hover: #5a5a7a;
            --bg-screen: #111;
            --text-primary: #eee;
            --text-secondary: #888;
            --accent: #ff6b6b;
            --accent-hover: #ff8080;
            --cyan: #4ecdc4;
            --border-primary: #3a3a5a;
        }

        body.light-theme {
            color-scheme: light;
            --bg-primary: #e8e8f0;
            --bg-secondary: #d0d0e0;
            --bg-tertiary: #dcdce8;
            --bg-button: #b0b0c0;
            --bg-button-hover: #9090a0;
            --bg-screen: #888;
            --text-primary: #222;
            --text-secondary: #555;
            --accent: #d04040;
            --accent-hover: #c03030;
            --cyan: #0a8a82;
            --border-primary: #b8b8c8;
        }
        body.light-theme .status {
            background: var(--bg-primary);
            border: 1px solid var(--bg-secondary);
        }
        body.light-theme .disasm-line.current {
            background: #ffe0b0;
        }
        body.light-theme .disasm-line.current.target {
            background: #d0d0d0;
        }
        body.light-theme .disasm-line.breakpoint.current {
            background: #ffc0a0;
        }
        body.light-theme .disasm-line.trace {
            background: #e8d0f0;
            border-left: 3px solid #a040a0;
        }
        body.light-theme .disasm-line.current.trace {
            background: #f0e0b8;
            border-left: 3px solid #a040a0;
        }
        body.light-theme .stack-entry.current {
            background: #c0f0c0;
            color: #060;
        }
        /* Light theme operand colors */
        body.light-theme .disasm-reg {
            color: #996600;
        }
        body.light-theme .disasm-num {
            color: #008800;
        }
        body.light-theme .disasm-char {
            color: #9933cc;
        }
        body.light-theme .disasm-bin {
            color: #336699;
        }
        body.light-theme .disasm-ptr {
            color: #666666;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            margin: 0;
            padding: 10px;
            min-height: 100vh;
            transition: background 0.3s, color 0.3s;
        }
        .container { max-width: 1090px; margin: 0 auto; }
        .main-layout { display: flex; flex-direction: column; }
        .emulator-section { flex-shrink: 0; }

        /* Landscape mode - side by side layout */
        @media (min-width: 1400px) {
            body { padding: 10px; }
            .container { max-width: none; margin: 0; position: relative; }
            .top-bar { margin-bottom: 10px; }
            .main-layout {
                flex-direction: row;
                align-items: flex-start;
                gap: 20px;
            }
            .emulator-section {
                flex: 0 0 auto;
                position: relative;
            }
            .screen-container {
                margin-bottom: 4px;
            }
            .tab-container {
                flex: 1;
                min-width: 800px;
                position: relative;
                top: -40px;
                margin-bottom: -40px;
                margin-top: 0;
                margin-left: 60px;
            }
            .tab-container.zoom-shifted {
                margin-left: 20px;
            }
            .main-layout {
                gap: 10px;
            }
            .debugger-panel.open {
                max-height: calc(100vh - 50px);
                overflow-y: auto;
                overflow-x: hidden;
            }
            .main-debug-row {
                flex-wrap: nowrap;
            }
            .panel-tabs {
                max-width: 1090px;
            }
            .disasm-panel {
                height: 740px !important;
                flex: 0 0 480px !important;
            }
            .right-column {
                height: 740px !important;
                flex: 0 0 600px !important;
                display: flex;
                flex-direction: column;
            }
            .memory-section.memory-panel {
                margin-top: 3px !important;
                flex: 1 !important;
                display: flex !important;
                flex-direction: column !important;
            }
            #memoryView, #rightDisassemblyView {
                flex: 1 !important;
                min-height: 0 !important;
                overflow: hidden !important;
            }
            .disasm-panel .disassembly-view,
            .disasm-panel .memory-view {
                flex: 1 !important;
                min-height: 0 !important;
                overflow: hidden !important;
            }
            .breakpoint-list {
                max-height: 60px !important;
            }
            .labels-list {
                max-height: 80px !important;
            }
            .memory-search {
                border-top: none !important;
                margin-top: 0 !important;
                padding-top: 0 !important;
            }
            .memory-search.inline {
                margin-top: 10px !important;
            }
            .opcodes-container {
                height: calc(100vh - 80px) !important;
                min-height: 800px !important;
                max-height: none !important;
            }
            .graphics-container {
                max-height: calc(100vh - 100px) !important;
            }
            .graphics-dump-wrap {
                max-height: calc(100vh - 180px) !important;
            }
        }

        /* Portrait mode - stacked layout */
        @media (max-width: 1399px) {
            .main-debug-row {
                align-items: flex-start !important;
            }
            .disasm-panel {
                height: 720px !important;
                display: flex !important;
                flex-direction: column !important;
            }
            .disasm-panel .disassembly-view,
            .disasm-panel .memory-view {
                flex: 1 !important;
                min-height: 0 !important;
                overflow: hidden !important;
            }
            .disasm-panel .bookmarks-bar,
            .disasm-panel .debugger-controls,
            .disasm-panel .memory-search {
                flex: 0 0 auto !important;
            }
            .right-column {
                height: 720px !important;
                display: flex !important;
                flex-direction: column !important;
            }
            .memory-section.memory-panel {
                flex: 1 !important;
                display: flex !important;
                flex-direction: column !important;
            }
            .memory-section.memory-panel .memory-view,
            .memory-section.memory-panel .disassembly-view {
                flex: 1 !important;
                min-height: 0 !important;
                overflow: hidden !important;
            }
            .memory-section.memory-panel .bookmarks-bar,
            .memory-section.memory-panel .debugger-controls,
            .memory-section.memory-panel .memory-search {
                flex: 0 0 auto !important;
            }
        }

        .top-bar {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 6px;
            flex-wrap: wrap;
        }
        .top-bar h1 { color: var(--accent); margin: 0; font-size: 1.3em; }
        .toolbar-select {
            padding: 6px 10px;
            font-size: 12px;
        }
        .toolbar-btn {
            padding: 6px 12px;
            font-size: 12px;
        }
        .version { color: var(--text-secondary); font-size: 0.9em; }
        .help-btn {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--bg-button);
            color: var(--text-secondary);
            border: none;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            padding: 0;
            line-height: 24px;
        }
        .help-btn:hover {
            background: var(--bg-button-hover);
            color: var(--text-primary);
        }
        .test-link {
            color: var(--text-secondary);
            font-size: 12px;
            text-decoration: none;
            padding: 4px 8px;
            background: var(--bg-button);
            border-radius: 3px;
        }
        .test-link:hover {
            background: var(--bg-button-hover);
            color: var(--text-primary);
        }
        .theme-btn {
            background: var(--bg-secondary);
            border: none;
            font-size: 16px;
            cursor: pointer;
            padding: 5px 10px;
            border-radius: 4px;
            color: inherit;
            outline: none;
            box-shadow: none;
            transition: none;
        }
        .theme-btn:hover {
            background: var(--bg-button-hover);
        }
        .screen-container {
            background: var(--bg-screen);
            padding: 6px;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            margin-bottom: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            overflow: auto;
            position: relative;
        }
        .screen-wrapper {
            position: relative;
            display: inline-block;
        }
        #screen {
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            -ms-interpolation-mode: nearest-neighbor;
            cursor: crosshair;
            display: block;
        }
        #overlayCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 10;
        }
        .sprite-region-overlay {
            position: absolute;
            pointer-events: none;
            z-index: 20;
            border: 2px dashed #ff0000;
            background: rgba(255, 0, 0, 0.15);
            box-sizing: border-box;
            display: none;
        }
        /* Fullscreen mode styles */
        .screen-wrapper:fullscreen,
        .screen-wrapper:-webkit-full-screen {
            background: #000 !important;
            overflow: hidden !important;
            width: 100vw !important;
            height: 100vh !important;
            max-width: 100vw !important;
            max-height: 100vh !important;
            display: block !important;
            margin: 0 !important;
            padding: 0 !important;
        }
        .screen-wrapper:fullscreen .sprite-region-overlay,
        .screen-wrapper:-webkit-full-screen .sprite-region-overlay {
            display: none !important;
        }
        .screen-info-popup {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 8px 12px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 11px;
            line-height: 1.5;
            z-index: 100;
            pointer-events: none;
            white-space: nowrap;
            border: 1px solid var(--cyan);
        }
        .screen-info-popup.hidden {
            display: none;
        }
        .screen-info-popup .info-label {
            color: var(--text-secondary);
        }
        .screen-info-popup .info-value {
            color: var(--cyan);
        }
        .screen-info-popup .info-dec {
            color: var(--text-secondary);
            font-size: 10px;
        }
        .controls {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 4px;
        }
        .controls button, .controls select {
            padding: 2px 10px;
            font-size: 13px;
            height: 26px;
        }
        button {
            background: var(--bg-button);
            color: var(--text-primary);
            border: none;
            padding: 4px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }
        button:hover { background: var(--bg-button-hover); }
        button:disabled { background: var(--bg-secondary); cursor: not-allowed; opacity: 0.5; }
        button.primary { background: var(--accent); }
        button.primary:hover { background: var(--accent-hover); }
        #btnRun { width: 90px; text-align: center; }
        .file-input { display: none; }
        select {
            background: var(--bg-button);
            color: var(--text-primary);
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
            color-scheme: dark;
        }
        body.light-theme select {
            color-scheme: light;
        }
        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 5px;
            background: var(--bg-button);
            padding: 2px 10px;
            border-radius: 4px;
            font-size: 13px;
            cursor: pointer;
            height: 26px;
        }
        .checkbox-label:hover { background: var(--bg-button-hover); }
        .checkbox-label input { cursor: pointer; }
        .zoom-btn {
            background: var(--bg-secondary);
            color: var(--text-secondary);
            border: none;
            padding: 2px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            margin-left: 3px;
            height: 26px;
        }
        .zoom-btn:hover { background: var(--bg-button); color: var(--text-primary); }
        .zoom-btn.active { background: var(--accent); color: #fff; }
        .zoom-group {
            margin-left: 10px;
            display: flex;
            align-items: center;
            gap: 3px;
            font-size: 12px;
        }
        #overlaySelect {
            min-width: 95px;
        }
        .status {
            text-align: left;
            padding: 6px;
            background: var(--bg-secondary);
            border-radius: 4px;
            margin-bottom: 8px;
            font-family: monospace;
            border: none;
            box-shadow: none;
            outline: none;
            overflow: hidden;
        }
        .status-item { display: inline-block; margin: 0 6px; }
        .status-label { color: var(--text-secondary); }
        .status-value { color: var(--cyan); }
        .small-btn {
            padding: 2px 6px;
            font-size: 10px;
            margin-left: 5px;
            background: var(--bg-button);
            border: 1px solid var(--bg-button);
            color: var(--text-primary);
            border-radius: 3px;
            cursor: pointer;
        }
        .small-btn:hover { background: var(--accent); }

        /* Keyboard Help Modal */
        .help-modal {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }
        .help-modal.hidden { display: none; }
        .help-modal-content {
            background: var(--bg-secondary);
            padding: 20px 30px;
            border-radius: 8px;
            max-width: 450px;
            width: 90%;
        }
        .help-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .help-modal-header h3 { margin: 0; color: var(--cyan); }
        .help-modal-close {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        .help-modal-close:hover { color: var(--text-primary); }
        .help-modal table { width: 100%; border-collapse: collapse; }
        .help-modal td { padding: 5px 10px; border-bottom: 1px solid var(--bg-button); }
        .help-modal td:first-child { color: var(--accent); font-family: monospace; width: 120px; }
        .help-section-header { padding-top: 10px !important; color: var(--cyan) !important; font-weight: bold; }
        
        .message {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 25px;
            border-radius: 4px;
            animation: fadeIn 0.3s ease;
            z-index: 100;
        }
        .message.success { background: #2ecc71; }
        .message.error { background: #e74c3c; }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .drop-zone {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(78, 205, 196, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            font-size: 2em;
            z-index: 50;
        }
        .drop-zone.active { display: flex; }
        
        /* ROM Selection Modal */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }
        .modal-overlay.hidden { display: none; }
        .modal {
            background: var(--bg-secondary);
            padding: 30px;
            border-radius: 12px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }
        .modal h2 {
            margin-top: 0;
            color: var(--accent);
            text-align: center;
        }
        .modal p {
            color: var(--text-primary);
            line-height: 1.6;
        }
        .rom-grid {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 6px 12px;
            align-items: center;
            margin: 12px 0;
            padding: 12px;
            background: var(--bg-primary);
            border-radius: 8px;
        }
        .rom-grid button {
            width: 100%;
            white-space: nowrap;
        }
        .rom-grid .rom-status {
            font-size: 0.85em;
            color: var(--text-secondary);
        }
        .rom-grid .rom-status.loaded {
            color: #2ecc71;
        }
        .modal-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        .modal-actions button {
            flex: 1;
            padding: 12px;
        }
        .modal-actions button:disabled {
            opacity: 0.5;
        }
        .modal-hint {
            font-size: 0.85em;
            color: var(--text-secondary);
            margin-top: 15px;
            text-align: center;
        }

        /* Tab System */
        .tab-container {
            margin-top: 0;
        }
        .tab-container.collapsed .tab-content,
        .tab-container.collapsed .tab-content.active {
            display: none !important;
        }
        .tab-bar {
            display: flex;
            gap: 2px;
            background: var(--bg-primary);
            padding: 4px 4px 0 4px;
            border-radius: 6px 6px 0 0;
        }
        .tab-container.collapsed .tab-bar {
            border-radius: 6px;
            padding: 4px;
        }
        .tab-btn {
            padding: 8px 16px;
            background: var(--bg-button);
            border: none;
            border-radius: 6px 6px 0 0;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s;
        }
        .tab-container.collapsed .tab-btn {
            border-radius: 4px;
        }
        .tab-btn .arrow {
            margin-right: 6px;
            font-size: 10px;
            display: inline-block;
            transition: transform 0.2s;
        }
        .tab-btn.active .arrow {
            transform: rotate(90deg);
        }
        .tab-container.collapsed .tab-btn .arrow {
            transform: rotate(0deg);
        }
        .tab-btn:hover {
            background: var(--bg-button-hover);
            color: var(--text-primary);
        }
        .tab-btn.active {
            background: var(--bg-secondary);
            color: var(--cyan);
        }
        .tab-container.collapsed .tab-btn.active {
            background: var(--bg-button);
            color: var(--text-secondary);
        }
        .tab-content {
            display: none;
            background: var(--bg-secondary);
            border-radius: 0 6px 6px 6px;
            padding: 10px;
        }
        .tab-content.active {
            display: block;
        }

        /* Assembler Tab */
        .assembler-container {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 200px);
            min-height: 500px;
            max-height: 900px;
        }
        .assembler-header {
            display: flex;
            justify-content: flex-start;
            align-items: center;
            padding: 10px 15px;
            background: var(--bg-primary);
            border-radius: 4px;
            margin-bottom: 10px;
        }
        .assembler-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        .assembler-controls button {
            padding: 4px 10px;
            font-size: 11px;
        }
        .asm-option {
            font-size: 11px;
            color: var(--text-secondary);
            margin-left: 10px;
            cursor: pointer;
        }
        .asm-option input {
            margin-right: 4px;
        }
        .asm-option input[type="text"] {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: 2px 6px;
            font-family: monospace;
            font-size: 11px;
            width: 140px;
            margin-left: 4px;
        }
        .asm-option input[type="text"]::placeholder {
            color: var(--text-secondary);
            opacity: 0.6;
        }
        #asmDetectedDefines {
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            padding: 2px;
            font-family: monospace;
            font-size: 11px;
            margin-left: 6px;
            min-width: 100px;
            max-width: 200px;
            height: auto;
            max-height: 60px;
        }
        #asmDetectedDefines option {
            padding: 2px 4px;
            background-color: var(--bg-secondary);
            color: var(--text-primary);
        }
        #asmDetectedDefines option:checked {
            background-color: var(--accent);
            color: var(--bg-primary);
        }
        #asmDetectedDefines option:hover {
            background-color: var(--bg-button);
        }
        .assembler-body {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 6px;
            min-height: 0;
        }
        .asm-editor-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--bg-primary);
            border-radius: 4px;
            overflow: hidden;
            min-height: 0;
            transition: box-shadow 0.15s;
        }
        .asm-editor-container.drag-over {
            box-shadow: inset 0 0 0 3px var(--cyan);
        }
        .asm-line-numbers {
            padding: 10px 8px;
            background: var(--bg-button);
            color: var(--text-secondary);
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: var(--asm-font-size, 12px);
            line-height: var(--asm-line-height, 17px);
            text-align: right;
            user-select: none;
            min-width: 35px;
            overflow-y: auto;
            overflow-x: hidden;
            white-space: pre;
            scrollbar-width: none;  /* Firefox */
            -ms-overflow-style: none;  /* IE/Edge */
            box-sizing: border-box;
            letter-spacing: 0;
            word-spacing: 0;
        }
        .asm-line-numbers::-webkit-scrollbar {
            display: none;  /* Chrome/Safari */
        }
        .asm-editor-wrap {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        .asm-textarea {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 10px;
            margin: 0;
            border: none;
            outline: none;
            resize: none;
            background: transparent;
            color: var(--text-primary);
            caret-color: var(--text-primary);
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: var(--asm-font-size, 12px);
            line-height: var(--asm-line-height, 17px);
            tab-size: 8;
            -moz-tab-size: 8;
            white-space: pre;
            overflow: auto;
            z-index: 2;
            box-sizing: border-box;
            letter-spacing: 0;
            word-spacing: 0;
        }
        .asm-textarea.highlighting {
            color: transparent;
        }
        .asm-textarea::placeholder {
            color: var(--text-secondary);
        }
        .asm-highlight {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 10px;
            margin: 0;
            border: none;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: var(--asm-font-size, 12px);
            line-height: var(--asm-line-height, 17px);
            tab-size: 8;
            -moz-tab-size: 8;
            white-space: pre;
            overflow: auto;
            pointer-events: none;
            z-index: 1;
            color: var(--text-primary);
            box-sizing: border-box;
            letter-spacing: 0;
            word-spacing: 0;
            background: transparent;
        }
        .asm-output-container {
            flex: 0 0 auto;
            display: flex;
            flex-direction: column;
            background: var(--bg-primary);
            border-radius: 4px;
            min-height: 90px;
            max-height: 200px;
        }
        .asm-output-header {
            padding: 4px 10px;
            background: var(--bg-button);
            color: var(--cyan);
            font-size: 11px;
            font-weight: bold;
            border-radius: 4px 4px 0 0;
        }
        .asm-output {
            flex: 1;
            padding: 6px 10px;
            font-family: monospace;
            font-size: 11px;
            line-height: 1.4;
            overflow: auto;
            color: var(--text-primary);
        }
        .asm-output .asm-hint {
            color: var(--text-secondary);
            font-style: italic;
        }
        .asm-output .asm-status-line {
            font-weight: bold;
            margin-bottom: 6px;
            padding-bottom: 4px;
            border-bottom: 1px solid var(--bg-button);
        }
        .asm-output .asm-status-line.success {
            color: #80ff80;
        }
        .asm-output .asm-status-line.error {
            color: #ff8080;
        }
        .asm-output .asm-files-section {
            margin-top: 8px;
            padding: 6px 8px;
            background: var(--bg-secondary);
            border-radius: 4px;
        }
        .asm-output .asm-files-header {
            color: var(--cyan);
            font-weight: bold;
            margin-bottom: 4px;
        }
        .asm-output .asm-file-item {
            color: var(--text-primary);
            padding: 2px 0;
            font-family: monospace;
        }
        .asm-output .asm-file-item::before {
            content: '\2022 ';
            color: var(--text-secondary);
        }
        .asm-output .asm-file-details {
            color: var(--text-secondary);
        }
        .asm-output .asm-file-md5 {
            color: var(--cyan);
            font-size: 0.85em;
            opacity: 0.8;
        }
        .asm-output .asm-md5-pass {
            color: #80ff80;
            font-weight: bold;
        }
        .asm-output .asm-md5-fail {
            color: #ff8080;
            font-weight: bold;
        }
        .asm-output .asm-line {
            display: flex;
            gap: 10px;
        }
        .asm-output .asm-addr {
            color: var(--cyan);
            min-width: 40px;
        }
        .asm-output .asm-bytes {
            color: #80c0ff;
            min-width: 100px;
        }
        .asm-output .asm-source {
            color: var(--text-secondary);
        }
        .asm-output .asm-error {
            color: #ff8080;
        }
        .asm-output .asm-warning {
            color: #ffcc00;
        }
        .asm-output .asm-clickable {
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 2px;
        }
        .asm-output .asm-clickable:hover {
            background: rgba(255, 255, 255, 0.1);
            text-decoration: underline;
        }
        .asm-output .asm-label-def {
            color: var(--accent);
        }

        /* File tabs */
        .asm-file-tabs {
            display: flex;
            flex-wrap: nowrap;
            gap: 2px;
            padding: 4px 4px 0 4px;
            background: var(--bg-secondary);
            border-radius: 4px 4px 0 0;
            min-height: 28px;
            overflow-x: auto;
            overflow-y: hidden;
            scrollbar-width: thin;
        }
        .asm-file-tabs::-webkit-scrollbar {
            height: 4px;
        }
        .asm-file-tabs::-webkit-scrollbar-thumb {
            background: var(--bg-button);
            border-radius: 2px;
        }
        .asm-file-tabs:empty {
            display: none;
        }
        .asm-file-tab {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            background: var(--bg-button);
            border-radius: 4px 4px 0 0;
            font-size: 11px;
            cursor: pointer;
            max-width: 120px;
            min-width: 60px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex-shrink: 0;
        }
        .asm-file-tab .tab-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        /* Files dropdown */
        .asm-files-dropdown {
            position: relative;
            display: inline-block;
        }
        .asm-files-list {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: var(--bg-secondary);
            border: 1px solid var(--bg-button);
            border-radius: 4px;
            min-width: 375px;
            max-width: 600px;
            max-height: 400px;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        .asm-files-list.show {
            display: block;
        }
        .asm-files-list-item {
            padding: 6px 10px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
            border-bottom: 1px solid var(--bg-button);
        }
        .asm-files-list-item:last-child {
            border-bottom: none;
        }
        .asm-files-list-item:hover {
            background: var(--bg-button);
        }
        .asm-files-list-item.main {
            color: var(--accent);
        }
        .asm-files-list-item.binary {
            color: var(--text-secondary);
            font-style: italic;
        }
        .asm-files-list-item.open {
            background: var(--bg-button);
            color: var(--cyan);
        }
        .asm-files-list-item .file-icon {
            width: 14px;
            text-align: center;
        }
        .asm-files-list-item .file-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .asm-files-list-item .file-size {
            color: var(--text-secondary);
            font-size: 10px;
        }
        .asm-files-list-item .file-dir {
            color: var(--text-secondary);
            font-size: 11px;
        }
        /* Search/Replace bar */
        .asm-search-bar {
            background: var(--bg-secondary);
            padding: 6px 10px;
            border-bottom: 1px solid var(--bg-button);
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .asm-search-row, .asm-replace-row {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .asm-search-bar input[type="text"] {
            flex: 1;
            max-width: 250px;
            padding: 4px 8px;
            font-size: 12px;
            background: var(--bg-primary);
            border: 1px solid var(--bg-button);
            border-radius: 3px;
            color: var(--text-primary);
        }
        .asm-search-bar input[type="text"]:focus {
            outline: none;
            border-color: var(--accent);
        }
        .asm-search-bar button {
            padding: 4px 8px;
            font-size: 11px;
            background: var(--bg-button);
            border: none;
            border-radius: 3px;
            color: var(--text-primary);
            cursor: pointer;
        }
        .asm-search-bar button:hover {
            background: var(--bg-secondary);
        }
        #btnAsmSearchClose {
            font-size: 14px;
            padding: 2px 6px;
        }
        .asm-search-count {
            font-size: 11px;
            color: var(--text-secondary);
            min-width: 60px;
        }
        .asm-search-option {
            font-size: 11px;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 3px;
        }
        .asm-search-option input {
            margin: 0;
        }
        .asm-search-results {
            max-height: 200px;
            overflow-y: auto;
            background: var(--bg-secondary);
            border-top: 1px solid var(--bg-button);
            font-size: 12px;
        }
        .asm-search-result-item {
            padding: 4px 8px;
            cursor: pointer;
            border-bottom: 1px solid var(--bg-button);
            display: flex;
            gap: 8px;
        }
        .asm-search-result-item:hover {
            background: var(--bg-button);
        }
        .asm-search-result-file {
            color: var(--cyan);
            min-width: 100px;
            flex-shrink: 0;
        }
        .asm-search-result-line {
            color: var(--text-secondary);
            min-width: 40px;
            flex-shrink: 0;
        }
        .asm-search-result-text {
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .asm-search-result-match {
            background: rgba(255, 255, 0, 0.3);
            color: #ff0;
        }
        .asm-search-results-header {
            padding: 4px 8px;
            background: var(--bg-button);
            font-weight: bold;
            color: var(--text-secondary);
        }
        /* File selector dialog */
        .file-selector-dialog {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        .file-selector-dialog.hidden {
            display: none;
        }
        .file-selector-content {
            background: var(--bg-primary);
            border: 1px solid var(--bg-button);
            border-radius: 8px;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        }
        .file-selector-header {
            padding: 12px 16px;
            border-bottom: 1px solid var(--bg-button);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .file-selector-header h3 {
            margin: 0;
            font-size: 16px;
        }
        .file-selector-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 20px;
            cursor: pointer;
        }
        .file-selector-close:hover {
            color: var(--accent);
        }
        .file-selector-body {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }
        .file-selector-item {
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 4px;
            margin-bottom: 2px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .file-selector-item:hover {
            background: var(--bg-button);
        }
        .file-selector-item.detected {
            background: var(--bg-button);
            border: 1px solid var(--cyan);
        }
        .file-selector-item .item-icon {
            width: 16px;
            text-align: center;
            color: var(--text-secondary);
        }
        .file-selector-item .item-name {
            flex: 1;
        }
        .file-selector-item .item-hint {
            font-size: 10px;
            color: var(--cyan);
        }
        .asm-file-tab:hover {
            background: var(--bg-hover);
        }
        .asm-file-tab.active {
            background: var(--bg-primary);
            color: var(--cyan);
        }
        .asm-file-tab.main::before {
            content: "▶";
            font-size: 8px;
            color: var(--accent);
        }
        .asm-file-tab.modified::after {
            content: "●";
            font-size: 8px;
            color: var(--accent);
            margin-left: 2px;
        }
        .asm-file-tab .tab-close {
            font-size: 12px;
            color: var(--text-secondary);
            padding: 0 2px;
            margin-left: 4px;
        }
        .asm-file-tab .tab-close:hover {
            color: #ff8080;
        }
        .asm-file-tab.binary {
            color: var(--text-secondary);
            font-style: italic;
        }
        .asm-editor-area {
            display: flex;
            flex: 1;
            min-height: 0;
        }
        .asm-main-label {
            font-size: 10px;
            color: #ff6666;
            cursor: pointer;
            margin-left: 10px;
        }
        .asm-main-label:hover {
            color: #ff9999;
        }
        .asm-main-label::before {
            content: "Main: ";
            color: #ff6666;
        }

        /* Syntax highlighting colors */
        .asm-hl-instruction { color: var(--accent); font-weight: bold; }
        .asm-hl-directive { color: #c080ff; }
        .asm-hl-register { color: #ffd080; }
        .asm-hl-number { color: #80ff80; }
        .asm-hl-string { color: #ff80c0; }
        .asm-hl-label { color: var(--cyan); }
        .asm-hl-comment { color: var(--text-secondary); font-style: italic; }
        .asm-hl-operator { color: var(--text-primary); }
        .asm-hl-paren { color: #c0c0c0; }

        /* Opcodes Tab */
        .opcodes-container {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 500px);
            min-height: 400px;
            max-height: 700px;
        }
        .opcodes-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: var(--bg-primary);
            border-radius: 4px;
            margin-bottom: 10px;
        }
        .opcodes-header h3 {
            margin: 0;
            color: var(--cyan);
            font-size: 14px;
        }
        .opcodes-filter {
            display: flex;
            gap: 10px;
        }
        .opcode-search {
            padding: 5px 10px;
            background: var(--bg-secondary);
            border: 1px solid var(--bg-button);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 12px;
            width: 150px;
        }
        .opcodes-filter select {
            padding: 5px 10px;
            font-size: 12px;
        }
        .opcodes-body {
            flex: 1;
            overflow-y: auto;
            background: var(--bg-primary);
            border-radius: 4px;
        }
        .opcodes-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
            font-family: monospace;
        }
        .opcodes-table thead {
            position: sticky;
            top: 0;
            background: var(--bg-button);
            z-index: 1;
        }
        .opcodes-table th {
            padding: 8px 10px;
            text-align: left;
            color: var(--cyan);
            font-weight: bold;
            border-bottom: 2px solid var(--bg-secondary);
        }
        .opcodes-table td {
            padding: 5px 10px;
            border-bottom: 1px solid var(--bg-secondary);
            vertical-align: top;
        }
        .opcodes-table tr:hover {
            background: var(--bg-button);
        }
        .opcodes-table .op-mnemonic {
            color: var(--accent);
            font-weight: bold;
            white-space: nowrap;
        }
        .opcodes-table .op-mnemonic.undoc {
            color: #c080ff;
        }
        .opcodes-table .op-mnemonic.undoc::after {
            content: '*';
            color: #ff80ff;
            font-size: 10px;
            vertical-align: super;
        }
        .opcodes-table .op-opcode {
            color: #80c0ff;
            text-align: left;
            white-space: nowrap;
        }
        .opcodes-table .op-bytes {
            color: var(--text-secondary);
            text-align: center;
        }
        .opcodes-table .op-cycles {
            color: var(--cyan);
            text-align: center;
        }
        .opcodes-table .op-flags {
            font-size: 10px;
            letter-spacing: 1px;
        }
        .opcodes-table .op-desc {
            color: var(--text-primary);
        }
        .opcodes-footer {
            padding: 8px 15px;
            background: var(--bg-primary);
            border-radius: 4px;
            margin-top: 10px;
        }
        .flags-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            font-size: 10px;
            color: var(--text-secondary);
        }
        .flags-legend .flag-symbol {
            color: var(--cyan);
        }

        /* Graphics Viewer Tab */
        .graphics-container {
            padding: 10px;
            height: auto;
        }
        .graphics-body {
            display: inline-flex;
            gap: 10px;
            overflow: visible;
        }
        .graphics-dump-wrap {
            flex: 0 0 auto;
            overflow: auto;
            background: #000;
            border: 1px solid var(--border-secondary);
            max-height: calc(100vh - 200px);
        }
        .graphics-dump-canvas {
            image-rendering: pixelated;
            display: block;
        }
        .graphics-sidebar {
            width: 160px;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .gfx-col-address,
        .gfx-col-actions {
            display: flex;
            flex-direction: column;
            gap: 6px;
            flex-shrink: 0;
        }
        .gfx-control-group {
            background: var(--bg-secondary);
            border: 1px solid var(--border-secondary);
            border-radius: 4px;
            padding: 8px;
        }
        .gfx-control-group label {
            display: block;
            font-size: 10px;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }
        .gfx-control-group input[type="text"] {
            width: 100%;
            padding: 4px 6px;
            background: var(--bg-primary);
            border: 1px solid var(--border-secondary);
            color: var(--text-primary);
            border-radius: 3px;
            font-family: monospace;
            font-size: 12px;
            box-sizing: border-box;
        }
        #gfxAddress {
            width: 50px;
        }
        .gfx-spinner {
            display: flex;
            gap: 2px;
        }
        .gfx-spinner input {
            width: 30px !important;
            max-width: 30px;
            flex: 0 0 30px;
            text-align: center;
        }
        .gfx-spinner button {
            width: 28px;
            padding: 4px;
            background: var(--bg-button);
            border: 1px solid var(--border-secondary);
            color: var(--text-primary);
            cursor: pointer;
            border-radius: 3px;
        }
        .gfx-spinner button:hover {
            background: var(--accent);
            color: var(--bg-primary);
        }
        .gfx-checkboxes label {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            margin-right: 10px;
            cursor: pointer;
        }
        .gfx-zoom-inline {
            display: flex;
            gap: 6px;
            margin-top: 4px;
        }
        .gfx-zoom-inline label {
            margin-right: 0;
        }
        .gfx-nav-buttons {
            display: flex;
            gap: 2px;
            margin-bottom: 2px;
            width: 160px;
        }
        .gfx-nav-buttons button {
            flex: 1;
            padding: 4px 6px;
            background: var(--bg-button);
            border: 1px solid var(--border-secondary);
            color: var(--text-primary);
            cursor: pointer;
            border-radius: 3px;
            font-size: 10px;
        }
        .gfx-nav-buttons button:hover {
            background: var(--accent);
            color: var(--bg-primary);
        }
        .gfx-preview-wrap {
            background: #000;
            border: 1px solid var(--border-secondary);
            padding: 4px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            overflow: hidden;
            max-width: 160px;
            min-height: 200px;
        }
        .gfx-preview-canvas {
            image-rendering: pixelated;
            max-width: 100%;
        }
        .gfx-info {
            font-size: 10px;
            color: var(--text-secondary);
            text-align: center;
            margin-top: 4px;
        }
        .gfx-actions {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .gfx-actions button {
            padding: 6px 8px;
            background: var(--bg-button);
            border: 1px solid var(--accent);
            color: var(--accent);
            cursor: pointer;
            border-radius: 3px;
            font-size: 11px;
        }
        .gfx-actions button:hover {
            background: var(--accent);
            color: var(--bg-primary);
        }

        /* Info Tab */
        #tab-info {
            overflow-y: auto;
            max-height: calc(100vh - 120px);
            padding-top: 0;
        }
        .info-tab-content {
            padding: 0 15px 15px 15px;
            max-width: 800px;
        }
        .info-tab-content h3 {
            margin: 0 0 15px 0;
            color: var(--accent);
            font-size: 16px;
        }
        .keyboard-image {
            margin-bottom: 15px;
            text-align: center;
        }
        .keyboard-image img {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
        }
        .info-section {
            margin-bottom: 20px;
        }
        .info-section h4 {
            margin: 0 0 8px 0;
            color: var(--cyan);
            font-size: 13px;
            border-bottom: 1px solid var(--border-secondary);
            padding-bottom: 4px;
        }
        .info-section p, .info-section li {
            font-size: 11px;
            color: var(--text-secondary);
            margin: 4px 0;
            line-height: 1.4;
        }
        .info-section ul {
            margin: 0;
            padding-left: 20px;
        }
        .info-section code {
            background: var(--bg-tertiary);
            padding: 2px 4px;
            border-radius: 2px;
            font-family: monospace;
            color: var(--text-primary);
        }
        .info-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
        }
        .info-table th, .info-table td {
            border: 1px solid var(--border-secondary);
            padding: 4px 8px;
            text-align: left;
        }
        .info-table th {
            background: var(--bg-tertiary);
            color: var(--cyan);
            font-weight: normal;
        }
        .info-table td {
            color: var(--text-secondary);
        }
        .info-table td.contended {
            color: var(--accent);
        }

        /* Info Sub-tabs */
        .info-subtab-bar {
            display: flex;
            gap: 2px;
            border-bottom: 1px solid var(--bg-button);
            position: sticky;
            top: 0;
            background: var(--bg-secondary);
            z-index: 10;
            padding: 0 10px;
            margin: 0 -10px 10px -10px;
        }
        .info-subtab-btn {
            padding: 6px 16px;
            background: var(--bg-tertiary);
            border: 1px solid var(--bg-button);
            border-bottom: none;
            border-radius: 4px 4px 0 0;
            color: var(--text-secondary);
            font-size: 12px;
            cursor: pointer;
            margin-bottom: -1px;
        }
        .info-subtab-btn:hover {
            background: var(--bg-button);
            color: var(--text-primary);
        }
        .info-subtab-btn.active {
            background: var(--bg-secondary);
            color: var(--cyan);
            border-bottom: 1px solid var(--bg-secondary);
        }
        .info-subtab-content {
            display: none;
        }
        .info-subtab-content.active {
            display: block;
        }

        /* Tools Tab */
        #tab-tools {
            padding-top: 0;
        }
        .tools-subtab-bar {
            display: flex;
            gap: 2px;
            border-bottom: 1px solid var(--bg-button);
            margin-bottom: 10px;
            padding: 0 10px;
            position: sticky;
            top: 0;
            background: var(--bg-secondary);
            z-index: 10;
        }
        .tools-subtab-btn {
            padding: 6px 16px;
            background: var(--bg-tertiary);
            border: 1px solid var(--bg-button);
            border-bottom: none;
            border-radius: 4px 4px 0 0;
            color: var(--text-secondary);
            font-size: 12px;
            cursor: pointer;
            margin-bottom: -1px;
        }
        .tools-subtab-btn:hover {
            background: var(--bg-button);
            color: var(--text-primary);
        }
        .tools-subtab-btn.active {
            background: var(--bg-secondary);
            color: var(--cyan);
            border-bottom: 1px solid var(--bg-secondary);
        }
        .tools-subtab-content {
            display: none;
        }
        .tools-subtab-content.active {
            display: block;
        }

        /* Settings Tab */
        #tab-settings {
            overflow-y: auto;
            max-height: calc(100vh - 120px);
            padding-top: 0;
        }
        .settings-subtab-bar {
            display: flex;
            gap: 2px;
            border-bottom: 1px solid var(--bg-button);
            margin-bottom: 10px;
            padding: 0 10px;
            position: sticky;
            top: 0;
            background: var(--bg-secondary);
            z-index: 10;
        }
        .settings-subtab-btn {
            padding: 6px 16px;
            background: var(--bg-tertiary);
            border: 1px solid var(--bg-button);
            border-bottom: none;
            border-radius: 4px 4px 0 0;
            color: var(--text-secondary);
            font-size: 12px;
            cursor: pointer;
            margin-bottom: -1px;
        }
        .settings-subtab-btn:hover {
            background: var(--bg-button);
            color: var(--text-primary);
        }
        .settings-subtab-btn.active {
            background: var(--bg-secondary);
            color: var(--cyan);
            border-bottom: 1px solid var(--bg-secondary);
        }
        .settings-subtab-content {
            display: none;
        }
        .settings-subtab-content.active {
            display: block;
        }
        .media-catalog-bar {
            display: flex;
            gap: 2px;
            margin-top: 6px;
            border-bottom: 1px solid var(--bg-button);
        }
        .media-catalog-btn {
            padding: 3px 10px;
            background: var(--bg-tertiary);
            border: 1px solid var(--bg-button);
            border-bottom: none;
            border-radius: 3px 3px 0 0;
            color: var(--text-secondary);
            font-size: 11px;
            cursor: pointer;
            margin-bottom: -1px;
        }
        .media-catalog-btn:hover {
            background: var(--bg-button);
            color: var(--text-primary);
        }
        .media-catalog-btn.active {
            background: var(--bg-secondary);
            color: var(--cyan);
            border-bottom: 1px solid var(--bg-secondary);
        }
        .settings-tab-content {
            padding: 15px;
            max-width: 720px;
        }
        .settings-tab-content h3 {
            margin: 0 0 15px 0;
            color: var(--accent);
            font-size: 16px;
        }
        .settings-section {
            margin-bottom: 15px;
            padding: 12px;
            background: var(--bg-secondary);
            border: 1px solid var(--bg-button);
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }
        .settings-section h4 {
            margin: -12px -12px 12px -12px;
            padding: 8px 12px;
            color: var(--cyan);
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            background: var(--bg-button);
            border-radius: 3px 3px 0 0;
        }
        .settings-row {
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .settings-row label:not(.checkbox-label) {
            min-width: 100px;
            color: var(--text-secondary);
            font-size: 12px;
        }
        .settings-row select {
            flex: 1;
            max-width: 200px;
            padding: 5px 10px;
            font-size: 12px;
        }
        .settings-section select {
            padding: 5px 10px;
            font-size: 12px;
        }
        .palette-preview {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-top: 8px;
        }
        .palette-row {
            display: flex;
            gap: 4px;
            align-items: center;
        }
        .palette-row-label {
            font-size: 10px;
            color: var(--text-secondary);
            width: 42px;
            text-align: right;
            margin-right: 4px;
        }
        .palette-color {
            width: 28px;
            height: 28px;
            border: 1px solid var(--border-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            font-weight: bold;
            color: #000;
            text-shadow: -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff, 1px 1px 0 #fff;
        }
        .palette-color::after {
            content: attr(data-index);
            border-radius: 2px;
        }
        .ulaplus-palette-preview {
            margin-top: 10px;
            padding: 8px;
            background: var(--bg-tertiary);
            border-radius: 4px;
        }
        .ulaplus-palette-grid {
            display: grid;
            grid-template-columns: repeat(16, 18px);
            gap: 2px;
        }
        .ulaplus-palette-cell {
            width: 18px;
            height: 18px;
            border: 1px solid var(--border-secondary);
        }
        .frame-export-controls {
            gap: 5px;
        }
        .sprite-region-row {
            gap: 2px !important;
        }
        .sprite-input-group {
            display: inline-flex;
            align-items: center;
            gap: 2px;
            margin-right: 6px;
        }
        .sprite-input-group label {
            min-width: auto !important;
            font-size: 11px;
            color: var(--text-secondary);
        }
        .sprite-input-group input {
            font-size: 11px;
            padding: 2px 4px;
            width: 50px;
        }
        .settings-section.full-width {
            max-width: none;
        }
        .frame-grab-btn {
            padding: 4px 12px;
            font-size: 11px;
        }
        .frame-grab-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .frame-grab-status {
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 8px;
            min-height: 16px;
        }
        .frame-grab-status.recording {
            color: var(--accent);
        }

        /* Calculator (right panel) */
        .calc-wrapper {
            display: flex;
            flex-direction: column;
            gap: 5px;
            padding: 5px;
        }
        .calc-top-row {
            display: flex;
            gap: 8px;
            align-items: flex-start;
        }
        .calc-container {
            width: 306px;
            min-width: 306px;
            font-family: 'Consolas', 'Monaco', monospace;
        }
        .calc-log {
            width: 475px;
            height: 445px;
            background: var(--bg-primary);
            border: 1px solid var(--bg-button);
            border-radius: 6px;
            font-family: 'Consolas', 'Monaco', monospace;
            display: flex;
            flex-direction: column;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .calc-log-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            border-bottom: 1px solid var(--border-color);
            font-size: 11px;
            color: var(--text-secondary);
        }
        .calc-log-header button {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 14px;
            padding: 0 4px;
        }
        .calc-log-header button:hover {
            color: var(--accent);
        }
        .calc-log-content {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
            font-size: 11px;
        }
        .calc-log-entry {
            padding: 4px 6px;
            margin: 2px 0;
            border-radius: 3px;
            background: var(--bg-secondary);
            cursor: pointer;
        }
        .calc-log-entry:hover {
            background: var(--bg-button);
        }
        .calc-log-op {
            color: var(--text-secondary);
        }
        .calc-log-val {
            color: var(--cyan);
            margin-left: 4px;
        }
        .calc-log-result {
            color: var(--green);
            font-weight: bold;
        }
        .calc-display {
            background: var(--bg-primary);
            border: 1px solid var(--bg-button);
            border-radius: 6px;
            padding: 12px;
            min-height: 180px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .calc-input-row {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }
        .calc-base-select {
            background: var(--bg-button);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            padding: 1px 4px;
            font-family: inherit;
            font-size: 10px;
            height: 20px;
        }
        .calc-base-select:disabled {
            opacity: 0.4;
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            cursor: not-allowed;
            pointer-events: none;
        }
        .calc-input {
            flex: 1;
            background: var(--bg-primary);
            color: var(--cyan);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 8px;
            font-family: inherit;
            font-size: 16px;
            text-align: right;
        }
        .calc-output-row {
            display: flex;
            align-items: center;
            padding: 4px 0;
            gap: 10px;
            min-height: 20px;
        }
        .calc-label {
            font-size: 11px;
            font-weight: bold;
            width: 35px;
        }
        .calc-label.dec { color: #4CAF50; }
        .calc-label.hex { color: var(--cyan); }
        .calc-label.oct { color: var(--text-secondary); }
        .calc-label.bin { color: var(--text-secondary); }
        .calc-label.ascii { color: var(--yellow); }
        .calc-output-row.ascii-row {
            height: 20px;
            min-height: 20px;
            max-height: 20px;
        }
        .calc-signed {
            color: #e74c3c;
            font-size: 12px;
            margin-left: 10px;
            min-width: 60px;
        }
        .calc-value {
            font-size: 13px;
            color: var(--text-primary);
            word-break: break-all;
            max-width: 280px;
        }
        .calc-value.bin-value {
            font-size: 11px;
            letter-spacing: -0.5px;
        }
        .calc-buttons {
            display: flex;
            flex-direction: column;
            gap: 3px;
            background: var(--bg-primary);
            border: 1px solid var(--bg-button);
            border-radius: 6px;
            padding: 8px;
            margin-top: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .calc-row {
            display: flex;
            gap: 3px;
        }
        .calc-btn {
            flex: 1;
            padding: 8px 3px;
            font-family: inherit;
            font-size: 12px;
            border: 1px solid var(--bg-button);
            border-radius: 4px;
            cursor: pointer;
            background: var(--bg-secondary);
            color: var(--text-primary);
            transition: background 0.1s;
        }
        .calc-btn:hover {
            background: var(--bg-button);
        }
        .calc-btn:active {
            background: var(--accent);
        }
        .calc-btn.digit {
            background: var(--bg-primary);
            font-size: 14px;
            font-weight: bold;
        }
        .calc-btn.hex-digit {
            background: var(--bg-secondary);
            color: var(--text-secondary);
            font-size: 13px;
        }
        .calc-btn-disabled,
        .calc-btn-disabled:hover {
            opacity: 0.35;
            cursor: not-allowed;
            background: var(--bg-tertiary) !important;
            color: var(--text-secondary);
        }
        .calc-btn.op {
            color: var(--text-secondary);
        }
        .calc-btn.func {
            color: var(--text-secondary);
            font-size: 11px;
        }
        .calc-btn.mode {
            background: var(--bg-button);
            color: var(--text-primary);
            font-size: 12px;
            font-weight: bold;
        }
        .calc-btn.special {
            color: var(--cyan);
            font-weight: bold;
        }
        .calc-btn.clear {
            background: #c0392b;
            color: white;
            font-weight: bold;
        }
        .calc-btn.clear:hover {
            background: #e74c3c;
        }
        .calc-btn.equals {
            background: var(--bg-button);
            color: var(--text-primary);
            font-size: 16px;
            font-weight: bold;
        }
        .calc-btn.paren {
            font-size: 14px;
        }
        .calc-bits-panel {
            width: 100%;
            background: var(--bg-primary);
            border: 1px solid var(--bg-button);
            border-radius: 6px;
            padding: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .calc-bits-labels {
            display: flex;
            gap: 1px;
            margin-bottom: 2px;
            justify-content: flex-start;
        }
        .calc-bits-label {
            width: 18px;
            font-size: 8px;
            text-align: center;
            color: var(--text-secondary);
        }
        .calc-bits-label-sep {
            width: 3px;
        }
        .calc-bits-grid {
            display: flex;
            flex-wrap: nowrap;
            gap: 1px;
        }
        .calc-bit {
            width: 18px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            background: var(--bg-secondary);
            border: 1px solid var(--bg-button);
            border-radius: 2px;
            cursor: pointer;
            color: var(--text-secondary);
        }
        .calc-bit.set {
            background: var(--cyan);
            color: var(--bg-primary);
        }
        .calc-bit-separator {
            width: 3px;
        }
        .calc-bit-label {
            font-size: 9px;
            color: var(--text-secondary);
            width: 100%;
            text-align: center;
            margin-top: 2px;
        }

        /* Tests Tab */
        .tests-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 10px;
            height: 100%;
            overflow: hidden;
        }
        .tests-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }
        .tests-note {
            font-size: 11px;
            color: var(--text-secondary);
            font-style: italic;
            margin: 4px 0;
        }
        .tests-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            background: var(--bg-button);
            color: var(--text-primary);
            cursor: pointer;
            font-size: 12px;
        }
        .tests-btn:hover:not(:disabled) {
            background: var(--bg-tertiary);
        }
        .tests-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .tests-btn.primary {
            background: var(--cyan);
            color: var(--bg-primary);
        }
        .tests-btn.primary:hover:not(:disabled) {
            background: #5dade2;
        }
        .tests-btn.danger {
            background: #c0392b;
            color: white;
        }
        .tests-btn.danger:hover:not(:disabled) {
            background: #e74c3c;
        }
        .tests-checkbox-label {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 11px;
            color: var(--text-secondary);
            cursor: pointer;
            margin-left: 8px;
        }
        .tests-checkbox-label input {
            cursor: pointer;
        }
        .tests-status {
            color: var(--text-secondary);
            font-size: 11px;
            margin-left: auto;
        }
        .tests-list-container {
            flex: 1;
            overflow-y: auto;
            background: var(--bg-primary);
            border: 1px solid var(--bg-button);
            border-radius: 4px;
            min-height: 80px;
            max-height: 310px;
        }
        .tests-category-tabs {
            display: flex;
            gap: 2px;
            margin-bottom: 8px;
            flex-wrap: wrap;
        }
        .tests-category-tab {
            padding: 4px 10px;
            font-size: 11px;
            background: var(--bg-secondary);
            border: 1px solid var(--bg-button);
            border-radius: 4px;
            color: var(--text-secondary);
            cursor: pointer;
        }
        .tests-category-tab:hover {
            background: var(--bg-button);
            color: var(--text-primary);
        }
        .tests-category-tab.active {
            background: var(--accent);
            color: var(--bg-primary);
            border-color: var(--accent);
        }
        .tests-category-tab .count {
            opacity: 0.7;
            font-size: 10px;
            margin-left: 4px;
        }
        .tests-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
        }
        .tests-table th, .tests-table td {
            padding: 6px 8px;
            text-align: left;
            border-bottom: 1px solid var(--bg-button);
        }
        .tests-table th {
            background: var(--bg-secondary);
            color: var(--text-secondary);
            font-weight: normal;
            text-transform: uppercase;
            font-size: 10px;
            position: sticky;
            top: 0;
        }
        .tests-table tbody tr:hover {
            background: var(--bg-secondary);
        }
        .tests-row-disabled {
            opacity: 0.5;
        }
        .tests-row-disabled td {
            color: var(--text-muted);
        }
        .tests-col-check { width: 30px; text-align: center; }
        .tests-col-name { min-width: 150px; }
        .tests-col-machine { width: 80px; }
        .tests-col-file { min-width: 120px; color: var(--text-secondary); }
        .tests-col-result { width: 80px; text-align: center; }
        .tests-result-pass { color: #2ecc71; font-weight: bold; }
        .tests-result-fail { color: #e74c3c; font-weight: bold; }
        .tests-result-pending { color: var(--text-secondary); }
        .tests-result-running { color: var(--yellow); }
        .tests-progress {
            background: var(--bg-primary);
            border: 1px solid var(--bg-button);
            border-radius: 4px;
            padding: 10px;
        }
        .tests-progress-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            font-size: 12px;
        }
        .tests-progress-bar {
            height: 8px;
            background: var(--bg-secondary);
            border-radius: 4px;
            overflow: hidden;
        }
        .tests-progress-fill {
            height: 100%;
            background: var(--cyan);
            transition: width 0.1s;
        }
        .tests-progress-details {
            display: flex;
            justify-content: space-between;
            margin-top: 6px;
            font-size: 10px;
            color: var(--text-secondary);
        }
        .tests-preview {
            background: var(--bg-primary);
            border: 1px solid var(--accent);
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 10px;
        }
        .tests-preview-header {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
            font-size: 14px;
        }
        .tests-preview-header strong {
            color: var(--accent);
            font-size: 16px;
        }
        .tests-preview-buttons {
            display: flex;
            gap: 4px;
        }
        .tests-preview-canvas-container {
            display: flex;
            justify-content: center;
            background: #000;
            padding: 5px;
            border-radius: 4px;
        }
        .tests-preview-canvas-container canvas {
            image-rendering: pixelated;
        }
        .tests-preview-info {
            margin-top: 10px;
            color: var(--text-secondary);
            font-size: 12px;
            text-align: center;
        }
        .tests-comparison {
            background: var(--bg-primary);
            border: 1px solid var(--bg-button);
            border-radius: 4px;
            padding: 10px;
        }
        .tests-comparison-images {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        .tests-comparison-panel {
            text-align: center;
        }
        .tests-comparison-label {
            font-size: 10px;
            color: var(--text-secondary);
            margin-bottom: 4px;
            text-transform: uppercase;
        }
        .tests-comparison-panel canvas {
            border: 1px solid var(--bg-button);
            background: #000;
            image-rendering: pixelated;
        }
        .tests-comparison-result {
            text-align: center;
            margin-top: 8px;
            font-size: 12px;
            padding: 6px;
            border-radius: 4px;
            background: var(--bg-secondary);
        }
        .tests-comparison-result.pass {
            background: rgba(46, 204, 113, 0.2);
            color: #2ecc71;
        }
        .tests-comparison-result.fail {
            background: rgba(231, 76, 60, 0.2);
            color: #e74c3c;
        }
        .tests-summary {
            background: var(--bg-primary);
            border: 1px solid var(--bg-button);
            border-radius: 4px;
            padding: 10px;
        }
        .tests-summary-header {
            font-size: 12px;
            color: var(--cyan);
            margin-bottom: 8px;
            text-transform: uppercase;
        }
        .tests-summary-stats {
            display: flex;
            gap: 16px;
            margin-bottom: 10px;
        }
        .tests-stat {
            font-size: 12px;
        }
        .tests-stat.passed { color: #2ecc71; }
        .tests-stat.failed { color: #e74c3c; }
        .tests-stat.skipped { color: var(--text-secondary); }
        .tests-results-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
        }
        .tests-results-table th, .tests-results-table td {
            padding: 4px 8px;
            text-align: left;
            border-bottom: 1px solid var(--bg-button);
        }
        .tests-results-table th {
            background: var(--bg-secondary);
            color: var(--text-secondary);
            font-weight: normal;
            text-transform: uppercase;
            font-size: 10px;
        }

        /* Explorer Tab */
        .explorer-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 10px;
            height: calc(100vh - 200px);
            min-height: 500px;
            max-height: 875px; /* portrait: +25% from base ~700px */
            overflow: hidden;
        }
        @media (min-width: 1400px) {
            .explorer-container {
                max-height: 770px; /* landscape: +10% from base ~700px */
            }
        }
        .explorer-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }
        /* Prevent focus halos on controls */
        .explorer-subtab:focus,
        .explorer-btn:focus,
        .explorer-select:focus,
        .explorer-input:focus {
            outline: none;
        }
        .explorer-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            background: var(--bg-button);
            color: var(--text-primary);
            cursor: pointer;
            font-size: 12px;
        }
        .explorer-btn:hover:not(:disabled) {
            background: var(--bg-tertiary);
        }
        .explorer-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .explorer-btn.primary {
            background: var(--cyan);
            color: var(--bg-primary);
        }
        .explorer-btn.primary:hover:not(:disabled) {
            background: #5dade2;
        }
        .explorer-file-info {
            color: var(--cyan);
            font-size: 12px;
        }
        .explorer-file-size {
            color: var(--text-secondary);
            font-size: 11px;
        }
        .explorer-subtabs {
            display: flex;
            gap: 0;
            border-bottom: 1px solid var(--border);
        }
        .explorer-subtab {
            padding: 8px 16px;
            background: transparent;
            border: none;
            border-bottom: 2px solid transparent;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 12px;
        }
        .explorer-subtab:hover {
            color: var(--text-primary);
            background: var(--bg-tertiary);
        }
        .explorer-subtab.active {
            color: var(--cyan);
            border-bottom-color: var(--cyan);
        }
        .explorer-content {
            flex: 1;
            overflow: auto;
            display: flex;
            flex-direction: column;
        }
        .explorer-subtab-content {
            flex: 1;
            overflow: auto;
        }
        .explorer-subtab-content.active {
            display: flex;
            flex-direction: column;
        }
        .explorer-output {
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
            white-space: pre-wrap;
            color: var(--text-primary);
            flex: 1;
            overflow: auto;
            background: var(--bg-primary);
            border: 1px solid var(--bg-button);
            border-radius: 4px;
            padding: 6px 10px;
            max-height: 750px; /* portrait */
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
            cursor: text;
        }
        #explorerInfoOutput {
            white-space: normal;
            width: 50%;
            min-width: 300px;
        }
        .explorer-info-row {
            display: flex;
            gap: 15px;
            flex: 1;
            overflow: hidden;
        }
        .explorer-preview {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            background: var(--bg-primary);
            border: 1px solid var(--bg-button);
            border-radius: 4px;
        }
        .explorer-preview canvas {
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        .explorer-preview-label {
            margin-top: 6px;
            font-size: 10px;
            color: var(--text-secondary);
            text-transform: uppercase;
        }
        @media (min-width: 1400px) {
            .explorer-output {
                max-height: 650px; /* landscape */
            }
        }
        .explorer-empty {
            color: var(--text-secondary);
            font-style: italic;
            padding: 20px;
            text-align: center;
        }
        .explorer-label {
            font-size: 11px;
            color: var(--text-secondary);
            background: transparent;
            border: none;
            outline: none;
        }
        .explorer-select {
            font-size: 11px;
            padding: 4px 8px;
            min-width: 150px;
            background: var(--bg-secondary);
            border: 1px solid var(--bg-button);
            border-radius: 4px;
            color: var(--text-primary);
        }
        .explorer-input {
            font-size: 11px;
            padding: 4px 8px;
            background: var(--bg-secondary);
            border: 1px solid var(--bg-button);
            border-radius: 4px;
            color: var(--text-primary);
            font-family: 'Consolas', 'Monaco', monospace;
        }
        .explorer-input.addr {
            width: 50px;
            text-transform: uppercase;
        }
        .explorer-input.len {
            width: 70px;
        }
        .explorer-info-section {
            margin-bottom: 10px;
        }
        .explorer-info-section:first-child {
            margin-top: 0;
        }
        .explorer-info-header {
            color: var(--cyan);
            font-size: 11px;
            text-transform: uppercase;
            margin-bottom: 2px;
            letter-spacing: 0.5px;
        }
        .explorer-info-table {
            width: auto;
            max-width: 400px;
            border-collapse: collapse;
            font-size: 11px;
            font-family: 'Consolas', 'Monaco', monospace;
        }
        .explorer-info-table th,
        .explorer-info-table td {
            padding: 3px 8px;
            text-align: left;
            border-bottom: 1px solid var(--bg-button);
        }
        .explorer-info-table th {
            color: var(--text-secondary);
            font-weight: normal;
            width: 120px;
        }
        .explorer-info-table td {
            color: var(--text-primary);
        }
        .explorer-block-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .explorer-block {
            border-left: 3px solid var(--cyan);
            padding: 6px 10px;
            background: var(--bg-secondary);
            font-size: 11px;
            font-family: 'Consolas', 'Monaco', monospace;
            cursor: pointer;
            outline: none;
        }
        .explorer-block:hover {
            opacity: 0.85;
        }
        .explorer-block.basic-block {
            border-left-color: #2ecc71;
        }
        .explorer-block.code-block {
            border-left-color: var(--cyan);
        }
        .explorer-block.array-block {
            border-left-color: #9b59b6;
        }
        .explorer-block.data-block {
            border-left-color: #7f8c8d;
            background: var(--bg-tertiary);
        }
        .explorer-block-header {
            color: var(--yellow);
            font-weight: bold;
        }
        .explorer-block-meta {
            color: var(--text-secondary);
        }
        .explorer-block-meta .checksum-ok {
            color: #2ecc71;
        }
        .explorer-block-meta .checksum-bad {
            color: #e74c3c;
        }
        .explorer-block-details {
            color: var(--text-primary);
            line-height: 1.4;
        }
        .explorer-block-details .label {
            color: var(--text-secondary);
        }
        .explorer-block-details .value {
            color: var(--cyan);
        }
        .explorer-block-details .filename {
            color: #2ecc71;
        }
        /* TRD/SCL file list - compact table-like layout */
        .explorer-file-list {
            display: table;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
            width: 100%;
            max-width: 500px;
        }
        .explorer-file-entry {
            display: table-row;
            cursor: pointer;
        }
        .explorer-file-entry:hover {
            background: var(--bg-tertiary);
        }
        .explorer-file-entry > span {
            display: table-cell;
            padding: 3px 8px;
            border-bottom: 1px solid var(--bg-tertiary);
        }
        .explorer-file-num {
            color: var(--text-secondary);
            text-align: right;
            width: 30px;
        }
        .explorer-file-type {
            color: var(--yellow);
            width: 20px;
        }
        .explorer-file-name {
            color: #2ecc71;
        }
        .explorer-file-size {
            color: var(--text-secondary);
            text-align: right;
        }
        .explorer-file-addr {
            color: var(--cyan);
            text-align: right;
        }
        .explorer-file-preview {
            color: var(--magenta);
            width: 20px;
            text-align: center;
        }
        .explorer-basic-line {
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
            -webkit-user-select: text;
            -moz-user-select: text;
            user-select: text;
            cursor: text;
        }
        .explorer-basic-linenum {
            color: var(--yellow);
            display: inline-block;
            width: 50px;
        }
        .explorer-basic-keyword {
            color: var(--cyan);
        }
        .explorer-basic-string {
            color: #2ecc71;
        }
        .explorer-basic-number {
            color: #e67e22;
        }
        .explorer-basic-comment {
            color: var(--text-secondary);
        }
        #explorerDisasmOutput {
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 11px;
            white-space: pre;
        }
        .da { color: var(--yellow); }
        .db { color: var(--text-secondary); }
        .dm { color: var(--cyan); }
        .dl { color: #2ecc71; }
        #explorerHexOutput {
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 11px;
            white-space: pre;
        }
        .ha { color: var(--yellow); }
        .hb { color: var(--text-primary); }
        .hc { color: var(--cyan); }

        /* Debugger Panel */
        .debugger-container {
            margin-top: 0;
        }
        .debugger-panel {
            display: block;
            background: var(--bg-primary);
            border: 1px solid var(--bg-button);
            border-radius: 4px;
            padding: 10px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 11px;
        }
        .debugger-section {
            margin-bottom: 8px;
        }
        .debugger-section h4 {
            color: var(--cyan);
            margin: 0 0 4px 0;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .registers-row {
            display: flex;
            gap: 4px;
            flex-wrap: nowrap;
            margin-bottom: 4px;
            justify-content: flex-start;
        }
        .stack-pages-row {
            display: flex;
            gap: 4px;
        }
        .registers-grid.vertical {
            flex-direction: column;
        }
        .reg-group {
            background: var(--bg-secondary);
            padding: 4px 5px;
            border-radius: 3px;
            flex-shrink: 0;
        }
        .reg-group h4 {
            color: var(--cyan);
            margin: 0 0 3px 0;
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .registers-grid {
            display: flex;
            flex-wrap: nowrap;
            gap: 3px;
        }
        .registers-grid + .registers-grid {
            margin-top: 6px;
        }
        .register-item {
            background: var(--bg-primary);
            padding: 1px 4px;
            border-radius: 2px;
            font-size: 11px;
            white-space: nowrap;
        }
        .register-name {
            color: var(--text-secondary);
        }
        .register-value {
            color: var(--accent);
            font-weight: bold;
            margin-left: 2px;
            display: inline-block;
        }
        .register-value.editable {
            cursor: pointer;
            border-bottom: 1px dashed var(--text-secondary);
        }
        .register-value.editable:hover {
            color: var(--yellow);
            border-bottom-color: var(--yellow);
        }
        .register-value.editing {
            color: var(--yellow);
            border-bottom-color: var(--yellow);
        }
        .reg-swap-btn {
            height: 21px;
            padding: 0 6px;
            margin-left: 2px;
            font-size: 11px;
            background: var(--bg-button);
            color: var(--text-primary);
            border: none;
            border-radius: 3px;
            cursor: pointer;
            align-self: flex-end;
        }
        .reg-swap-btn:first-of-type {
            margin-left: 5px;
        }
        .reg-swap-btn:hover {
            background: var(--bg-button-hover);
        }
        .flags-row {
            display: flex;
            align-items: flex-start;
            gap: 4px;
            margin-top: 6px;
        }
        .flags-block {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        .flags-label {
            font-size: 9px;
            color: var(--cyan);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 0;
        }
        .flags-display {
            display: flex;
            gap: 2px;
            flex-wrap: wrap;
        }
        .flag-item {
            background: var(--bg-primary);
            padding: 1px 4px;
            border-radius: 2px;
            color: var(--text-secondary);
            font-size: 10px;
            cursor: pointer;
            user-select: none;
        }
        .flag-item:hover {
            background: var(--bg-tertiary);
            border: 1px solid var(--accent);
            padding: 0 3px;
        }
        .flag-item.set {
            background: #4a6a4a;
            color: #8f8;
        }
        .flag-item.set:hover {
            background: #5a7a5a;
        }
        .flag-item:not(.editable) {
            cursor: default;
            opacity: 0.7;
        }
        .flag-item:not(.editable):hover {
            border: none;
            padding: 1px 4px;
            background: inherit;
        }
        .stack-view {
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 11px;
            background: var(--bg-secondary);
            border-radius: 3px;
            padding: 2px;
        }
        .stack-entry {
            display: flex;
            padding: 1px 1px;
            border-radius: 2px;
            cursor: context-menu;
        }
        .stack-entry:hover {
            background: var(--bg-button);
        }
        .stack-entry.current {
            background: #3a4a3a;
            color: #8f8;
        }
        .stack-entry.changed {
            color: var(--accent);
        }
        .calls-group {
            width: 147px;
            flex: 0 0 147px;
            overflow: hidden;
        }
        .calls-group .stack-view {
            overflow: hidden;
        }
        .calls-group .stack-entry {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .call-label {
            color: var(--text-secondary);
            font-size: 10px;
            margin-left: 3px;
        }
        .stack-addr {
            color: var(--text-secondary);
            margin-right: 1px;
        }
        .stack-value {
            color: var(--text-primary);
        }
        .stack-pointer {
            color: #8f8;
            margin-left: 2px;
        }
        .stack-context-menu {
            position: fixed;
            background: var(--bg-secondary);
            border: 1px solid var(--bg-button);
            border-radius: 4px;
            padding: 4px 0;
            z-index: 1000;
            box-shadow: 2px 2px 8px rgba(0,0,0,0.5);
        }
        .stack-context-menu div {
            padding: 4px 12px;
            cursor: pointer;
        }
        .stack-context-menu div:hover {
            background: var(--bg-button);
        }
        .label-context-menu {
            position: fixed;
            background: var(--bg-secondary);
            border: 1px solid var(--bg-button);
            border-radius: 4px;
            padding: 4px 0;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        .label-context-menu div {
            padding: 4px 12px;
            cursor: pointer;
            font-size: 12px;
        }
        .label-context-menu div:hover {
            background: var(--bg-button);
        }
        .label-context-menu div.danger {
            color: var(--accent);
        }
        .label-context-menu div.selected {
            color: var(--accent);
        }
        .label-context-menu div.selected::before {
            content: '✓ ';
        }
        .label-context-menu .menu-separator {
            height: 1px;
            background: var(--bg-button);
            margin: 4px 0;
            padding: 0;
        }
        .label-context-menu .menu-separator:hover {
            background: var(--bg-button);
        }
        .label-context-menu .menu-header {
            color: var(--cyan);
            font-weight: bold;
            cursor: default;
        }
        .label-context-menu .menu-header:hover {
            background: transparent;
        }
        .label-context-menu .menu-submenu {
            position: relative;
        }
        .label-context-menu .menu-submenu-items {
            display: none;
            position: absolute;
            left: 100%;
            top: 0;
            background: var(--bg-secondary);
            border: 1px solid var(--bg-button);
            border-radius: 4px;
            padding: 4px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            white-space: nowrap;
        }
        .label-context-menu .menu-submenu:hover .menu-submenu-items {
            display: block;
        }
        .label-context-menu .menu-submenu.submenu-left .menu-submenu-items {
            left: auto;
            right: 100%;
        }
        .label-context-menu .menu-submenu.submenu-up .menu-submenu-items {
            top: auto;
            bottom: 0;
        }
        .label-context-menu .menu-submenu-items div {
            padding: 4px 12px;
        }
        .region-type-code { color: #8f8; }
        .region-type-db { color: #88f; }
        .region-type-dw { color: #8cf; }
        .region-type-text { color: #ff8; }
        .region-type-graphics { color: #f8f; }
        .region-type-smc { color: #f88; }
        .label-dialog {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1001;
        }
        .label-dialog.hidden {
            display: none;
        }
        .label-dialog-content {
            background: var(--bg-secondary);
            border: 1px solid var(--bg-button);
            border-radius: 6px;
            padding: 15px;
            min-width: 280px;
        }
        .label-dialog h4 {
            margin: 0 0 12px 0;
            color: var(--cyan);
        }
        .label-dialog-row {
            margin-bottom: 10px;
        }
        .label-dialog-row label {
            display: block;
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 3px;
        }
        .label-dialog-row input {
            width: 100%;
            padding: 6px 8px;
            background: var(--bg-primary);
            border: 1px solid var(--bg-button);
            border-radius: 3px;
            color: var(--text-primary);
            font-size: 12px;
            box-sizing: border-box;
        }
        .label-dialog-row input:focus {
            outline: none;
            border-color: var(--cyan);
        }
        .label-dialog-row textarea {
            width: 100%;
            padding: 5px 8px;
            background: var(--bg-primary);
            border: 1px solid var(--bg-button);
            border-radius: 3px;
            color: var(--text-primary);
            font-size: 12px;
            font-family: var(--font-mono);
            box-sizing: border-box;
            resize: vertical;
        }
        .label-dialog-row textarea:focus {
            outline: none;
            border-color: var(--cyan);
        }
        .label-dialog-buttons button.danger {
            background: #633;
        }
        .label-dialog-buttons button.danger:hover {
            background: #844;
        }
        .label-dialog-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            margin-top: 15px;
        }
        .label-dialog-buttons button {
            padding: 6px 14px;
            font-size: 12px;
        }
        .export-options {
            display: flex;
            flex-direction: column;
            gap: 5px;
            align-items: flex-start;
        }
        .export-options label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 12px;
            cursor: pointer;
            white-space: nowrap;
        }
        .disassembly-view {
            background: var(--bg-primary);
            border: none;
            border-radius: 3px;
            padding: 5px;
            flex: 1;
            overflow: hidden;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 11px;
        }
        .main-debug-row {
            display: flex;
            gap: 8px;
            margin-top: 0;
            align-items: stretch;
        }
        .right-column {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-width: 0;
        }
        .disasm-panel {
            flex: 0 0 480px;
            width: 480px;
            height: 740px;
            background: var(--bg-secondary);
            border: 1px solid var(--bg-button);
            border-radius: 3px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            margin-bottom: 0;
        }
        .memory-panel {
            width: 100%;
            min-width: 0;
            margin-top: 0;
            display: flex;
            flex-direction: column;
        }
        .tools-row .search-label {
            color: var(--text-secondary);
            font-size: 11px;
        }
        .disasm-line {
            display: flex;
            padding: 1px 3px;
            border-radius: 2px;
        }
        .disasm-line.flow-break {
            margin-bottom: 6px;
        }
        .disasm-line.data-line .disasm-mnemonic {
            color: #8cf;
            font-style: italic;
        }
        .disasm-line:hover {
            background: var(--bg-button);
        }
        .disasm-line.current {
            background: #4a3a2a;
            border-left: 3px solid var(--accent);
            margin-left: -3px;
        }
        .disasm-line.trace {
            background: #3a2a4a;
            border-left: 3px solid #c060c0;
            margin-left: -3px;
        }
        .disasm-line.current.trace {
            background: #4a3a4a;
            border-left: 3px solid #c060c0;
        }
        .disasm-line.target {
            background: #2a3a4a;
            border-right: 3px solid var(--cyan);
        }
        .disasm-line.current.target {
            background: #3a3a3a;
        }
        .disasm-addr {
            color: var(--text-secondary);
            width: 100px;
            flex-shrink: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            cursor: pointer;
        }
        .disasm-addr:hover {
            color: var(--cyan);
            text-decoration: underline;
        }
        .disasm-addr .label-name {
            color: var(--cyan);
            font-weight: bold;
        }
        .disasm-line.has-long-label {
            flex-wrap: wrap;
        }
        .disasm-line.has-long-label .disasm-label-row {
            width: 100%;
            padding-left: 16px;
            margin-bottom: 1px;
            color: var(--cyan);
        }
        .disasm-line.has-long-label .disasm-label-row .label-name {
            color: var(--cyan);
            font-weight: bold;
        }
        .disasm-label-operand {
            color: var(--cyan);
        }
        .disasm-operand-addr {
            cursor: pointer;
            color: #00aa00; /* Green for address operands */
        }
        .disasm-operand-addr:hover {
            text-decoration: underline;
        }
        .disasm-label-operand.disasm-operand-addr {
            color: var(--cyan); /* Cyan for labels */
        }
        body.light-theme .disasm-operand-addr {
            color: #008800;
        }
        body.light-theme .disasm-label-operand.disasm-operand-addr {
            color: #0066aa;
        }
        .xref-tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.95);
            color: #fff;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 11px;
            font-family: monospace;
            max-width: 300px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 10000;
            pointer-events: none;
            display: none;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
            border: 1px solid #444;
        }
        .xref-tooltip-header {
            font-weight: bold;
            margin-bottom: 4px;
            border-bottom: 1px solid #444;
            padding-bottom: 4px;
            color: #fff;
        }
        .xref-tooltip-item {
            padding: 2px 0;
            white-space: nowrap;
        }
        .xref-type-call { color: #ff8080; }
        .xref-type-jp { color: #80ff80; }
        .xref-type-jr { color: #80ffff; }
        .xref-type-djnz { color: #80ffff; }
        .xref-type-rst { color: #ff80ff; }
        .xref-type-ld { color: #ffff80; }
        .disasm-bytes {
            color: var(--text-secondary);
            width: 80px;
            flex-shrink: 0;
            opacity: 0.6;
        }
        .disasm-mnemonic {
            color: var(--cyan);
            flex-grow: 1;
        }
        .disasm-mnemonic .op {
            color: var(--accent);
        }
        /* Operand syntax colors */
        .disasm-reg {
            color: #daa520; /* Gold - registers */
        }
        .disasm-num {
            color: #00aa00; /* Green - hex/decimal numbers */
        }
        .disasm-char {
            color: #cc66cc; /* Purple - character literals */
        }
        .disasm-bin {
            color: #6699cc; /* Blue - binary numbers */
        }
        .disasm-ptr {
            color: #888888; /* Gray - parentheses for indirect */
        }
        .disasm-tstates {
            color: var(--text-secondary);
            font-size: 10px;
            width: 40px;
            flex-shrink: 0;
            text-align: right;
            margin-right: 8px;
        }
        .debugger-controls {
            display: flex;
            gap: 5px;
            margin-top: 10px;
            margin-bottom: -3px;
        }
        .debugger-controls button {
            padding: 4px 8px;
            font-size: 11px;
        }
        .debugger-controls button kbd {
            background: var(--bg-secondary);
            padding: 1px 4px;
            border-radius: 2px;
            margin-left: 4px;
            font-size: 10px;
        }
        .tstates-input {
            width: 55px;
            padding: 4px 6px;
            font-size: 11px;
            font-family: monospace;
            background: var(--bg-secondary);
            border: 1px solid var(--bg-button);
            border-radius: 3px;
            color: var(--text-primary);
        }
        .disasm-line.breakpoint {
            background: #4a2a2a;
        }
        .disasm-line.breakpoint.current {
            background: #5a3a2a;
        }
        .disasm-bp {
            width: 16px;
            flex-shrink: 0;
            text-align: center;
            cursor: pointer;
            user-select: none;
        }
        .disasm-bp::before {
            content: '○';
            color: var(--text-secondary);
        }
        .disasm-bp:hover::before {
            color: var(--accent);
        }
        .disasm-bp.active::before {
            content: '●';
            color: var(--accent);
        }
        /* Comment styling */
        .disasm-comment {
            color: #7a7;
            font-style: italic;
        }
        .disasm-comment-line {
            display: block;
            padding-left: 80px;
            color: #7a7;
            font-style: italic;
            white-space: pre-wrap;
        }
        .disasm-separator {
            display: block;
            padding-left: 80px;
            color: #666;
        }
        .disasm-sub-separator {
            display: block;
            padding-left: 20px;
            color: var(--cyan);
            font-family: monospace;
        }
        .disasm-sub-name {
            display: block;
            padding-left: 20px;
            color: var(--yellow);
            font-weight: bold;
        }
        .disasm-sub-comment {
            display: block;
            padding-left: 20px;
            color: #7a7;
            font-style: italic;
        }
        .disasm-sub-end {
            display: block;
            padding-left: 20px;
            color: var(--cyan);
            font-family: monospace;
        }
        /* Code folding styles */
        .disasm-fold-toggle {
            display: inline-block;
            width: 14px;
            cursor: pointer;
            color: var(--cyan);
            font-family: monospace;
            user-select: none;
            margin-right: 2px;
        }
        .disasm-fold-toggle:hover {
            color: var(--accent);
        }
        .disasm-fold-summary {
            display: block;
            padding: 2px 20px;
            background: var(--bg-button);
            border-left: 3px solid var(--cyan);
            color: var(--text-secondary);
            cursor: pointer;
            font-family: monospace;
        }
        .disasm-fold-summary:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }
        .disasm-fold-summary .fold-name {
            color: var(--yellow);
            font-weight: bold;
        }
        .disasm-fold-summary .fold-stats {
            color: var(--text-secondary);
            margin-left: 8px;
        }
        .disasm-user-fold-start {
            display: block;
            padding-left: 20px;
            color: var(--magenta);
            font-family: monospace;
        }
        .disasm-user-fold-end {
            display: block;
            padding-left: 20px;
            color: var(--magenta);
            font-family: monospace;
        }
        .disasm-inline-comment {
            color: #7a7;
            font-style: italic;
            margin-left: 8px;
        }
        .bp-add-form {
            display: flex;
            gap: 3px;
        }
        .bp-add-form input {
            width: 55px;
            padding: 2px 5px;
            background: var(--bg-primary);
            border: 1px solid var(--bg-button);
            border-radius: 3px;
            color: var(--text-primary);
            font-family: monospace;
            font-size: 11px;
        }
        #triggerCondInput {
            width: 80px;
        }
        .bp-add-form select {
            padding: 2px 3px;
            font-size: 10px;
        }
        .bp-add-form button {
            padding: 2px 6px;
            font-size: 10px;
        }
        .breakpoint-list {
            max-height: 80px;
            overflow-y: auto;
        }
        .breakpoint-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 2px 5px;
            background: var(--bg-primary);
            border-radius: 2px;
            margin-bottom: 2px;
            font-size: 11px;
        }
        .breakpoint-item:hover {
            background: var(--bg-button);
        }
        .bp-addr {
            color: var(--accent);
            font-family: monospace;
            cursor: pointer;
        }
        .bp-addr:hover {
            text-decoration: underline;
        }
        .bp-remove {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 2px 4px;
            font-size: 12px;
        }
        .bp-remove:hover {
            color: var(--accent);
        }
        /* Unified Trigger Styles */
        .trigger-item {
            display: flex;
            align-items: center;
            padding: 2px 5px;
            background: var(--bg-primary);
            border-radius: 2px;
            margin-bottom: 2px;
            font-size: 11px;
            gap: 4px;
        }
        .trigger-item:hover {
            background: var(--bg-button);
        }
        .trigger-item.disabled {
            opacity: 0.5;
        }
        .trigger-icon {
            color: var(--text-secondary);
            font-size: 10px;
            min-width: 16px;
            text-align: center;
        }
        .trigger-icon.exec { color: var(--accent); }
        .trigger-icon.read { color: var(--cyan); }
        .trigger-icon.write { color: var(--warning); }
        .trigger-icon.rw { color: #ff80ff; }
        .trigger-icon.port { color: var(--purple); }
        .trigger-icon.port-filter { color: var(--cyan); }
        .trigger-desc {
            flex: 1;
            color: var(--accent);
            font-family: monospace;
            cursor: pointer;
        }
        .trigger-desc:hover {
            text-decoration: underline;
        }
        .trigger-skip {
            color: var(--yellow);
            font-size: 10px;
            margin-left: 3px;
        }
        .trigger-toggle {
            color: var(--text-secondary);
            cursor: pointer;
            padding: 0 3px;
            font-size: 10px;
        }
        .trigger-toggle:hover {
            color: var(--accent);
        }
        .trigger-remove {
            color: var(--text-secondary);
            cursor: pointer;
            padding: 0 3px;
            font-size: 12px;
        }
        .trigger-remove:hover {
            color: var(--accent);
        }
        .wp-type {
            color: var(--text-secondary);
            font-size: 10px;
            margin-left: 5px;
        }
        .no-breakpoints {
            color: var(--text-secondary);
            font-size: 10px;
            text-align: center;
            padding: 5px;
        }
        .label-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 2px 5px;
            background: var(--bg-primary);
            border-radius: 2px;
            margin-bottom: 2px;
            font-size: 11px;
            cursor: pointer;
        }
        .label-item:hover {
            background: var(--bg-button);
        }
        .label-info {
            display: flex;
            gap: 6px;
            overflow: hidden;
            flex: 1;
        }
        .label-addr {
            color: var(--accent);
            font-family: monospace;
            flex-shrink: 0;
        }
        .label-name {
            color: #8bd;
            font-family: monospace;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .label-comment {
            color: var(--text-secondary);
            font-size: 10px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .label-actions {
            display: flex;
            gap: 2px;
            flex-shrink: 0;
        }
        .label-btn {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 2px 4px;
            font-size: 11px;
        }
        .label-btn:hover {
            color: var(--accent);
        }
        .labels-list {
            max-height: 100px;
            overflow-y: auto;
        }
        .rom-labels-toggle {
            display: flex;
            align-items: center;
            gap: 0;
            font-size: 11px;
            cursor: pointer;
        }
        .rom-labels-toggle input {
            margin: 0 2px 0 0;
            width: 13px;
        }
        .label-item.rom-label {
            opacity: 0.7;
            font-style: italic;
        }
        .label-item.rom-label .label-item-name::before {
            content: "ROM: ";
            color: var(--text-secondary);
            font-style: normal;
        }

        /* Memory Hex View */
        .memory-section {
            background: var(--bg-secondary);
            border: 1px solid var(--bg-button);
            border-radius: 3px;
            padding: 10px;
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        .memory-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .memory-header h4 {
            margin: 0;
            color: var(--cyan);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .panel-type-select {
            padding: 3px 6px;
            background: var(--bg-button);
            border: 1px solid var(--bg-button);
            border-radius: 3px;
            color: var(--cyan);
            font-size: 11px;
            font-weight: bold;
            cursor: pointer;
            margin-right: 8px;
        }
        .panel-type-select option {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }
        .panel-type-select:hover {
            background: var(--bg-hover);
        }
        .memory-controls {
            display: flex;
            gap: 2px;
            align-items: center;
        }
        .memory-controls input {
            width: 60px;
            padding: 4px 8px;
            background: var(--bg-primary);
            border: 1px solid var(--bg-button);
            border-radius: 3px;
            color: var(--text-primary);
            font-family: monospace;
            font-size: 12px;
        }
        .memory-controls button {
            padding: 4px 10px;
            font-size: 11px;
        }
        .memory-option {
            margin-left: 5px;
            font-size: 11px;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 0;
            white-space: nowrap;
        }
        .memory-option input {
            margin: 0 2px 0 0;
            width: 13px;
        }
        .disasm-option {
            margin-left: 0;
            font-size: 10px;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 0;
            white-space: nowrap;
        }
        .disasm-option input[type="checkbox"] {
            margin: 0 2px 0 0;
            padding: 0;
            width: 12px;
            height: 12px;
        }
        .disasm-select {
            padding: 2px 4px;
            font-size: 10px;
            background: var(--bg-primary);
            color: var(--text-primary);
            border: 1px solid var(--bg-button);
            border-radius: 3px;
            margin-left: 3px;
        }
        .memory-view {
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 11px;
            flex: 1;
            overflow: hidden;
            background: var(--bg-primary);
            border-radius: 2px;
            padding: 5px;
            min-height: 0;
        }
        .memory-line {
            display: flex;
            padding: 1px 0;
            white-space: nowrap;
            line-height: 18px;
        }
        .memory-addr {
            color: var(--text-secondary);
            width: 36px;
            flex-shrink: 0;
            cursor: pointer;
        }
        .memory-addr:hover {
            text-decoration: underline;
        }
        .memory-hex {
            display: flex;
            gap: 0;
            margin-right: 8px;
        }
        #leftMemoryView .memory-hex {
            margin-right: 14px;
        }
        .memory-byte {
            color: var(--text-primary);
            width: 18px;
            height: 16px;
            line-height: 16px;
            text-align: center;
            cursor: pointer;
            border-radius: 2px;
            display: inline-block;
        }
        .memory-byte:hover {
            background: var(--bg-button);
        }
        .memory-byte.modified {
            color: var(--accent);
        }
        .memory-byte.changed {
            background: #4a2a2a;
            color: #f88;
        }
        .memory-byte.has-bp {
            outline: 1px solid #f44;
        }
        .memory-byte.has-wp {
            outline: 1px solid #4af;
        }
        .memory-byte.has-wp-r {
            outline: 1px solid #4f4;
        }
        .memory-byte.has-wp-w {
            outline: 1px solid #fa4;
        }
        .memory-byte.region-db {
            color: #88f;
        }
        .memory-byte.region-dw {
            color: #8cf;
        }
        .memory-byte.region-text {
            color: #ff8;
        }
        .memory-byte.region-graphics {
            color: #f8f;
        }
        .memory-byte.region-smc {
            color: #f88;
        }
        .memory-byte.selected {
            background: #446;
            outline: 1px solid #88f;
        }
        .memory-ascii .changed {
            color: #f88;
        }
        .memory-ascii {
            color: var(--text-secondary);
            letter-spacing: 0;
        }
        .memory-ascii .printable {
            color: var(--cyan);
        }
        .memory-ascii .region-text {
            color: #ff8;
            font-weight: bold;
        }
        .memory-edit-input {
            width: 22px;
            height: 18px;
            padding: 0;
            margin: 0;
            text-align: center;
            font-family: inherit;
            font-size: inherit;
            background: var(--bg-secondary);
            border: 1px solid var(--cyan);
            border-radius: 2px;
            color: var(--text-primary);
            outline: none;
            box-sizing: border-box;
        }
        .memory-search {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid var(--bg-button);
        }
        .memory-search.inline {
            margin-top: 4px;
            padding-top: 4px;
            margin-bottom: -10px;
            border-top: none;
        }
        .memory-search.inline input[type="text"] {
            flex: 0 1 auto;
            width: 140px;
        }
        .memory-search.inline .search-options {
            gap: 6px;
            margin: 0;
        }
        .search-row {
            display: flex;
            gap: 5px;
            align-items: center;
        }
        .search-row input {
            flex: 1;
            padding: 4px 8px;
            background: var(--bg-primary);
            border: 1px solid var(--bg-button);
            border-radius: 3px;
            color: var(--text-primary);
            font-family: monospace;
            font-size: 12px;
        }
        .search-row select {
            padding: 4px;
            background: var(--bg-primary);
            border: 1px solid var(--bg-button);
            border-radius: 3px;
            color: var(--text-primary);
            font-size: 11px;
        }
        .search-row button {
            padding: 4px 10px;
            font-size: 11px;
        }
        .search-options {
            display: flex;
            gap: 15px;
            margin: 5px 0;
        }
        .search-option {
            font-size: 10px;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 3px;
        }
        .search-results {
            max-height: 80px;
            overflow-y: auto;
            margin-top: 5px;
            font-family: monospace;
            font-size: 11px;
        }
        .search-result {
            padding: 2px 5px;
            cursor: pointer;
            border-radius: 2px;
        }
        .search-result:hover {
            background: var(--bg-button);
        }
        .search-result .addr {
            color: var(--accent);
        }
        .search-result .preview {
            color: var(--text-secondary);
            margin-left: 10px;
        }
        .search-info {
            color: var(--text-secondary);
            font-style: italic;
        }
        /* Panel tabs (Breakpoints/Labels/Tools) */
        .panel-tabs {
            margin-top: 10px;
            min-width: 0;
            overflow: hidden;
        }
        .panel-tab-bar {
            display: flex;
            gap: 2px;
            border-bottom: 1px solid var(--bg-button);
            margin-bottom: 0;
        }
        .panel-tab-btn {
            padding: 4px 12px;
            background: var(--bg-secondary);
            border: 1px solid var(--bg-button);
            border-bottom: none;
            border-radius: 3px 3px 0 0;
            color: var(--text-secondary);
            font-size: 11px;
            cursor: pointer;
            margin-bottom: -1px;
        }
        .panel-tab-btn:hover {
            background: var(--bg-button);
            color: var(--text-primary);
        }
        .panel-tab-btn.active {
            background: var(--bg-secondary);
            color: var(--cyan);
            border-bottom: 1px solid var(--bg-secondary);
        }
        .panel-tab-content {
            display: none;
            background: var(--bg-secondary);
            border: 1px solid var(--bg-button);
            border-top: none;
            border-radius: 0 0 3px 3px;
            padding: 8px;
            overflow: hidden;
        }
        .panel-tab-content.active {
            display: block;
        }
        .panel-tab-content .panel-row {
            display: flex;
            gap: 10px;
        }
        .panel-tab-content .panel-column {
            flex: 1;
        }
        .tools-row {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            align-items: center;
            margin-bottom: 5px;
        }
        .tools-row:last-child {
            margin-bottom: 0;
        }
        .tools-row button {
            padding: 2px 6px;
            font-size: 11px;
        }
        .tools-row select {
            font-size: 11px;
            padding: 2px 4px;
        }
        .tools-group {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: 3px;
            padding: 5px 8px;
            margin-bottom: 6px;
        }
        .tools-group:last-child {
            margin-bottom: 0;
        }
        .tools-group-label {
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--cyan);
            margin-bottom: 3px;
        }
        .tools-panel-row {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }
        .tools-panel-row > .tools-group {
            flex: 0 1 auto;
            margin-bottom: 0;
        }
        .poke-status {
            color: var(--text-secondary);
            font-size: 11px;
            margin-left: 5px;
        }
        .poke-results {
            max-height: 60px;
            overflow-y: auto;
            margin-top: 5px;
            font-family: monospace;
            font-size: 11px;
        }
        .poke-result {
            display: inline-block;
            padding: 2px 6px;
            margin: 1px;
            background: var(--bg-primary);
            border-radius: 2px;
            cursor: pointer;
        }
        .poke-result:hover {
            background: var(--bg-button);
        }
        .poke-result .addr {
            color: var(--accent);
        }
        .poke-result .val {
            color: var(--text-secondary);
            margin-left: 3px;
        }
        .text-scan-results {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 5px;
            font-family: monospace;
            font-size: 11px;
        }
        .text-scan-result {
            display: flex;
            padding: 2px 6px;
            margin: 1px 0;
            background: var(--bg-primary);
            border-radius: 2px;
            cursor: pointer;
            gap: 8px;
        }
        .text-scan-result:hover {
            background: var(--bg-button);
        }
        .text-scan-result .addr {
            color: var(--accent);
            min-width: 45px;
        }
        .text-scan-result .len {
            color: var(--text-secondary);
            min-width: 25px;
        }
        .text-scan-result .text {
            color: var(--cyan);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .text-scan-result .text .dict-match {
            color: var(--green);
            font-weight: bold;
        }
        .text-scan-result .bank {
            color: var(--magenta);
            font-size: 9px;
            margin-left: 2px;
        }
        .automap-stats {
            color: var(--text-secondary);
            font-size: 11px;
            margin-left: 5px;
        }
        .automap-stats.active {
            color: var(--accent);
        }

        /* Trace Panel */
        .trace-controls {
            padding: 4px;
        }
        .trace-row {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 6px;
            margin-bottom: 4px;
        }
        .trace-row .search-label {
            min-width: auto;
        }
        .trace-row button {
            padding: 2px 6px;
            font-size: 11px;
        }
        .trace-row select {
            font-size: 11px;
            padding: 2px 4px;
        }
        /* Trace List */
        #panel-trace .trace-list {
            display: block;
            max-height: calc(100% - 100px);
            min-height: 80px;
        }
        .trace-list {
            max-height: 120px;
            overflow-y: auto;
            margin-top: 5px;
            font-family: monospace;
            font-size: 11px;
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            display: none;
        }
        .trace-list.visible {
            display: block;
        }
        .trace-entry {
            padding: 1px 4px;
            cursor: pointer;
            white-space: nowrap;
            border-bottom: 1px solid var(--border-primary);
        }
        .trace-entry:hover {
            background: var(--bg-button);
        }
        .trace-entry.current {
            background: var(--bg-selected);
        }
        .trace-entry.viewing {
            background: var(--accent);
            color: var(--bg-primary);
        }
        .trace-entry .addr {
            color: var(--accent);
        }
        .trace-entry.viewing .addr {
            color: var(--bg-primary);
        }
        .trace-entry .instr {
            color: var(--text-primary);
            margin-left: 8px;
        }
        .trace-entry .regs {
            color: var(--text-secondary);
            margin-left: 8px;
        }
        .trace-entry .ports {
            color: var(--cyan);
            margin-left: 8px;
            font-weight: bold;
        }
        .trace-entry.viewing .ports {
            color: var(--bg-secondary);
        }
        .trace-entry .memops {
            color: var(--warning);
            margin-left: 8px;
        }
        .trace-entry.viewing .memops {
            color: var(--bg-secondary);
        }
        .trace-viewing-indicator {
            background: var(--warning);
            color: #000;
            padding: 2px 6px;
            font-size: 11px;
            margin-left: 5px;
            border-radius: 3px;
        }

        /* Watches Panel */
        .watches-controls {
            display: flex;
            align-items: center;
            gap: 3px;
            margin-bottom: 5px;
        }
        .watches-controls input {
            padding: 2px 5px;
            font-size: 11px;
            font-family: monospace;
            background: var(--bg-primary);
            border: 1px solid var(--bg-button);
            border-radius: 3px;
            color: var(--text-primary);
        }
        #watchAddrInput {
            width: 60px;
        }
        #watchNameInput {
            width: 80px;
        }
        .watches-controls button {
            padding: 2px 6px;
            font-size: 10px;
        }
        .watches-list {
            font-family: monospace;
            font-size: 11px;
            max-height: 150px;
            overflow-y: auto;
        }
        .watch-entry {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 2px 0;
            border-bottom: 1px solid var(--border-primary);
        }
        .watch-entry:last-child {
            border-bottom: none;
        }
        .watch-addr {
            color: var(--accent);
            min-width: 45px;
        }
        .watch-name {
            color: var(--text-secondary);
            min-width: 60px;
            max-width: 80px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .watch-name.label {
            color: var(--cyan);
        }
        .watch-bytes {
            color: var(--text-primary);
        }
        .watch-ascii {
            color: var(--text-secondary);
        }
        .watch-remove {
            padding: 0 4px;
            font-size: 10px;
            background: var(--bg-button);
            border: 1px solid var(--border-primary);
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 2px;
        }
        .watch-remove:hover {
            background: var(--warning);
            color: #000;
        }
        .watch-bytes .changed {
            color: var(--warning);
            font-weight: bold;
        }

        /* Memory Map Dialog */
        .memmap-dialog {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .memmap-dialog.hidden {
            display: none;
        }
        .memmap-content {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 10px 15px 15px 15px;
            max-width: 90vw;
            max-height: 90vh;
            overflow: auto;
            min-width: 750px;
            position: relative;
        }
        .memmap-header {
            position: absolute;
            top: 8px;
            right: 10px;
            z-index: 10;
        }
        .memmap-title {
            margin: 0;
            margin-top: auto;
            color: var(--text-secondary);
            font-size: 12px;
            font-weight: normal;
        }
        .memmap-scale {
            display: flex;
            flex-direction: column;
            width: 45px;
            flex-shrink: 0;
            font-size: 9px;
            color: var(--text-secondary);
            padding-right: 5px;
            position: relative;
        }
        .memmap-scale-tick {
            position: absolute;
            right: -10px;
            font-size: 9px;
        }
        .memmap-scale-tick::after {
            content: '';
            position: absolute;
            top: 0;
            right: -5px;
            width: 10px;
            height: 1px;
            background: var(--text-secondary);
        }
        .memmap-scale-item {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            padding-top: 2px;
            height: 128px;
            box-sizing: border-box;
            position: relative;
        }
        .memmap-scale-item::after {
            content: '';
            position: absolute;
            top: 0;
            right: -15px;
            width: 15px;
            height: 1px;
            background: var(--text-secondary);
        }
        .memmap-scale-addr {
            color: var(--cyan);
            font-family: monospace;
        }
        .memmap-scale-end {
            position: relative;
            font-size: 9px;
            margin-top: -2px;
        }
        .memmap-scale-end::after {
            content: '';
            position: absolute;
            top: 0;
            right: -15px;
            width: 15px;
            height: 1px;
            background: var(--text-secondary);
        }
        .memmap-btn {
            background: var(--accent);
            border: none;
            color: var(--bg-primary);
            padding: 5px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 8px;
            font-weight: bold;
        }
        .memmap-btn:hover {
            background: var(--cyan);
        }
        .memmap-close {
            background: var(--bg-button);
            border: none;
            color: var(--text-primary);
            padding: 5px 15px;
            border-radius: 4px;
            cursor: pointer;
        }
        .memmap-close:hover {
            background: var(--bg-button-hover);
        }
        .memmap-view-toggle {
            display: flex;
            gap: 2px;
        }
        .memmap-view-btn {
            background: var(--bg-button);
            border: 1px solid var(--border-secondary);
            color: var(--text-secondary);
            padding: 4px 12px;
            cursor: pointer;
            font-size: 11px;
        }
        .memmap-view-btn:first-child {
            border-radius: 4px 0 0 4px;
        }
        .memmap-view-btn:last-child {
            border-radius: 0 4px 4px 0;
        }
        .memmap-view-btn.active {
            background: var(--accent);
            color: var(--bg-primary);
            border-color: var(--accent);
        }
        .memmap-view-btn:hover:not(.active) {
            background: var(--bg-button-hover);
        }
        .memmap-heatmap-scale {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-top: 10px;
            font-size: 10px;
            color: var(--text-secondary);
        }
        .memmap-gradient {
            flex: 1;
            height: 12px;
            background: linear-gradient(to right, #000, #0066ff, #00ff66, #ff6600, #fff);
            border-radius: 2px;
        }
        .memmap-body {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: flex-start;
        }
        .memmap-canvas-container {
            position: relative;
            width: 512px;
            height: 512px;
            flex-shrink: 0;
        }
        #memmapCanvas {
            border: 1px solid var(--bg-button);
            cursor: crosshair;
            image-rendering: pixelated;
        }
        .memmap-tooltip {
            position: absolute;
            background: rgba(0,0,0,0.9);
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            pointer-events: none;
            white-space: nowrap;
            display: none;
        }
        .memmap-sidebar {
            width: 220px;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            min-height: 512px;
            padding-top: 5px;
        }
        .memmap-legend {
            margin-bottom: 15px;
        }
        .memmap-legend.hidden {
            display: none;
        }
        .memmap-legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 4px 0;
            font-size: 12px;
        }
        .memmap-legend-color {
            width: 16px;
            height: 16px;
            border-radius: 2px;
        }
        .memmap-stats {
            font-size: 12px;
        }
        .memmap-stats table {
            width: 100%;
            border-collapse: collapse;
        }
        .memmap-stats td {
            padding: 3px 5px;
        }
        .memmap-stats td:nth-child(2),
        .memmap-stats td:nth-child(3) {
            text-align: right;
            font-family: monospace;
        }
        .memmap-stats tr.total {
            border-top: 1px solid var(--bg-button);
            font-weight: bold;
        }
        .memmap-bar {
            height: 8px;
            background: var(--bg-button);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 10px;
        }
        .memmap-bar-fill {
            height: 100%;
            display: flex;
        }
        .memmap-addr-info {
            margin-top: 15px;
            padding: 8px;
            background: var(--bg-primary);
            border-radius: 4px;
            font-family: monospace;
            font-size: 11px;
            height: 80px;
            overflow: hidden;
            white-space: pre-wrap;
        }
        /* Full Help Dialog */
        .fullhelp-dialog {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .fullhelp-dialog.hidden {
            display: none;
        }
        .fullhelp-content {
            background: var(--bg-secondary);
            border-radius: 8px;
            width: 90vw;
            max-width: 900px;
            height: 90vh;
            max-height: 800px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .fullhelp-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            border-bottom: 1px solid var(--bg-button);
        }
        .fullhelp-header h3 {
            margin: 0;
            color: var(--cyan);
        }
        .help-version {
            color: var(--text-secondary);
            font-size: 0.8em;
        }
        .fullhelp-close {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 28px;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        .fullhelp-close:hover {
            color: var(--text-primary);
        }
        .fullhelp-body {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        .fullhelp-nav {
            display: flex;
            flex-direction: column;
            gap: 2px;
            padding: 10px;
            background: var(--bg-primary);
            min-width: 130px;
            overflow-y: auto;
        }
        .fullhelp-nav-btn {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            text-align: left;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }
        .fullhelp-nav-btn:hover {
            background: var(--bg-button);
            color: var(--text-primary);
        }
        .fullhelp-nav-btn.active {
            background: var(--accent);
            color: #fff;
        }
        .fullhelp-section {
            flex: 1;
            padding: 20px 25px;
            overflow-y: auto;
            line-height: 1.6;
        }
        .fullhelp-section.hidden {
            display: none;
        }
        .fullhelp-section h4 {
            margin: 0 0 15px 0;
            color: var(--cyan);
            font-size: 18px;
            border-bottom: 1px solid var(--bg-button);
            padding-bottom: 8px;
        }
        .fullhelp-section h5 {
            margin: 20px 0 10px 0;
            color: var(--accent);
            font-size: 14px;
        }
        .fullhelp-section p {
            margin: 0 0 10px 0;
            color: var(--text-primary);
        }
        .fullhelp-section ul, .fullhelp-section ol {
            margin: 0 0 15px 0;
            padding-left: 25px;
        }
        .fullhelp-section li {
            margin-bottom: 5px;
        }
        .fullhelp-section code {
            background: var(--bg-primary);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 12px;
            color: var(--cyan);
        }
        .fullhelp-section pre {
            background: var(--bg-primary);
            padding: 15px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 11px;
            overflow-x: auto;
            line-height: 1.4;
            color: var(--text-primary);
        }
        .fullhelp-section table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 15px;
        }
        .fullhelp-section th, .fullhelp-section td {
            padding: 8px 12px;
            text-align: left;
            border-bottom: 1px solid var(--bg-button);
        }
        .fullhelp-section th {
            color: var(--cyan);
            font-weight: bold;
        }
        .fullhelp-section td:first-child {
            font-family: monospace;
            color: var(--accent);
            white-space: nowrap;
        }
        /* Bookmarks bar */
        .bookmarks-bar {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 2px 6px;
            background: var(--bg-tertiary);
            border-top: 1px solid var(--border-color);
            font-size: 10px;
            margin-bottom: -6px;
        }
        .bookmarks-label {
            color: var(--text-secondary);
            margin-right: 4px;
        }
        .bookmark-btn {
            min-width: 40px;
            padding: 2px 6px;
            font-family: monospace;
            font-size: 10px;
            background: var(--bg-button);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            cursor: pointer;
        }
        .bookmark-btn:hover {
            background: var(--bg-hover);
        }
        .bookmark-btn.set {
            background: var(--bg-button);
            color: var(--text-primary);
        }
        .bookmark-btn.type-mismatch {
            color: var(--text-secondary);
            font-style: italic;
        }

        /* Game Browser Dialog */
        .gamebrowser-dialog {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .gamebrowser-dialog.hidden {
            display: none;
        }
        .gamebrowser-content {
            background: var(--bg-secondary);
            border-radius: 8px;
            width: 90vw;
            max-width: 1000px;
            height: 90vh;
            max-height: 700px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .gamebrowser-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 20px;
            border-bottom: 1px solid var(--bg-button);
            background: var(--bg-primary);
        }
        .gamebrowser-header h3 {
            margin: 0;
            color: var(--cyan);
            font-size: 16px;
        }
        .gamebrowser-close {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 28px;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        .gamebrowser-close:hover {
            color: var(--text-primary);
        }
        .gamebrowser-search {
            display: flex;
            gap: 10px;
            padding: 12px 20px;
            border-bottom: 1px solid var(--bg-button);
            background: var(--bg-primary);
        }
        .gamebrowser-search input {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid var(--bg-button);
            border-radius: 4px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 14px;
        }
        .gamebrowser-search input:focus {
            outline: none;
            border-color: var(--cyan);
        }
        .gamebrowser-search button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            background: var(--cyan);
            color: var(--bg-primary);
            cursor: pointer;
            font-weight: 500;
        }
        .gamebrowser-search button:hover {
            opacity: 0.9;
        }
        .gamebrowser-search button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .gamebrowser-source {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .gamebrowser-source label {
            display: flex;
            align-items: center;
            gap: 4px;
            color: var(--text-secondary);
            font-size: 12px;
            cursor: pointer;
        }
        .gamebrowser-body {
            flex: 1;
            display: flex;
            overflow: hidden;
        }
        .gamebrowser-results {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }
        .gamebrowser-item {
            display: flex;
            gap: 12px;
            padding: 10px;
            border-radius: 6px;
            cursor: pointer;
            border: 1px solid transparent;
            margin-bottom: 8px;
            background: var(--bg-primary);
        }
        .gamebrowser-item:hover {
            background: var(--bg-hover);
        }
        .gamebrowser-item.selected {
            border-color: var(--cyan);
            background: var(--bg-hover);
        }
        .gamebrowser-thumb {
            width: 80px;
            height: 60px;
            background: #000;
            border-radius: 4px;
            overflow: hidden;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .gamebrowser-thumb img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        .gamebrowser-thumb-placeholder {
            width: 100%;
            height: 100%;
            background:
                repeating-linear-gradient(
                    45deg,
                    transparent,
                    transparent 4px,
                    rgba(128, 128, 128, 0.4) 4px,
                    rgba(128, 128, 128, 0.4) 5px
                );
        }
        .gamebrowser-info {
            flex: 1;
            min-width: 0;
        }
        .gamebrowser-title {
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .gamebrowser-meta {
            font-size: 11px;
            color: var(--text-secondary);
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        .gamebrowser-meta span {
            display: flex;
            align-items: center;
            gap: 3px;
        }
        .gamebrowser-score {
            color: var(--yellow);
        }
        .gamebrowser-source-badge {
            font-size: 9px;
            padding: 1px 5px;
            border-radius: 3px;
            background: var(--bg-button);
            color: var(--text-secondary);
        }
        .gamebrowser-unavailable {
            color: var(--red);
        }
        .gamebrowser-detail {
            width: 300px;
            border-left: 1px solid var(--bg-button);
            padding: 15px;
            overflow-y: auto;
            background: var(--bg-primary);
        }
        .gamebrowser-detail-title {
            font-size: 16px;
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: 10px;
        }
        .gamebrowser-detail-screen {
            width: 100%;
            background: #000;
            border-radius: 4px;
            margin-bottom: 10px;
            aspect-ratio: 4/3;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .gamebrowser-detail-screen img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        .gamebrowser-detail-info {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 15px;
        }
        .gamebrowser-detail-info p {
            margin: 4px 0;
        }
        .gamebrowser-detail-info strong {
            color: var(--text-primary);
        }
        .gamebrowser-releases {
            margin-bottom: 15px;
        }
        .gamebrowser-releases-title {
            font-size: 12px;
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: 8px;
        }
        .gamebrowser-release {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 8px;
            background: var(--bg-secondary);
            border-radius: 4px;
            margin-bottom: 4px;
            font-size: 11px;
        }
        .gamebrowser-release-info {
            color: var(--text-secondary);
        }
        .gamebrowser-release button {
            padding: 3px 10px;
            border: none;
            border-radius: 3px;
            background: var(--cyan);
            color: var(--bg-primary);
            cursor: pointer;
            font-size: 11px;
        }
        .gamebrowser-release button:hover {
            opacity: 0.9;
        }
        .gamebrowser-release button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: var(--bg-button);
            color: var(--text-secondary);
        }
        .gamebrowser-release-note {
            font-size: 10px;
            color: var(--text-dim);
            padding: 4px 8px;
            font-style: italic;
        }
        .gamebrowser-release-format {
            font-weight: 600;
            color: var(--cyan);
            min-width: 35px;
        }
        .gamebrowser-release-link {
            background: transparent;
            justify-content: center;
            margin-top: 8px;
        }
        .gamebrowser-release-link a {
            color: var(--cyan);
            text-decoration: none;
            font-size: 11px;
        }
        .gamebrowser-release-link a:hover {
            text-decoration: underline;
        }
        .gamebrowser-download-btn {
            padding: 3px 10px;
            border: none;
            border-radius: 3px;
            background: var(--cyan);
            color: var(--bg-primary);
            cursor: pointer;
            font-size: 11px;
            text-decoration: none;
        }
        .gamebrowser-download-btn:hover {
            opacity: 0.9;
        }
        .gamebrowser-source-info {
            font-size: 11px;
            color: var(--text-dim);
            margin-left: auto;
        }
        .gamebrowser-source-info a {
            color: var(--cyan);
            text-decoration: none;
        }
        .gamebrowser-source-info a:hover {
            text-decoration: underline;
        }
        .gamebrowser-external {
            margin-top: 10px;
        }
        .gamebrowser-external a {
            display: inline-block;
            padding: 4px 10px;
            background: var(--bg-button);
            color: var(--text-primary);
            text-decoration: none;
            border-radius: 4px;
            font-size: 11px;
            margin-right: 5px;
        }
        .gamebrowser-external a:hover {
            background: var(--bg-hover);
        }
        .gamebrowser-pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            padding: 10px;
            border-top: 1px solid var(--bg-button);
            background: var(--bg-primary);
        }
        .gamebrowser-pagination button {
            padding: 5px 15px;
            border: none;
            border-radius: 4px;
            background: var(--bg-button);
            color: var(--text-primary);
            cursor: pointer;
        }
        .gamebrowser-pagination button:hover:not(:disabled) {
            background: var(--bg-hover);
        }
        .gamebrowser-pagination button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .gamebrowser-pagination span {
            color: var(--text-secondary);
            font-size: 12px;
        }
        .gamebrowser-status {
            text-align: center;
            padding: 40px;
            color: var(--text-secondary);
        }
        .gamebrowser-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        .gamebrowser-spinner {
            width: 30px;
            height: 30px;
            border: 3px solid var(--bg-button);
            border-top-color: var(--cyan);
            border-radius: 50%;
            animation: gamebrowser-spin 1s linear infinite;
        }
        @keyframes gamebrowser-spin {
            to { transform: rotate(360deg); }
        }
        .gamebrowser-error {
            color: var(--red);
        }
    </style>
</head>
<body>
    <!-- ROM Selection Modal (shown only if ROMs not found in roms/) -->
    <div class="modal-overlay hidden" id="romModal">
        <div class="modal">
            <h2>🖥️ ROM Files Required</h2>
            <p>No ROM files found in <code>roms/</code> directory. Select ROM files below, or place them in the <code>roms/</code> folder.</p>

            <div class="rom-grid">
                <button id="btnSelect48Rom">48.rom</button>
                <div class="rom-status" id="status48Rom">Not loaded (required)</div>

                <button id="btnSelect128Rom">128.rom</button>
                <div class="rom-status" id="status128Rom">Not loaded</div>

                <button id="btnSelectPlus2Rom">plus2.rom</button>
                <div class="rom-status" id="statusPlus2Rom">Not loaded</div>

                <button id="btnSelectPlus2aRom">plus2a.rom</button>
                <div class="rom-status" id="statusPlus2aRom">Not loaded</div>

                <button id="btnSelectPlus3Rom">plus3.rom</button>
                <div class="rom-status" id="statusPlus3Rom">Not loaded</div>

                <button id="btnSelectPentagonRom">pentagon.rom</button>
                <div class="rom-status" id="statusPentagonRom">Not loaded</div>

                <button id="btnSelectScorpionRom">scorpion.rom</button>
                <div class="rom-status" id="statusScorpionRom">Not loaded</div>

                <button id="btnSelectTrdosRom">trdos.rom</button>
                <div class="rom-status" id="statusTrdosRom">Not loaded (for TRD/SCL disks)</div>
            </div>

            <div class="modal-actions">
                <button id="btnStartEmulator" class="primary" disabled>Start Emulator</button>
                <button id="btnCloseRomModal" class="hidden">Close</button>
            </div>
            
            <p class="modal-hint">
                You can also drag & drop ROM files onto this dialog.
            </p>
        </div>
    </div>

    <!-- ZIP File Selection Modal -->
    <div id="zipModal" class="modal-overlay hidden">
        <div class="modal">
            <h2>Select File to Load</h2>
            <p>The archive contains multiple files. Select one to load:</p>
            <div id="zipFileList" class="zip-file-list"></div>
            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                <button id="btnBootTrdos" class="secondary" style="display: none;">Boot TR-DOS</button>
                <button id="btnZipCancel" class="secondary">Cancel</button>
            </div>
        </div>
    </div>

    <style>
        .zip-file-list {
            max-height: 300px;
            overflow-y: auto;
            margin: 15px 0;
        }
        .zip-file-item {
            padding: 10px 15px;
            margin: 5px 0;
            background: #2a2a3a;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .zip-file-item:hover {
            background: #3a3a4a;
        }
        .zip-file-name {
            color: var(--cyan);
        }
        .zip-file-type {
            color: #888;
            font-size: 12px;
            text-transform: uppercase;
            min-width: 50px;
        }
        .zip-file-info {
            color: #666;
            font-size: 11px;
            font-family: monospace;
        }
    </style>

    <div class="container">
        <div class="top-bar">
            <select id="machineSelect" class="toolbar-select" title="Select machine type">
            </select>
            <select id="loadSelect" class="toolbar-select" title="Load file" style="width:auto;padding:4px 6px;">
                <option value="" disabled selected hidden>Load</option>
                <option value="file">File</option>
                <option value="browse">Web</option>
                <option value="project">Project</option>
                <option value="quick">Quick (F5)</option>
            </select>
            <select id="saveSelect" class="toolbar-select" title="Save" style="width:auto;padding:4px 6px;">
                <option value="" disabled selected hidden>Save</option>
                <option value="sna">SNA</option>
                <option value="z80">Z80</option>
                <option value="szx">SZX</option>
                <option value="project">Project</option>
                <option value="quick">Quick (F2)</option>
            </select>
            <button id="btnHelpFull" class="test-link" title="ZX-M8XXX v0.9.31 — Help">Help</button>
            <button id="themeToggle" class="theme-btn" title="Toggle light/dark theme">☀️</button>
            <input type="file" id="projectFileInput" class="file-input" accept=".zxproj,.json">
        </div>
        
        <div class="main-layout">
        <div class="emulator-section">
        <div class="screen-container">
            <div class="screen-wrapper">
                <canvas id="screen" width="320" height="240"></canvas>
                <canvas id="overlayCanvas" width="320" height="240"></canvas>
                <div id="spriteRegionOverlay" class="sprite-region-overlay"></div>
            </div>
            <div id="screenInfoPopup" class="screen-info-popup hidden"></div>
            <div id="xrefTooltip" class="xref-tooltip"></div>
        </div>

        <div class="status">
            <span class="status-item">
                <span class="status-value" id="fps" style="min-width: 32px; display: inline-block; text-align: right;">0</span>
            </span>
            <span class="status-item" id="rzxInfo" style="visibility: hidden;">
                <span class="status-label">RZX:</span>
                <span class="status-value" id="rzxStatus" style="min-width: 130px; display: inline-block; font-variant-numeric: tabular-nums;">-</span>
                <button id="btnRzxStop" class="small-btn" title="Stop RZX playback">Stop</button>
            </span>
            <span class="status-item" id="tapeInfo" style="display:none;">
                <span class="status-label" id="tapeLed" title="No tape">📼</span>
                <span class="status-value" id="tapeProgress" style="color: var(--cyan); min-width: 30px; display: inline-block; text-align: right;"></span>
            </span>
            <span class="status-item" id="diskInfo" style="display:none;">
                <span class="status-label" id="diskInfoLed" title="No disk">💾</span>
            </span>
            <span class="status-item" id="diskActivity" style="display:none;">
                <span class="status-label" id="diskLed" title="Disk activity">💾</span>
                <span class="status-value" id="diskStatus" style="display:inline-block;min-width:6.5em;font-family:monospace;">-</span>
            </span>
        </div>
        
        <div class="controls">
            <button id="btnScreenshotMain" title="Save screenshot">📷</button>
            <button id="btnRun" class="primary" title="Run/Pause emulation (F5)">Run</button>
            <button id="btnReset" title="Reset machine">Reset</button>
            <select id="speedSelect" title="Emulation speed">
                <option value="10">10%</option>
                <option value="25">25%</option>
                <option value="50">50%</option>
                <option value="75">75%</option>
                <option value="100" selected>100%</option>
                <option value="200">200%</option>
                <option value="400">400%</option>
                <option value="0">Max</option>
            </select>
            <button id="btnSound" title="Toggle sound (AY-3-8910)">🔇</button>
            <button id="btnFullscreen" title="Toggle fullscreen (F11)">⛶</button>
            <button id="btnMouse" title="Capture mouse (Kempston Mouse)" style="display: none;">🖱️</button>
        </div>
        <input type="file" id="rom48Input" class="file-input" accept=".rom,.bin">
        <input type="file" id="rom128Input" class="file-input" accept=".rom,.bin">
        <input type="file" id="romPlus2Input" class="file-input" accept=".rom,.bin">
        <input type="file" id="romPlus2aInput" class="file-input" accept=".rom,.bin">
        <input type="file" id="romPlus3Input" class="file-input" accept=".rom,.bin">
        <input type="file" id="romPentagonInput" class="file-input" accept=".rom,.bin">
        <input type="file" id="romScorpionInput" class="file-input" accept=".rom,.bin">
        <input type="file" id="romTrdosInput" class="file-input" accept=".rom,.bin">
        <input type="file" id="fileInput" class="file-input" accept=".sna,.tap,.tzx,.z80,.szx,.zip,.rzx,.trd,.scl,.dsk">
        </div><!-- emulator-section -->

        <!-- Tab Container -->
        <div class="tab-container" id="tabContainer">
            <div class="tab-bar">
                <button class="tab-btn active" data-tab="debugger"><span class="arrow">▶</span>Debug</button>
                <button class="tab-btn" data-tab="assembler"><span class="arrow">▶</span>ASM</button>
                <button class="tab-btn" data-tab="graphics"><span class="arrow">▶</span>GFX</button>
                <button class="tab-btn" data-tab="info"><span class="arrow">▶</span>Info</button>
                <button class="tab-btn" data-tab="settings"><span class="arrow">▶</span>Settings</button>
                <button class="tab-btn" data-tab="tools"><span class="arrow">▶</span>Tools</button>
            </div>

            <!-- Debugger Tab -->
            <div class="tab-content active" id="tab-debugger">
            <div class="debugger-container">
            <div class="debugger-panel open" id="debuggerPanel">
                <div class="main-debug-row">
                    <div class="debugger-section disasm-panel" id="leftPanel">
                        <div class="memory-header">
                            <select id="leftPanelType" class="panel-type-select" title="Panel type">
                                <option value="disasm">Disasm</option>
                                <option value="memdump">Memory</option>
                            </select>
                            <div class="memory-controls left-disasm-controls">
                                <input type="text" id="disasmAddress" placeholder="0000" maxlength="4" value="">
                                <button id="btnDisasmGo" title="Go to address">Go</button>
                                <button id="btnDisasmPC" title="Go to current PC">PC</button>
                                <button id="btnDisasmPgUp" title="Navigate Back (Alt+Left)">◀</button>
                                <button id="btnDisasmPgDn" title="Navigate Forward (Alt+Right)">▶</button>
                                <label class="disasm-option" title="Show T-states for each instruction"><input type="checkbox" id="chkShowTstates">T-states</label>
                                <button id="btnDisasmExport" title="Export visible disassembly">Export</button>
                                <button id="btnDisasmExportRange" title="Export address range">Export...</button>
                            </div>
                            <div class="memory-controls left-memdump-controls" style="display:none">
                                <input type="text" id="leftMemAddress" placeholder="0000" maxlength="4" value="0000">
                                <button id="btnLeftMemGo" title="Go to address">Go</button>
                                <button id="btnLeftMemPC" title="Go to PC">PC</button>
                                <button id="btnLeftMemSP" title="Go to SP">SP</button>
                                <button id="btnLeftMemHL" title="Go to HL">HL</button>
                                <button id="btnLeftMemPgUp" title="Page up">▲</button>
                                <button id="btnLeftMemPgDn" title="Page down">▼</button>
                            </div>
                        </div>
                        <div class="disassembly-view" id="disassemblyView"></div>
                        <div class="memory-view" id="leftMemoryView" style="display:none"></div>
                        <div class="bookmarks-bar" id="disasmBookmarks">
                            <span class="bookmarks-label">Bookmarks:</span>
                            <button class="bookmark-btn" data-index="0" title="Click: go, Right-click: set">-</button>
                            <button class="bookmark-btn" data-index="1" title="Click: go, Right-click: set">-</button>
                            <button class="bookmark-btn" data-index="2" title="Click: go, Right-click: set">-</button>
                            <button class="bookmark-btn" data-index="3" title="Click: go, Right-click: set">-</button>
                            <button class="bookmark-btn" data-index="4" title="Click: go, Right-click: set">-</button>
                        </div>
                        <div class="memory-search inline left-memory-search" style="display:none">
                            <div class="search-row">
                                <span class="search-label">Search:</span>
                                <input type="text" id="leftMemSearchInput">
                                <select id="leftMemSearchType">
                                    <option value="hex">Hex</option>
                                    <option value="dec">Dec</option>
                                    <option value="text">Text</option>
                                </select>
                                <button id="btnLeftMemSearch" title="Find bytes in memory">Find</button>
                                <button id="btnLeftMemSearchNext" title="Find next occurrence">Next</button>
                                <div class="search-options">
                                    <label class="search-option"><input type="checkbox" id="chkLeftSearchCase"> Case</label>
                                    <label class="search-option"><input type="checkbox" id="chkLeftSearch7bit"> +128</label>
                                </div>
                            </div>
                            <div class="search-results" id="leftSearchResults"></div>
                        </div>
                        <div class="debugger-controls left-debugger-controls">
                            <button id="btnStepInto" title="Step Into (F7)">Step Into</button>
                            <button id="btnStepOver" title="Step Over (F8)">Step Over</button>
                            <button id="btnRunTo" title="Run to Cursor (F4)">To Cursor</button>
                            <button id="btnRunToInt" title="Run to INT">To INT</button>
                            <button id="btnRunToRet" title="Run to RET">To RET</button>
                            <input type="text" id="tstatesInput" class="tstates-input" placeholder="T" maxlength="8" value="1000" title="Number of T-states to run">
                            <button id="btnRunTstates" title="Run specified T-states">Tstates</button>
                            <label style="margin-left: 8px; font-size: 11px;" title="Add separator comment before each step"><input type="checkbox" id="chkAutoComment"> comm</label>
                            <label style="margin-left: 8px; font-size: 11px;" title="Auto-scroll disassembly to follow PC"><input type="checkbox" id="chkFollowPC"> follow</label>
                        </div>
                    </div>
                    <div class="right-column">
                        <div class="registers-row">
                            <div class="reg-group">
                                <h4>Regs</h4>
                                <div class="registers-grid" id="mainRegisters"></div>
                                <div class="registers-grid" id="altRegisters"></div>
                                <div class="registers-grid" id="ixiyRegisters"></div>
                            </div>
                            <div class="reg-group">
                                <h4>System</h4>
                                <div class="registers-grid" id="indexRegisters"></div>
                                <div class="registers-grid" id="statusRegisters"></div>
                                <div class="flags-row">
                                    <div class="register-item" id="regRItem"></div>
                                    <div class="flags-block">
                                        <div class="flags-label">Flags</div>
                                        <div class="flags-display" id="flagsDisplay"></div>
                                    </div>
                                </div>
                            </div>
                            <div class="stack-pages-row">
                                <div class="reg-group">
                                    <h4>Stack</h4>
                                    <div class="stack-view" id="stackView"></div>
                                </div>
                                <div class="reg-group calls-group">
                                    <h4>Calls</h4>
                                    <div class="stack-view" id="callStackView"></div>
                                </div>
                                <div class="reg-group" id="pagesGroup" style="display: none;">
                                    <h4>Pages</h4>
                                    <div class="registers-grid vertical" id="pagesInfo"></div>
                                </div>
                            </div>
                        </div>
                        <div class="memory-section memory-panel" id="rightPanel">
                            <div class="memory-header">
                                <select id="rightPanelType" class="panel-type-select" title="Panel type">
                                    <option value="memdump">Memory</option>
                                    <option value="disasm">Disasm</option>
                                    <option value="calc">Calculator</option>
                                </select>
                                <div class="memory-controls right-memdump-controls">
                                    <input type="text" id="memoryAddress" placeholder="0000" maxlength="4" value="0000">
                                    <button id="btnMemoryGo" title="Go to address">Go</button>
                                    <button id="btnMemoryPC" title="Go to PC">PC</button>
                                    <button id="btnMemorySP" title="Go to SP">SP</button>
                                    <button id="btnMemoryHL" title="Go to HL">HL</button>
                                    <button id="btnMemoryPgUp" title="Page up">▲</button>
                                    <button id="btnMemoryPgDn" title="Page down">▼</button>
                                    <button id="btnMemorySnap" title="Snapshot memory for diff">Snap</button>
                                    <button id="btnMemoryClearSnap" title="Clear snapshot" style="display:none">Clear</button>
                                    <label class="memory-option" title="Allow editing ROM area"><input type="checkbox" id="chkRomEdit">Edit ROM</label>
                                </div>
                                <div class="memory-controls right-disasm-controls" style="display:none">
                                    <input type="text" id="rightDisasmAddress" placeholder="0000" maxlength="4" value="">
                                    <button id="btnRightDisasmGo" title="Go to address">Go</button>
                                    <button id="btnRightDisasmPC" title="Go to current PC">PC</button>
                                    <button id="btnRightDisasmPgUp" title="Navigate Back">◀</button>
                                    <button id="btnRightDisasmPgDn" title="Navigate Forward">▶</button>
                                    <label class="disasm-option" title="Show T-states for each instruction"><input type="checkbox" id="chkRightShowTstates">T-states</label>
                                </div>
                            </div>
                            <div class="memory-view" id="memoryView"></div>
                            <div class="disassembly-view" id="rightDisassemblyView" style="display:none"></div>
                            <div class="calculator-view" id="rightCalculatorView" style="display:none">
                                <div class="calc-wrapper">
                                <div class="calc-top-row">
                                <div class="calc-container">
                                    <div class="calc-display">
                                        <div class="calc-input-row">
                                            <select id="calcInputBase" class="calc-base-select">
                                                <option value="16">HEX</option>
                                                <option value="10">DEC</option>
                                                <option value="8">OCT</option>
                                                <option value="2">BIN</option>
                                            </select>
                                            <input type="text" id="calcInput" class="calc-input" value="0" spellcheck="false">
                                        </div>
                                        <div class="calc-output-row">
                                            <span class="calc-label dec">DEC</span>
                                            <span class="calc-value" id="calcDec">0</span>
                                            <span class="calc-signed" id="calcSigned"></span>
                                        </div>
                                        <div class="calc-output-row">
                                            <span class="calc-label hex">HEX</span>
                                            <span class="calc-value" id="calcHex">0</span>
                                        </div>
                                        <div class="calc-output-row">
                                            <span class="calc-label oct">OCT</span>
                                            <span class="calc-value" id="calcOct">0</span>
                                        </div>
                                        <div class="calc-output-row">
                                            <span class="calc-label bin">BIN</span>
                                            <span class="calc-value bin-value" id="calcBin">0</span>
                                        </div>
                                        <div class="calc-output-row ascii-row">
                                            <span class="calc-label ascii">ASCII</span>
                                            <span class="calc-value" id="calcAscii"></span>
                                        </div>
                                    </div>
                                    <div class="calc-buttons">
                                        <div class="calc-row">
                                            <button class="calc-btn mode" id="calcBitSize" title="Toggle bit size (8/16/32 bits)">u16</button>
                                            <button class="calc-btn op" data-op="and" title="Bitwise AND: A and B">and</button>
                                            <button class="calc-btn op" data-op="or" title="Bitwise OR: A or B">or</button>
                                            <button class="calc-btn op" data-op="not" title="Bitwise NOT: invert all bits">not</button>
                                            <button class="calc-btn op" data-op="xor" title="Bitwise XOR: A xor B">xor</button>
                                        </div>
                                        <div class="calc-row">
                                            <button class="calc-btn func" data-op="inc" title="Increment: add 1">inc</button>
                                            <button class="calc-btn func" data-op="dec" title="Decrement: subtract 1">dec</button>
                                            <button class="calc-btn func" data-op="lsl" title="Logical Shift Left: shift bits left, fill with 0">lsl</button>
                                            <button class="calc-btn func" data-op="lsr" title="Logical Shift Right: shift bits right, fill with 0">lsr</button>
                                            <button class="calc-btn func" data-op="asr" title="Arithmetic Shift Right: shift right, preserve sign bit">asr</button>
                                            <button class="calc-btn func" data-op="rand" title="Random: generate random number">rand</button>
                                        </div>
                                        <div class="calc-row">
                                            <button class="calc-btn paren" data-char="(">(</button>
                                            <button class="calc-btn paren" data-char=")">)</button>
                                            <button class="calc-btn func" data-op="rol" title="Rotate Left: shift left, top bit wraps to bottom">rol</button>
                                            <button class="calc-btn func" data-op="ror" title="Rotate Right: shift right, bottom bit wraps to top">ror</button>
                                            <button class="calc-btn op" data-op="mod" title="Modulo: remainder after division">mod</button>
                                            <button class="calc-btn op" data-op="/" title="Divide: integer division">/</button>
                                        </div>
                                        <div class="calc-row">
                                            <button class="calc-btn hex-digit" data-char="A">A</button>
                                            <button class="calc-btn hex-digit" data-char="B">B</button>
                                            <button class="calc-btn digit" data-char="7">7</button>
                                            <button class="calc-btn digit" data-char="8">8</button>
                                            <button class="calc-btn digit" data-char="9">9</button>
                                            <button class="calc-btn op" data-op="*" title="Multiply">*</button>
                                        </div>
                                        <div class="calc-row">
                                            <button class="calc-btn hex-digit" data-char="C">C</button>
                                            <button class="calc-btn hex-digit" data-char="D">D</button>
                                            <button class="calc-btn digit" data-char="4">4</button>
                                            <button class="calc-btn digit" data-char="5">5</button>
                                            <button class="calc-btn digit" data-char="6">6</button>
                                            <button class="calc-btn op" data-op="-" title="Subtract">-</button>
                                        </div>
                                        <div class="calc-row">
                                            <button class="calc-btn hex-digit" data-char="E">E</button>
                                            <button class="calc-btn hex-digit" data-char="F">F</button>
                                            <button class="calc-btn digit" data-char="1">1</button>
                                            <button class="calc-btn digit" data-char="2">2</button>
                                            <button class="calc-btn digit" data-char="3">3</button>
                                            <button class="calc-btn op" data-op="+" title="Add">+</button>
                                        </div>
                                        <div class="calc-row">
                                            <button class="calc-btn clear" id="calcClear" title="Clear: reset to 0">C</button>
                                            <button class="calc-btn clear" id="calcDel" title="Delete: remove last digit">DEL</button>
                                            <button class="calc-btn digit" data-char="0">0</button>
                                            <button class="calc-btn digit" data-char="0" id="calcDot" style="visibility:hidden">.</button>
                                            <button class="calc-btn func" id="calcNegate" title="Negate: two's complement (flip sign)">+/-</button>
                                            <button class="calc-btn equals" id="calcEquals" title="Equals: calculate result">=</button>
                                        </div>
                                    </div>
                                </div>
                                <div class="calc-log">
                                    <div class="calc-log-header">
                                        <span>History</span>
                                        <button id="calcLogClear" title="Clear history">&times;</button>
                                    </div>
                                    <div class="calc-log-content" id="calcLogContent"></div>
                                </div>
                                </div>
                                <div class="calc-bits-panel" id="calcBitsPanel">
                                    <div class="calc-bits-labels" id="calcBitsLabels"></div>
                                    <div class="calc-bits-grid" id="calcBitsGrid"></div>
                                </div>
                                </div>
                            </div>
                            <div class="bookmarks-bar" id="memoryBookmarks">
                                <span class="bookmarks-label">Bookmarks:</span>
                                <button class="bookmark-btn" data-index="0" title="Click: go, Right-click: set">-</button>
                                <button class="bookmark-btn" data-index="1" title="Click: go, Right-click: set">-</button>
                                <button class="bookmark-btn" data-index="2" title="Click: go, Right-click: set">-</button>
                                <button class="bookmark-btn" data-index="3" title="Click: go, Right-click: set">-</button>
                                <button class="bookmark-btn" data-index="4" title="Click: go, Right-click: set">-</button>
                            </div>
                            <div class="debugger-controls right-debugger-controls" style="display:none">
                                <button id="btnRightStepInto" title="Step Into (F7)">Step Into</button>
                                <button id="btnRightStepOver" title="Step Over (F8)">Step Over</button>
                                <button id="btnRightRunTo" title="Run to Cursor (F4)">To Cursor</button>
                                <button id="btnRightRunToInt" title="Run to INT">To INT</button>
                                <button id="btnRightRunToRet" title="Run to RET">To RET</button>
                                <input type="text" id="rightTstatesInput" class="tstates-input" placeholder="T" maxlength="8" value="1000">
                                <button id="btnRightRunTstates" title="Run T-States">Tstates</button>
                            </div>
                            <div class="memory-search inline right-memory-search">
                                <div class="search-row">
                                    <span class="search-label">Search:</span>
                                    <input type="text" id="memSearchInput">
                                    <select id="memSearchType">
                                        <option value="hex">Hex</option>
                                        <option value="dec">Dec</option>
                                        <option value="text">Text</option>
                                    </select>
                                    <button id="btnMemSearch" title="Find bytes in memory">Find</button>
                                    <button id="btnMemSearchNext" title="Find next occurrence">Next</button>
                                    <div class="search-options">
                                        <label class="search-option"><input type="checkbox" id="chkSearchCase"> Case</label>
                                        <label class="search-option"><input type="checkbox" id="chkSearch7bit"> +128</label>
                                    </div>
                                </div>
                                <div class="search-results" id="searchResults"></div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="panel-tabs">
                    <div class="panel-tab-bar">
                        <button class="panel-tab-btn active" data-panel="breakpoints" title="Breakpoints and watchpoints">Breakpoints</button>
                        <button class="panel-tab-btn" data-panel="labels" title="Address labels">Labels</button>
                        <button class="panel-tab-btn" data-panel="watches" title="Memory watches">Watches</button>
                        <button class="panel-tab-btn" data-panel="tools" title="POKE search, Auto-Map, XRefs, Text scan">Tools</button>
                        <button class="panel-tab-btn" data-panel="trace" title="Execution trace history">Trace</button>
                    </div>
                    <!-- Breakpoints Panel -->
                    <div class="panel-tab-content active" id="panel-breakpoints">
                        <div class="bp-add-form" style="margin-bottom: 5px;">
                            <select id="triggerType" title="Trigger type">
                                <option value="exec">Exec</option>
                                <option value="read">Read</option>
                                <option value="write">Write</option>
                                <option value="rw">R/W</option>
                                <option value="port_in">Port IN</option>
                                <option value="port_out">Port OUT</option>
                                <option value="port_io">Port I/O</option>
                            </select>
                            <input type="text" id="triggerAddrInput" placeholder="ADDR" maxlength="15" title="Examples: 4000, 4000-4FFF, 5:C000, FE&FF">
                            <input type="text" id="triggerCondInput" placeholder="if..." maxlength="30" title="Condition: A==0, val==FF, port&FE==FE">
                            <input type="number" id="triggerSkipInput" placeholder="skip" min="0" value="0" title="Skip count: number of hits to skip before breaking" style="width: 45px;">
                            <button id="btnAddTrigger" title="Add breakpoint/watchpoint">+</button>
                            <button id="btnClearTriggers" title="Clear all triggers">Clear</button>
                        </div>
                        <div class="breakpoint-list trigger-list" id="triggerList">
                            <div class="no-breakpoints">No breakpoints</div>
                        </div>
                    </div>
                    <!-- Labels Panel -->
                    <div class="panel-tab-content" id="panel-labels">
                        <div class="bp-add-form" style="margin-bottom: 5px;">
                            <select id="labelDisplayMode" class="disasm-select" title="Label display mode">
                                <option value="addr">Addr</option>
                                <option value="label">Label</option>
                                <option value="both" selected>Both</option>
                            </select>
                            <label class="rom-labels-toggle" title="Show ROM labels"><input type="checkbox" id="chkShowRomLabels" checked>ROM</label>
                            <input type="text" id="labelFilterInput" placeholder="Filter..." maxlength="20" style="width: 80px;">
                            <button id="btnAddLabel" title="Add label">+</button>
                            <button id="btnExportLabels" title="Export labels to file">Export</button>
                            <button id="btnImportLabels" title="Import labels from file">Import</button>
                            <button id="btnClearLabels" title="Clear user labels">Clear</button>
                            <span id="labelCount" style="font-size: 10px; color: var(--text-secondary); margin-left: 2px;"></span>
                            <input type="file" id="labelFileInput" accept=".json,.txt" style="display:none">
                        </div>
                        <div class="breakpoint-list labels-list" id="labelsList">
                            <div class="no-breakpoints">No labels</div>
                        </div>
                    </div>
                    <!-- Watches Panel -->
                    <div class="panel-tab-content" id="panel-watches">
                        <div class="watches-controls">
                            <input type="text" id="watchAddrInput" placeholder="[P:]Addr" maxlength="7" title="Address (hex), e.g. 4000 or 5:C000">
                            <input type="text" id="watchNameInput" placeholder="Name" maxlength="16" title="Watch name (optional)">
                            <button id="btnWatchAdd" title="Add memory watch (max 10)">+</button>
                            <button id="btnWatchClear" title="Clear all watches">Clear</button>
                        </div>
                        <div class="watches-list" id="watchesList"></div>
                    </div>
                    <!-- Tools Panel -->
                    <div class="panel-tab-content" id="panel-tools">
                        <div class="tools-panel-row">
                        <div class="tools-group">
                            <div class="tools-group-label">analysis</div>
                            <div class="tools-row">
                                <span class="search-label">Auto-Map:</span>
                                <label class="search-option"><input type="checkbox" id="chkAutoMap"> Track</label>
                                <button id="btnAutoMapSnap" title="Capture current state for export (registers, memory)">Snap</button>
                                <button id="btnAutoMapApply" title="Apply tracked regions">Apply</button>
                                <button id="btnAutoMapClear" title="Clear tracking data">Clear</button>
                                <span id="autoMapStats" class="automap-stats"></span>
                                <button id="btnClearRegions" title="Clear all marked regions">Clr Regions</button>
                                <button id="btnMemoryMap" title="Show memory map visualization">Map</button>
                            </div>
                            <div class="tools-row">
                                <span class="search-label">Analyze:</span>
                                <button id="btnCfaRun" title="Static code-flow analysis from entry points">Flow</button>
                                <label class="search-option" title="Skip ROM area (0000-3FFF)">
                                    <input type="checkbox" id="chkCfaSkipRom" checked> Skip ROM
                                </label>
                                <label class="search-option" title="Include ISR handler at $0038">
                                    <input type="checkbox" id="chkCfaISR" checked> ISR
                                </label>
                                <input type="text" id="cfaExtraEntries" placeholder="Extra entries (hex, comma-sep)"
                                       style="width:160px" title="Additional entry point addresses, e.g. 8000,9000">
                                <button id="btnCfaClear" title="Clear code-flow analysis results">Clear</button>
                                <span id="cfaStatus" class="automap-stats"></span>
                            </div>
                            <div class="tools-row">
                                <span class="search-label">XRefs:</span>
                                <button id="btnXrefScan" title="Scan visible range for cross-references">Scan</button>
                                <button id="btnXrefScanAll" title="Scan full 64KB memory">Scan All</button>
                                <button id="btnXrefClear" title="Clear all cross-references">Clear</button>
                                <label class="search-option"><input type="checkbox" id="chkXrefRuntime"> Runtime</label>
                                <span id="xrefStats" class="automap-stats"></span>
                            </div>
                        </div>
                        <div class="tools-group">
                            <div class="tools-group-label">search</div>
                            <div class="tools-row">
                                <span class="search-label">POKE:</span>
                                <button id="btnPokeSnap" title="Take snapshot">Snap</button>
                                <select id="pokeSearchMode">
                                    <option value="dec1">-1</option>
                                    <option value="inc1">+1</option>
                                    <option value="decreased">Decreased</option>
                                    <option value="increased">Increased</option>
                                    <option value="changed">Changed</option>
                                    <option value="unchanged">Unchanged</option>
                                    <option value="equals">Equals</option>
                                </select>
                                <input type="text" id="pokeSearchValue" placeholder="Val" maxlength="5" style="width:40px;display:none">
                                <button id="btnPokeSearch" title="Search candidates">Search</button>
                                <button id="btnPokeReset" title="Reset search">Reset</button>
                                <span id="pokeStatus" class="poke-status"></span>
                                <div class="poke-results" id="pokeResults"></div>
                            </div>
                            <div class="tools-row">
                                <span class="search-label">Text:</span>
                                <button id="btnTextScan" title="Scan memory for text strings">Scan</button>
                                <select id="textScanMode" title="Scan mode">
                                    <option value="all">All strings</option>
                                    <option value="dict">Dictionary</option>
                                    <option value="custom">Custom</option>
                                </select>
                                <input type="text" id="textScanCustom" placeholder="Search text..." style="width:80px;display:none">
                                <label class="search-option" title="Minimum string length"><input type="number" id="textScanMinLen" value="4" min="2" max="20" style="width:35px"> min</label>
                                <label class="search-option" title="Include ROM area (0000-3FFF)"><input type="checkbox" id="textScanROM"> ROM</label>
                                <label class="search-option" title="Scan all 128K RAM banks"><input type="checkbox" id="textScanAllBanks"> All banks</label>
                                <select id="textScanMax" title="Max results to show">
                                    <option value="10">10</option>
                                    <option value="25">25</option>
                                    <option value="50">50</option>
                                    <option value="100">100</option>
                                    <option value="0">All</option>
                                </select>
                                <span id="textScanStatus" class="automap-stats"></span>
                            </div>
                            <div class="tools-row" id="textScanPagination" style="display:none">
                                <button id="textScanPrev" title="Previous page">&lt;</button>
                                <span id="textScanPage">Page 1/1</span>
                                <button id="textScanNext" title="Next page">&gt;</button>
                            </div>
                            <div class="text-scan-results" id="textScanResults"></div>
                        </div>
                        </div>
                    </div>
                    <!-- Trace Panel -->
                    <div class="panel-tab-content" id="panel-trace">
                        <div class="trace-controls">
                            <div class="tools-panel-row">
                            <div class="tools-group">
                                <div class="tools-group-label">trace</div>
                                <div class="trace-row">
                                    <label class="search-option"><input type="checkbox" id="chkTraceEnabled" checked> Step</label>
                                    <label class="search-option"><input type="checkbox" id="chkTraceRuntime"> Runtime</label>
                                    <button id="btnTraceBack" title="Step back in history (Alt+←)">◀</button>
                                    <button id="btnTraceForward" title="Step forward in history (Alt+→)">▶</button>
                                    <button id="btnTraceLive" title="Return to live view">Live</button>
                                    <button id="btnTraceClear" title="Clear trace history">Clear</button>
                                    <span id="traceStatus" class="automap-stats"></span>
                                </div>
                                <div class="trace-row">
                                    <span class="search-label">Include:</span>
                                    <label class="search-option"><input type="checkbox" id="chkTraceBytes"> Bytes</label>
                                    <label class="search-option"><input type="checkbox" id="chkTraceAlt"> Alt regs</label>
                                    <label class="search-option"><input type="checkbox" id="chkTraceSys"> Sys regs</label>
                                    <label class="search-option"><input type="checkbox" id="chkTracePorts"> Ports</label>
                                    <label class="search-option"><input type="checkbox" id="chkTraceSkipROM" checked> Skip ROM</label>
                                    <label class="search-option"><input type="checkbox" id="chkTraceCollapseBlock"> Collapse block</label>
                                </div>
                                <div class="trace-row">
                                    <span class="search-label">Export:</span>
                                    <button id="btnTraceExport" title="Export trace to file">Export</button>
                                    <select id="selTraceExportMode" title="Export first or last N entries">
                                        <option value="first" selected>First</option>
                                        <option value="last">Last</option>
                                    </select>
                                    <input type="number" id="txtTraceExportCount" min="0" max="1000000" value="0" style="width:70px" title="Number of entries to export (0=all)">
                                    <span class="search-label">Stop:</span>
                                    <input type="number" id="txtTraceStopAfter" min="0" max="1000000" value="10000" style="width:70px" title="Stop after N entries (0=unlimited)">
                                </div>
                            </div>
                            <div class="tools-group">
                                <div class="tools-group-label">port i/o</div>
                                <div class="trace-row">
                                    <span class="search-label">Port I/O:</span>
                                    <label class="search-option"><input type="checkbox" id="chkPortLog"> Log</label>
                                    <select id="selPortLogFilter" title="Filter by direction">
                                        <option value="both">Both</option>
                                        <option value="in">IN only</option>
                                        <option value="out">OUT only</option>
                                    </select>
                                    <button id="btnPortLogExport" title="Export port I/O log">Export</button>
                                    <button id="btnPortLogClear" title="Clear port log">Clear</button>
                                    <span id="portLogStatus" class="automap-stats"></span>
                                </div>
                                <div class="trace-row">
                                    <span class="search-label">Port filter:</span>
                                    <input type="text" id="txtPortTraceFilter" placeholder="PORT[&MASK]" maxlength="15"
                                           title="Port spec: FE, 7FFD, FE&FF" style="width:90px">
                                    <button id="btnAddPortFilter" title="Add port to trace filter">+</button>
                                    <button id="btnClearPortFilters" title="Clear all (trace all ports)">Clear</button>
                                    <span id="portFilterStatus" class="automap-stats"></span>
                                </div>
                                <div class="breakpoint-list" id="portFilterList" style="max-height:60px">
                                    <div class="no-breakpoints">All ports (no filter)</div>
                                </div>
                            </div>
                            </div>
                        </div>
                        <div class="trace-list" id="traceList"></div>
                    </div>
                </div>
            </div><!-- debugger-panel -->
        </div><!-- debugger-container -->
        </div><!-- tab-debugger -->

        <!-- Assembler Tab -->
        <div class="tab-content" id="tab-assembler">
            <div class="assembler-container">
                <div class="assembler-header">
                    <div class="assembler-controls">
                        <div class="asm-files-dropdown">
                            <button id="btnAsmFiles" title="Browse project files" disabled>Files ▼</button>
                            <div class="asm-files-list" id="asmFilesList"></div>
                        </div>
                        <button id="btnAsmAssemble" title="Assemble code (F9)" disabled>Assemble</button>
                        <button id="btnAsmInject" title="Inject assembled code to memory" disabled>Inject</button>
                        <button id="btnAsmDebug" title="Inject code and start debugging at entry point" disabled>Debug</button>
                        <button id="btnAsmClear" title="Clear all">Clear</button>
                        <button id="btnAsmNew" title="Create new file">New</button>
                        <button id="btnAsmLoad" title="Load files (ASM, ZIP, binary)">Load</button>
                        <button id="btnAsmExport" title="Export all source files as ZIP" style="display:none">Export</button>
                        <button id="btnAsmDownload" title="Download generated files (.bin, .sna, .tap, .trd)" disabled>Download</button>
                        <input type="file" id="asmFileInput" accept=".asm,.z80,.s,.a80,.inc,.bin,.scr,.tap,.zip" multiple style="display:none">
                        <label class="asm-option"><input type="checkbox" id="chkAsmUnusedLabels"> Unused labels</label>
                        <label class="asm-option"><input type="checkbox" id="chkAsmShowCompiled"> Show compiled</label>
                        <label class="asm-option">Font:
                            <select id="asmFontSize" title="Editor font size" style="width: 45px; padding: 2px;">
                                <option value="8">8</option>
                                <option value="9">9</option>
                                <option value="10">10</option>
                                <option value="11">11</option>
                                <option value="12" selected>12</option>
                                <option value="13">13</option>
                                <option value="14">14</option>
                                <option value="16">16</option>
                                <option value="18">18</option>
                                <option value="20">20</option>
                                <option value="22">22</option>
                                <option value="24">24</option>
                            </select>
                        </label>
                        <label class="asm-option asm-defines-label" title="Command-line defines for IFDEF/IFNDEF (e.g., DEBUG,VERSION=5)">Defines: <input type="text" id="asmDefines" placeholder="NAME,NAME=value" spellcheck="false"></label>
                        <select id="asmDetectedDefines" multiple size="1" title="Defines from @define markers in source (click to toggle)" style="display:none"></select>
                        <span id="asmMainFileLabel" class="asm-main-label" style="display:none" title="Click to change main file"></span>
                    </div>
                </div>
                <div class="assembler-body">
                    <div class="asm-editor-container">
                        <div class="asm-file-tabs" id="asmFileTabs"></div>
                        <div class="asm-search-bar" id="asmSearchBar" style="display:none">
                            <div class="asm-search-row">
                                <input type="text" id="asmSearchInput" placeholder="Find (Ctrl+F)" spellcheck="false">
                                <button id="btnAsmFindPrev" title="Find Previous (Shift+F3)">▲</button>
                                <button id="btnAsmFindNext" title="Find Next (F3)">▼</button>
                                <span id="asmSearchCount" class="asm-search-count"></span>
                                <label class="asm-search-option"><input type="checkbox" id="chkAsmSearchCase"> Case</label>
                                <button id="btnAsmSearchAll" title="Search in all project files">All Files</button>
                                <button id="btnAsmSearchClose" title="Close (Esc)">×</button>
                            </div>
                            <div class="asm-replace-row" id="asmReplaceRow" style="display:none">
                                <input type="text" id="asmReplaceInput" placeholder="Replace (Ctrl+R)" spellcheck="false">
                                <button id="btnAsmReplace" title="Replace">Replace</button>
                                <button id="btnAsmReplaceAll" title="Replace All">All</button>
                            </div>
                            <div class="asm-search-results" id="asmSearchResults" style="display:none"></div>
                        </div>
                        <div class="asm-editor-area">
                            <div class="asm-line-numbers" id="asmLineNumbers"></div>
                            <div class="asm-editor-wrap">
                                <pre class="asm-highlight" id="asmHighlight"></pre>
                                <textarea id="asmEditor" class="asm-textarea" spellcheck="false" placeholder="; Enter Z80 assembly code here
; @entry start
; Example:
        ORG $8000
start:
        LD A, 2
        OUT (254), A
        JP start"></textarea>
                            </div>
                        </div>
                    </div>
                    <div class="asm-output-container">
                        <div class="asm-output-header">Output</div>
                        <div class="asm-output" id="asmOutput"><span class="asm-hint">Press Assemble to compile</span></div>
                    </div>
                </div>
            </div>
        </div><!-- tab-assembler -->

        <!-- Opcodes Tab -->
        <!-- Graphics Viewer Tab -->
        <div class="tab-content" id="tab-graphics">
            <div class="graphics-container">
                <div class="graphics-body">
                    <div class="graphics-dump-wrap">
                        <canvas id="gfxDumpCanvas" class="graphics-dump-canvas"></canvas>
                    </div>
                    <div class="gfx-col-address">
                        <div class="gfx-control-group">
                            <label>Address</label>
                            <input type="text" id="gfxAddress" value="3000" maxlength="4" title="Memory address in hex (Enter to apply)">
                        </div>
                        <div class="gfx-control-group">
                            <label>Navigate</label>
                            <div class="gfx-nav-buttons">
                                <button id="btnGfxByte1" title="Back 1 byte">-1</button>
                                <button id="btnGfxByte2" title="Forward 1 byte">+1</button>
                            </div>
                            <div class="gfx-nav-buttons">
                                <button id="btnGfxLine1" title="Back 1 line">-Line</button>
                                <button id="btnGfxLine2" title="Forward 1 line">+Line</button>
                            </div>
                            <div class="gfx-nav-buttons">
                                <button id="btnGfxRow1" title="Back 8 lines">-Row</button>
                                <button id="btnGfxRow2" title="Forward 8 lines">+Row</button>
                            </div>
                            <div class="gfx-nav-buttons">
                                <button id="btnGfxSprite1" title="Previous sprite">-Spr</button>
                                <button id="btnGfxSprite2" title="Next sprite">+Spr</button>
                            </div>
                            <div class="gfx-nav-buttons">
                                <button id="btnGfxPage1" title="Back 24 rows (192 lines)">-Page</button>
                                <button id="btnGfxPage2" title="Forward 24 rows (192 lines)">+Page</button>
                            </div>
                        </div>
                        <div class="gfx-control-group">
                            <label>Width (bytes)</label>
                            <div class="gfx-spinner">
                                <button id="btnGfxWidthMin" title="Minimum width (1 byte)">|&lt;</button>
                                <button id="btnGfxWidthDec" title="Decrease width">-</button>
                                <input type="text" id="gfxWidth" value="24" maxlength="2" title="Sprite width in bytes (1-32)">
                                <button id="btnGfxWidthInc" title="Increase width">+</button>
                                <button id="btnGfxWidthMax" title="Maximum width (32 bytes)">&gt;|</button>
                            </div>
                        </div>
                        <div class="gfx-control-group">
                            <label>Height (lines)</label>
                            <div class="gfx-spinner">
                                <button id="btnGfxHeightDec8" title="Decrease height by 8 lines">-8</button>
                                <button id="btnGfxHeightDec" title="Decrease height">-</button>
                                <input type="text" id="gfxHeight" value="8" maxlength="2" title="Sprite height in lines (1-64)">
                                <button id="btnGfxHeightInc" title="Increase height">+</button>
                                <button id="btnGfxHeightInc8" title="Increase height by 8 lines">+8</button>
                            </div>
                        </div>
                        <div class="gfx-control-group gfx-checkboxes">
                            <label title="Invert colors (white on black)"><input type="checkbox" id="gfxInvert"> Invert</label>
                            <label title="Show pixel grid overlay"><input type="checkbox" id="gfxGrid" checked> Grid</label>
                            <label title="Character mode: 8x8 tiles stored sequentially"><input type="checkbox" id="gfxCharMode"> Char</label>
                            <div class="gfx-zoom-inline">
                                <label title="1:1 zoom"><input type="radio" name="gfxZoom" id="gfxZoom1" value="1"> x1</label>
                                <label title="2:1 zoom"><input type="radio" name="gfxZoom" id="gfxZoom2" value="2" checked> x2</label>
                                <label title="3:1 zoom"><input type="radio" name="gfxZoom" id="gfxZoom3" value="3"> x3</label>
                            </div>
                        </div>
                        <div class="gfx-control-group">
                            <label>Preview</label>
                            <div class="gfx-preview-wrap">
                                <canvas id="gfxPreviewCanvas" class="gfx-preview-canvas"></canvas>
                            </div>
                            <div class="gfx-info" id="gfxInfo">0000h: 8x8</div>
                        </div>
                    </div>
                    <div class="gfx-col-actions">
                        <div class="gfx-control-group">
                            <label>Comment</label>
                            <input type="text" id="gfxComment" placeholder="Sprite name..." maxlength="40" title="Label for the graphics region">
                        </div>
                        <div class="gfx-control-group gfx-actions">
                            <button id="btnGfxMarkRegion" title="Mark selected area as graphics region">Mark</button>
                            <button id="btnGfxCopyAsm" title="Copy selection as assembly DEFB statements">Copy</button>
                            <button id="btnGfxSaveAsm" title="Save selection as .asm file">Save</button>
                            <button id="btnGfxExportAll" title="Export all marked graphics regions">Export</button>
                        </div>
                        <div class="gfx-control-group gfx-actions">
                            <button id="btnGfxGoDisasm" title="Go to address in Disassembler">→Disasm</button>
                            <button id="btnGfxGoMem" title="Go to address in Memory view">→Memdump</button>
                        </div>
                    </div>
                </div>
            </div>
        </div><!-- tab-graphics -->

        <!-- Info Tab -->
        <div class="tab-content" id="tab-info">
            <div class="info-tab-content">
                <div class="info-subtab-bar">
                    <button class="info-subtab-btn active" data-infotab="io">I/O</button>
                    <button class="info-subtab-btn" data-infotab="timings">Timings</button>
                    <button class="info-subtab-btn" data-infotab="opcodes">Opcodes</button>
                </div>

                <!-- I/O Sub-tab -->
                <div class="info-subtab-content active" id="info-io">
                    <div class="keyboard-image">
                        <img src="keyboard.png" alt="ZX Spectrum Keyboard Layout">
                    </div>

                    <div class="info-section">
                        <h4>Keyboard Port (IN #xxFE)</h4>
                        <p>Read keyboard half-rows via port #FE. High byte selects row(s). <strong>Bit = 0 when key pressed</strong> (active low).</p>
                        <table class="info-table">
                            <thead>
                                <tr><th>High Byte</th><th>Bit 0</th><th>Bit 1</th><th>Bit 2</th><th>Bit 3</th><th>Bit 4</th></tr>
                            </thead>
                            <tbody>
                                <tr><td>#FE (254)</td><td>Shift</td><td>Z</td><td>X</td><td>C</td><td>V</td></tr>
                                <tr><td>#FD (253)</td><td>A</td><td>S</td><td>D</td><td>F</td><td>G</td></tr>
                                <tr><td>#FB (251)</td><td>Q</td><td>W</td><td>E</td><td>R</td><td>T</td></tr>
                                <tr><td>#F7 (247)</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td></tr>
                                <tr><td>#EF (239)</td><td>0</td><td>9</td><td>8</td><td>7</td><td>6</td></tr>
                                <tr><td>#DF (223)</td><td>P</td><td>O</td><td>I</td><td>U</td><td>Y</td></tr>
                                <tr><td>#BF (191)</td><td>Enter</td><td>L</td><td>K</td><td>J</td><td>H</td></tr>
                                <tr><td>#7F (127)</td><td>Space</td><td>Sym</td><td>M</td><td>N</td><td>B</td></tr>
                            </tbody>
                        </table>
                        <p>Bits 5-7 always return 1. Multiple rows can be scanned at once (AND high bytes together).</p>
                    </div>

                    <div class="info-section">
                        <h4>Kempston Joystick (IN #1F / #DF)</h4>
                        <p>Read joystick state via port #1F (or #DF). <strong>Bit = 1 when pressed</strong> (active high — opposite to keyboard!).</p>
                        <table class="info-table">
                            <thead>
                                <tr><th>Bit</th><th>Direction/Button</th></tr>
                            </thead>
                            <tbody>
                                <tr><td>0</td><td>Right</td></tr>
                                <tr><td>1</td><td>Left</td></tr>
                                <tr><td>2</td><td>Down</td></tr>
                                <tr><td>3</td><td>Up</td></tr>
                                <tr><td>4</td><td>Fire</td></tr>
                                <tr><td>5-7</td><td>Not used (typically 0)</td></tr>
                            </tbody>
                        </table>
                    </div>

                    <div class="info-section">
                        <h4>Kempston Mouse</h4>
                        <p>Mouse interface uses three ports:</p>
                        <table class="info-table">
                            <thead>
                                <tr><th>Port</th><th>Function</th><th>Notes</th></tr>
                            </thead>
                            <tbody>
                                <tr><td>#FBDF</td><td>Buttons</td><td>Bit 0=Right, Bit 1=Left, Bit 2=Middle (active low: 0=pressed)</td></tr>
                                <tr><td>#FFDF</td><td>X position</td><td>0-255, wraps around</td></tr>
                                <tr><td>#FADF</td><td>Y position</td><td>0-255, wraps around</td></tr>
                            </tbody>
                        </table>
                    </div>

                    <div class="info-section">
                        <h4>Input State Summary</h4>
                        <table class="info-table">
                            <thead>
                                <tr><th>Device</th><th>Pressed State</th><th>Not Pressed</th></tr>
                            </thead>
                            <tbody>
                                <tr><td>Keyboard</td><td><strong>0</strong> (active low)</td><td>1</td></tr>
                                <tr><td>Kempston Joystick</td><td><strong>1</strong> (active high)</td><td>0</td></tr>
                                <tr><td>Kempston Mouse buttons</td><td><strong>0</strong> (active low)</td><td>1</td></tr>
                            </tbody>
                        </table>
                    </div>

                    <div class="info-section">
                        <h4>Border/Attribute Colors</h4>
                        <table class="info-table">
                            <thead>
                                <tr><th>Value</th><th>Color</th><th>Bright</th></tr>
                            </thead>
                            <tbody>
                                <tr><td>0</td><td style="color:#000">Black</td><td style="color:#000">Black</td></tr>
                                <tr><td>1</td><td style="color:#0000D7">Blue</td><td style="color:#0000FF">Bright Blue</td></tr>
                                <tr><td>2</td><td style="color:#D70000">Red</td><td style="color:#FF0000">Bright Red</td></tr>
                                <tr><td>3</td><td style="color:#D700D7">Magenta</td><td style="color:#FF00FF">Bright Magenta</td></tr>
                                <tr><td>4</td><td style="color:#00D700">Green</td><td style="color:#00FF00">Bright Green</td></tr>
                                <tr><td>5</td><td style="color:#00D7D7">Cyan</td><td style="color:#00FFFF">Bright Cyan</td></tr>
                                <tr><td>6</td><td style="color:#D7D700">Yellow</td><td style="color:#FFFF00">Bright Yellow</td></tr>
                                <tr><td>7</td><td style="color:#D7D7D7">White</td><td style="color:#FFFFFF">Bright White</td></tr>
                            </tbody>
                        </table>
                        <p>Border: bits 0-2 of port #FE. Attributes: INK (bits 0-2), PAPER (bits 3-5), BRIGHT (bit 6), FLASH (bit 7).</p>
                    </div>

                    <div class="info-section">
                        <h4>ULAplus (Extended Palette)</h4>
                        <p>ULAplus extends the Spectrum to 64 simultaneous colors from a 256-color palette.</p>
                        <table class="info-table">
                            <thead>
                                <tr><th>Port</th><th>Function</th><th>Access</th></tr>
                            </thead>
                            <tbody>
                                <tr><td>#BF3B</td><td>Register select</td><td>Write only</td></tr>
                                <tr><td>#FF3B</td><td>Data port</td><td>Read/Write</td></tr>
                            </tbody>
                        </table>
                        <p><strong>Register port (#BF3B) format:</strong></p>
                        <table class="info-table">
                            <thead>
                                <tr><th>Bits</th><th>Function</th></tr>
                            </thead>
                            <tbody>
                                <tr><td>7-6</td><td>Group: 00=Palette, 01=Mode</td></tr>
                                <tr><td>5-0</td><td>Palette entry (0-63) when group=00</td></tr>
                            </tbody>
                        </table>
                        <p><strong>Palette data format (GRB):</strong></p>
                        <table class="info-table">
                            <thead>
                                <tr><th>Bits</th><th>Color</th><th>Range</th></tr>
                            </thead>
                            <tbody>
                                <tr><td>7-5</td><td>Green</td><td>0-7</td></tr>
                                <tr><td>4-2</td><td>Red</td><td>0-7</td></tr>
                                <tr><td>1-0</td><td>Blue</td><td>0-3 (expanded to 0-7)</td></tr>
                            </tbody>
                        </table>
                        <p>Blue expansion: 00→000, 01→011, 10→101, 11→111</p>
                        <p><strong>Palette organization (4 CLUTs × 16 colors):</strong></p>
                        <table class="info-table">
                            <thead>
                                <tr><th>Entry</th><th>CLUT</th><th>Type</th><th>Index</th></tr>
                            </thead>
                            <tbody>
                                <tr><td>0-7</td><td>0</td><td>INK</td><td>Attr bits 0-2</td></tr>
                                <tr><td>8-15</td><td>0</td><td>PAPER</td><td>Attr bits 3-5</td></tr>
                                <tr><td>16-23</td><td>1</td><td>INK</td><td>BRIGHT=1</td></tr>
                                <tr><td>24-31</td><td>1</td><td>PAPER</td><td>BRIGHT=1</td></tr>
                                <tr><td>32-39</td><td>2</td><td>INK</td><td>FLASH=1</td></tr>
                                <tr><td>40-47</td><td>2</td><td>PAPER</td><td>FLASH=1</td></tr>
                                <tr><td>48-55</td><td>3</td><td>INK</td><td>FLASH=1, BRIGHT=1</td></tr>
                                <tr><td>56-63</td><td>3</td><td>PAPER</td><td>FLASH=1, BRIGHT=1</td></tr>
                            </tbody>
                        </table>
                        <p>CLUT selection: <code>(FLASH × 2 + BRIGHT)</code>. Border uses PAPER color from CLUT 0.</p>
                        <p><strong>Mode register (group=01):</strong> Bit 0 = ULAplus on/off, Bit 1 = Grayscale mode.</p>
                        <p><strong>Raster effects:</strong> HAM256 and similar demos that update palette mid-frame are fully supported. The emulator tracks palette writes with T-state timing and applies them per 16-line group.</p>
                    </div>

                    <div class="info-section">
                        <h4>AY-3-8910 Sound Chip (128K)</h4>
                        <p>The AY sound chip is clocked at 1.7734 MHz on 128K models.</p>
                        <table class="info-table">
                            <thead>
                                <tr><th>Port</th><th>Function</th><th>Access</th></tr>
                            </thead>
                            <tbody>
                                <tr><td>#FFFD</td><td>Register select / read</td><td>Read/Write</td></tr>
                                <tr><td>#BFFD</td><td>Data write</td><td>Write only</td></tr>
                            </tbody>
                        </table>
                        <p><strong>Registers:</strong></p>
                        <table class="info-table">
                            <thead>
                                <tr><th>Reg</th><th>Function</th><th>Bits</th></tr>
                            </thead>
                            <tbody>
                                <tr><td>0</td><td>Channel A pitch fine</td><td>8</td></tr>
                                <tr><td>1</td><td>Channel A pitch coarse</td><td>4</td></tr>
                                <tr><td>2</td><td>Channel B pitch fine</td><td>8</td></tr>
                                <tr><td>3</td><td>Channel B pitch coarse</td><td>4</td></tr>
                                <tr><td>4</td><td>Channel C pitch fine</td><td>8</td></tr>
                                <tr><td>5</td><td>Channel C pitch coarse</td><td>4</td></tr>
                                <tr><td>6</td><td>Noise pitch</td><td>5</td></tr>
                                <tr><td>7</td><td>Mixer control</td><td>8</td></tr>
                                <tr><td>8</td><td>Channel A volume</td><td>5</td></tr>
                                <tr><td>9</td><td>Channel B volume</td><td>5</td></tr>
                                <tr><td>10</td><td>Channel C volume</td><td>5</td></tr>
                                <tr><td>11</td><td>Envelope period fine</td><td>8</td></tr>
                                <tr><td>12</td><td>Envelope period coarse</td><td>8</td></tr>
                                <tr><td>13</td><td>Envelope shape</td><td>4</td></tr>
                            </tbody>
                        </table>
                        <p><strong>Mixer (R7):</strong> Bit 0-2 = Tone off (A,B,C), Bit 3-5 = Noise off (A,B,C)</p>
                        <p><strong>Volume (R8-10):</strong> Bit 4 = Envelope mode, Bits 0-3 = Volume (0-15)</p>
                        <p><strong>Envelope shapes (R13):</strong></p>
                        <table class="info-table">
                            <thead>
                                <tr><th>Value</th><th>Shape</th><th>Description</th></tr>
                            </thead>
                            <tbody>
                                <tr><td>0-3</td><td>\___</td><td>Decay, hold low</td></tr>
                                <tr><td>4-7</td><td>/___</td><td>Attack, hold low</td></tr>
                                <tr><td>8</td><td>\\\\</td><td>Decay (sawtooth)</td></tr>
                                <tr><td>9</td><td>\___</td><td>Decay, hold low</td></tr>
                                <tr><td>10</td><td>\/\/</td><td>Decay-attack (triangle)</td></tr>
                                <tr><td>11</td><td>\¯¯¯</td><td>Decay, hold high</td></tr>
                                <tr><td>12</td><td>////</td><td>Attack (sawtooth)</td></tr>
                                <tr><td>13</td><td>/¯¯¯</td><td>Attack, hold high</td></tr>
                                <tr><td>14</td><td>/\/\</td><td>Attack-decay (triangle)</td></tr>
                                <tr><td>15</td><td>/___</td><td>Attack, hold low</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- Timings Sub-tab -->
                <div class="info-subtab-content" id="info-timings">
                    <div class="info-section">
                        <h4>Frame Timing</h4>
                        <table class="info-table">
                            <thead>
                                <tr><th>Parameter</th><th>48K</th><th>128K/+2/+2A</th><th>Pentagon/Scorpion</th></tr>
                            </thead>
                            <tbody>
                                <tr><td>T-states per line</td><td>224</td><td>228</td><td>224</td></tr>
                                <tr><td>Lines per frame</td><td>312</td><td>311</td><td>320</td></tr>
                                <tr><td>T-states per frame</td><td>69888</td><td>70908</td><td>71680</td></tr>
                                <tr><td>Frame rate (Hz)</td><td>50.08</td><td>50.02</td><td>48.83</td></tr>
                                <tr><td>CPU clock (MHz)</td><td>3.5</td><td>3.5469</td><td>3.5</td></tr>
                                <tr><td>First screen line</td><td>64</td><td>63</td><td>80</td></tr>
                                <tr><td>INT length (T)</td><td>32</td><td>32</td><td>32</td></tr>
                            </tbody>
                        </table>
                    </div>

                    <div class="info-section">
                        <h4>Border Sizes (pixels)</h4>
                        <table class="info-table">
                            <thead>
                                <tr><th>Border</th><th>48K</th><th>128K/+2/+2A</th><th>Pentagon/Scorpion</th></tr>
                            </thead>
                            <tbody>
                                <tr><td>Top (lines)</td><td>64</td><td>63</td><td>80</td></tr>
                                <tr><td>Bottom (lines)</td><td>56</td><td>56</td><td>48</td></tr>
                                <tr><td>Left (pixels)</td><td>48</td><td>48</td><td>48</td></tr>
                                <tr><td>Right (pixels)</td><td>48</td><td>48</td><td>48</td></tr>
                                <tr><td>Total visible width</td><td>352</td><td>352</td><td>352</td></tr>
                                <tr><td>Total visible height</td><td>312</td><td>311</td><td>320</td></tr>
                            </tbody>
                        </table>
                    </div>

                    <div class="info-section">
                        <h4>Memory Map (128K/+2/+2A/Pentagon/Scorpion)</h4>
                        <table class="info-table">
                            <thead>
                                <tr><th>Address</th><th>Content</th><th>Contention (128K/+2)</th><th>Contention (+2A)</th></tr>
                            </thead>
                            <tbody>
                                <tr><td>0000-3FFF</td><td>ROM (128K: 0-1, +2A/Scorpion: 0-3)</td><td>No</td><td>No</td></tr>
                                <tr><td>4000-7FFF</td><td>RAM Bank 5 (Screen)</td><td class="contended">Yes (always)</td><td class="contended">Yes (always)</td></tr>
                                <tr><td>8000-BFFF</td><td>RAM Bank 2</td><td>No</td><td>No</td></tr>
                                <tr><td>C000-FFFF</td><td>RAM Bank 0-7 (paged)</td><td>Odd banks only</td><td>Banks 4-7 only</td></tr>
                            </tbody>
                        </table>
                    </div>

                    <div class="info-section">
                        <h4>RAM Banks Contention</h4>
                        <table class="info-table">
                            <thead>
                                <tr><th>Bank</th><th>128K/+2</th><th>+2A</th><th>Notes</th></tr>
                            </thead>
                            <tbody>
                                <tr><td>0</td><td>No</td><td>No</td><td>Default at C000</td></tr>
                                <tr><td>1</td><td class="contended">Yes</td><td>No</td><td></td></tr>
                                <tr><td>2</td><td>No</td><td>No</td><td>Always at 8000</td></tr>
                                <tr><td>3</td><td class="contended">Yes</td><td>No</td><td></td></tr>
                                <tr><td>4</td><td>No</td><td class="contended">Yes</td><td></td></tr>
                                <tr><td>5</td><td class="contended">Yes</td><td class="contended">Yes</td><td>Always at 4000 (screen 0)</td></tr>
                                <tr><td>6</td><td>No</td><td class="contended">Yes</td><td></td></tr>
                                <tr><td>7</td><td class="contended">Yes</td><td class="contended">Yes</td><td>Screen 1 (when selected)</td></tr>
                            </tbody>
                        </table>
                    </div>

                    <div class="info-section">
                        <h4>Contention Pattern</h4>
                        <p><strong>48K:</strong> Screen lines use 192 T-states for drawing. Memory contention occurs when CPU accesses 4000-7FFF during screen drawing (lines 64-255, T-states 14-126).</p>
                        <p><strong>128K/+2:</strong> Screen lines use 196 T-states for drawing (228 total per line). Contended banks: 1, 3, 5, 7 (odd).</p>
                        <p><strong>+2A:</strong> Same timing as 128K. Contended banks: 4, 5, 6, 7 (high). In special paging mode, contention applies per-slot based on the mapped bank.</p>
                        <p>Pattern repeats every 8 T-states: <code>6, 5, 4, 3, 2, 1, 0, 0</code> (delay in T-states)</p>
                        <p>I/O contention: ULA port (xxFE) also causes delays when accessed during screen time.</p>
                    </div>

                    <div class="info-section">
                        <h4>+2A Differences (vs 128K)</h4>
                        <ul>
                            <li>4 ROM banks (64KB) selected via ports 0x7FFD bit 4 + 0x1FFD bit 2</li>
                            <li>Port 0x1FFD: special paging, ROM high bit, disk motor</li>
                            <li>4 special all-RAM paging modes (port 0x1FFD bit 0 = 1)</li>
                            <li>Different contended banks: 4, 5, 6, 7 (not 1, 3, 5, 7)</li>
                            <li>48K BASIC ROM in bank 3 (not bank 1)</li>
                        </ul>
                    </div>

                    <div class="info-section">
                        <h4>Pentagon Differences</h4>
                        <ul>
                            <li>No memory or I/O contention</li>
                            <li>320 lines per frame (more top border)</li>
                            <li>TR-DOS ROM pages in/out via 3Dxx trigger</li>
                            <li>Beta Disk interface at ports 1F, 3F, 5F, 7F, FF</li>
                        </ul>
                    </div>

                    <div class="info-section">
                        <h4>Scorpion ZS 256 Differences</h4>
                        <ul>
                            <li>256KB RAM (16 pages), Pentagon-compatible ULA timing</li>
                            <li>4 ROM banks: ROM0=128 BASIC, ROM1=48 BASIC, ROM2=Service Monitor, ROM3=TR-DOS</li>
                            <li>Port 0x7FFD: standard 128K paging (RAM 0-7, ROM 0/1, screen, lock)</li>
                            <li>Port 0x1FFD: bit 0 = RAM over ROM, bit 1 = ROM 2 select, bit 4 = RAM page +8</li>
                            <li>ROM selection (3-way): 1FFD.1 set → ROM 2; unset → 7FFD.4 selects ROM 0/1</li>
                            <li>TR-DOS built into ROM bank 3 (no separate trdos.rom needed)</li>
                            <li>No memory or I/O contention (same as Pentagon)</li>
                        </ul>
                    </div>
                </div>

                <!-- Opcodes Sub-tab -->
                <div class="info-subtab-content" id="info-opcodes">
                    <div class="opcodes-container">
                        <div class="opcodes-header">
                            <h3>Z80 Instruction Set Reference</h3>
                            <div class="opcodes-filter">
                                <input type="text" id="opcodeSearch" placeholder="Search opcode..." class="opcode-search">
                                <select id="opcodeGroup">
                                    <option value="all">All Groups</option>
                                    <option value="load">Load (LD)</option>
                                    <option value="arith">Arithmetic</option>
                                    <option value="logic">Logic</option>
                                    <option value="rotate">Rotate/Shift</option>
                                    <option value="bit">Bit Operations</option>
                                    <option value="jump">Jump/Call</option>
                                    <option value="io">I/O</option>
                                    <option value="block">Block</option>
                                    <option value="misc">Misc</option>
                                </select>
                                <select id="opcodeCycles">
                                    <option value="all">All T-states</option>
                                </select>
                                <select id="opcodeSort">
                                    <option value="mnemonic">Sort: Mnemonic</option>
                                    <option value="opcode">Sort: Opcode</option>
                                </select>
                            </div>
                        </div>
                        <div class="opcodes-body">
                            <table class="opcodes-table" id="opcodesTable">
                                <thead>
                                    <tr>
                                        <th>Mnemonic</th>
                                        <th>Opcode</th>
                                        <th>Size</th>
                                        <th>Cycles</th>
                                        <th>Flags</th>
                                        <th>Description</th>
                                    </tr>
                                </thead>
                                <tbody id="opcodesBody">
                                </tbody>
                            </table>
                        </div>
                        <div class="opcodes-footer">
                            <div class="flags-legend">
                                <span><b>Flags:</b></span>
                                <span>S=Sign</span>
                                <span>Z=Zero</span>
                                <span>H=Half-carry</span>
                                <span>P=Parity/Overflow</span>
                                <span>N=Subtract</span>
                                <span>C=Carry</span>
                                <span class="flag-symbol">*=affected</span>
                                <span class="flag-symbol">-=unchanged</span>
                                <span class="flag-symbol">0=reset</span>
                                <span class="flag-symbol">1=set</span>
                                <span class="flag-symbol">?=undefined</span>
                                <span style="color:#c080ff; margin-left:10px;"><b>*</b>=undocumented</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div><!-- tab-info -->

        <!-- Settings Tab -->
        <div class="tab-content" id="tab-settings">
            <div class="settings-subtab-bar">
                <button class="settings-subtab-btn active" data-settingstab="display">Display</button>
                <button class="settings-subtab-btn" data-settingstab="input">Input</button>
                <button class="settings-subtab-btn" data-settingstab="media">Media</button>
                <button class="settings-subtab-btn" data-settingstab="audio">Audio</button>
                <button class="settings-subtab-btn" data-settingstab="machines">Machines</button>
                <button class="settings-subtab-btn" data-settingstab="signatures">Signatures</button>
            </div>

            <!-- Display Sub-tab -->
            <div class="settings-subtab-content active" id="settings-display">
            <div class="settings-tab-content">
                <div class="settings-section">
                    <div class="settings-row">
                        <select id="borderSizeSelect" title="Border size preset">
                            <option value="full" selected>Full border (352x312)</option>
                            <option value="normal">Normal (320x240)</option>
                            <option value="thick">Thick (352x288)</option>
                            <option value="medium">Medium (320x256)</option>
                            <option value="small">Small (288x224)</option>
                            <option value="none">None (256x192)</option>
                        </select>
                        <label class="checkbox-label" title="Invert screen colors" style="margin-left: 15px;">
                            <input type="checkbox" id="chkInvertDisplay"> Invert
                        </label>
                        <select id="overlaySelect" style="margin-left: 15px;" title="Overlay display mode">
                            <option value="normal" selected>Normal</option>
                            <option value="grid">Grid</option>
                            <option value="box">Box</option>
                            <option value="screen">Screen</option>
                            <option value="reveal">Reveal</option>
                            <option value="beam">Beam</option>
                            <option value="beamscreen">BeamScreen</option>
                            <option value="noattr">No Attr</option>
                            <option value="nobitmap">No Bitmap</option>
                        </select>
                        <span class="zoom-group" style="margin-left: 15px;">
                            Zoom:
                            <button id="zoom1" class="zoom-btn active" title="Zoom 1x">x1</button>
                            <button id="zoom2" class="zoom-btn" title="Zoom 2x">x2</button>
                            <button id="zoom3" class="zoom-btn" title="Zoom 3x">x3</button>
                        </span>
                    </div>
                    <div class="settings-row">
                        <label for="paletteSelect">Color Palette:</label>
                        <select id="paletteSelect">
                            <option value="default">Default</option>
                        </select>
                        <span style="margin-left: 15px;">
                            <label for="fullscreenMode">Fullscreen:</label>
                            <select id="fullscreenMode" title="Fullscreen aspect ratio mode">
                                <option value="crisp" selected>Crisp (integer scale)</option>
                                <option value="fit">Fit (keep aspect ratio)</option>
                                <option value="stretch">Stretch (fill screen)</option>
                            </select>
                        </span>
                    </div>
                    <div class="palette-preview" id="palettePreview">
                        <div class="palette-row">
                            <span class="palette-row-label">Normal</span>
                            <span class="palette-color" data-index="0"></span>
                            <span class="palette-color" data-index="1"></span>
                            <span class="palette-color" data-index="2"></span>
                            <span class="palette-color" data-index="3"></span>
                            <span class="palette-color" data-index="4"></span>
                            <span class="palette-color" data-index="5"></span>
                            <span class="palette-color" data-index="6"></span>
                            <span class="palette-color" data-index="7"></span>
                        </div>
                        <div class="palette-row">
                            <span class="palette-row-label">Bright</span>
                            <span class="palette-color" data-index="0" data-bright="true"></span>
                            <span class="palette-color" data-index="1" data-bright="true"></span>
                            <span class="palette-color" data-index="2" data-bright="true"></span>
                            <span class="palette-color" data-index="3" data-bright="true"></span>
                            <span class="palette-color" data-index="4" data-bright="true"></span>
                            <span class="palette-color" data-index="5" data-bright="true"></span>
                            <span class="palette-color" data-index="6" data-bright="true"></span>
                            <span class="palette-color" data-index="7" data-bright="true"></span>
                        </div>
                    </div>
                    <div class="settings-row" style="margin-top: 10px;">
                        <label class="checkbox-label" title="Enable ULAplus extended palette support (64 colors)">
                            <input type="checkbox" id="chkULAplus"> ULA+
                        </label>
                        <button id="btnResetULAplus" style="margin-left: 10px; padding: 2px 8px; font-size: 11px;" title="Reset ULAplus palette to defaults">Reset</button>
                        <span id="ulaplusStatus" style="margin-left: 10px; color: var(--text-dim); font-size: 11px;"></span>
                    </div>
                    <div class="ulaplus-palette-preview hidden" id="ulaplusPalettePreview">
                        <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">ULA+ Palette (4 CLUTs × 16 colors)</div>
                        <div class="ulaplus-palette-grid" id="ulaplusPaletteGrid"></div>
                    </div>
                </div>
            </div>
            </div><!-- settings-display -->

            <!-- Input Sub-tab -->
            <div class="settings-subtab-content" id="settings-input">
            <div class="settings-tab-content">
                <div class="settings-section">
                    <div class="settings-row">
                        <label class="checkbox-label">
                            <input type="checkbox" id="chkKempston"> Kempston Joystick (Numpad)
                        </label>
                        <label class="checkbox-label" title="Extended buttons: [ = C, ] = A, \ = Start" style="margin-left: 15px;">
                            <input type="checkbox" id="chkKempstonExtended"> Extended
                        </label>
                        <label class="checkbox-label" title="Use USB/Bluetooth gamepad for Kempston joystick" style="margin-left: 15px;">
                            <input type="checkbox" id="chkGamepad"> Gamepad
                        </label>
                        <button id="btnCalibrateGamepad" class="small-btn" style="margin-left: 5px; padding: 2px 6px; font-size: 11px;" title="Configure gamepad mapping">Calibrate</button>
                        <span id="gamepadStatus" style="margin-left: 5px; color: var(--text-dim); font-size: 11px;"></span>
                    </div>
                    <div class="settings-row">
                        <label class="checkbox-label" title="Click screen to capture mouse, Escape to release">
                            <input type="checkbox" id="chkKempstonMouse"> Kempston Mouse
                        </label>
                        <label class="checkbox-label" title="Mouse wheel on bits 7:4 of button port" style="margin-left: 15px;">
                            <input type="checkbox" id="chkMouseWheel"> Wheel
                        </label>
                        <label class="checkbox-label" title="Swap left/right mouse buttons (bit0↔bit1)" style="margin-left: 15px;">
                            <input type="checkbox" id="chkMouseSwap"> Swap L/R
                        </label>
                        <span id="mouseStatus" style="margin-left: 10px; color: var(--text-dim); font-size: 11px;"></span>
                    </div>
                </div>
            </div>
            </div><!-- settings-input -->

            <!-- Media Sub-tab -->
            <div class="settings-subtab-content" id="settings-media">
            <div class="settings-tab-content">
                <div class="settings-section">
                    <div class="settings-row">
                        <label style="min-width: 80px;">Last File:</label>
                        <span id="lastLoadedFile" style="color: var(--cyan); font-size: 11px;">—</span>
                    </div>
                    <div class="settings-row">
                        <label class="checkbox-label" title="Flash load = instant (trap), unchecked = real-time with border stripes and sound">
                            <input type="checkbox" id="chkFlashLoad" checked> Flash Load
                        </label>
                        <span id="tapeLoadMode" style="margin-left: 10px; color: var(--text-dim); font-size: 11px;">(instant)</span>
                        <label class="checkbox-label" title="Enable tape loading sounds (real-time mode)" style="margin-left: 15px;">
                            <input type="checkbox" id="chkTapeAudio" checked> Tape Sound
                        </label>
                        <label class="checkbox-label" title="Automatically type LOAD &quot;&quot; for tape files, boot TR-DOS for disk images" style="margin-left: 15px;">
                            <input type="checkbox" id="chkAutoLoad" checked> Auto Load
                        </label>
                    </div>
                    <div class="settings-row">
                        <button id="btnTapePlay" class="control-btn" title="Play tape (real-time mode)">▶ Play</button>
                        <button id="btnTapeStop" class="control-btn" title="Stop tape playback" style="margin-left: 5px;">⏹ Stop</button>
                        <button id="btnTapeRewind" class="control-btn" title="Rewind tape to beginning" style="margin-left: 5px;">⏪ Rewind</button>
                        <span id="tapePosition" style="margin-left: 10px; color: var(--cyan); font-size: 11px;"></span>
                    </div>
                    <div class="settings-row">
                        <button id="btnBlankDisk" class="control-btn" title="Insert blank formatted disk">💾 Blank Disk</button>
                    </div>
                    <div class="settings-row" style="margin-top: 10px;">
                        <label for="bootTrdMode" style="min-width: 80px;">Boot File:</label>
                        <select id="bootTrdMode" style="width: 120px;" title="How to handle boot file when loading TRD images">
                            <option value="none">No change</option>
                            <option value="add">Add boot</option>
                            <option value="replace">Replace boot</option>
                        </select>
                        <button id="btnSelectBootTrd" class="control-btn" style="margin-left: 10px;" title="Select TRD or Hobeta file containing boot file">Select...</button>
                        <input type="file" id="bootTrdFile" accept=".trd,.$c,.$b,.$d,.$#,.hobeta" style="display: none;">
                    </div>
                    <div class="settings-row">
                        <span id="bootTrdName" style="color: var(--text-dim); font-size: 11px; margin-left: 80px;">No boot file selected</span>
                    </div>
                    <div class="settings-row" id="driveSelector" style="display: none;">
                        <label>Target drive:</label>
                        <select id="driveSelectorSelect" style="margin-left: 4px; font-size: 11px;">
                            <option value="0">A:</option>
                            <option value="1">B:</option>
                            <option value="2">C:</option>
                            <option value="3">D:</option>
                        </select>
                    </div>
                    <div id="mediaCatalogContainer" style="display: none; margin-top: 6px;">
                        <div class="media-catalog-bar" id="mediaCatalogBar">
                            <button class="media-catalog-btn" id="mediaCatalogTapeBtn" data-catalog="tape" style="display: none;">Tape</button>
                            <button class="media-catalog-btn" id="mediaCatalogDiskBtn" data-catalog="disk" style="display: none;">Disk</button>
                            <span id="diskDriveTabs" style="display: none; margin-left: 4px;">
                                <!-- Drive tabs are dynamically generated by updateDiskDriveTabs() -->
                            </span>
                        </div>
                        <div id="tapeCatalog" style="max-height: 150px; overflow-y: auto; font-family: monospace; font-size: 11px; display: none; border: 1px solid var(--border); border-top: none; border-radius: 0 0 3px 3px; padding: 2px 0;"></div>
                        <div id="diskCatalog" style="max-height: 150px; overflow-y: auto; font-family: monospace; font-size: 11px; display: none; border: 1px solid var(--border); border-top: none; border-radius: 0 0 3px 3px; padding: 2px 0;"></div>
                    </div>
                </div>
            </div>
            </div><!-- settings-media -->

            <!-- Audio Sub-tab -->
            <div class="settings-subtab-content" id="settings-audio">
            <div class="settings-tab-content">
                <div class="settings-section">
                    <div class="settings-row">
                        <label class="checkbox-label" title="Enable AY-3-8910 sound output">
                            <input type="checkbox" id="chkSound"> Sound
                        </label>
                        <label class="checkbox-label" title="Enable AY chip in 48K mode (like Melodik interface)" style="margin-left: 15px;">
                            <input type="checkbox" id="chkAY48k"> AY in 48K
                        </label>
                        <button id="btnMute" class="control-btn" style="margin-left: 15px;" title="Mute/unmute sound">🔊</button>
                    </div>
                    <div class="settings-row">
                        <label for="volumeSlider" style="min-width: 60px;">Volume:</label>
                        <input type="range" id="volumeSlider" min="0" max="100" value="50" style="width: 120px;">
                        <span id="volumeValue" style="min-width: 35px; text-align: right;">50%</span>
                    </div>
                    <div class="settings-row">
                        <label for="stereoMode">Stereo:</label>
                        <select id="stereoMode" title="Stereo panning mode">
                            <option value="mono">Mono</option>
                            <option value="abc" selected>ABC (A-left, B-center, C-right)</option>
                            <option value="acb">ACB (A-left, C-center, B-right)</option>
                        </select>
                    </div>
                </div>
            </div>
            </div><!-- settings-audio -->

            <!-- Machines Sub-tab -->
            <div class="settings-subtab-content" id="settings-machines">
            <div class="settings-tab-content">
                <div class="settings-section">
                    <div style="margin-bottom: 8px; color: var(--text-secondary); font-size: 11px;">Choose which machines appear in the toolbar dropdown:</div>
                    <div id="machineCheckboxes"></div>
                    <button id="btnSettingsLoadRoms" style="margin-top: 8px;">Load ROMs...</button>
                    <label class="checkbox-label" title="Late ULA timing (warm ULA behavior, +1 T-state shift). Real ULAs drift from early to late as they warm up." style="margin-top: 8px; display: inline-block;">
                        <input type="checkbox" id="chkLateTimings"> Late Timings
                    </label>
                    <div style="margin-top: 4px;">
                        <label class="checkbox-label" title="Enable Beta Disk interface for TR-DOS (requires trdos.rom). Always enabled for Pentagon." style="display: inline-block;">
                            <input type="checkbox" id="chkBetaDisk"> Beta Disk (TR-DOS)
                        </label>
                        <span id="betaDiskStatus" style="margin-left: 10px; color: var(--text-dim); font-size: 11px;"></span>
                    </div>
                </div>
            </div>
            </div><!-- settings-machines -->

            <!-- Signatures Sub-tab -->
            <div class="settings-subtab-content" id="settings-signatures">
            <div class="settings-tab-content">
                <div class="settings-section">
                    <div style="margin-bottom: 8px; color: var(--text-secondary); font-size: 11px;">Signature packs for automatic label/region recognition:</div>
                    <div class="settings-row" style="margin-bottom: 6px;">
                        <button id="btnSigImportSkool" title="Import .skool or .asm files from disk">Import File</button>
                        <button id="btnSigImportPack" title="Import a signature pack JSON file from disk">Import Pack</button>
                        <button id="btnSigGitHub" title="Browse a GitHub repository for disassembly sources (.asm, .skool, .a80, .json)">GitHub</button>
                        <button id="btnSigScanMemory" title="Scan current memory for matching signatures">Scan Memory</button>
                    </div>
                    <div id="sigGitHubBrowser" class="hidden" style="margin-top: 6px; padding: 6px 8px; background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: 3px;">
                        <div style="display: flex; gap: 6px; align-items: center; margin-bottom: 6px;">
                            <input id="sigGitHubUrl" type="text" placeholder="GitHub repo URL or owner/repo" style="flex: 1; padding: 4px 8px; font-size: 11px; background: var(--bg-primary); color: var(--text-primary); border: 1px solid var(--bg-button); border-radius: 3px;">
                            <button id="btnSigGitHubFetch" style="font-size: 11px; padding: 3px 10px;">Browse</button>
                            <button id="btnSigGitHubClose" style="font-size: 11px; padding: 3px 6px;" title="Close">&times;</button>
                        </div>
                        <div id="sigGitHubStatus" style="font-size: 10px; color: var(--text-secondary); margin-bottom: 4px;"></div>
                        <div id="sigGitHubFileList" style="max-height: 200px; overflow-y: auto;"></div>
                        <div id="sigGitHubActions" class="hidden" style="margin-top: 6px; display: flex; gap: 6px; align-items: center;">
                            <button id="btnSigGitHubImport" style="font-size: 11px; padding: 3px 10px;">Import Selected</button>
                            <span id="sigGitHubSelected" style="font-size: 10px; color: var(--text-secondary);"></span>
                        </div>
                    </div>
                    <div id="sigPackList" style="margin-top: 6px;"></div>
                    <div id="sigScanResults" class="hidden" style="margin-top: 8px; padding: 6px 8px; background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: 3px; font-size: 11px; max-height: 33vh; overflow-y: auto;"></div>
                </div>
            </div>
            </div><!-- settings-signatures -->

        </div><!-- tab-settings -->

        <!-- Tools Tab -->
        <div class="tab-content" id="tab-tools">
            <div class="tools-subtab-bar">
                <button class="tools-subtab-btn active" data-toolstab="explorer">Explorer</button>
                <button class="tools-subtab-btn" data-toolstab="compare">Compare</button>
                <button class="tools-subtab-btn" data-toolstab="tests">Tests</button>
                <button class="tools-subtab-btn" data-toolstab="export">Export</button>
            </div>

            <!-- Tests Sub-tab -->
            <div class="tools-subtab-content" id="tools-tests">
            <div class="tests-container">
                <!-- Controls Row -->
                <div class="tests-controls">
                    <button id="btnRunSelectedTests" class="tests-btn primary" disabled>Run Selected</button>
                    <button id="btnPreviewTest" class="tests-btn" disabled>Preview</button>
                    <button id="btnAbortTests" class="tests-btn danger hidden">Abort</button>
                    <button id="btnReloadTests" class="tests-btn">Reload</button>
                    <label class="tests-checkbox-label" title="Highlight pixel differences with semi-transparent overlay">
                        <input type="checkbox" id="chkHighlightDiff"> Highlight Diff
                    </label>
                    <a href="system-test.html" class="test-link" title="Run system tests">System Tests</a>
                    <a href="fuse-test.html" class="test-link" title="Run FUSE Z80 CPU tests">FUSE Tests</a>
                    <a href="asm-test.html" class="test-link" title="Run assembler tests">Assembler Tests</a>
                    <span class="tests-status" id="testsStatus">Loading tests...</span>
                </div>

                <!-- Developer Note -->
                <div class="tests-note">This functionality is intended for emulator developers only, not for end users.</div>

                <!-- Test List -->
                <div class="tests-list-container">
                    <div class="tests-category-tabs" id="testsCategoryTabs">
                        <button class="tests-category-tab active" data-category="all">All</button>
                        <button class="tests-category-tab" data-category="cpu">CPU</button>
                        <button class="tests-category-tab" data-category="video">Video</button>
                        <button class="tests-category-tab" data-category="ulaplus">ULA+</button>
                        <button class="tests-category-tab" data-category="multicolor">Multicolor</button>
                        <button class="tests-category-tab" data-category="rzx">RZX</button>
                    </div>
                    <table class="tests-table" id="testsTable">
                        <thead>
                            <tr>
                                <th class="tests-col-check"><input type="checkbox" id="testsSelectAll" title="Select/deselect all"></th>
                                <th class="tests-col-name">Test Name</th>
                                <th class="tests-col-machine">Machine</th>
                                <th class="tests-col-file">File</th>
                                <th class="tests-col-result">Result</th>
                            </tr>
                        </thead>
                        <tbody id="testsTableBody">
                        </tbody>
                    </table>
                </div>

                <!-- Progress Section -->
                <div class="tests-progress hidden" id="testsProgressSection">
                    <div class="tests-progress-header">
                        <span id="testsProgressText">Test 1/5: ULA 48K Timing</span>
                        <span id="testsProgressPercent">0%</span>
                    </div>
                    <div class="tests-progress-bar">
                        <div class="tests-progress-fill" id="testsProgressFill" style="width: 0%"></div>
                    </div>
                    <div class="tests-progress-details">
                        <span id="testsFrameCount">Frame: 0/500</span>
                        <span id="testsTstateCount">T-states: 0</span>
                    </div>
                </div>

                <!-- Preview Section (for calibration) -->
                <div class="tests-preview hidden" id="testsPreviewSection">
                    <div class="tests-preview-header">
                        <span>Frame: <strong id="testsPreviewFrame">0</strong></span>
                        <div class="tests-preview-buttons">
                            <button id="btnPausePreview" class="tests-btn">Pause</button>
                            <button id="btnCopyFrame" class="tests-btn">Copy Frame#</button>
                            <button id="btnTestScreenshot" class="tests-btn">Screenshot</button>
                            <button id="btnStopPreview" class="tests-btn danger">Stop</button>
                        </div>
                    </div>
                    <div class="tests-preview-canvas-container">
                        <canvas id="testsPreviewCanvas" width="320" height="240"></canvas>
                    </div>
                    <div class="tests-preview-info" id="testsPreviewInfo"></div>
                </div>

                <!-- Comparison Section -->
                <div class="tests-comparison hidden" id="testsComparisonSection">
                    <div class="tests-comparison-images">
                        <div class="tests-comparison-panel">
                            <div class="tests-comparison-label">Expected (Pristine)</div>
                            <canvas id="testsExpectedCanvas" width="320" height="240"></canvas>
                        </div>
                        <div class="tests-comparison-panel">
                            <div class="tests-comparison-label">Actual (Current)</div>
                            <canvas id="testsActualCanvas" width="320" height="240"></canvas>
                        </div>
                    </div>
                    <div class="tests-comparison-result" id="testsComparisonResult">
                        No comparison yet
                    </div>
                </div>

                <!-- Results Summary -->
                <div class="tests-summary hidden" id="testsSummarySection">
                    <div class="tests-summary-header">Results Summary</div>
                    <div class="tests-summary-stats">
                        <span class="tests-stat passed"><span id="testsPassed">0</span> passed</span>
                        <span class="tests-stat failed"><span id="testsFailed">0</span> failed</span>
                        <span class="tests-stat skipped"><span id="testsSkipped">0</span> skipped</span>
                        <span class="tests-stat time"><span id="testsTime">0.0</span>s</span>
                        <span class="tests-stat fps"><span id="testsFps">0</span> fps</span>
                    </div>
                    <table class="tests-results-table" id="testsResultsTable">
                        <thead>
                            <tr>
                                <th>Test</th>
                                <th>Result</th>
                                <th>Details</th>
                            </tr>
                        </thead>
                        <tbody id="testsResultsBody">
                        </tbody>
                    </table>
                </div>
            </div>
            </div><!-- tools-tests -->

            <!-- Compare Sub-tab Content -->
            <div class="tools-subtab-content" id="tools-compare">
            <div class="compare-container" style="padding:10px;display:flex;flex-direction:column;gap:15px;max-width:1200px">

                <!-- Compare Mode Selection -->
                <div class="compare-mode" style="display:flex;gap:15px;flex-wrap:wrap">
                    <label style="display:flex;align-items:center;gap:5px;cursor:pointer">
                        <input type="radio" name="compareMode" value="sna-sna" checked> Snapshots
                    </label>
                    <label style="display:flex;align-items:center;gap:5px;cursor:pointer">
                        <input type="radio" name="compareMode" value="bin-bin"> Binaries
                    </label>
                    <label style="display:flex;align-items:center;gap:5px;cursor:pointer">
                        <input type="radio" name="compareMode" value="sna-emu"> Snapshot vs Emulator
                    </label>
                </div>

                <!-- File Inputs -->
                <div class="compare-inputs" style="display:flex;gap:15px;flex-wrap:wrap">
                    <div class="compare-file" style="flex:1;min-width:200px">
                        <label style="display:block;margin-bottom:5px;color:var(--text-secondary);font-size:11px">File A:</label>
                        <input type="file" id="compareFileA" accept=".sna,.z80,.szx,.rzx,.bin,.rom,.dat,*" style="width:100%">
                    </div>
                    <div class="compare-file" id="compareFileBContainer" style="flex:1;min-width:200px">
                        <label style="display:block;margin-bottom:5px;color:var(--text-secondary);font-size:11px">File B:</label>
                        <input type="file" id="compareFileB" accept=".sna,.z80,.szx,.rzx,.bin,.rom,.dat,*" style="width:100%">
                    </div>
                </div>

                <!-- Compare Options -->
                <div class="compare-options" style="display:flex;gap:15px;flex-wrap:wrap;align-items:center">
                    <button id="btnCompare" title="Compare selected files or states" style="padding:8px 20px;background:var(--accent);color:var(--bg-primary);border:none;border-radius:4px;cursor:pointer;font-size:12px">Compare</button>
                    <label style="display:flex;align-items:center;gap:5px;font-size:12px">
                        <input type="checkbox" id="chkCompareShowEqual"> Show equal values
                    </label>
                    <label style="display:flex;align-items:center;gap:5px;font-size:12px">
                        <input type="checkbox" id="chkCompareHexDump" checked> Hex dump
                    </label>
                    <label style="display:flex;align-items:center;gap:5px;font-size:12px" title="Exclude $4000-$5AFF screen area (and $C000-$DAFF for 128K bank 7)">
                        <input type="checkbox" id="chkCompareExcludeScreen" checked> Exclude screen
                    </label>
                </div>

                <!-- Results -->
                <div class="compare-results" style="flex:1;overflow:auto">
                    <!-- Register Comparison -->
                    <div id="compareHeaderResults" style="display:none;margin-bottom:15px">
                        <div id="compareHeaderTable" style="font-family:monospace;font-size:12px;background:var(--bg-secondary);padding:10px;border-radius:4px;max-height:200px;overflow:auto"></div>
                    </div>

                    <!-- Data/Memory Differences -->
                    <div id="compareDataResults" style="display:none">
                        <span id="compareDataTitle" style="display:none"></span>
                        <div id="comparePagination" style="display:none;margin-bottom:8px;align-items:center;gap:10px;font-size:12px">
                            <button id="comparePrevPage" style="padding:4px 8px">◄ Prev</button>
                            <span id="comparePageInfo" style="color:var(--text-secondary)">Page 1 / 1</span>
                            <button id="compareNextPage" style="padding:4px 8px">Next ►</button>
                            <span style="color:var(--text-secondary);margin-left:10px">Go to:</span>
                            <input type="number" id="compareGoToPage" min="1" style="width:60px;padding:2px 4px;font-size:12px">
                            <button id="compareGoPage" style="padding:4px 8px">Go</button>
                            <span id="compareDiffCount" style="margin-left:15px;color:var(--yellow);font-size:12px"></span>
                        </div>
                        <div id="compareDiffCountNoPage" style="display:none;margin-bottom:8px;color:var(--yellow);font-size:12px"></div>
                        <div id="compareDataTable" style="font-family:monospace;font-size:12px;background:var(--bg-secondary);padding:10px;border-radius:4px;max-height:400px;overflow:auto"></div>
                    </div>

                    <!-- No differences message -->
                    <div id="compareNoResults" style="display:none;text-align:center;padding:40px;color:var(--green)">
                        <span style="font-size:24px">✓</span><br>
                        Files are identical
                    </div>
                </div>
            </div>
            </div><!-- tools-compare -->

            <!-- Explorer Sub-tab Content -->
            <div class="tools-subtab-content active" id="tools-explorer">
            <div class="explorer-container">
                <!-- Controls Row -->
                <div class="explorer-controls">
                    <input type="file" id="explorerFileInput" accept=".tap,.tzx,.sna,.z80,.szx,.rzx,.trd,.scl,.dsk,.zip" style="display:none">
                    <button id="btnExplorerLoad" class="explorer-btn primary">Load File</button>
                    <span id="explorerFileName" class="explorer-file-info">No file loaded</span>
                    <span id="explorerFileSize" class="explorer-file-size"></span>
                </div>

                <!-- Sub-tabs -->
                <div class="explorer-subtabs">
                    <button class="explorer-subtab active" data-subtab="info">File Info</button>
                    <button class="explorer-subtab" data-subtab="basic">BASIC</button>
                    <button class="explorer-subtab" data-subtab="disasm">Disasm</button>
                    <button class="explorer-subtab" data-subtab="hexdump">Hex Dump</button>
                </div>

                <!-- Sub-tab Content -->
                <div class="explorer-content">
                    <!-- File Info Sub-tab -->
                    <div class="explorer-subtab-content active" id="explorer-info">
                        <div class="explorer-info-row">
                            <div id="explorerInfoOutput" class="explorer-output">
                                <span class="explorer-empty">Load a file to view its structure</span>
                            </div>
                            <div id="explorerPreviewContainer" class="explorer-preview" style="display:none">
                                <canvas id="explorerPreviewCanvas" width="256" height="192"></canvas>
                                <div id="explorerPreviewLabel" class="explorer-preview-label"></div>
                            </div>
                        </div>
                    </div>

                    <!-- BASIC Sub-tab -->
                    <div class="explorer-subtab-content" id="explorer-basic" style="display:none">
                        <div class="explorer-controls" style="margin-bottom:10px">
                            <span class="explorer-label">Source:</span>
                            <select id="explorerBasicSource" class="explorer-select"></select>
                            <button id="btnExplorerBasic" class="explorer-btn">Decode</button>
                        </div>
                        <div id="explorerBasicOutput" class="explorer-output">
                            <span class="explorer-empty">Select a BASIC program and click Decode</span>
                        </div>
                    </div>

                    <!-- Disasm Sub-tab -->
                    <div class="explorer-subtab-content" id="explorer-disasm" style="display:none">
                        <div class="explorer-controls" style="margin-bottom:10px">
                            <span class="explorer-label">Source:</span>
                            <select id="explorerDisasmSource" class="explorer-select"></select>
                            <span class="explorer-label">Address:</span>
                            <input type="text" id="explorerDisasmAddr" value="0000" maxlength="4" class="explorer-input addr">
                            <span class="explorer-label">Length:</span>
                            <input type="number" id="explorerDisasmLen" value="256" min="1" max="65536" class="explorer-input len">
                            <button id="btnExplorerDisasm" class="explorer-btn">Disassemble</button>
                        </div>
                        <div id="explorerDisasmOutput" class="explorer-output">
                            <span class="explorer-empty">Select a source and click Disassemble</span>
                        </div>
                    </div>

                    <!-- Hex Dump Sub-tab -->
                    <div class="explorer-subtab-content" id="explorer-hexdump" style="display:none">
                        <div class="explorer-controls" style="margin-bottom:10px">
                            <span class="explorer-label">Source:</span>
                            <select id="explorerHexSource" class="explorer-select"></select>
                            <span class="explorer-label">Address:</span>
                            <input type="text" id="explorerHexAddr" value="0000" maxlength="4" class="explorer-input addr">
                            <span class="explorer-label">Length:</span>
                            <input type="number" id="explorerHexLen" value="256" min="16" max="65536" class="explorer-input len">
                            <button id="btnExplorerHex" class="explorer-btn">View</button>
                        </div>
                        <div id="explorerHexOutput" class="explorer-output">
                            <span class="explorer-empty">Select a source and click View</span>
                        </div>
                    </div>
                </div>
            </div>
            </div><!-- tools-explorer -->

            <!-- Export Sub-tab -->
            <div class="tools-subtab-content" id="tools-export">
            <div class="settings-tab-content">
                <div class="settings-section full-width">
                    <div class="settings-row">
                        <button id="btnScreenshot" title="Export current screen in selected format">Export</button>
                    </div>
                    <div class="settings-row">
                        <label for="frameExportFormat">Format:</label>
                        <select id="frameExportFormat">
                            <option value="png">PNG</option>
                            <option value="scr">SCR (screen only)</option>
                            <option value="bsc">BSC (with border)</option>
                            <option value="zip">ZIP (PNG sequence)</option>
                            <option value="gif">Animated GIF</option>
                            <option value="sca">SCA (animation)</option>
                        </select>
                        <label for="maxFrames" style="min-width: auto; margin-left: 10px; margin-right: -6px;">Max:</label>
                        <input type="number" id="maxFrames" value="0" min="0" style="width: 50px;">
                        <span style="color: var(--text-secondary); font-size: 11px;">(0=∞)</span>
                    </div>
                    <div class="settings-row" id="scaOptionsRow" style="display: none;">
                        <label for="scaPayloadType">Payload:</label>
                        <select id="scaPayloadType">
                            <option value="0">Type 0 (full frames)</option>
                            <option value="1">Type 1 (attrs only)</option>
                        </select>
                        <label for="scaFillPattern" style="min-width: auto; margin-left: 10px;">Fill:</label>
                        <select id="scaFillPattern">
                            <option value="auto">Automatic</option>
                            <option value="53c">53c (AA 55)</option>
                            <option value="127c">127c (DD 77)</option>
                            <option value="v4x8">Vertical 4x8 (F0)</option>
                            <option value="h8x4">Horizontal 8x4 (FF/00)</option>
                            <option value="custom">Custom</option>
                        </select>
                    </div>
                    <div class="settings-row" id="scaCustomPatternRow" style="display: none;">
                        <label for="scaCustomPattern">Pattern (8 hex bytes):</label>
                        <input type="text" id="scaCustomPattern" value="AA 55 AA 55 AA 55 AA 55" style="width: 200px; font-family: monospace;">
                    </div>
                    <div class="settings-row" id="sizeRow">
                        <label for="frameExportSize">Size:</label>
                        <select id="frameExportSize">
                            <option value="screen">Screen only (256×192)</option>
                            <option value="normal">Normal border</option>
                            <option value="full">Full border</option>
                            <option value="sprite-pixels">Sprite (pixels)</option>
                            <option value="sprite-cells">Sprite (cells 8×8)</option>
                        </select>
                    </div>
                    <div class="settings-row sprite-region-row" id="spriteRegionRow" style="display: none;">
                        <span class="sprite-input-group"><label id="spriteLabelX">X:</label><input type="number" id="spriteX" value="0" min="0" max="255"></span>
                        <span class="sprite-input-group"><label id="spriteLabelY">Y:</label><input type="number" id="spriteY" value="0" min="0" max="191"></span>
                        <span class="sprite-input-group"><label id="spriteLabelW">W:</label><input type="number" id="spriteW" value="16" min="1" max="256"></span>
                        <span class="sprite-input-group"><label id="spriteLabelH">H:</label><input type="number" id="spriteH" value="16" min="1" max="192"></span>
                    </div>
                    <div class="settings-row frame-export-controls">
                        <button id="btnFrameGrabStart" class="frame-grab-btn">Start</button>
                        <button id="btnFrameGrabStop" class="frame-grab-btn" disabled>Stop</button>
                        <button id="btnFrameGrabCancel" class="frame-grab-btn" disabled>Cancel</button>
                    </div>
                    <div class="frame-grab-status" id="frameGrabStatus"></div>
                    <div style="border-top: 1px solid var(--text-secondary); margin: 12px 0 8px 0; opacity: 0.3;"></div>
                    <div class="settings-row" style="margin-bottom: 4px;">
                        <span style="font-weight: bold; font-size: 11px; color: var(--text-secondary);">AY Capture (PSG)</span>
                        <button id="btnPsgPlayer" style="margin-left: auto; font-size: 11px;" title="Download PSG player Z80 source code">Get Player</button>
                    </div>
                    <div class="settings-row">
                        <label class="checkbox-label" title="Only record registers that changed from previous frame (smaller file)">
                            <input type="checkbox" id="chkPsgChangedOnly" checked> Changed only
                        </label>
                    </div>
                    <div class="settings-row frame-export-controls">
                        <button id="btnPsgStart" class="frame-grab-btn" title="Start recording AY register writes">Record</button>
                        <button id="btnPsgStop" class="frame-grab-btn" disabled title="Stop and export PSG file">Export</button>
                        <button id="btnPsgCancel" class="frame-grab-btn" disabled title="Cancel recording">Cancel</button>
                    </div>
                    <div class="frame-grab-status" id="psgStatus"></div>
                    <div style="border-top: 1px solid var(--text-secondary); margin: 12px 0 8px 0; opacity: 0.3;"></div>
                    <div class="settings-row" style="margin-bottom: 4px;">
                        <span style="font-weight: bold; font-size: 11px; color: var(--text-secondary);">RZX Recording</span>
                    </div>
                    <div class="settings-row frame-export-controls">
                        <button id="btnRzxRecStart" class="frame-grab-btn" title="Start recording inputs for RZX">Record</button>
                        <button id="btnRzxRecExport" class="frame-grab-btn" disabled title="Stop and export RZX file">Export</button>
                        <button id="btnRzxRecCancel" class="frame-grab-btn" disabled title="Cancel recording">Cancel</button>
                    </div>
                    <div class="frame-grab-status" id="rzxRecStatus"></div>
                    <div style="border-top: 1px solid var(--text-secondary); margin: 12px 0 8px 0; opacity: 0.3;"></div>
                    <div class="settings-row">
                        <label class="checkbox-label" title="Detect unrolled loops (identical instruction sequences) and output as REPT blocks when exporting ASM from Memory Map">
                            <input type="checkbox" id="chkExportDedupLoops" checked> Dedup ASM loops
                        </label>
                    </div>
                </div>
            </div>
            </div><!-- tools-export -->

        </div><!-- tab-tools -->

        </div><!-- tab-container -->
    </div><!-- main-layout -->

    <!-- Memory Map Dialog -->
    <div class="memmap-dialog hidden" id="memmapDialog">
        <div class="memmap-content">
            <div class="memmap-header">
                <button class="memmap-close" id="btnMemmapClose">Close</button>
            </div>
            <div class="memmap-body">
                <div class="memmap-scale">
                    <div class="memmap-scale-item"><span id="memmapRomLabel">ROM</span><span class="memmap-scale-addr">0000</span></div>
                    <div class="memmap-scale-item"><span>Bank 5</span><span class="memmap-scale-addr">4000</span></div>
                    <div class="memmap-scale-tick" style="top:182px"><span class="memmap-scale-addr">5B00</span></div>
                    <div class="memmap-scale-item"><span>Bank 2</span><span class="memmap-scale-addr">8000</span></div>
                    <div class="memmap-scale-item"><span id="memmapBankLabel">Bank 0</span><span class="memmap-scale-addr">C000</span></div>
                    <div class="memmap-scale-end"><span class="memmap-scale-addr">FFFF</span></div>
                </div>
                <div class="memmap-canvas-container">
                    <canvas id="memmapCanvas" width="512" height="512"></canvas>
                    <div class="memmap-tooltip" id="memmapTooltip"></div>
                </div>
                <div class="memmap-sidebar">
                    <div class="memmap-view-toggle" style="margin-bottom:8px">
                        <button class="memmap-view-btn active" id="btnMemmapRegions">Regions</button>
                        <button class="memmap-view-btn" id="btnMemmapHeatmap">Heatmap</button>
                    </div>
                    <div class="memmap-view-toggle" id="memmapBankToggle" style="display:none;margin-bottom:8px">
                        <button class="memmap-view-btn active" id="btnMemmap64K">64KB</button>
                        <button class="memmap-view-btn" id="btnMemmap128K">128KB</button>
                    </div>
                    <div class="memmap-legend" id="memmapLegendRegions">
                        <div class="memmap-legend-item"><div class="memmap-legend-color" style="background:#4080ff"></div>Code</div>
                        <div class="memmap-legend-item"><div class="memmap-legend-color" style="background:#ff4040"></div>SMC</div>
                        <div class="memmap-legend-item"><div class="memmap-legend-color" style="background:#ffcc00"></div>DB (bytes)</div>
                        <div class="memmap-legend-item"><div class="memmap-legend-color" style="background:#ff8800"></div>DW (words)</div>
                        <div class="memmap-legend-item"><div class="memmap-legend-color" style="background:#40cc40"></div>Text</div>
                        <div class="memmap-legend-item"><div class="memmap-legend-color" style="background:#cc40cc"></div>Graphics</div>
                        <div class="memmap-legend-item"><div class="memmap-legend-color" style="background:#606060"></div>Unmapped</div>
                        <div class="memmap-legend-item"><div class="memmap-legend-color" style="background:#000000;border:1px solid #444"></div>Zeroes</div>
                    </div>
                    <div class="memmap-legend hidden" id="memmapLegendHeatmap">
                        <div class="memmap-legend-item"><div class="memmap-legend-color" style="background:#0066ff"></div>Execute</div>
                        <div class="memmap-legend-item"><div class="memmap-legend-color" style="background:#00ff66"></div>Read</div>
                        <div class="memmap-legend-item"><div class="memmap-legend-color" style="background:#ff6600"></div>Write</div>
                        <div class="memmap-legend-item"><div class="memmap-legend-color" style="background:#ffffff"></div>Mixed (high)</div>
                        <div class="memmap-legend-item"><div class="memmap-legend-color" style="background:#000000;border:1px solid #444"></div>No access</div>
                        <div class="memmap-heatmap-scale">
                            <div>Low</div>
                            <div class="memmap-gradient"></div>
                            <div>High</div>
                        </div>
                    </div>
                    <div class="memmap-stats" id="memmapStats"></div>
                    <div class="memmap-bar" id="memmapBar"></div>
                    <div class="memmap-addr-info" id="memmapAddrInfo">Hover over map to see details<br>Click to navigate</div>
                    <h3 class="memmap-title">Memory Map (64KB)</h3>
                    <div style="margin-top:10px;display:flex;align-items:center;gap:10px">
                        <button class="memmap-view-btn" id="btnExportAsm" title="Export disassembly as sjasmplus-compatible ASM file" style="border-radius:4px">Export ASM</button>
                        <label style="display:flex;align-items:center;gap:4px;font-size:11px;color:var(--text-secondary);cursor:pointer" title="Include address and bytes as comments (e.g. LD A,$00 ; 8000: 3E 00)">
                            <input type="checkbox" id="chkExportAddrBytes"> Addr+Bytes
                        </label>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Keyboard Help Modal -->
    <div class="help-modal hidden" id="helpModal">
        <div class="help-modal-content">
            <div class="help-modal-header">
                <h3>Keyboard Mapping</h3>
                <button class="help-modal-close" id="btnHelpClose">×</button>
            </div>
            <table>
                <tr><td>A-Z, 0-9</td><td>Standard keys</td></tr>
                <tr><td>Ctrl</td><td>Caps Shift</td></tr>
                <tr><td>Alt</td><td>Symbol Shift</td></tr>
                <tr><td>Enter</td><td>Enter</td></tr>
                <tr><td>Space</td><td>Space / Break</td></tr>
                <tr><td>Backspace</td><td>Delete (Shift+0)</td></tr>
                <tr><td>Arrow Keys</td><td>Cursor keys (Shift+5/6/7/8)</td></tr>
                <tr><td colspan="2" class="help-section-header">Symbols (Ctrl + Key)</td></tr>
                <tr><td>Ctrl+0</td><td>_ (underscore)</td></tr>
                <tr><td>Ctrl+1-9</td><td>! @ # $ % &amp; ' ( )</td></tr>
                <tr><td>Ctrl+Letter</td><td>Various symbols (see Help)</td></tr>
                <tr><td colspan="2" class="help-section-header">Kempston Joystick (Numpad)</td></tr>
                <tr><td>Numpad 8/2/4/6</td><td>Up/Down/Left/Right</td></tr>
                <tr><td>Numpad 5 or 0</td><td>Fire</td></tr>
                <tr><td>Numpad 7/9/1/3</td><td>Diagonals</td></tr>
                <tr><td colspan="2" class="help-section-header">Debugger</td></tr>
                <tr><td>F6 / Pause</td><td>Pause/Resume emulation</td></tr>
                <tr><td>F7</td><td>Step Into</td></tr>
                <tr><td>F8</td><td>Step Over</td></tr>
                <tr><td>F4</td><td>Run to Cursor</td></tr>
                <tr><td>F9</td><td>Toggle Breakpoint</td></tr>
                <tr><td>F1</td><td>Cycle Zoom (x1/x2/x3)</td></tr>
                <tr><td>F10</td><td>Cycle Overlay Mode</td></tr>
            </table>
        </div>
    </div>
    
    <!-- Label Edit Dialog -->
    <div class="label-dialog hidden" id="labelDialog">
        <div class="label-dialog-content">
            <h4 id="labelDialogTitle">Add Label</h4>
            <div class="label-dialog-row">
                <label>Address</label>
                <input type="text" id="labelAddrInput" readonly>
            </div>
            <div class="label-dialog-row">
                <label>Name</label>
                <input type="text" id="labelNameInput" placeholder="LABEL_NAME" maxlength="32">
            </div>
            <div class="label-dialog-row">
                <label>Comment (optional)</label>
                <input type="text" id="labelCommentInput" placeholder="Description..." maxlength="100">
            </div>
            <div class="label-dialog-row">
                <label>Size (bytes, 1 = code)</label>
                <input type="number" id="labelSizeInput" value="1" min="1" max="65536">
            </div>
            <div class="label-dialog-buttons">
                <button id="btnLabelSave">Save</button>
                <button id="btnLabelCancel">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Region Mark Dialog -->
    <div class="label-dialog hidden" id="regionDialog">
        <div class="label-dialog-content">
            <h4 id="regionDialogTitle">Mark Region</h4>
            <div class="label-dialog-row">
                <label>Start Address</label>
                <input type="text" id="regionStartInput" readonly>
            </div>
            <div class="label-dialog-row">
                <label>End Address</label>
                <input type="text" id="regionEndInput" placeholder="FFFF" maxlength="4">
            </div>
            <div class="label-dialog-row">
                <label>Type</label>
                <select id="regionTypeSelect">
                    <option value="code">Code</option>
                    <option value="db">DB (bytes)</option>
                    <option value="dw">DW (words)</option>
                    <option value="text">Text (ASCII)</option>
                    <option value="graphics">Graphics</option>
                    <option value="smc">SMC (self-modifying)</option>
                </select>
            </div>
            <div class="label-dialog-row">
                <label>Comment (optional)</label>
                <input type="text" id="regionCommentInput" placeholder="Description..." maxlength="100">
            </div>
            <div class="label-dialog-buttons">
                <button id="btnRegionSave">Mark</button>
                <button id="btnRegionCancel">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Fold Block Dialog -->
    <div class="label-dialog hidden" id="foldDialog">
        <div class="label-dialog-content">
            <h4>Create Fold Block</h4>
            <div class="label-dialog-row">
                <label>Start Address</label>
                <input type="text" id="foldStartInput" readonly>
            </div>
            <div class="label-dialog-row">
                <label>End Address</label>
                <input type="text" id="foldEndInput" placeholder="FFFF" maxlength="4">
            </div>
            <div class="label-dialog-row">
                <label>Name (optional)</label>
                <input type="text" id="foldNameInput" placeholder="e.g. Sprite Data" maxlength="50">
            </div>
            <div class="label-dialog-buttons">
                <button id="btnFoldSave">Create</button>
                <button id="btnFoldCancel">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Comment Dialog -->
    <div class="label-dialog hidden" id="commentDialog">
        <div class="label-dialog-content" style="width: 400px;">
            <h4 id="commentDialogTitle">Edit Comment</h4>
            <div class="label-dialog-row">
                <label>Address</label>
                <input type="text" id="commentAddrInput" readonly>
            </div>
            <div class="label-dialog-row">
                <label><input type="checkbox" id="commentSeparator"> Add separator line (----------)</label>
            </div>
            <div class="label-dialog-row">
                <label>Before (multiline)</label>
                <textarea id="commentBeforeInput" rows="3" placeholder="Comment before instruction..."></textarea>
            </div>
            <div class="label-dialog-row">
                <label>Inline</label>
                <input type="text" id="commentInlineInput" placeholder="Short comment on same line" maxlength="60">
            </div>
            <div class="label-dialog-row">
                <label>After (multiline)</label>
                <textarea id="commentAfterInput" rows="3" placeholder="Comment after instruction..."></textarea>
            </div>
            <div class="label-dialog-buttons">
                <button id="btnCommentSave">Save</button>
                <button id="btnCommentDelete" class="danger">Delete</button>
                <button id="btnCommentCancel">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Export Disasm Dialog -->
    <div class="label-dialog hidden" id="exportDisasmDialog">
        <div class="label-dialog-content">
            <h4>Export Disassembly</h4>
            <div class="label-dialog-row">
                <label>Start Address</label>
                <input type="text" id="exportStartAddr" placeholder="0000" maxlength="4">
            </div>
            <div class="label-dialog-row">
                <label>End Address</label>
                <input type="text" id="exportEndAddr" placeholder="FFFF" maxlength="4">
            </div>
            <div class="label-dialog-row">
                <label>Options</label>
                <div class="export-options">
                    <label><input type="checkbox" id="exportWithOrg" checked> ORG directive</label>
                    <label><input type="checkbox" id="exportWithAddr" checked> Address comments</label>
                    <label><input type="checkbox" id="exportWithBytes"> Byte comments</label>
                    <label><input type="checkbox" id="exportWithTstates"> T-states</label>
                </div>
            </div>
            <div class="label-dialog-buttons">
                <button id="btnExportSave">Export</button>
                <button id="btnExportCancel">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Gamepad Calibration Dialog -->
    <div class="label-dialog hidden" id="gamepadCalibDialog">
        <div class="label-dialog-content" style="width: 350px;">
            <h4>Gamepad Calibration</h4>
            <div id="gamepadCalibInfo" style="margin-bottom: 10px; font-size: 12px; color: var(--text-dim);">
                No gamepad detected
            </div>
            <div style="margin-bottom: 15px;">
                <table style="width: 100%; font-size: 12px;">
                    <tr>
                        <td style="padding: 4px;">Up:</td>
                        <td id="gamepadMapUp" style="color: var(--cyan);">-</td>
                        <td><button class="small-btn gamepad-assign-btn" data-dir="up">Assign</button></td>
                    </tr>
                    <tr>
                        <td style="padding: 4px;">Down:</td>
                        <td id="gamepadMapDown" style="color: var(--cyan);">-</td>
                        <td><button class="small-btn gamepad-assign-btn" data-dir="down">Assign</button></td>
                    </tr>
                    <tr>
                        <td style="padding: 4px;">Left:</td>
                        <td id="gamepadMapLeft" style="color: var(--cyan);">-</td>
                        <td><button class="small-btn gamepad-assign-btn" data-dir="left">Assign</button></td>
                    </tr>
                    <tr>
                        <td style="padding: 4px;">Right:</td>
                        <td id="gamepadMapRight" style="color: var(--cyan);">-</td>
                        <td><button class="small-btn gamepad-assign-btn" data-dir="right">Assign</button></td>
                    </tr>
                    <tr>
                        <td style="padding: 4px;">Fire:</td>
                        <td id="gamepadMapFire" style="color: var(--cyan);">-</td>
                        <td><button class="small-btn gamepad-assign-btn" data-dir="fire">Assign</button></td>
                    </tr>
                    <tr><td colspan="3" style="padding: 6px 0 2px; color: var(--text-dim); font-size: 11px;">Extended (optional):</td></tr>
                    <tr>
                        <td style="padding: 4px;">C:</td>
                        <td id="gamepadMapC" style="color: var(--cyan);">-</td>
                        <td><button class="small-btn gamepad-assign-btn" data-dir="c">Assign</button></td>
                    </tr>
                    <tr>
                        <td style="padding: 4px;">A:</td>
                        <td id="gamepadMapA" style="color: var(--cyan);">-</td>
                        <td><button class="small-btn gamepad-assign-btn" data-dir="a">Assign</button></td>
                    </tr>
                    <tr>
                        <td style="padding: 4px;">Start:</td>
                        <td id="gamepadMapStart" style="color: var(--cyan);">-</td>
                        <td><button class="small-btn gamepad-assign-btn" data-dir="start">Assign</button></td>
                    </tr>
                </table>
            </div>
            <div id="gamepadCalibStatus" style="margin-bottom: 10px; min-height: 20px; font-size: 12px; color: var(--accent);"></div>
            <div class="label-dialog-buttons">
                <button id="btnGamepadCalibReset">Reset</button>
                <button id="btnGamepadCalibSave">Save</button>
                <button id="btnGamepadCalibClose">Close</button>
            </div>
        </div>
    </div>

    <!-- Game Browser Dialog -->
    <div class="gamebrowser-dialog hidden" id="gameBrowserDialog">
        <div class="gamebrowser-content">
            <div class="gamebrowser-header">
                <h3>Game Browser</h3>
                <button class="gamebrowser-close" id="btnGameBrowserClose">&times;</button>
            </div>
            <div class="gamebrowser-search">
                <input type="text" id="gameBrowserSearch" placeholder="Search games..." spellcheck="false">
                <button id="btnGameBrowserSearchGo">Search</button>
                <span class="gamebrowser-source-info">Powered by <a href="https://spectrumcomputing.co.uk" target="_blank">Spectrum Computing</a></span>
            </div>
            <div class="gamebrowser-body">
                <div class="gamebrowser-results" id="gameBrowserResults">
                    <div class="gamebrowser-status">
                        Enter a search term to find games
                    </div>
                </div>
                <div class="gamebrowser-detail hidden" id="gameBrowserDetail">
                    <div class="gamebrowser-detail-title" id="gameBrowserDetailTitle">Select a game</div>
                    <div class="gamebrowser-detail-screen" id="gameBrowserDetailScreen">
                        <div class="gamebrowser-thumb-placeholder"></div>
                    </div>
                    <div class="gamebrowser-detail-info" id="gameBrowserDetailInfo"></div>
                    <div class="gamebrowser-releases" id="gameBrowserReleases">
                        <div class="gamebrowser-releases-title">Available Downloads</div>
                        <div id="gameBrowserReleasesList"></div>
                    </div>
                    <div class="gamebrowser-external" id="gameBrowserExternal"></div>
                </div>
            </div>
            <div class="gamebrowser-pagination">
                <button id="btnGameBrowserPrev" disabled>&lt; Prev</button>
                <span id="gameBrowserPageInfo">Page 0 of 0</span>
                <button id="btnGameBrowserNext" disabled>Next &gt;</button>
            </div>
        </div>
    </div>

    <!-- Comprehensive Help Dialog -->
    <div class="fullhelp-dialog hidden" id="fullHelpDialog">
        <div class="fullhelp-content">
            <div class="fullhelp-header">
                <h3>ZX-M8XXX <span class="help-version">v0.9.31</span> Help</h3>
                <button class="fullhelp-close" id="btnFullHelpClose">&times;</button>
            </div>
            <div class="fullhelp-body">
                <div class="fullhelp-nav">
                    <button class="fullhelp-nav-btn active" data-section="overview">Overview</button>
                    <button class="fullhelp-nav-btn" data-section="files">Files</button>
                    <button class="fullhelp-nav-btn" data-section="keyboard">Keyboard</button>
                    <button class="fullhelp-nav-btn" data-section="assembler">Assembler</button>
                    <button class="fullhelp-nav-btn" data-section="debugger">Debugger</button>
                    <button class="fullhelp-nav-btn" data-section="breakpoints">Breakpoints</button>
                    <button class="fullhelp-nav-btn" data-section="memory">Memory</button>
                    <button class="fullhelp-nav-btn" data-section="labels">Labels</button>
                    <button class="fullhelp-nav-btn" data-section="signatures">Signatures</button>
                    <button class="fullhelp-nav-btn" data-section="regions">Regions</button>
                    <button class="fullhelp-nav-btn" data-section="xrefs">XRefs</button>
                    <button class="fullhelp-nav-btn" data-section="graphics">Graphics</button>
                    <button class="fullhelp-nav-btn" data-section="tests">Tests</button>
                    <button class="fullhelp-nav-btn" data-section="compare">Compare</button>
                    <button class="fullhelp-nav-btn" data-section="explorer">Explorer</button>
                    <button class="fullhelp-nav-btn" data-section="api">API</button>
                    <button class="fullhelp-nav-btn" data-section="about">About</button>
                </div>
                <div class="fullhelp-section" id="help-overview">
                    <h4>Overview</h4>
                    <p>ZX-M8XXX (ZX Matrix) is a vanilla JavaScript ZX Spectrum emulator with integrated debugger for reverse engineering.</p>
                    <h5>Features</h5>
                    <ul>
                        <li>Full Z80 CPU emulation (all documented + undocumented opcodes)</li>
                        <li>48K, 128K, +2, +2A, +3, Pentagon, and Scorpion machine support</li>
                        <li>Memory banking (128K/+2/+2A/Pentagon/Scorpion)</li>
                        <li>ULA video generation with border</li>
                        <li>ULAplus extended palette (64 colors, HAM256 raster effects)</li>
                        <li>Memory contention emulation</li>
                        <li>AY-3-8910 sound chip (stereo modes)</li>
                        <li>PSG file export (record AY music)</li>
                        <li>SNA/Z80/SZX snapshot loading/saving</li>
                        <li>Quicksave/Quickload (F2/F5) - instant state save to browser storage</li>
                        <li>TAP/TZX tape loading (instant or real-time with border stripes and sound)</li>
                        <li>TRD/SCL disk images (TR-DOS)</li>
                        <li>DSK disk images (+3 µPD765 FDC)</li>
                        <li>ZIP archive support</li>
                        <li>RZX playback (partial)</li>
                        <li>Game Browser - search and download games from Spectrum Computing</li>
                        <li>Fullscreen mode (F11) with crisp/fit/stretch options</li>
                        <li>Automated test suite with screenshot comparison</li>
                        <li>Compare tool for snapshots and binaries</li>
                        <li>Explorer for file analysis (BASIC decoder, disassembly, hex dump)</li>
                    </ul>
                    <h5>Quick Start</h5>
                    <ol>
                        <li>Place ROM files in <code>roms/</code> directory (48.rom, 128.rom, plus2.rom, plus2a.rom, plus3.rom, pentagon.rom, scorpion.rom, trdos.rom)</li>
                        <li>Open index.html in a modern browser</li>
                        <li>Use Load → Web to browse and download games online</li>
                        <li>Or Load → File to load SNA/Z80/SZX snapshots, TAP/TZX tapes, TRD/SCL/DSK disks</li>
                        <li>F2 = Quicksave, F5 = Quickload during gameplay</li>
                    </ol>
                </div>
                <div class="fullhelp-section hidden" id="help-keyboard">
                    <h4>Keyboard Mapping</h4>
                    <table>
                        <tr><th>PC Key</th><th>Spectrum Key</th></tr>
                        <tr><td>A-Z, 0-9</td><td>Standard keys</td></tr>
                        <tr><td>Ctrl</td><td>Caps Shift</td></tr>
                        <tr><td>Alt</td><td>Symbol Shift</td></tr>
                        <tr><td>Enter</td><td>Enter</td></tr>
                        <tr><td>Space</td><td>Space / Break</td></tr>
                        <tr><td>Backspace</td><td>Delete (Ctrl+0)</td></tr>
                        <tr><td>Arrow Keys</td><td>Cursor (Ctrl+5/6/7/8)</td></tr>
                    </table>
                    <p style="font-size: 11px; color: var(--text-dim);">PC Shift is free for regular shifted characters (!@#$%^&amp;*etc)<br>
                    Keys use physical QWERTY positions - works with any keyboard layout.</p>
                    <h5>Symbol Shift Combinations (Alt + Key)</h5>
                    <table>
                        <tr><th>Keys</th><th>Symbol</th><th>Keys</th><th>Symbol</th><th>Keys</th><th>Symbol</th></tr>
                        <tr><td>Alt+1</td><td>!</td><td>Alt+Q</td><td>&lt;=</td><td>Alt+A</td><td>~</td></tr>
                        <tr><td>Alt+2</td><td>@</td><td>Alt+W</td><td>&lt;&gt;</td><td>Alt+S</td><td>|</td></tr>
                        <tr><td>Alt+3</td><td>#</td><td>Alt+E</td><td>&gt;=</td><td>Alt+D</td><td>\</td></tr>
                        <tr><td>Alt+4</td><td>$</td><td>Alt+R</td><td>&lt;</td><td>Alt+F</td><td>{</td></tr>
                        <tr><td>Alt+5</td><td>%</td><td>Alt+T</td><td>&gt;</td><td>Alt+G</td><td>}</td></tr>
                        <tr><td>Alt+6</td><td>&amp;</td><td>Alt+Y</td><td>[</td><td>Alt+H</td><td>^</td></tr>
                        <tr><td>Alt+7</td><td>'</td><td>Alt+U</td><td>]</td><td>Alt+J</td><td>-</td></tr>
                        <tr><td>Alt+8</td><td>(</td><td>Alt+I</td><td>©</td><td>Alt+K</td><td>+</td></tr>
                        <tr><td>Alt+9</td><td>)</td><td>Alt+O</td><td>;</td><td>Alt+L</td><td>=</td></tr>
                        <tr><td>Alt+0</td><td>_</td><td>Alt+P</td><td>"</td><td>Alt+Z</td><td>:</td></tr>
                        <tr><td>Alt+M</td><td>.</td><td>Alt+N</td><td>,</td><td>Alt+B</td><td>*</td></tr>
                        <tr><td>Alt+C</td><td>?</td><td>Alt+V</td><td>/</td><td>Alt+X</td><td>£</td></tr>
                    </table>
                    <h5>Kempston Joystick (Numpad)</h5>
                    <table>
                        <tr><td>Numpad 8/2/4/6</td><td>Up/Down/Left/Right</td></tr>
                        <tr><td>Numpad 5 or 0</td><td>Fire (B button)</td></tr>
                        <tr><td>Numpad 7/9/1/3</td><td>Diagonals</td></tr>
                    </table>
                    <h5>Extended Kempston (Sega Genesis compatible)</h5>
                    <p>Enable in Settings → Input → Extended. Uses port 0x1F bits 5-7:</p>
                    <table>
                        <tr><td>[ (left bracket)</td><td>C button (bit 5)</td></tr>
                        <tr><td>] (right bracket)</td><td>A button (bit 6)</td></tr>
                        <tr><td>\ (backslash)</td><td>Start button (bit 7)</td></tr>
                    </table>
                    <h5>Hardware Gamepad</h5>
                    <p>Enable in Settings → Input → Gamepad. Supports USB/Bluetooth controllers.</p>
                    <p><b>Calibration:</b> Click "Calibrate" button to configure non-standard gamepads:</p>
                    <ul style="margin: 5px 0; padding-left: 20px;">
                        <li>Click "Assign" next to each direction/button</li>
                        <li>Move stick or press button on your gamepad</li>
                        <li>Mapping is auto-detected and saved</li>
                    </ul>
                    <table>
                        <tr><td>Up/Down/Left/Right</td><td>Directions (calibrate if needed)</td></tr>
                        <tr><td>Fire</td><td>Main fire button</td></tr>
                        <tr><td>C, A, Start</td><td>Extended buttons (Sega-style)</td></tr>
                    </table>
                    <p style="margin-top: 5px; font-size: 11px; color: var(--text-dim);">Mapping saved to browser localStorage and project files.</p>
                    <h5>Kempston Mouse</h5>
                    <p>Enable in Settings → Input → Kempston Mouse. Ports: FADF (buttons), FBDF (X), FFDF (Y).</p>
                    <table>
                        <tr><td>Click screen or 🖱️ button</td><td>Capture mouse</td></tr>
                        <tr><td>Escape</td><td>Release mouse</td></tr>
                        <tr><td>Mouse wheel</td><td>Wheel (bits 7:4 of FADF, if enabled)</td></tr>
                        <tr><td>Swap L/R</td><td>Swap left/right button bits (bit0↔bit1)</td></tr>
                    </table>
                    <h5>Debugger Hotkeys</h5>
                    <table>
                        <tr><td>F6 / Pause</td><td>Pause/Resume emulation</td></tr>
                        <tr><td>F7</td><td>Step Into (single instruction)</td></tr>
                        <tr><td>F8</td><td>Step Over (skip CALL/RST)</td></tr>
                        <tr><td>F4</td><td>Run to Cursor</td></tr>
                        <tr><td>F9</td><td>Toggle Breakpoint at PC</td></tr>
                        <tr><td>F11</td><td>Toggle Fullscreen</td></tr>
                        <tr><td>F2</td><td>Quicksave</td></tr>
                        <tr><td>F5</td><td>Quickload</td></tr>
                        <tr><td>PageUp / PageDown</td><td>Scroll disassembly view (page)</td></tr>
                        <tr><td>Up / Down (paused)</td><td>Scroll disassembly view (line)</td></tr>
                        <tr><td>` (tilde)</td><td>Resume emulation (paused mode)</td></tr>
                        <tr><td>1-5 (paused)</td><td>Jump to left panel bookmark</td></tr>
                        <tr><td>Shift+1-5 (paused)</td><td>Set left panel bookmark</td></tr>
                        <tr><td>6-9, 0 (paused)</td><td>Jump to right panel bookmark</td></tr>
                        <tr><td>Shift+6-9, 0 (paused)</td><td>Set right panel bookmark</td></tr>
                        <tr><td>F1</td><td>Cycle canvas zoom (x1 → x2 → x3)</td></tr>
                        <tr><td>F10</td><td>Cycle overlay mode (Normal → Grid → Box → ...)</td></tr>
                    </table>
                </div>
                <div class="fullhelp-section hidden" id="help-debugger">
                    <h4>Debugger</h4>
                    <p>The built-in debugger provides comprehensive tools for development and reverse engineering.</p>
                    <h5>Registers View</h5>
                    <p>Shows all Z80 registers including the alternate set (AF', BC', DE', HL'). Flags are displayed as visual indicators: S, Z, H, P/V, N, C.</p>
                    <p><strong>ΔT (Delta T-states)</strong>: Accumulated T-states since the last breakpoint fired. Useful for measuring cycle-exact timing between breakpoints. The counter accumulates through steps, runs, and all execution modes. Resets to 0 when any breakpoint fires (exec, watchpoint, or port).</p>
                    <h5>Configurable Panels</h5>
                    <p>Left and right debug panels can show different views:</p>
                    <ul>
                        <li>Use the dropdown selector in each panel header to choose view type</li>
                        <li>Left panel: Disasm or Memory</li>
                        <li>Right panel: Memory, Disasm, or Calculator</li>
                        <li>Step controls (Step Into, Step Over, etc.) appear in disasm panels</li>
                        <li>Search controls appear in memory panels</li>
                        <li>Bookmarks show panel type: 🔍 disasm, 📦 memory</li>
                    </ul>
                    <h5>Programmer Calculator</h5>
                    <p>Available in the right panel dropdown. Features:</p>
                    <ul>
                        <li>Input in HEX, DEC, OCT, or BIN with simultaneous display of all bases</li>
                        <li>8/16/32-bit modes with signed/unsigned display</li>
                        <li>Bitwise operations: AND, OR, XOR, NOT, shifts, rotates</li>
                        <li>Expression evaluation: type formulas like "FF+10*2"</li>
                        <li>Interactive bit grid for toggling individual bits</li>
                        <li>History panel preserves calculations when switching views</li>
                        <li>Base selector disabled during formula input to prevent conversion errors</li>
                    </ul>
                    <h5>Disassembly View</h5>
                    <ul>
                        <li>Live disassembly from current PC with label support</li>
                        <li>Click address to set "run to cursor" target</li>
                        <li>Right-click for context menu (labels, regions, operand format, subroutines)</li>
                        <li>Hover over addresses to see cross-references</li>
                        <li>Subroutine separators (IDA-style) for marked routines</li>
                        <li>Syntax coloring: <span style="color:#daa520">registers</span>, <span style="color:#00aa00">numbers</span>, <span style="color:#cc66cc">chars</span></li>
                    </ul>
                    <h5>Subroutines</h5>
                    <ul>
                        <li>Right-click &rarr; "Mark as subroutine" to manually mark</li>
                        <li>Auto-detected during Auto-Map Apply (CALL targets)</li>
                        <li>Displays IDA-style separator before subroutine start</li>
                        <li>Uses label name if available, or generates sub_XXXX</li>
                    </ul>
                    <h5>Code Folding</h5>
                    <p>Collapse subroutines and custom blocks to reduce clutter in disassembly:</p>
                    <ul>
                        <li>Click <b>&#x25BE;</b> toggle on subroutine header to collapse, <b>&#x25B8;</b> to expand</li>
                        <li>Collapsed view shows summary: "(N bytes, M instructions)"</li>
                        <li>Right-click &rarr; "Create fold block..." for custom regions (data tables, init code)</li>
                        <li>User fold markers displayed in magenta</li>
                        <li>"Collapse all folds" / "Expand all folds" in context menu</li>
                        <li>Auto-expands if PC enters a collapsed region</li>
                        <li>Fold state saved in projects and localStorage</li>
                    </ul>
                    <h5>Operand Formatting</h5>
                    <p>Right-click any disassembly line and select "Operand format..." to change how numeric operands are displayed:</p>
                    <ul>
                        <li><strong>Hex</strong>: FFh, 1234h (default)</li>
                        <li><strong>Decimal</strong>: 255, 4660</li>
                        <li><strong>Binary</strong>: %11111111, %0001001000110100</li>
                        <li><strong>Char</strong>: 'A' (for printable ASCII)</li>
                    </ul>
                    <p>Format settings persist per instruction address and are saved with projects.</p>
                    <h5>Stack View</h5>
                    <p>Shows current stack contents from SP upward. Changed values are highlighted. Click an entry to navigate to that address (prefers disasm panel, falls back to memory view). Right-click for context menu with explicit panel choices.</p>
                    <h5>Calls Panel</h5>
                    <p>Runtime call stack tracking. Monitors CALL, RST, and INT instructions during execution and maintains a live subroutine chain. When RET/RETI/RETN executes, the corresponding entry is removed. Most recent call is shown at the top.</p>
                    <ul>
                        <li><strong>Click</strong>: Navigate to address (prefers disasm panel, falls back to memory)</li>
                        <li><strong>Right-click</strong>: Context menu for explicit panel choice (disasm/memory, left/right)</li>
                        <li><strong>INT</strong> marker shown for interrupt-triggered entries</li>
                        <li>Labels from debugger and assembler are displayed alongside addresses</li>
                        <li>Direct SP manipulation (LD SP,nn etc.) resets the call stack</li>
                        <li>POP instructions do not affect the call stack (only true RET/RETI/RETN)</li>
                        <li>Cleared on machine reset; max depth: 32 levels</li>
                    </ul>
                    <h5>Overlay Modes</h5>
                    <p>Visual overlays for screen analysis (Settings row or F10 to cycle):</p>
                    <ul>
                        <li><strong>Normal</strong>: Standard display, no overlay</li>
                        <li><strong>Grid</strong>: 8×8 character cell grid over the screen</li>
                        <li><strong>Box</strong>: Yellow rectangle around the paper area boundary (256×192 region)</li>
                        <li><strong>Screen</strong>: Border-only — removes paper area, showing border colors extended across the full display</li>
                        <li><strong>Reveal</strong>: Normal screen content rendered at 50% transparency over border-only display — shows border effects underneath the screen picture</li>
                        <li><strong>Beam</strong>: ULA beam position indicator</li>
                        <li><strong>BeamScreen</strong>: Beam position over border-only display</li>
                        <li><strong>No Attr</strong>: Screen bitmap without attribute colors (monochrome)</li>
                        <li><strong>No Bitmap</strong>: Attribute colors only — bitmap replaced by diagonal X crosses per cell (ink on paper)</li>
                    </ul>
                    <h5>Bookmarks</h5>
                    <p>Quick navigation: click bookmark to jump, right-click to set bookmark at current address. 5 slots for disassembly, 5 for memory view.</p>
                    <p><strong>Hotkeys (paused mode only):</strong> 1-5 = left panel bookmarks, 6-9,0 = right panel bookmarks. Shift+digit sets bookmark at current address.</p>
                    <h5>Context Menu Navigation</h5>
                    <p>Right-click any address in disassembly or memory view for quick navigation:</p>
                    <ul>
                        <li><strong>Disasm left/right</strong>: Open address in left or right panel as disassembly</li>
                        <li><strong>Memory left/right</strong>: Open address in left or right panel as memory dump</li>
                        <li>In memory view, right-click works on both hex bytes and address column</li>
                    </ul>
                </div>
                <div class="fullhelp-section hidden" id="help-labels">
                    <h4>Labels</h4>
                    <p>Labels provide meaningful names for memory addresses in the disassembly view.</p>
                    <h5>Adding Labels</h5>
                    <ul>
                        <li>Right-click address in disassembly &rarr; "Add Label"</li>
                        <li>Or use the Labels panel "Add" button</li>
                    </ul>
                    <h5>Display Modes</h5>
                    <ul>
                        <li><strong>Address only</strong>: Show hex addresses</li>
                        <li><strong>Label only</strong>: Show label names</li>
                        <li><strong>Both</strong>: Show "address (label)"</li>
                    </ul>
                    <h5>Features</h5>
                    <ul>
                        <li>Labels appear in operands: <code>CALL main_loop</code></li>
                        <li>Persistent storage per loaded file (localStorage)</li>
                        <li>Import/Export to JSON files</li>
                        <li>Click label in list to navigate</li>
                        <li>Label count shown next to the Clear button</li>
                    </ul>
                </div>
                <div class="fullhelp-section hidden" id="help-signatures">
                    <h4>Signature Packs</h4>
                    <p>Modular knowledge base for automatic label and region recognition. Each pack is a self-contained JSON file with labels, regions, and byte-pattern anchors for matching.</p>
                    <h5>Pack Types</h5>
                    <ul>
                        <li><strong>Engine packs</strong> &mdash; Match known engines (AGD, Quill, PAW, etc.). One pack covers all games using that engine version.</li>
                        <li><strong>Game packs</strong> &mdash; Labels for a specific game from community disassemblies.</li>
                    </ul>
                    <h5>Workflow</h5>
                    <ol>
                        <li><strong>Import</strong> a .skool file, .asm/.a80 source, .zip archive, or pack JSON via Settings &rarr; Signatures</li>
                        <li><strong>Build Anchors</strong> &mdash; with the game loaded, click "Anchors" to snapshot byte patterns at key labeled addresses. Anchors automatically mask 16-bit address operands (CALL nn, JP nn, LD rr,nn, etc.) for cross-game matching.</li>
                        <li><strong>Scan Memory</strong> &mdash; load a game and click "Scan Memory" to find matching packs. Results show confidence percentage. Two-pass matching: exact first, then masked fallback.</li>
                        <li><strong>Apply</strong> &mdash; click "Apply" on a match to add labels and regions. Per-anchor offset voting handles procedures relocated to different addresses.</li>
                        <li><strong>Direct Apply</strong> &mdash; click "Apply" in the pack list to apply all labels at offset 0 (no scanning needed).</li>
                    </ol>
                    <h5>Cross-Game Matching</h5>
                    <p>Signature packs can match code across different games sharing the same engine (e.g. applying EATF labels to Bomberman). Each procedure is matched independently with its own offset, so shuffled code is handled correctly. Address operands in Z80 instructions are masked automatically, since absolute addresses differ between builds.</p>
                    <h5>Supported Formats</h5>
                    <ul>
                        <li><strong>.skool</strong> (SkoolKit) &mdash; reads <code>@label=</code> directives, control chars (<code>c</code>=code, <code>b</code>=data, <code>t</code>=text, <code>w</code>=words), inline comments</li>
                        <li><strong>.asm / .a80</strong> (sjasmplus, pasmo, z80asm) &mdash; reads labels, ORG directives, EQU constants, data directives (DEFB/DEFW/DEFS/DEFM). INCLUDE directives resolved when importing multiple files.</li>
                        <li><strong>.zip</strong> &mdash; archives containing any combination of .skool, .asm, and .a80 files. All source files are extracted and processed together.</li>
                    </ul>
                    <h5>GitHub Browser</h5>
                    <p>Click <strong>GitHub</strong> to browse a repository. Paste a URL (e.g. <code>github.com/Bedazzle/EATF</code>) or <code>owner/repo</code> shorthand. The scanner finds .skool, .asm, .a80 files recursively (up to 3 levels). ASM files are downloaded as a batch so INCLUDE directives resolve across the project.</p>
                    <h5>Pack Management</h5>
                    <ul>
                        <li>Enable/disable individual packs via checkboxes</li>
                        <li>Export packs as JSON for sharing</li>
                        <li>User-imported packs stored in localStorage</li>
                        <li>Shipped packs loaded from <code>signatures/</code> directory</li>
                    </ul>
                </div>
                <div class="fullhelp-section hidden" id="help-breakpoints">
                    <h4>Breakpoints &amp; Watchpoints</h4>
                    <h5>Execution Breakpoints</h5>
                    <ul>
                        <li>Click gutter (left margin) in disassembly</li>
                        <li>Or press F9 at current PC</li>
                        <li>Execution pauses when PC reaches breakpoint</li>
                    </ul>
                    <h5>Conditional Breakpoints</h5>
                    <p>Add conditions to break only when criteria are met:</p>
                    <table>
                        <tr><th>Type</th><th>Examples</th></tr>
                        <tr><td>Registers</td><td><code>A==0</code>, <code>HL&gt;4000</code>, <code>BC!=DE</code></td></tr>
                        <tr><td>Flags</td><td><code>Z</code>, <code>NZ</code>, <code>C</code>, <code>NC</code>, <code>P</code>, <code>M</code></td></tr>
                        <tr><td>Memory</td><td><code>(HL)==FF</code>, <code>(4000)==0</code>, <code>(IX+5)&gt;10</code></td></tr>
                        <tr><td>T-states</td><td><code>T&gt;=14335</code>, <code>TSTATES&lt;20000</code></td></tr>
                        <tr><td>Operators</td><td><code>==</code>, <code>!=</code>, <code>&lt;&gt;</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>&amp;</code>, <code>|</code></td></tr>
                        <tr><td>Literals</td><td>Hex: <code>FF</code>, <code>4000h</code> / Decimal: <code>255</code></td></tr>
                    </table>
                    <h5>Watchpoints</h5>
                    <p>Break on memory access:</p>
                    <ul>
                        <li><strong>Read watchpoint</strong>: Break when address is read</li>
                        <li><strong>Write watchpoint</strong>: Break when address is written</li>
                    </ul>
                    <h5>Port Breakpoints</h5>
                    <p>Break on I/O port access (IN/OUT instructions).</p>
                    <h5>Port I/O Log</h5>
                    <p>In the Trace tab, enable Port I/O logging to record all port reads/writes. Export produces a TSV file with columns: Dir, Port, Value, PC, Src, Frame, T-states.</p>
                    <p>The <strong>Src</strong> column identifies the ROM source when PC is in 0000-3FFF:</p>
                    <ul>
                        <li><strong>TRDOS</strong> &mdash; TR-DOS ROM is paged in (Beta Disk)</li>
                        <li><strong>ROM:N</strong> &mdash; ROM bank N (e.g. ROM:0 = 128 BASIC, ROM:2 = +3DOS)</li>
                        <li><strong>RAM</strong> &mdash; RAM mapped over ROM (Pentagon 1024, Scorpion, +2A special paging)</li>
                        <li><em>empty</em> &mdash; PC is in RAM (address &ge; 4000h)</li>
                    </ul>
                </div>
                <div class="fullhelp-section hidden" id="help-memory">
                    <h4>Memory Tools</h4>
                    <h5>Memory Dump</h5>
                    <ul>
                        <li>Hex view with inline editing (click byte to edit)</li>
                        <li>Click and drag to select range</li>
                        <li>Right-click selection for region marking</li>
                    </ul>
                    <h5>Memory Diff</h5>
                    <ol>
                        <li>Click <strong>Snap</strong> to snapshot current memory</li>
                        <li>Run the program</li>
                        <li>Changed bytes are highlighted in the dump</li>
                    </ol>
                    <h5>POKE Search</h5>
                    <p>Find memory locations storing game values (lives, score, etc.):</p>
                    <ol>
                        <li><strong>Snap</strong> - Take initial memory snapshot</li>
                        <li>Play game and change target value</li>
                        <li><strong>Search</strong> with mode:
                            <ul>
                                <li><code>Decreased</code> - value went down</li>
                                <li><code>Increased</code> - value went up</li>
                                <li><code>Changed</code> - any change</li>
                                <li><code>Unchanged</code> - stayed same</li>
                                <li><code>Equals</code> - specific hex value</li>
                            </ul>
                        </li>
                        <li>Repeat to narrow candidates</li>
                        <li>Click result to view in memory dump</li>
                    </ol>
                </div>
                <div class="fullhelp-section hidden" id="help-graphics">
                    <h4>Graphics Viewer</h4>
                    <p>View and analyze sprite/tile graphics stored in memory. Features a continuous memory dump view (EmuzWin-style). Access via the <strong>Graphics</strong> tab.</p>
                    <h5>Memory Dump View</h5>
                    <p>The main area shows memory rendered as graphics. Each byte is displayed as 8 horizontal pixels. A <span style="color:#f00">red rectangle</span> marks the current sprite selection.</p>
                    <h5>Controls</h5>
                    <ul>
                        <li><strong>Address</strong>: Current sprite address (hex). Press Enter to jump.</li>
                        <li><strong>Width</strong>: Sprite width in bytes (1-32). Each byte = 8 pixels. Max 32 = full screen width.</li>
                        <li><strong>Height</strong>: Sprite height in lines (1-64)</li>
                        <li><strong>Invert</strong>: Swap foreground/background colors</li>
                        <li><strong>Grid</strong>: Show grid lines (vertical between bytes, horizontal every 8 rows)</li>
                        <li><strong>x1/x2/x3</strong>: Zoom level for main dump view</li>
                    </ul>
                    <h5>Navigation</h5>
                    <ul>
                        <li><strong>-1/+1</strong>: Move sprite selection by 1 byte</li>
                        <li><strong>-Line/+Line</strong>: Move by one line (width bytes)</li>
                        <li><strong>-Row/+Row</strong>: Move by 8 lines (character row)</li>
                        <li><strong>-Spr/+Spr</strong>: Move by full sprite (width × height bytes)</li>
                        <li><strong>-Page/+Page</strong>: Move by 24 rows (192 lines × width bytes)</li>
                        <li><strong>Mouse wheel</strong>: Scroll the dump view</li>
                    </ul>
                    <h5>Actions</h5>
                    <ul>
                        <li><strong>Mark Region</strong>: Mark sprite as Graphics region (stores width/height)</li>
                        <li><strong>Copy Selection</strong>: Copy current selection as assembler DB statements</li>
                        <li><strong>Save Selection</strong>: Save current selection to .asm file</li>
                        <li><strong>Export All Marked</strong>: Export all marked Graphics regions to single file</li>
                        <li><strong>→ Disasm</strong>: Jump to address in disassembly</li>
                        <li><strong>→ Memory</strong>: Jump to address in memory dump</li>
                    </ul>
                </div>
                <div class="fullhelp-section hidden" id="help-regions">
                    <h4>Memory Regions</h4>
                    <p>Mark memory regions for reverse engineering analysis. Affects how memory is displayed in disassembly and memory map.</p>
                    <h5>Region Types</h5>
                    <table>
                        <tr><td><strong>Code</strong></td><td>Executable code (default)</td></tr>
                        <tr><td><strong>DB</strong></td><td>Data bytes - shown as <code>DB nn,nn,...</code></td></tr>
                        <tr><td><strong>DW</strong></td><td>Data words - shown as <code>DW nnnn,...</code></td></tr>
                        <tr><td><strong>Text</strong></td><td>ASCII strings - shown as <code>DB "text"</code></td></tr>
                        <tr><td><strong>Graphics</strong></td><td>Sprite/tile graphics</td></tr>
                        <tr><td><strong>SMC</strong></td><td>Self-modifying code</td></tr>
                    </table>
                    <h5>Auto-Map</h5>
                    <p>Automatically detect regions during execution:</p>
                    <ul>
                        <li>Executed addresses marked as Code</li>
                        <li>Read addresses marked as Data</li>
                        <li>Code that gets overwritten marked as SMC</li>
                    </ul>
                    <h5>Memory Map Dialog</h5>
                    <p>Visual 256x256 map of entire 64KB memory. Click to navigate, colors indicate region types.</p>
                    <h5>Export ASM</h5>
                    <p>Export disassembly as sjasmplus-compatible ASM file from the Memory Map dialog:</p>
                    <ul>
                        <li>Uses memory regions to determine code vs data</li>
                        <li>Code regions disassembled as Z80 instructions</li>
                        <li>DB/DW/Text regions exported with appropriate directives</li>
                        <li>Graphics regions exported as DB with width/height metadata</li>
                        <li>Includes labels and CPU state in header</li>
                        <li><strong>Addr+Bytes</strong> option adds address and hex bytes as comments</li>
                        <li>Screen memory ($4000-$5AFF) exported as INCBIN directive</li>
                    </ul>
                </div>
                <div class="fullhelp-section hidden" id="help-xrefs">
                    <h4>Cross-References (XRefs)</h4>
                    <p>Track where addresses are referenced from in the code.</p>
                    <h5>Generating XRefs</h5>
                    <ul>
                        <li><strong>Scan</strong> - Scan visible disassembly range</li>
                        <li><strong>Scan All</strong> - Scan full 64KB memory</li>
                        <li><strong>Runtime</strong> checkbox - Collect refs during execution</li>
                    </ul>
                    <h5>Viewing XRefs</h5>
                    <p>Hover over an address operand in disassembly to see tooltip showing all references to that address.</p>
                    <h5>Reference Types</h5>
                    <ul>
                        <li><span style="color:#ff8080">CALL</span> - subroutine calls</li>
                        <li><span style="color:#80ff80">JP</span> - absolute jumps</li>
                        <li><span style="color:#80ffff">JR/DJNZ</span> - relative jumps</li>
                        <li><span style="color:#ffff80">LD</span> - data references</li>
                    </ul>
                </div>
                <div class="fullhelp-section hidden" id="help-files">
                    <h4>File Formats</h4>
                    <h5>Snapshots (Load &amp; Save)</h5>
                    <p>Use the <strong>Save</strong> dropdown to choose format (SNA/Z80/SZX).</p>
                    <table>
                        <tr><td><strong>SNA</strong></td><td>48K/128K - simple format, widely supported</td></tr>
                        <tr><td><strong>SZX</strong></td><td>Spectaculator format with zlib compression</td></tr>
                        <tr><td><strong>Z80</strong></td><td>v1/v2/v3 load, v3 save (48K/128K/+2/Pentagon)</td></tr>
                    </table>
                    <h5>Quicksave / Quickload</h5>
                    <p>Instant state save/restore during gameplay using browser localStorage.</p>
                    <table>
                        <tr><td><strong>F2</strong></td><td>Quicksave - saves current state</td></tr>
                        <tr><td><strong>F5</strong></td><td>Quickload - restores saved state</td></tr>
                    </table>
                    <p style="font-size: 11px; color: var(--text-dim);">Also accessible via Save → Quick (F2) and Load → Quick (F5). Uses SZX format internally.</p>
                    <h5>Tapes</h5>
                    <table>
                        <tr><td><strong>TAP</strong></td><td>Standard tape format</td></tr>
                        <tr><td><strong>TZX</strong></td><td>Extended tape format (turbo blocks, pure tone, loops)</td></tr>
                    </table>
                    <p><strong>Loading modes:</strong></p>
                    <ul>
                        <li><strong>Flash Load</strong> (default, checkbox on): Instant loading via ROM traps - most reliable</li>
                        <li><strong>Real-time</strong> (Flash Load off): Cycle-accurate playback with border stripes and sound</li>
                    </ul>
                    <p style="color: var(--yellow); font-size: 11px;"><strong>Note:</strong> Real-time tape loading is work in progress. Standard loaders and many turbo loaders work; some copy protection schemes may fail. Use Flash Load for problematic tapes.</p>
                    <h5>Input Recording</h5>
                    <table>
                        <tr><td><strong>RZX</strong></td><td>Playback with embedded snapshot (may desync)</td></tr>
                    </table>
                    <h5>Disk Images</h5>
                    <table>
                        <tr><td><strong>TRD</strong></td><td>TR-DOS disk image (Pentagon/Beta Disk)</td></tr>
                        <tr><td><strong>SCL</strong></td><td>TR-DOS file archive (more compact format)</td></tr>
                        <tr><td><strong>DSK</strong></td><td>+3 disk image (standard and extended CPC DSK format)</td></tr>
                    </table>
                    <h5>Boot File Injection</h5>
                    <p>Automatically add a boot loader to TRD disk images via Settings → Media → Boot File:</p>
                    <ol>
                        <li>Click <strong>Select...</strong> to choose a boot file source (TRD or Hobeta)</li>
                        <li>Select the injection mode from the dropdown</li>
                    </ol>
                    <table>
                        <tr><td><strong>No change</strong></td><td>Load TRD images as-is (default)</td></tr>
                        <tr><td><strong>Add boot</strong></td><td>Add boot only if TRD has no boot file</td></tr>
                        <tr><td><strong>Replace boot</strong></td><td>Replace existing boot, or add if none</td></tr>
                    </table>
                    <p style="font-size: 11px; color: var(--text-dim);">Supports TRD disk images and Hobeta files (typically .$b or .$c). When replacing, the new boot file reuses the old boot's disk location if it fits. Settings are saved in localStorage.</p>
                    <h5>Archives</h5>
                    <table>
                        <tr><td><strong>ZIP</strong></td><td>Select file from archive dialog</td></tr>
                    </table>
                    <h5>Game Browser (Load → Web)</h5>
                    <p>Search and download games online from <a href="https://spectrumcomputing.co.uk" target="_blank">Spectrum Computing</a> (ZXDB database).</p>
                    <ul>
                        <li>Search by title - results sorted alphabetically</li>
                        <li>View screenshots, year, publisher, genre, authors</li>
                        <li>Direct download links for TAP, TZX, Z80, SNA files</li>
                        <li>Drag downloaded files into emulator to play</li>
                    </ul>
                    <p style="font-size: 11px; color: var(--text-dim);">Powered by ZXInfo API (api.zxinfo.dk). Zero dependencies - works directly from browser.</p>
                    <h5>Project Files</h5>
                    <p>Save/Load complete session state:</p>
                    <ul>
                        <li>Current snapshot</li>
                        <li>All breakpoints and watchpoints</li>
                        <li>Labels and comments</li>
                        <li>Memory regions</li>
                        <li>Cross-references</li>
                        <li>Bookmarks</li>
                        <li>Loaded media (TAP/TRD/SCL) with tape position</li>
                    </ul>
                    <h5>AY Music Export (PSG)</h5>
                    <p>Record AY chip output to PSG file format in Settings → AY Capture:</p>
                    <ul>
                        <li><strong>Record</strong> - Start capturing AY register writes</li>
                        <li><strong>Export</strong> - Stop and save as .psg file</li>
                        <li><strong>Cancel</strong> - Discard recording</li>
                        <li><strong>Changed only</strong> - Export only modified registers (smaller files)</li>
                        <li><strong>Get Player</strong> - Download Z80 assembly player source</li>
                    </ul>
                    <p>The player source is sjasmplus-compatible. Use <code>INCBIN "music.psg"</code> to include your recorded music, then assemble to create a playable .sna file.</p>
                    <h5>Screen Export</h5>
                    <p>Capture frames in Settings → Export section:</p>
                    <table>
                        <tr><td><strong>ZIP</strong></td><td>PNG sequence in ZIP archive</td></tr>
                        <tr><td><strong>GIF</strong></td><td>Animated GIF</td></tr>
                        <tr><td><strong>SCR</strong></td><td>ZX Spectrum screen (6912 bytes)</td></tr>
                        <tr><td><strong>BSC</strong></td><td>Screen + border (11136 bytes)</td></tr>
                        <tr><td><strong>SCA</strong></td><td>Animation format (see below)</td></tr>
                    </table>
                    <p><strong>SCA Animation Export:</strong></p>
                    <ul>
                        <li><strong>Type 0</strong> - Full 6912-byte SCR frames (larger files)</li>
                        <li><strong>Type 1</strong> - 8-byte fill pattern + 768-byte attributes per frame (multicolor)</li>
                    </ul>
                    <p><strong>Type 1 Fill Patterns:</strong></p>
                    <table>
                        <tr><td><strong>Automatic</strong></td><td>Detect pattern from screen bitmap</td></tr>
                        <tr><td><strong>53c (AA 55)</strong></td><td>Checkerboard dithering</td></tr>
                        <tr><td><strong>127c (DD 77)</strong></td><td>Ink-biased dithering</td></tr>
                        <tr><td><strong>Vertical 4x8</strong></td><td>4-pixel vertical stripes (F0)</td></tr>
                        <tr><td><strong>Horizontal 8x4</strong></td><td>4-row horizontal stripes (FF/00)</td></tr>
                        <tr><td><strong>Custom</strong></td><td>Enter 8 hex bytes manually</td></tr>
                    </table>
                    <p style="font-size: 11px; color: var(--text-dim);">Type 1 is for multicolor animations where bitmap stays constant and only attributes change. Automatic mode detects if screen uses a consistent 8-byte pattern; prompts for choice if not detected.</p>
                </div>
                <div class="fullhelp-section hidden" id="help-assembler">
                    <h4>Z80 Assembler</h4>
                    <p>Integrated sjasmplus-compatible Z80 assembler for writing and testing code directly in the emulator.</p>
                    <p><a href="https://z00m128.github.io/sjasmplus/documentation.html" target="_blank" style="color: var(--cyan);">Full sjasmplus Documentation</a></p>
                    <h5>Keyboard Shortcuts</h5>
                    <table>
                        <tr><td><strong>F9</strong></td><td>Assemble code</td></tr>
                        <tr><td><strong>Ctrl+F</strong></td><td>Find</td></tr>
                        <tr><td><strong>Ctrl+R</strong> or <strong>Ctrl+H</strong></td><td>Find and Replace</td></tr>
                        <tr><td><strong>F3</strong></td><td>Find Next</td></tr>
                        <tr><td><strong>Shift+F3</strong></td><td>Find Previous</td></tr>
                        <tr><td><strong>Escape</strong></td><td>Close search bar</td></tr>
                    </table>
                    <h5>Toolbar Buttons</h5>
                    <ul>
                        <li><strong>Files ▼</strong> - Browse project files (disabled when ≤1 file)</li>
                        <li><strong>Assemble</strong> - Compile the assembly code (F9)</li>
                        <li><strong>Inject</strong> - Write assembled bytes to emulator memory</li>
                        <li><strong>Debug</strong> - Inject code, set PC to entry point, switch to debugger. Entry point priority: SAVESNA address > single ORG > prompt if multiple ORGs. Also injects assembler labels into the debugger (visible in disassembly, Calls panel, etc.); internal labels prefixed with <code>__</code> are skipped, and existing debugger labels are not overwritten</li>
                        <li><strong>Clear</strong> - Clear editor and reset project</li>
                        <li><strong>New</strong> - Add a new file to the project</li>
                        <li><strong>Load</strong> - Load .asm file or .zip project</li>
                        <li><strong>Export</strong> - Save source files as ZIP</li>
                        <li><strong>Download</strong> - Download generated output files (.bin, .sna, .tap). If multiple files, downloads as ZIP archive</li>
                    </ul>
                    <h5>Drag & Drop</h5>
                    <ul>
                        <li>Drag .asm or .zip files directly onto the editor to load them</li>
                        <li>If a file with the same name exists, you'll be asked to replace or add as new</li>
                        <li>Drag ROM/snapshot files (.sna, .tap, .trd) onto the emulator screen area instead</li>
                    </ul>
                    <h5>Multi-File Projects</h5>
                    <ul>
                        <li>Load a ZIP file containing multiple .asm files</li>
                        <li>Main file (red label) is assembled first and includes others</li>
                        <li>Click main file label to change which file is the main</li>
                        <li>Use tabs to switch between open files</li>
                        <li>Use <code>INCLUDE "filename.asm"</code> to include other files</li>
                    </ul>
                    <h5>Search All Files</h5>
                    <ul>
                        <li>Open search bar with Ctrl+F</li>
                        <li>Click <strong>All Files</strong> button to search across all project files</li>
                        <li>Results show filename, line number, and matching text</li>
                        <li>Click any result to jump to that file and line</li>
                    </ul>
                    <h5>Output Options</h5>
                    <ul>
                        <li><strong>Unused labels</strong> - Show labels that are defined but never referenced</li>
                        <li><strong>Show compiled</strong> - Include hex dump of assembled bytes</li>
                    </ul>
                    <h5>Command-Line Defines</h5>
                    <p>Use the <strong>Defines</strong> input field to pass defines for conditional assembly:</p>
                    <ul>
                        <li>Format: <code>NAME,NAME=value,...</code></li>
                        <li>Simple define: <code>DEBUG</code> (value = 1)</li>
                        <li>With value: <code>VERSION=5</code> or <code>BUILD=$100</code></li>
                        <li>Multiple: <code>DEBUG,VERSION=5,RELEASE</code></li>
                    </ul>
                    <h5>@define Markers</h5>
                    <p>Add <code>; @define</code> comments in the first 50 lines of your main file to show a dropdown of available defines:</p>
                    <pre>; @define DEBUG
; @define RELEASE
; @define VERSION=5
; @define BUILD=$0100</pre>
                    <p>The dropdown appears automatically. Ctrl+click to select multiple defines.</p>
                    <h5>Output Files</h5>
                    <p>Use directives to generate output files:</p>
                    <ul>
                        <li><code>SAVEBIN "file.bin", start, length</code> - Save binary data</li>
                        <li><code>SAVESNA "file.sna", start</code> - Save 48K SNA snapshot</li>
                        <li><code>SAVETAP "file.tap", CODE, "name", start, length</code> - Save TAP file</li>
                        <li><code>EMPTYTAP "file.tap"</code> - Create empty TAP (for multiple blocks)</li>
                    </ul>
                    <p>Generated files are listed in the output with size and MD5 hash.</p>
                    <h5>MD5 Checksum Verification</h5>
                    <p>Add expected MD5 hash in a comment to verify output:</p>
                    <pre>SAVEBIN "game.bin", $8000, $1000  ; md5: a1b2c3d4e5f6...</pre>
                    <p>Or use the MD5CHECK macro:</p>
                    <pre>MD5CHECK "game.bin", "a1b2c3d4e5f6..."</pre>
                    <p>Output shows <span style="color:#80ff80">MD5 OK</span> or <span style="color:#ff8080">MD5 MISMATCH</span>.</p>
                    <h5>Supported Directives</h5>
                    <ul>
                        <li><strong>ORG</strong> - Set origin address</li>
                        <li><strong>EQU</strong> - Define constant</li>
                        <li><strong>DEFINE</strong> - Define symbol</li>
                        <li><strong>DB/DEFB</strong> - Define bytes</li>
                        <li><strong>DW/DEFW</strong> - Define words</li>
                        <li><strong>DS/DEFS/BLOCK</strong> - Reserve space</li>
                        <li><strong>DZ</strong> - Zero-terminated string</li>
                        <li><strong>DC</strong> - High-bit terminated string</li>
                        <li><strong>ALIGN</strong> - Align to boundary</li>
                        <li><strong>INCLUDE</strong> - Include source file</li>
                        <li><strong>INCBIN</strong> - Include binary file</li>
                        <li><strong>IF/ELSE/ENDIF</strong> - Conditional assembly</li>
                        <li><strong>IFDEF/IFNDEF</strong> - Check if defined</li>
                        <li><strong>MACRO/ENDM</strong> - Define macro</li>
                        <li><strong>REPT/ENDR</strong> - Repeat block</li>
                        <li><strong>STRUCT/ENDS</strong> - Define structure</li>
                        <li><strong>DEVICE</strong> - Set target device (ZXSPECTRUM48, ZXSPECTRUM128)</li>
                        <li><strong>SLOT/PAGE</strong> - Memory paging (128K)</li>
                    </ul>
                </div>
                <div class="fullhelp-section hidden" id="help-tests">
                    <h4>Automated Tests</h4>
                    <p>The Tests tab provides automated regression testing for the emulator using native Spectrum programs.</p>

                    <h5>Test Configuration (tests.json)</h5>
                    <p>Tests are defined in <code>tests.json</code> with the following structure:</p>
                    <pre>{
    "tests": [
        {
            "id": "unique-id",
            "name": "Display Name",
            "file": "tests/program.tap",
            "machine": "48k",           // 48k, 128k, +2, +2a, +3, pentagon, pentagon1024, scorpion
            "earlyTimings": true,       // Use early ULA timings
            "ulaplus": false,           // Enable ULAplus (default: false)
            "palette": "default",       // Color palette
            "enabled": true,            // false to skip
            "fullBorder": true,         // Include border in comparison
            "diskRun": "game",          // TRD/SCL: program to RUN (optional)
            "author": "Author Name",    // Test program author
            "source": "https://...",    // Source URL
            "steps": [
                { "frames": 500, "screen": "tests/screen1.png" }
            ]
        }
    ]
}</pre>

                    <h5>Step Definition</h5>
                    <table>
                        <tr><th>Field</th><th>Description</th></tr>
                        <tr><td><code>frames</code></td><td>Absolute frame number from test start (required)</td></tr>
                        <tr><td><code>screen</code></td><td>Path to reference PNG screenshot (optional)</td></tr>
                        <tr><td><code>keys</code></td><td>Keys to press before running this step (optional)</td></tr>
                    </table>

                    <h5>Multi-Step Tests</h5>
                    <p>For programs with multiple screens (e.g., menu → game → results), use multiple steps with key presses:</p>
                    <pre>{
    "steps": [
        { "frames": 2350, "screen": "tests/menu.png" },
        { "frames": 5000, "screen": "tests/game.png", "keys": "ENTER" },
        { "frames": 8000, "screen": "tests/results.png", "keys": "SPACE" }
    ]
}</pre>
                    <p><em>Note: Frame counts are absolute from test start, not relative to previous step.</em></p>

                    <h5>Key String Format</h5>
                    <table>
                        <tr><th>Format</th><th>Example</th><th>Description</th></tr>
                        <tr><td>Single key</td><td><code>ENTER</code></td><td>Press Enter key</td></tr>
                        <tr><td>Letter/digit</td><td><code>a</code>, <code>1</code></td><td>Press letter or digit</td></tr>
                        <tr><td>Caps Shift</td><td><code>CTRL+a</code></td><td>Caps Shift + A</td></tr>
                        <tr><td>Symbol Shift</td><td><code>ALT+p</code></td><td>Symbol Shift + P (produces ")</td></tr>
                        <tr><td>Sequence</td><td><code>ENTER,500ms,SPACE</code></td><td>ENTER, wait 500ms, then SPACE</td></tr>
                        <tr><td>Repeated keys</td><td><code>q,q,q,ENTER</code></td><td>Press Q three times, then ENTER</td></tr>
                        <tr><td>Repeated + delay</td><td><code>q,200ms,q,200ms,ENTER</code></td><td>Q, wait 200ms, Q, wait 200ms, ENTER</td></tr>
                        <tr><td>Comma key</td><td><code>ALT+n</code></td><td>Symbol Shift + N = comma on Spectrum</td></tr>
                    </table>

                    <h5>Special Keys</h5>
                    <p><code>ENTER</code>, <code>SPACE</code>, <code>CTRL</code> (Caps Shift), <code>ALT</code> (Symbol Shift),
                       <code>UP</code>, <code>DOWN</code>, <code>LEFT</code>, <code>RIGHT</code></p>

                    <h5>Preview Mode</h5>
                    <p>Use <strong>Preview</strong> to run a test with live display for calibrating frame numbers:</p>
                    <ol>
                        <li>Select a test and click <strong>Preview</strong></li>
                        <li>Click <strong>Pause</strong> when the desired screen appears</li>
                        <li>Click <strong>Copy Frame#</strong> to copy the frame count</li>
                        <li>Click <strong>Screenshot</strong> to save reference PNG</li>
                        <li>Update tests.json with the frame number and screenshot path</li>
                    </ol>

                    <h5>Example: Raxoft Z80 Test</h5>
                    <pre>{
    "id": "z80ccf",
    "name": "Raxoft z80ccf",
    "file": "tests/z80ccf.tap",
    "machine": "48k",
    "earlyTimings": true,
    "enabled": true,
    "steps": [
        { "frames": 2350, "screen": "tests/z80ccf_1.png" },
        { "frames": 5076, "screen": "tests/z80ccf_2.png", "keys": "ENTER" },
        { "frames": 6610, "screen": "tests/z80ccf_3.png", "keys": "ENTER" },
        { "frames": 8430, "screen": "tests/z80ccf_4.png", "keys": "ENTER" }
    ]
}</pre>

                    <h5>Example: TRD Disk Test</h5>
                    <pre>{
    "id": "disk-game",
    "name": "Game (TRD)",
    "file": "tests/game.trd",
    "machine": "pentagon",
    "diskRun": "game",          // Program name to run from disk
    "enabled": true,
    "steps": [
        { "frames": 500, "screen": "tests/game_menu.png" }
    ]
}</pre>
                    <p><code>diskRun</code> values: program name (e.g. <code>"game"</code>) for <code>RUN "game"</code>, or <code>"boot"</code> for <code>RUN</code> (boot file).</p>

                    <h5>Example: DSK Disk Test (+3)</h5>
                    <pre>{
    "id": "plus3-game",
    "name": "Game (DSK)",
    "file": "tests/game.dsk",
    "machine": "+3",
    "enabled": true,
    "steps": [
        { "frames": 800, "screen": "tests/game_menu.png" }
    ]
}</pre>
                    <p>DSK tests auto-boot via the +3 ROM. No <code>diskRun</code> needed — the +3 ROM auto-detects and loads from disk.</p>
                </div>
                <div class="fullhelp-section hidden" id="help-compare">
                    <h4>Compare Tool</h4>
                    <p>The Compare tab allows comparing snapshots and binary files to identify differences in memory and CPU state.</p>

                    <h5>Comparison Modes</h5>
                    <table>
                        <tr><th>Mode</th><th>Description</th></tr>
                        <tr><td><strong>Snapshots</strong></td><td>Compare two snapshot files (.SNA or .Z80, 48K or 128K)</td></tr>
                        <tr><td><strong>Binaries</strong></td><td>Compare two raw binary files byte-by-byte</td></tr>
                        <tr><td><strong>Snapshot vs Emulator</strong></td><td>Compare a snapshot file against current emulator state</td></tr>
                    </table>

                    <h5>Supported Formats</h5>
                    <ul>
                        <li><strong>Binary</strong> - Any raw binary file</li>
                        <li><strong>SNA</strong> - 48K (49179 bytes) and 128K (131103/147487 bytes)</li>
                        <li><strong>SZX</strong> - Spectaculator format (48K and 128K)</li>
                        <li><strong>Z80</strong> - Version 1, 2, and 3 formats (48K and 128K)</li>
                    </ul>

                    <h5>Options</h5>
                    <table>
                        <tr><th>Option</th><th>Description</th></tr>
                        <tr><td><strong>Show equal values</strong></td><td>Display matching bytes in addition to differences</td></tr>
                        <tr><td><strong>Hex dump</strong></td><td>Show side-by-side hex dump with ASCII representation</td></tr>
                        <tr><td><strong>Exclude screen</strong></td><td>Skip screen memory ($4000-$5AFF and $C000-$DAFF for 128K)</td></tr>
                    </table>

                    <h5>Register Comparison</h5>
                    <p>When comparing snapshots, CPU registers are displayed in two columns:</p>
                    <ul>
                        <li>Left column: Main registers (AF, BC, DE, HL, PC, IX, I, IM, Border)</li>
                        <li>Right column: Alternate registers (AF', BC', DE', HL', SP, IY, R, IFF1, IFF2)</li>
                    </ul>
                    <p>Differences are highlighted in red with a ◄ marker.</p>

                    <h5>Memory Comparison</h5>
                    <p>Memory differences are shown in a side-by-side hex dump with:</p>
                    <ul>
                        <li>Address and hex values for both files</li>
                        <li>ASCII representation (unprintable chars shown as dots)</li>
                        <li>Differing bytes highlighted in red</li>
                        <li>Pagination for large differences (50 blocks per page)</li>
                    </ul>

                    <h5>Use Cases</h5>
                    <ul>
                        <li>Verify emulator accuracy by comparing against reference snapshots</li>
                        <li>Debug save state issues</li>
                        <li>Analyze memory changes between two execution points</li>
                        <li>Compare different versions of a program</li>
                    </ul>
                </div>
                <div class="fullhelp-section hidden" id="help-explorer">
                    <h4>Explorer</h4>
                    <p>The Explorer tab analyzes ZX Spectrum file formats without loading them into the emulator.</p>
                    <h5>Supported Formats</h5>
                    <table>
                        <tr><th>Format</th><th>Description</th></tr>
                        <tr><td>RZX</td><td>Input recordings</td></tr>
                        <tr><td>SCL</td><td>TR-DOS file archives</td></tr>
                        <tr><td>SNA</td><td>48K/128K snapshots with registers</td></tr>
                        <tr><td>SZX</td><td>Spectaculator snapshots</td></tr>
                        <tr><td>TAP</td><td>Tape files with block structure</td></tr>
                        <tr><td>TRD</td><td>TR-DOS disk images</td></tr>
                        <tr><td>Z80</td><td>Compressed snapshots (v1, v2, v3)</td></tr>
                        <tr><td>ZIP</td><td>Archives containing above formats</td></tr>
                    </table>
                    <h5>Sub-tabs</h5>
                    <ul>
                        <li><strong>File Info</strong> - File structure, blocks, registers, disk catalog</li>
                        <li><strong>BASIC</strong> - Decode and display BASIC programs with syntax highlighting</li>
                        <li><strong>Disasm</strong> - Z80 disassembly with ROM labels, click addresses in BASIC to jump</li>
                        <li><strong>Hex Dump</strong> - Raw hex view with ASCII column</li>
                    </ul>
                    <h5>Features</h5>
                    <ul>
                        <li>Screen preview for snapshots and screen files</li>
                        <li>Click on TRD/SCL files to view: BASIC files open decoder, CODE files open disassembly</li>
                        <li>Click USR addresses in BASIC to jump to disassembly</li>
                        <li>Disassembly shows blank lines after JP, JR, CALL, RET, RST, DJNZ, HALT</li>
                        <li>Copy-friendly output format (text copies correctly to clipboard)</li>
                        <li>ROM routine labels shown in disassembly</li>
                    </ul>
                    <h5>TR-DOS File Types</h5>
                    <table>
                        <tr><th>Ext</th><th>Type</th></tr>
                        <tr><td>B</td><td>BASIC program</td></tr>
                        <tr><td>C</td><td>Code (machine code)</td></tr>
                        <tr><td>D</td><td>Data array</td></tr>
                        <tr><td>#</td><td>Sequential file</td></tr>
                    </table>
                </div>
                <div class="fullhelp-section hidden" id="help-api">
                    <h4>JavaScript API</h4>
                    <p>Access emulator via browser console:</p>
                    <pre>
// Access emulator
window.spectrum

// Get version
APP_VERSION

// Memory access
spectrum.peek(0x4000)
spectrum.poke(0x4000, 0xff)

// Control
spectrum.start()
spectrum.stop()
spectrum.reset()

// Breakpoints
spectrum.addBreakpoint(0x0000)
spectrum.addBreakpointWithCondition('4000', 'A==0')
spectrum.removeBreakpoint(0x0000)
spectrum.getBreakpoints()
spectrum.clearBreakpoints()

// Labels
labelManager.add({
    address: 0x4000,
    name: 'main_loop',
    comment: 'Main game loop'
})
labelManager.get(0x4000)
labelManager.remove(0x4000)
labelManager.findByName('main_loop')
labelManager.exportJSON()
labelManager.importJSON(jsonStr, merge)</pre>
                </div>
                <div class="fullhelp-section hidden" id="help-about">
                    <div style="text-align: center; margin: 15px 0;">
                        <img src="docs/m8xxx_cat.jpg" alt="M8XXX Cat" style="max-width: 300px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.5);">
                    </div>
                    <h5>The Name</h5>
                    <p><strong>ZX-M8XXX</strong> stands for <strong>ZX Matrix</strong> — a nod to the iconic 8-bit architecture and the intricate web of code, memory, and pixels that make up the Spectrum experience.</p>
                    <h5>License</h5>
                    <p>This software is released under the <strong>GPL-3.0</strong> license.</p>
                    <p>You are free to use, modify, and distribute this software under the terms of the GNU General Public License version 3.</p>
                    <p><a href="https://www.gnu.org/licenses/gpl-3.0.html" target="_blank" style="color: var(--cyan);">Read the full GPL-3.0 license text</a></p>
                    <p><strong>Test Programs:</strong> The test programs in the <code>tests/</code> folder (z80ccf, z80doc, z80docflags, etc.) are copyright of their respective authors. These programs are included for emulator validation purposes only.</p>
                    <h5>Source Code</h5>
                    <p><a href="https://github.com/Bedazzle/ZX-M8XXX" target="_blank" style="color: var(--cyan);">https://github.com/Bedazzle/ZX-M8XXX</a></p>
                    <h5>Inspired By</h5>
                    <ul>
                        <li><strong>JSSpeccy 3</strong> - Matt Westcott's excellent JavaScript Spectrum emulator</li>
                        <li><strong>Fuse</strong> - The Free Unix Spectrum Emulator</li>
                        <li><strong>EmuzWin</strong> - Windows Spectrum emulator</li>
                        <li><strong>Swan</strong> - Delphi Spectrum emulator (I/O contention algorithm)</li>
                        <li><strong>ZXMAK2</strong> - .NET Spectrum emulator</li>
                        <li><strong>IDA Pro</strong> - Interactive disassembler (debugger UI concepts)</li>
                        <li><strong>Ghidra</strong> - NSA reverse engineering tool (analysis features)</li>
                    </ul>
                    <h5>Known Limitations</h5>
                    <ul>
                        <li><strong>Chained prefix interrupts:</strong> On real Z80, interrupts can occur between chained DD/FD prefix bytes (each prefix is a separate instruction fetch). This emulator processes prefix chains atomically within a single step, so interrupts cannot occur mid-chain. This rarely affects real software.</li>
                        <li><strong>Floating bus:</strong> Not fully emulated. Some copy protection schemes may not work.</li>
                        <li><strong>Z80 save uncompressed:</strong> Z80 snapshots saved without RLE compression for compatibility (~131KB for 128K, ~49KB for 48K).</li>
                    </ul>
                    <h5>Technical References</h5>
                    <ul>
                        <li>Z80 CPU User Manual (Zilog)</li>
                        <li>The Undocumented Z80 Documented (Sean Young)</li>
                        <li>World of Spectrum documentation</li>
                    </ul>
                    <h5>Greetings</h5>
                    <p>Greetings fly out to:</p>
                    <ul>
                        <li>The ZX Spectrum demo scene and retro computing community</li>
                        <li>All the developers keeping the Speccy spirit alive</li>
                        <li>Everyone who contributed to documenting the Z80 and ZX Spectrum hardware</li>
                        <li>Amstrad for allowing free distribution of Spectrum ROMs</li>
                    </ul>
                    <p style="margin-top: 20px; color: var(--text-secondary); font-style: italic;">
                        "The Spectrum lives on!"
                    </p>
                </div>
            </div>
        </div>
    </div>

    <!-- File Selector Dialog -->
    <div class="file-selector-dialog hidden" id="fileSelectorDialog">
        <div class="file-selector-content">
            <div class="file-selector-header">
                <h3 id="fileSelectorTitle">Select Main File</h3>
                <button class="file-selector-close" id="btnFileSelectorClose">&times;</button>
            </div>
            <div class="file-selector-body" id="fileSelectorBody">
            </div>
        </div>
    </div>

    <div class="drop-zone" id="dropZone">Drop ROM or Snapshot here</div>

    <script>
        function is128kCompat(type) { return type === '128k' || type === '+2' || type === '+2a' || type === '+3'; }
    </script>

    <script src="constants.js"></script>
    <script src="machines.js"></script>

    <!-- Load modules in dependency order -->
    <script src="pako.min.js"></script>
    <script src="z80.js"></script>
    <script src="memory.js"></script>
    <script src="ula.js"></script>
    <script src="loaders.js"></script>
    <script src="fdc.js"></script>
    <script src="spectrum.js"></script>
    <script src="ay.js"></script>
    <script src="disasm.js"></script>
    <!-- sjasmplus-js assembler -->
    <script src="sjasmplus/errors.js"></script>
    <script src="sjasmplus/lexer.js"></script>
    <script src="sjasmplus/expression.js"></script>
    <script src="sjasmplus/labels.js"></script>
    <script src="sjasmplus/instructions.js"></script>
    <script src="sjasmplus/instructions2.js"></script>
    <script src="sjasmplus/instructions3.js"></script>
    <script src="sjasmplus/memory.js"></script>
    <script src="sjasmplus/output.js"></script>
    <script src="sjasmplus/preprocessor.js"></script>
    <script src="sjasmplus/parser.js"></script>
    <script src="sjasmplus/vfs.js"></script>
    <script src="sjasmplus/md5.js"></script>
    <script src="sjasmplus/assembler.js"></script>
    
    <script>
        const APP_VERSION = '0.9.31';
        console.log('ZX-M8XXX v' + APP_VERSION);

        // Auto Load timing constants (ms)
        const AUTO_LOAD_ROM_WAIT     = 3000;  // Wait for ROM init after reset
        const AUTO_LOAD_128K_WAIT    = 1500;  // Extra wait after 128K menu "1" press
        const AUTO_LOAD_KEY_HOLD     = 200;   // How long to hold each key
        const AUTO_LOAD_KEY_GAP      = 150;   // Gap between keypresses

        // Tape header constants
        const TAPE_STD_PILOT_PULSE   = 2168;  // Standard pilot pulse length (T-states)
        const TAPE_TURBO_TOLERANCE   = 50;    // Deviation from standard to classify as turbo
        const TAPE_STD_FLAG          = 0x00;  // Flag byte for standard header blocks
        const TAPE_HDR_MIN_LENGTH    = 18;    // Minimum data length for a valid header
        const TAPE_HDR_TYPE_PROGRAM  = 0;
        const TAPE_HDR_TYPE_NUM_ARR  = 1;
        const TAPE_HDR_TYPE_CHR_ARR  = 2;
        const TAPE_HDR_TYPE_BYTES    = 3;

        // TRD disk geometry
        const TRD_SECTOR_SIZE        = 256;
        const TRD_SECTOR9_OFFSET     = 8 * TRD_SECTOR_SIZE;  // Sector 9 (system info)
        const TRD_FREE_SECS_LO      = 0xE5;  // Offset within sector 9
        const TRD_FREE_SECS_HI      = 0xE6;
        const TRD_LABEL_OFFSET       = 0xF5;  // Disk label start within sector 9
        const TRD_LABEL_LENGTH       = 8;
        const TRD_MIN_IMAGE_SIZE     = 0x8E7; // Minimum size to have valid system sector

        // Help modal
        const helpModal = document.getElementById('helpModal');
        const btnHelpClose = document.getElementById('btnHelpClose');

        btnHelpClose.addEventListener('click', () => helpModal.classList.add('hidden'));
        helpModal.addEventListener('click', (e) => {
            if (e.target === helpModal) helpModal.classList.add('hidden');
        });

        // Full Help Dialog
        const fullHelpDialog = document.getElementById('fullHelpDialog');
        const btnHelpFull = document.getElementById('btnHelpFull');
        const btnFullHelpClose = document.getElementById('btnFullHelpClose');
        const helpNavBtns = fullHelpDialog.querySelectorAll('.fullhelp-nav-btn');
        const helpSections = fullHelpDialog.querySelectorAll('.fullhelp-section');

        function showHelpSection(sectionId) {
            helpNavBtns.forEach(btn => btn.classList.remove('active'));
            helpSections.forEach(sec => sec.classList.add('hidden'));
            const activeBtn = fullHelpDialog.querySelector(`.fullhelp-nav-btn[data-section="${sectionId}"]`);
            const activeSection = document.getElementById('help-' + sectionId);
            if (activeBtn) activeBtn.classList.add('active');
            if (activeSection) activeSection.classList.remove('hidden');
        }

        btnHelpFull.addEventListener('click', () => {
            fullHelpDialog.classList.remove('hidden');
            showHelpSection('overview');
        });

        btnFullHelpClose.addEventListener('click', () => fullHelpDialog.classList.add('hidden'));

        fullHelpDialog.addEventListener('click', (e) => {
            if (e.target === fullHelpDialog) fullHelpDialog.classList.add('hidden');
        });

        helpNavBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                const section = btn.getAttribute('data-section');
                showHelpSection(section);
            });
        });

        // ========== Tab System ==========
        const tabContainer = document.getElementById('tabContainer');
        const tabBtns = document.querySelectorAll('.tab-btn');
        const tabContents = document.querySelectorAll('.tab-content');

        tabBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                const tabId = btn.getAttribute('data-tab');
                const isCurrentlyActive = btn.classList.contains('active');
                const isCollapsed = tabContainer.classList.contains('collapsed');

                if (isCurrentlyActive) {
                    // Toggle collapse when clicking active tab
                    tabContainer.classList.toggle('collapsed');
                } else {
                    // Switch to different tab and expand
                    tabContainer.classList.remove('collapsed');
                    tabBtns.forEach(b => b.classList.remove('active'));
                    tabContents.forEach(c => c.classList.remove('active'));
                    btn.classList.add('active');
                    document.getElementById('tab-' + tabId).classList.add('active');
                    // Update graphics viewer when switching to its tab
                    if (tabId === 'graphics' && typeof updateGraphicsViewer === 'function') {
                        updateGraphicsViewer();
                    }
                    // Load tests when switching to tests tab
                    if (tabId === 'tests' && testRunner && testRunner.tests.length === 0) {
                        testRunner.loadTests();
                    }
                }
            });
        });

        // ========== Panel Tabs (Breakpoints/Labels/Tools/Trace) ==========
        document.querySelectorAll('.panel-tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const panelId = btn.dataset.panel;
                // Update buttons
                document.querySelectorAll('.panel-tab-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                // Update panels
                document.querySelectorAll('.panel-tab-content').forEach(p => p.classList.remove('active'));
                document.getElementById('panel-' + panelId).classList.add('active');
                // Refresh trace list when trace panel is selected
                if (panelId === 'trace' && typeof updateTraceList === 'function') {
                    updateTraceList();
                }
            });
        });

        // ========== Info Sub-tabs (I/O, Timings, Opcodes) ==========
        document.querySelectorAll('.info-subtab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const tabId = btn.dataset.infotab;
                // Update buttons
                document.querySelectorAll('.info-subtab-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                // Update content
                document.querySelectorAll('.info-subtab-content').forEach(c => c.classList.remove('active'));
                document.getElementById('info-' + tabId).classList.add('active');
            });
        });

        // ========== Tools Sub-tabs (Explorer, Compare, Tests, Export) ==========
        let testsTabVisited = false;
        document.querySelectorAll('.tools-subtab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const tabId = btn.dataset.toolstab;
                // Update buttons
                document.querySelectorAll('.tools-subtab-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                // Update content
                document.querySelectorAll('.tools-subtab-content').forEach(c => c.classList.remove('active'));
                document.getElementById('tools-' + tabId).classList.add('active');
                // Auto-load tests on first visit to Tests tab
                if (tabId === 'tests' && !testsTabVisited) {
                    testsTabVisited = true;
                    if (typeof testRunner !== 'undefined' && testRunner) {
                        testRunner.loadTests();
                    }
                }
            });
        });

        // ========== Settings Sub-tabs (Display, Input, Media, Audio) ==========
        document.querySelectorAll('.settings-subtab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const tabId = btn.dataset.settingstab;
                // Update buttons
                document.querySelectorAll('.settings-subtab-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                // Update content
                document.querySelectorAll('.settings-subtab-content').forEach(c => c.classList.remove('active'));
                document.getElementById('settings-' + tabId).classList.add('active');
            });
        });

        // ========== Programmer Calculator ==========

        // Global key handler for calculator input (called from inline onkeydown)
        function calcHandleKey(e) {
            e.stopPropagation();
            if (e.key === 'Enter' || e.code === 'NumpadEnter') {
                document.getElementById('calcEquals').click();
                e.preventDefault();
                return false;
            }
            return true;  // Allow other keys (Backspace, typing, etc.)
        }

        // Expression parser for formulas like "25*(3+2)"
        function calcParseExpression(expr, base) {
            // Tokenize: numbers, operators, parentheses
            const tokens = [];
            let i = 0;
            expr = expr.replace(/\s/g, '').toUpperCase();

            while (i < expr.length) {
                const ch = expr[i];

                // Number (hex, dec, oct, bin based on current base)
                if (/[0-9A-F]/i.test(ch)) {
                    let num = '';
                    while (i < expr.length && /[0-9A-F]/i.test(expr[i])) {
                        num += expr[i++];
                    }
                    try {
                        let val;
                        if (base === 16) val = BigInt('0x' + num);
                        else if (base === 8) val = BigInt('0o' + num);
                        else if (base === 2) val = BigInt('0b' + num);
                        else val = BigInt(num);
                        tokens.push({ type: 'num', value: val });
                    } catch (e) {
                        return null;  // Parse error
                    }
                    continue;
                }

                // Operators
                if ('+-*/%&|^'.includes(ch)) {
                    tokens.push({ type: 'op', value: ch });
                    i++;
                    continue;
                }

                // Parentheses
                if (ch === '(') {
                    tokens.push({ type: 'lparen' });
                    i++;
                    continue;
                }
                if (ch === ')') {
                    tokens.push({ type: 'rparen' });
                    i++;
                    continue;
                }

                // Unknown character
                i++;
            }

            if (tokens.length === 0) return null;

            // Shunting-yard algorithm for operator precedence
            const output = [];
            const opStack = [];
            const precedence = { '+': 1, '-': 1, '*': 2, '/': 2, '%': 2, '&': 0, '|': 0, '^': 0 };

            for (const token of tokens) {
                if (token.type === 'num') {
                    output.push(token.value);
                } else if (token.type === 'op') {
                    while (opStack.length > 0 && opStack[opStack.length - 1].type === 'op' &&
                           precedence[opStack[opStack.length - 1].value] >= precedence[token.value]) {
                        output.push(opStack.pop().value);
                    }
                    opStack.push(token);
                } else if (token.type === 'lparen') {
                    opStack.push(token);
                } else if (token.type === 'rparen') {
                    while (opStack.length > 0 && opStack[opStack.length - 1].type !== 'lparen') {
                        output.push(opStack.pop().value);
                    }
                    if (opStack.length > 0) opStack.pop();  // Remove lparen
                }
            }
            while (opStack.length > 0) {
                output.push(opStack.pop().value);
            }

            // Evaluate RPN
            const evalStack = [];
            for (const item of output) {
                if (typeof item === 'bigint') {
                    evalStack.push(item);
                } else {
                    if (evalStack.length < 2) return null;
                    const b = evalStack.pop();
                    const a = evalStack.pop();
                    let result;
                    switch (item) {
                        case '+': result = a + b; break;
                        case '-': result = a - b; break;
                        case '*': result = a * b; break;
                        case '/': result = b !== 0n ? a / b : 0n; break;
                        case '%': result = b !== 0n ? a % b : 0n; break;
                        case '&': result = a & b; break;
                        case '|': result = a | b; break;
                        case '^': result = a ^ b; break;
                        default: return null;
                    }
                    evalStack.push(result);
                }
            }

            return evalStack.length === 1 ? { result: evalStack[0], expr: expr } : null;
        }

        const calcInput = document.getElementById('calcInput');
        const calcInputBase = document.getElementById('calcInputBase');
        const calcDec = document.getElementById('calcDec');
        const calcHex = document.getElementById('calcHex');
        const calcOct = document.getElementById('calcOct');
        const calcBin = document.getElementById('calcBin');
        const calcSigned = document.getElementById('calcSigned');
        const calcAscii = document.getElementById('calcAscii');
        const calcBitSize = document.getElementById('calcBitSize');
        const calcBitsPanel = document.getElementById('calcBitsPanel');
        const calcBitsGrid = document.getElementById('calcBitsGrid');
        const calcBitsLabels = document.getElementById('calcBitsLabels');
        const calcClear = document.getElementById('calcClear');
        const calcDel = document.getElementById('calcDel');
        const calcEquals = document.getElementById('calcEquals');
        const calcNegate = document.getElementById('calcNegate');
        const calcLogContent = document.getElementById('calcLogContent');
        const calcLogClear = document.getElementById('calcLogClear');

        let calcValue = 0n;  // Use BigInt for precision
        let calcBitSizeValue = 16;  // 8, 16, 32
        let calcPendingOp = null;
        let calcPendingValue = 0n;
        let calcNewInput = true;
        let calcLogEntries = [];
        let calcExpressionParts = [];  // Track full expression for logging

        function calcFormatValue(val) {
            val = val & CALC_BIT_MASKS[calcBitSizeValue];
            return val.toString(16).toUpperCase() + 'h (' + val.toString() + ')';
        }

        function calcAddLog(entry) {
            calcLogEntries.push(entry);
            const div = document.createElement('div');
            div.className = 'calc-log-entry';
            div.innerHTML = entry;
            div.dataset.index = calcLogEntries.length - 1;
            calcLogContent.appendChild(div);
            calcLogContent.scrollTop = calcLogContent.scrollHeight;
        }

        function calcLogBinaryOp(a, op, b, result) {
            const opSymbol = op === 'and' ? '&' : op === 'or' ? '|' : op === 'xor' ? '^' : op === 'mod' ? '%' : op;
            calcAddLog(`<span class="calc-log-val">${calcFormatValue(a)}</span> <span class="calc-log-op">${opSymbol}</span> <span class="calc-log-val">${calcFormatValue(b)}</span> = <span class="calc-log-result">${calcFormatValue(result)}</span>`);
        }

        function calcLogUnaryOp(op, before, after) {
            calcAddLog(`<span class="calc-log-op">${op}</span> <span class="calc-log-val">${calcFormatValue(before)}</span> = <span class="calc-log-result">${calcFormatValue(after)}</span>`);
        }

        function calcLogExpression(parts, result) {
            // Format expression like: 25 + 5 + 3 - 7 = 26
            let html = '';
            for (let i = 0; i < parts.length; i++) {
                if (i % 2 === 0) {
                    // Value
                    html += `<span class="calc-log-val">${calcFormatValue(parts[i])}</span>`;
                } else {
                    // Operator
                    const op = parts[i];
                    const opSymbol = op === 'and' ? '&' : op === 'or' ? '|' : op === 'xor' ? '^' : op === 'mod' ? '%' : op;
                    html += ` <span class="calc-log-op">${opSymbol}</span> `;
                }
            }
            html += ` = <span class="calc-log-result">${calcFormatValue(result)}</span>`;
            calcAddLog(html);
        }

        calcLogClear.addEventListener('click', () => {
            calcLogEntries = [];
            calcLogContent.innerHTML = '';
        });

        calcLogContent.addEventListener('click', (e) => {
            const entry = e.target.closest('.calc-log-entry');
            if (entry) {
                // Extract result value from the entry and load it
                const resultEl = entry.querySelector('.calc-log-result');
                if (resultEl) {
                    const text = resultEl.textContent;
                    const match = text.match(/([0-9A-F]+)h/i);
                    if (match) {
                        calcValue = BigInt('0x' + match[1]);
                        calcUpdateDisplay();
                        calcNewInput = true;
                    }
                }
            }
        });

        const CALC_BIT_MASKS = {
            8: 0xFFn,
            16: 0xFFFFn,
            32: 0xFFFFFFFFn
        };

        function calcMask(val) {
            return val & CALC_BIT_MASKS[calcBitSizeValue];
        }

        function calcToSigned(val) {
            const mask = CALC_BIT_MASKS[calcBitSizeValue];
            const signBit = 1n << BigInt(calcBitSizeValue - 1);
            val = val & mask;
            if (val & signBit) {
                return val - (mask + 1n);
            }
            return val;
        }

        function calcFormatBin(val) {
            val = calcMask(val);
            const bits = val.toString(2).padStart(calcBitSizeValue, '0');
            // Group by 4 bits
            let result = '';
            for (let i = 0; i < bits.length; i += 4) {
                if (i > 0) result += ' ';
                result += bits.substr(i, 4);
            }
            return result;
        }

        function calcFormatDec(val) {
            val = calcMask(val);
            const str = val.toString();
            // Add thousand separators
            let result = '';
            for (let i = str.length - 1, c = 0; i >= 0; i--, c++) {
                if (c > 0 && c % 3 === 0) result = ' ' + result;
                result = str[i] + result;
            }
            return result;
        }

        function calcFormatOct(val) {
            val = calcMask(val);
            const str = val.toString(8);
            // Group by 3 digits
            let result = '';
            const padLen = Math.ceil(str.length / 3) * 3;
            const padded = str.padStart(padLen, '0');
            for (let i = 0; i < padded.length; i += 3) {
                if (i > 0) result += ' ';
                result += padded.substr(i, 3);
            }
            return result.replace(/^0+\s*/, '') || '0';
        }

        function calcUpdateDisplay() {
            const val = calcMask(calcValue);
            calcDec.textContent = calcFormatDec(val);
            calcHex.textContent = val.toString(16).toUpperCase();
            calcOct.textContent = calcFormatOct(val);
            calcBin.textContent = calcFormatBin(val);

            // Show signed value if negative (high bit set)
            const signedVal = calcToSigned(val);
            if (signedVal < 0n) {
                calcSigned.textContent = signedVal.toString();
            } else {
                calcSigned.textContent = '';
            }

            // Show ASCII if byte-sized and printable
            if (calcBitSizeValue === 8 || val <= 0xFFn) {
                const byteVal = Number(val & 0xFFn);
                if (byteVal >= 32 && byteVal < 127) {
                    calcAscii.textContent = `'${String.fromCharCode(byteVal)}'`;
                } else if (byteVal >= 0x80) {
                    const lowByte = byteVal & 0x7F;
                    if (lowByte >= 32 && lowByte < 127) {
                        calcAscii.textContent = `'${String.fromCharCode(lowByte)}'+$80`;
                    } else {
                        calcAscii.textContent = '';
                    }
                } else {
                    calcAscii.textContent = '';
                }
            } else {
                calcAscii.textContent = '';
            }

            // Update input field only if it doesn't contain a formula
            const currentInput = calcInput.value;
            const hasFormula = /[+\-*/%&|^()]/.test(currentInput);
            calcInputBase.disabled = hasFormula;
            if (!hasFormula) {
                const base = parseInt(calcInputBase.value);
                if (base === 16) calcInput.value = val.toString(16).toUpperCase();
                else if (base === 10) calcInput.value = val.toString();
                else if (base === 8) calcInput.value = val.toString(8);
                else if (base === 2) calcInput.value = val.toString(2);
            }

            // Always update bits panel
            calcRenderBits();
        }

        function calcUpdateDigitButtons() {
            const base = parseInt(calcInputBase.value);
            // Define valid digits for each base
            const validDigits = {
                2: ['0', '1'],
                8: ['0', '1', '2', '3', '4', '5', '6', '7'],
                10: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
                16: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F']
            };
            const valid = validDigits[base] || validDigits[16];

            // Update all digit and hex-digit buttons
            document.querySelectorAll('.calc-btn.digit, .calc-btn.hex-digit').forEach(btn => {
                const ch = btn.dataset.char;
                if (ch) {
                    const isValid = valid.includes(ch);
                    btn.disabled = !isValid;
                    btn.classList.toggle('calc-btn-disabled', !isValid);
                }
            });
        }

        function calcRenderBits() {
            if (!calcBitsLabels || !calcBitsGrid) return;
            const val = calcMask(calcValue);

            // Render labels (show key bit positions)
            let labelsHtml = '';
            for (let i = calcBitSizeValue - 1; i >= 0; i--) {
                // Show labels at positions: 31, 23, 15, 7, 0 (or subset based on bit size)
                if (i === calcBitSizeValue - 1 || i === 0 || (i + 1) % 8 === 0) {
                    labelsHtml += `<div class="calc-bits-label">${i}</div>`;
                } else {
                    labelsHtml += `<div class="calc-bits-label"></div>`;
                }
                if (i > 0 && i % 4 === 0) labelsHtml += '<div class="calc-bits-label-sep"></div>';
            }
            calcBitsLabels.innerHTML = labelsHtml;

            // Render bits
            let html = '';
            for (let i = calcBitSizeValue - 1; i >= 0; i--) {
                const bitSet = (val >> BigInt(i)) & 1n;
                html += `<div class="calc-bit${bitSet ? ' set' : ''}" data-bit="${i}">${bitSet}</div>`;
                if (i > 0 && i % 4 === 0) html += '<div class="calc-bit-separator"></div>';
            }
            calcBitsGrid.innerHTML = html;
        }

        function calcParseInput() {
            const base = parseInt(calcInputBase.value);
            const text = calcInput.value.trim().replace(/\s/g, '');
            try {
                if (base === 16) calcValue = BigInt('0x' + (text || '0'));
                else if (base === 8) calcValue = BigInt('0o' + (text || '0'));
                else if (base === 2) calcValue = BigInt('0b' + (text || '0'));
                else calcValue = BigInt(text || '0');
                calcValue = calcMask(calcValue);
            } catch (e) {
                // Invalid input, ignore
            }
        }

        function calcApplyOp(op, a, b) {
            switch (op) {
                case '+': return a + b;
                case '-': return a - b;
                case '*': return a * b;
                case '/': return b !== 0n ? a / b : 0n;
                case 'mod': return b !== 0n ? a % b : 0n;
                case 'and': return a & b;
                case 'or': return a | b;
                case 'xor': return a ^ b;
                default: return b;
            }
        }

        function calcApplyUnary(op) {
            const mask = CALC_BIT_MASKS[calcBitSizeValue];
            const before = calcValue;
            switch (op) {
                case 'not': calcValue = ~calcValue & mask; break;
                case 'inc': calcValue = (calcValue + 1n) & mask; break;
                case 'dec': calcValue = (calcValue - 1n) & mask; break;
                case 'lsl': calcValue = (calcValue << 1n) & mask; break;
                case 'lsr': calcValue = calcValue >> 1n; break;
                case 'asr': {
                    const signBit = 1n << BigInt(calcBitSizeValue - 1);
                    const sign = calcValue & signBit;
                    calcValue = (calcValue >> 1n) | sign;
                    break;
                }
                case 'rol': {
                    const topBit = (calcValue >> BigInt(calcBitSizeValue - 1)) & 1n;
                    calcValue = ((calcValue << 1n) | topBit) & mask;
                    break;
                }
                case 'ror': {
                    const bottomBit = calcValue & 1n;
                    calcValue = (calcValue >> 1n) | (bottomBit << BigInt(calcBitSizeValue - 1));
                    break;
                }
                case 'rand': calcValue = BigInt(Math.floor(Math.random() * Number(mask + 1n))); break;
            }
            calcLogUnaryOp(op, before, calcValue);
            calcUpdateDisplay();
        }

        // Helper to update base select disabled state
        function calcUpdateBaseSelectState() {
            const hasFormula = /[+\-*/%&|^()]/.test(calcInput.value);
            calcInputBase.disabled = hasFormula;
        }

        // Button handlers
        document.querySelectorAll('.calc-btn[data-char]').forEach(btn => {
            btn.addEventListener('click', () => {
                const ch = btn.dataset.char;
                const isParen = (ch === '(' || ch === ')');
                // Don't clear for parentheses - append to existing expression
                if (calcNewInput && !isParen) {
                    calcInput.value = '';
                    calcNewInput = false;
                }
                calcInput.value += ch;
                calcUpdateBaseSelectState();
                // Only parse as number if no operators/parens in input
                if (!/[+\-*/%&|^()]/.test(calcInput.value)) {
                    calcParseInput();
                    calcUpdateDisplay();
                }
            });
        });

        document.querySelectorAll('.calc-btn[data-op]').forEach(btn => {
            btn.addEventListener('click', () => {
                const op = btn.dataset.op;
                // Unary operators - always apply immediately
                if (['not', 'inc', 'dec', 'lsl', 'lsr', 'asr', 'rol', 'ror', 'rand'].includes(op)) {
                    calcApplyUnary(op);
                    calcNewInput = true;
                    return;
                }
                // For +, -, *, /, %, &, |, ^ - append to input as formula
                const opSymbol = op === 'and' ? '&' : op === 'or' ? '|' : op === 'xor' ? '^' : op === 'mod' ? '%' : op;
                if ('+-*/%&|^'.includes(opSymbol)) {
                    calcInput.value += opSymbol;
                    calcNewInput = false;
                    calcUpdateBaseSelectState();
                }
            });
        });

        calcEquals.addEventListener('click', () => {
            const inputText = calcInput.value.trim();
            const base = parseInt(calcInputBase.value);

            // Try to parse as expression if it contains operators or parentheses
            if (/[+\-*/%&|^()]/.test(inputText)) {
                const parsed = calcParseExpression(inputText, base);
                if (parsed) {
                    calcValue = calcMask(parsed.result);
                    calcAddLog(`<span class="calc-log-val">${inputText}</span> = <span class="calc-log-result">${calcFormatValue(calcValue)}</span>`);
                    calcExpressionParts = [];
                    calcPendingOp = null;
                    calcPendingValue = 0n;
                    // Update input to show result (clear formula first so calcUpdateDisplay updates it)
                    calcInput.value = '';
                    calcUpdateDisplay();
                    calcNewInput = true;
                    return;
                }
            }

            // Original button-based calculation
            if (calcPendingOp) {
                // Add final part to expression
                if (calcExpressionParts.length === 0) {
                    calcExpressionParts.push(calcPendingValue);
                }
                calcExpressionParts.push(calcPendingOp);
                calcExpressionParts.push(calcValue);

                // Calculate final result
                calcValue = calcMask(calcApplyOp(calcPendingOp, calcPendingValue, calcValue));

                // Log full expression
                calcLogExpression(calcExpressionParts, calcValue);

                calcExpressionParts = [];
                calcPendingOp = null;
                calcPendingValue = 0n;
                calcUpdateDisplay();
            }
            calcNewInput = true;
        });

        calcClear.addEventListener('click', () => {
            calcValue = 0n;
            calcPendingOp = null;
            calcPendingValue = 0n;
            calcExpressionParts = [];
            calcNewInput = true;
            calcInput.value = '0';  // Clear input directly
            calcUpdateDisplay();
        });

        calcDel.addEventListener('click', () => {
            const text = calcInput.value;
            if (text.length > 0) {
                calcInput.value = text.slice(0, -1) || '0';
                calcParseInput();
                calcUpdateDisplay();
            }
        });

        calcNegate.addEventListener('click', () => {
            const before = calcValue;
            calcValue = calcMask(-calcValue);
            calcLogUnaryOp('neg', before, calcValue);
            calcUpdateDisplay();
            calcNewInput = true;
        });

        calcBitSize.addEventListener('click', () => {
            if (calcBitSizeValue === 8) calcBitSizeValue = 16;
            else if (calcBitSizeValue === 16) calcBitSizeValue = 32;
            else calcBitSizeValue = 8;
            calcBitSize.textContent = 'u' + calcBitSizeValue;
            calcValue = calcMask(calcValue);
            calcUpdateDisplay();
        });

        let lastValidBase = calcInputBase.value;
        calcInputBase.addEventListener('change', () => {
            // Only allow base change if input is a plain number (no operators/parens)
            if (/[+\-*/%&|^()]/.test(calcInput.value)) {
                calcInputBase.value = lastValidBase;
                return;
            }
            lastValidBase = calcInputBase.value;
            calcUpdateDisplay();
            calcUpdateDigitButtons();
        });

        calcInput.addEventListener('input', () => {
            // Disable base change when formula is present
            const hasFormula = /[+\-*/%&|^()]/.test(calcInput.value);
            calcInputBase.disabled = hasFormula;

            // Only parse as number if no operators/parens (pure number input)
            if (!hasFormula) {
                calcParseInput();
                calcUpdateDisplay();
            }
        });

        calcBitsGrid.addEventListener('click', (e) => {
            const bitEl = e.target.closest('.calc-bit');
            if (bitEl) {
                const bitNum = parseInt(bitEl.dataset.bit);
                calcValue ^= (1n << BigInt(bitNum));
                calcUpdateDisplay();
            }
        });

        // Keyboard support for calculator
        function isCalcTabActive() {
            const calcView = document.getElementById('rightCalculatorView');
            return calcView && calcView.style.display !== 'none';
        }

        // Keyboard support for calculator
        document.addEventListener('keydown', (e) => {
            if (!isCalcTabActive()) return;
            // Don't capture if typing in other inputs (except calcInput)
            if (e.target.tagName === 'INPUT' && e.target.id !== 'calcInput') return;
            if (e.target.tagName === 'TEXTAREA') return;
            if (e.target.tagName === 'SELECT') return;

            const isInCalcInput = (e.target.id === 'calcInput');

            // Handle Enter first - before anything else
            if (e.key === 'Enter' || e.code === 'NumpadEnter') {
                e.preventDefault();
                e.stopPropagation();
                calcEquals.click();
                return;
            }

            // Handle Backspace
            if (e.key === 'Backspace') {
                e.stopPropagation();
                if (isInCalcInput) {
                    // Let browser handle backspace in input, but stop emulator
                    return;
                }
                e.preventDefault();
                calcDel.click();
                return;
            }

            // If in calcInput, let other keys work naturally
            if (isInCalcInput) {
                e.stopPropagation();
                return;
            }

            // Below is for when NOT focused on calcInput
            let handled = false;
            const base = parseInt(calcInputBase.value);

            // Only handle single character keys for digits
            if (e.key.length === 1) {
                const key = e.key.toUpperCase();

                // Digits 0-9 (check if valid for current base)
                if (key >= '0' && key <= '9') {
                    const digit = parseInt(key);
                    // Only allow digits valid for current base
                    if (digit < base) {
                        if (calcNewInput) {
                            calcInput.value = '';
                            calcNewInput = false;
                        }
                        calcInput.value += key;
                        calcUpdateBaseSelectState();
                        if (!/[+\-*/%&|^()]/.test(calcInput.value)) {
                            calcParseInput();
                            calcUpdateDisplay();
                        }
                        handled = true;
                    }
                }

                // Hex digits A-F (only in hex mode)
                if (!handled && base === 16 && key >= 'A' && key <= 'F') {
                    if (calcNewInput) {
                        calcInput.value = '';
                        calcNewInput = false;
                    }
                    calcInput.value += key;
                    calcUpdateBaseSelectState();
                    if (!/[+\-*/%&|^()]/.test(calcInput.value)) {
                        calcParseInput();
                        calcUpdateDisplay();
                    }
                    handled = true;
                }
            }

            // Operations
            if (!handled) {
                switch (e.key) {
                    case '+':
                        document.querySelector('.calc-btn[data-op="+"]').click();
                        handled = true;
                        break;
                    case '-':
                        document.querySelector('.calc-btn[data-op="-"]').click();
                        handled = true;
                        break;
                    case '*':
                        document.querySelector('.calc-btn[data-op="*"]').click();
                        handled = true;
                        break;
                    case '/':
                        document.querySelector('.calc-btn[data-op="/"]').click();
                        handled = true;
                        break;
                    case '%':
                        document.querySelector('.calc-btn[data-op="mod"]').click();
                        handled = true;
                        break;
                    case '&':
                        document.querySelector('.calc-btn[data-op="and"]').click();
                        handled = true;
                        break;
                    case '|':
                        document.querySelector('.calc-btn[data-op="or"]').click();
                        handled = true;
                        break;
                    case '^':
                        document.querySelector('.calc-btn[data-op="xor"]').click();
                        handled = true;
                        break;
                    case '~':
                        document.querySelector('.calc-btn[data-op="not"]').click();
                        handled = true;
                        break;
                    case '=':
                        calcEquals.click();
                        handled = true;
                        break;
                    case 'Escape':
                        calcClear.click();
                        handled = true;
                        break;
                    case '<':
                        document.querySelector('.calc-btn[data-op="lsl"]').click();
                        handled = true;
                        break;
                    case '>':
                        document.querySelector('.calc-btn[data-op="lsr"]').click();
                        handled = true;
                        break;
                    case '(':
                    case ')':
                        calcInput.value += e.key;
                        calcNewInput = false;
                        calcUpdateBaseSelectState();
                        handled = true;
                        break;
                }
            }

            if (handled) {
                e.preventDefault();
                e.stopPropagation();
            }
        }, true);  // Use capture phase

        // Initial display
        calcUpdateDisplay();
        calcUpdateDigitButtons();

        // ========== Z80 Opcodes Reference ==========
        const z80Opcodes = [
            // Load 8-bit
            { m: 'LD A,A', o: '7F', b: 1, c: '4', f: '------', d: 'Load A from A', g: 'load' },
            { m: 'LD A,B', o: '78', b: 1, c: '4', f: '------', d: 'Load A from B', g: 'load' },
            { m: 'LD A,C', o: '79', b: 1, c: '4', f: '------', d: 'Load A from C', g: 'load' },
            { m: 'LD A,D', o: '7A', b: 1, c: '4', f: '------', d: 'Load A from D', g: 'load' },
            { m: 'LD A,E', o: '7B', b: 1, c: '4', f: '------', d: 'Load A from E', g: 'load' },
            { m: 'LD A,H', o: '7C', b: 1, c: '4', f: '------', d: 'Load A from H', g: 'load' },
            { m: 'LD A,L', o: '7D', b: 1, c: '4', f: '------', d: 'Load A from L', g: 'load' },
            { m: 'LD B,A', o: '47', b: 1, c: '4', f: '------', d: 'Load B from A', g: 'load' },
            { m: 'LD B,B', o: '40', b: 1, c: '4', f: '------', d: 'Load B from B', g: 'load' },
            { m: 'LD B,C', o: '41', b: 1, c: '4', f: '------', d: 'Load B from C', g: 'load' },
            { m: 'LD B,D', o: '42', b: 1, c: '4', f: '------', d: 'Load B from D', g: 'load' },
            { m: 'LD B,E', o: '43', b: 1, c: '4', f: '------', d: 'Load B from E', g: 'load' },
            { m: 'LD B,H', o: '44', b: 1, c: '4', f: '------', d: 'Load B from H', g: 'load' },
            { m: 'LD B,L', o: '45', b: 1, c: '4', f: '------', d: 'Load B from L', g: 'load' },
            { m: 'LD C,A', o: '4F', b: 1, c: '4', f: '------', d: 'Load C from A', g: 'load' },
            { m: 'LD C,B', o: '48', b: 1, c: '4', f: '------', d: 'Load C from B', g: 'load' },
            { m: 'LD C,C', o: '49', b: 1, c: '4', f: '------', d: 'Load C from C', g: 'load' },
            { m: 'LD C,D', o: '4A', b: 1, c: '4', f: '------', d: 'Load C from D', g: 'load' },
            { m: 'LD C,E', o: '4B', b: 1, c: '4', f: '------', d: 'Load C from E', g: 'load' },
            { m: 'LD C,H', o: '4C', b: 1, c: '4', f: '------', d: 'Load C from H', g: 'load' },
            { m: 'LD C,L', o: '4D', b: 1, c: '4', f: '------', d: 'Load C from L', g: 'load' },
            { m: 'LD D,A', o: '57', b: 1, c: '4', f: '------', d: 'Load D from A', g: 'load' },
            { m: 'LD D,B', o: '50', b: 1, c: '4', f: '------', d: 'Load D from B', g: 'load' },
            { m: 'LD D,C', o: '51', b: 1, c: '4', f: '------', d: 'Load D from C', g: 'load' },
            { m: 'LD D,D', o: '52', b: 1, c: '4', f: '------', d: 'Load D from D', g: 'load' },
            { m: 'LD D,E', o: '53', b: 1, c: '4', f: '------', d: 'Load D from E', g: 'load' },
            { m: 'LD D,H', o: '54', b: 1, c: '4', f: '------', d: 'Load D from H', g: 'load' },
            { m: 'LD D,L', o: '55', b: 1, c: '4', f: '------', d: 'Load D from L', g: 'load' },
            { m: 'LD E,A', o: '5F', b: 1, c: '4', f: '------', d: 'Load E from A', g: 'load' },
            { m: 'LD E,B', o: '58', b: 1, c: '4', f: '------', d: 'Load E from B', g: 'load' },
            { m: 'LD E,C', o: '59', b: 1, c: '4', f: '------', d: 'Load E from C', g: 'load' },
            { m: 'LD E,D', o: '5A', b: 1, c: '4', f: '------', d: 'Load E from D', g: 'load' },
            { m: 'LD E,E', o: '5B', b: 1, c: '4', f: '------', d: 'Load E from E', g: 'load' },
            { m: 'LD E,H', o: '5C', b: 1, c: '4', f: '------', d: 'Load E from H', g: 'load' },
            { m: 'LD E,L', o: '5D', b: 1, c: '4', f: '------', d: 'Load E from L', g: 'load' },
            { m: 'LD H,A', o: '67', b: 1, c: '4', f: '------', d: 'Load H from A', g: 'load' },
            { m: 'LD H,B', o: '60', b: 1, c: '4', f: '------', d: 'Load H from B', g: 'load' },
            { m: 'LD H,C', o: '61', b: 1, c: '4', f: '------', d: 'Load H from C', g: 'load' },
            { m: 'LD H,D', o: '62', b: 1, c: '4', f: '------', d: 'Load H from D', g: 'load' },
            { m: 'LD H,E', o: '63', b: 1, c: '4', f: '------', d: 'Load H from E', g: 'load' },
            { m: 'LD H,H', o: '64', b: 1, c: '4', f: '------', d: 'Load H from H', g: 'load' },
            { m: 'LD H,L', o: '65', b: 1, c: '4', f: '------', d: 'Load H from L', g: 'load' },
            { m: 'LD L,A', o: '6F', b: 1, c: '4', f: '------', d: 'Load L from A', g: 'load' },
            { m: 'LD L,B', o: '68', b: 1, c: '4', f: '------', d: 'Load L from B', g: 'load' },
            { m: 'LD L,C', o: '69', b: 1, c: '4', f: '------', d: 'Load L from C', g: 'load' },
            { m: 'LD L,D', o: '6A', b: 1, c: '4', f: '------', d: 'Load L from D', g: 'load' },
            { m: 'LD L,E', o: '6B', b: 1, c: '4', f: '------', d: 'Load L from E', g: 'load' },
            { m: 'LD L,H', o: '6C', b: 1, c: '4', f: '------', d: 'Load L from H', g: 'load' },
            { m: 'LD L,L', o: '6D', b: 1, c: '4', f: '------', d: 'Load L from L', g: 'load' },
            { m: 'LD A,n', o: '3E nn', b: 2, c: '7', f: '------', d: 'Load A with immediate', g: 'load' },
            { m: 'LD B,n', o: '06 nn', b: 2, c: '7', f: '------', d: 'Load B with immediate', g: 'load' },
            { m: 'LD C,n', o: '0E nn', b: 2, c: '7', f: '------', d: 'Load C with immediate', g: 'load' },
            { m: 'LD D,n', o: '16 nn', b: 2, c: '7', f: '------', d: 'Load D with immediate', g: 'load' },
            { m: 'LD E,n', o: '1E nn', b: 2, c: '7', f: '------', d: 'Load E with immediate', g: 'load' },
            { m: 'LD H,n', o: '26 nn', b: 2, c: '7', f: '------', d: 'Load H with immediate', g: 'load' },
            { m: 'LD L,n', o: '2E nn', b: 2, c: '7', f: '------', d: 'Load L with immediate', g: 'load' },
            { m: 'LD A,(HL)', o: '7E', b: 1, c: '7', f: '------', d: 'Load A from (HL)', g: 'load' },
            { m: 'LD B,(HL)', o: '46', b: 1, c: '7', f: '------', d: 'Load B from (HL)', g: 'load' },
            { m: 'LD C,(HL)', o: '4E', b: 1, c: '7', f: '------', d: 'Load C from (HL)', g: 'load' },
            { m: 'LD D,(HL)', o: '56', b: 1, c: '7', f: '------', d: 'Load D from (HL)', g: 'load' },
            { m: 'LD E,(HL)', o: '5E', b: 1, c: '7', f: '------', d: 'Load E from (HL)', g: 'load' },
            { m: 'LD H,(HL)', o: '66', b: 1, c: '7', f: '------', d: 'Load H from (HL)', g: 'load' },
            { m: 'LD L,(HL)', o: '6E', b: 1, c: '7', f: '------', d: 'Load L from (HL)', g: 'load' },
            { m: 'LD A,(IX+d)', o: 'DD 7E dd', b: 3, c: '19', f: '------', d: 'Load A from (IX+d)', g: 'load' },
            { m: 'LD B,(IX+d)', o: 'DD 46 dd', b: 3, c: '19', f: '------', d: 'Load B from (IX+d)', g: 'load' },
            { m: 'LD C,(IX+d)', o: 'DD 4E dd', b: 3, c: '19', f: '------', d: 'Load C from (IX+d)', g: 'load' },
            { m: 'LD D,(IX+d)', o: 'DD 56 dd', b: 3, c: '19', f: '------', d: 'Load D from (IX+d)', g: 'load' },
            { m: 'LD E,(IX+d)', o: 'DD 5E dd', b: 3, c: '19', f: '------', d: 'Load E from (IX+d)', g: 'load' },
            { m: 'LD H,(IX+d)', o: 'DD 66 dd', b: 3, c: '19', f: '------', d: 'Load H from (IX+d)', g: 'load' },
            { m: 'LD L,(IX+d)', o: 'DD 6E dd', b: 3, c: '19', f: '------', d: 'Load L from (IX+d)', g: 'load' },
            { m: 'LD A,(IY+d)', o: 'FD 7E dd', b: 3, c: '19', f: '------', d: 'Load A from (IY+d)', g: 'load' },
            { m: 'LD B,(IY+d)', o: 'FD 46 dd', b: 3, c: '19', f: '------', d: 'Load B from (IY+d)', g: 'load' },
            { m: 'LD C,(IY+d)', o: 'FD 4E dd', b: 3, c: '19', f: '------', d: 'Load C from (IY+d)', g: 'load' },
            { m: 'LD D,(IY+d)', o: 'FD 56 dd', b: 3, c: '19', f: '------', d: 'Load D from (IY+d)', g: 'load' },
            { m: 'LD E,(IY+d)', o: 'FD 5E dd', b: 3, c: '19', f: '------', d: 'Load E from (IY+d)', g: 'load' },
            { m: 'LD H,(IY+d)', o: 'FD 66 dd', b: 3, c: '19', f: '------', d: 'Load H from (IY+d)', g: 'load' },
            { m: 'LD L,(IY+d)', o: 'FD 6E dd', b: 3, c: '19', f: '------', d: 'Load L from (IY+d)', g: 'load' },
            { m: 'LD (HL),A', o: '77', b: 1, c: '7', f: '------', d: 'Load (HL) from A', g: 'load' },
            { m: 'LD (HL),B', o: '70', b: 1, c: '7', f: '------', d: 'Load (HL) from B', g: 'load' },
            { m: 'LD (HL),C', o: '71', b: 1, c: '7', f: '------', d: 'Load (HL) from C', g: 'load' },
            { m: 'LD (HL),D', o: '72', b: 1, c: '7', f: '------', d: 'Load (HL) from D', g: 'load' },
            { m: 'LD (HL),E', o: '73', b: 1, c: '7', f: '------', d: 'Load (HL) from E', g: 'load' },
            { m: 'LD (HL),H', o: '74', b: 1, c: '7', f: '------', d: 'Load (HL) from H', g: 'load' },
            { m: 'LD (HL),L', o: '75', b: 1, c: '7', f: '------', d: 'Load (HL) from L', g: 'load' },
            { m: 'LD (IX+d),A', o: 'DD 77 dd', b: 3, c: '19', f: '------', d: 'Load (IX+d) from A', g: 'load' },
            { m: 'LD (IX+d),B', o: 'DD 70 dd', b: 3, c: '19', f: '------', d: 'Load (IX+d) from B', g: 'load' },
            { m: 'LD (IX+d),C', o: 'DD 71 dd', b: 3, c: '19', f: '------', d: 'Load (IX+d) from C', g: 'load' },
            { m: 'LD (IX+d),D', o: 'DD 72 dd', b: 3, c: '19', f: '------', d: 'Load (IX+d) from D', g: 'load' },
            { m: 'LD (IX+d),E', o: 'DD 73 dd', b: 3, c: '19', f: '------', d: 'Load (IX+d) from E', g: 'load' },
            { m: 'LD (IX+d),H', o: 'DD 74 dd', b: 3, c: '19', f: '------', d: 'Load (IX+d) from H', g: 'load' },
            { m: 'LD (IX+d),L', o: 'DD 75 dd', b: 3, c: '19', f: '------', d: 'Load (IX+d) from L', g: 'load' },
            { m: 'LD (IY+d),A', o: 'FD 77 dd', b: 3, c: '19', f: '------', d: 'Load (IY+d) from A', g: 'load' },
            { m: 'LD (IY+d),B', o: 'FD 70 dd', b: 3, c: '19', f: '------', d: 'Load (IY+d) from B', g: 'load' },
            { m: 'LD (IY+d),C', o: 'FD 71 dd', b: 3, c: '19', f: '------', d: 'Load (IY+d) from C', g: 'load' },
            { m: 'LD (IY+d),D', o: 'FD 72 dd', b: 3, c: '19', f: '------', d: 'Load (IY+d) from D', g: 'load' },
            { m: 'LD (IY+d),E', o: 'FD 73 dd', b: 3, c: '19', f: '------', d: 'Load (IY+d) from E', g: 'load' },
            { m: 'LD (IY+d),H', o: 'FD 74 dd', b: 3, c: '19', f: '------', d: 'Load (IY+d) from H', g: 'load' },
            { m: 'LD (IY+d),L', o: 'FD 75 dd', b: 3, c: '19', f: '------', d: 'Load (IY+d) from L', g: 'load' },
            { m: 'LD (HL),n', o: '36 nn', b: 2, c: '10', f: '------', d: 'Load (HL) with immediate', g: 'load' },
            { m: 'LD (IX+d),n', o: 'DD 36 dd nn', b: 4, c: '19', f: '------', d: 'Load (IX+d) with immediate', g: 'load' },
            { m: 'LD (IY+d),n', o: 'FD 36 dd nn', b: 4, c: '19', f: '------', d: 'Load (IY+d) with immediate', g: 'load' },
            { m: 'LD A,(BC)', o: '0A', b: 1, c: '7', f: '------', d: 'Load A from (BC)', g: 'load' },
            { m: 'LD A,(DE)', o: '1A', b: 1, c: '7', f: '------', d: 'Load A from (DE)', g: 'load' },
            { m: 'LD A,(nn)', o: '3A nn nn', b: 3, c: '13', f: '------', d: 'Load A from memory', g: 'load' },
            { m: 'LD (BC),A', o: '02', b: 1, c: '7', f: '------', d: 'Load (BC) from A', g: 'load' },
            { m: 'LD (DE),A', o: '12', b: 1, c: '7', f: '------', d: 'Load (DE) from A', g: 'load' },
            { m: 'LD (nn),A', o: '32 nn nn', b: 3, c: '13', f: '------', d: 'Load memory from A', g: 'load' },
            { m: 'LD A,I', o: 'ED 57', b: 2, c: '9', f: 'SZ*P0-', d: 'Load A from I', g: 'load' },
            { m: 'LD A,R', o: 'ED 5F', b: 2, c: '9', f: 'SZ*P0-', d: 'Load A from R', g: 'load' },
            { m: 'LD I,A', o: 'ED 47', b: 2, c: '9', f: '------', d: 'Load I from A', g: 'load' },
            { m: 'LD R,A', o: 'ED 4F', b: 2, c: '9', f: '------', d: 'Load R from A', g: 'load' },
            // Undocumented LD with IXH/IXL/IYH/IYL
            { m: 'LD A,IXH', o: 'DD 7C', b: 2, c: '8', f: '------', d: 'Load A from IXH', g: 'load', u: true },
            { m: 'LD A,IXL', o: 'DD 7D', b: 2, c: '8', f: '------', d: 'Load A from IXL', g: 'load', u: true },
            { m: 'LD A,IYH', o: 'FD 7C', b: 2, c: '8', f: '------', d: 'Load A from IYH', g: 'load', u: true },
            { m: 'LD A,IYL', o: 'FD 7D', b: 2, c: '8', f: '------', d: 'Load A from IYL', g: 'load', u: true },
            { m: 'LD IXH,A', o: 'DD 67', b: 2, c: '8', f: '------', d: 'Load IXH from A', g: 'load', u: true },
            { m: 'LD IXL,A', o: 'DD 6F', b: 2, c: '8', f: '------', d: 'Load IXL from A', g: 'load', u: true },
            { m: 'LD IYH,A', o: 'FD 67', b: 2, c: '8', f: '------', d: 'Load IYH from A', g: 'load', u: true },
            { m: 'LD IYL,A', o: 'FD 6F', b: 2, c: '8', f: '------', d: 'Load IYL from A', g: 'load', u: true },
            { m: 'LD IXH,n', o: 'DD 26 nn', b: 3, c: '11', f: '------', d: 'Load IXH with immediate', g: 'load', u: true },
            { m: 'LD IXL,n', o: 'DD 2E nn', b: 3, c: '11', f: '------', d: 'Load IXL with immediate', g: 'load', u: true },
            { m: 'LD IYH,n', o: 'FD 26 nn', b: 3, c: '11', f: '------', d: 'Load IYH with immediate', g: 'load', u: true },
            { m: 'LD IYL,n', o: 'FD 2E nn', b: 3, c: '11', f: '------', d: 'Load IYL with immediate', g: 'load', u: true },
            // Load 16-bit
            { m: 'LD BC,nn', o: '01 nn nn', b: 3, c: '10', f: '------', d: 'Load BC with immediate', g: 'load' },
            { m: 'LD DE,nn', o: '11 nn nn', b: 3, c: '10', f: '------', d: 'Load DE with immediate', g: 'load' },
            { m: 'LD HL,nn', o: '21 nn nn', b: 3, c: '10', f: '------', d: 'Load HL with immediate', g: 'load' },
            { m: 'LD SP,nn', o: '31 nn nn', b: 3, c: '10', f: '------', d: 'Load SP with immediate', g: 'load' },
            { m: 'LD IX,nn', o: 'DD 21 nn nn', b: 4, c: '14', f: '------', d: 'Load IX with immediate', g: 'load' },
            { m: 'LD IY,nn', o: 'FD 21 nn nn', b: 4, c: '14', f: '------', d: 'Load IY with immediate', g: 'load' },
            { m: 'LD HL,(nn)', o: '2A nn nn', b: 3, c: '16', f: '------', d: 'Load HL from memory', g: 'load' },
            { m: 'LD BC,(nn)', o: 'ED 4B nn nn', b: 4, c: '20', f: '------', d: 'Load BC from memory', g: 'load' },
            { m: 'LD DE,(nn)', o: 'ED 5B nn nn', b: 4, c: '20', f: '------', d: 'Load DE from memory', g: 'load' },
            { m: 'LD SP,(nn)', o: 'ED 7B nn nn', b: 4, c: '20', f: '------', d: 'Load SP from memory', g: 'load' },
            { m: 'LD IX,(nn)', o: 'DD 2A nn nn', b: 4, c: '20', f: '------', d: 'Load IX from memory', g: 'load' },
            { m: 'LD IY,(nn)', o: 'FD 2A nn nn', b: 4, c: '20', f: '------', d: 'Load IY from memory', g: 'load' },
            { m: 'LD (nn),HL', o: '22 nn nn', b: 3, c: '16', f: '------', d: 'Load memory from HL', g: 'load' },
            { m: 'LD (nn),BC', o: 'ED 43 nn nn', b: 4, c: '20', f: '------', d: 'Load memory from BC', g: 'load' },
            { m: 'LD (nn),DE', o: 'ED 53 nn nn', b: 4, c: '20', f: '------', d: 'Load memory from DE', g: 'load' },
            { m: 'LD (nn),SP', o: 'ED 73 nn nn', b: 4, c: '20', f: '------', d: 'Load memory from SP', g: 'load' },
            { m: 'LD (nn),IX', o: 'DD 22 nn nn', b: 4, c: '20', f: '------', d: 'Load memory from IX', g: 'load' },
            { m: 'LD (nn),IY', o: 'FD 22 nn nn', b: 4, c: '20', f: '------', d: 'Load memory from IY', g: 'load' },
            { m: 'LD SP,HL', o: 'F9', b: 1, c: '6', f: '------', d: 'Load SP from HL', g: 'load' },
            { m: 'LD SP,IX', o: 'DD F9', b: 2, c: '10', f: '------', d: 'Load SP from IX', g: 'load' },
            { m: 'LD SP,IY', o: 'FD F9', b: 2, c: '10', f: '------', d: 'Load SP from IY', g: 'load' },
            { m: 'PUSH AF', o: 'F5', b: 1, c: '11', f: '------', d: 'Push AF to stack', g: 'load' },
            { m: 'PUSH BC', o: 'C5', b: 1, c: '11', f: '------', d: 'Push BC to stack', g: 'load' },
            { m: 'PUSH DE', o: 'D5', b: 1, c: '11', f: '------', d: 'Push DE to stack', g: 'load' },
            { m: 'PUSH HL', o: 'E5', b: 1, c: '11', f: '------', d: 'Push HL to stack', g: 'load' },
            { m: 'PUSH IX', o: 'DD E5', b: 2, c: '15', f: '------', d: 'Push IX to stack', g: 'load' },
            { m: 'PUSH IY', o: 'FD E5', b: 2, c: '15', f: '------', d: 'Push IY to stack', g: 'load' },
            { m: 'POP AF', o: 'F1', b: 1, c: '10', f: '------', d: 'Pop AF from stack', g: 'load' },
            { m: 'POP BC', o: 'C1', b: 1, c: '10', f: '------', d: 'Pop BC from stack', g: 'load' },
            { m: 'POP DE', o: 'D1', b: 1, c: '10', f: '------', d: 'Pop DE from stack', g: 'load' },
            { m: 'POP HL', o: 'E1', b: 1, c: '10', f: '------', d: 'Pop HL from stack', g: 'load' },
            { m: 'POP IX', o: 'DD E1', b: 2, c: '14', f: '------', d: 'Pop IX from stack', g: 'load' },
            { m: 'POP IY', o: 'FD E1', b: 2, c: '14', f: '------', d: 'Pop IY from stack', g: 'load' },
            // Exchange
            { m: 'EX DE,HL', o: 'EB', b: 1, c: '4', f: '------', d: 'Exchange DE and HL', g: 'load' },
            { m: 'EX AF,AF\'', o: '08', b: 1, c: '4', f: '------', d: 'Exchange AF and AF\'', g: 'load' },
            { m: 'EXX', o: 'D9', b: 1, c: '4', f: '------', d: 'Exchange BC,DE,HL with alternates', g: 'load' },
            { m: 'EX (SP),HL', o: 'E3', b: 1, c: '19', f: '------', d: 'Exchange (SP) and HL', g: 'load' },
            { m: 'EX (SP),IX', o: 'DD E3', b: 2, c: '23', f: '------', d: 'Exchange (SP) and IX', g: 'load' },
            { m: 'EX (SP),IY', o: 'FD E3', b: 2, c: '23', f: '------', d: 'Exchange (SP) and IY', g: 'load' },
            // Arithmetic 8-bit
            { m: 'ADD A,A', o: '87', b: 1, c: '4', f: 'SZ*V0C', d: 'Add A to A', g: 'arith' },
            { m: 'ADD A,B', o: '80', b: 1, c: '4', f: 'SZ*V0C', d: 'Add B to A', g: 'arith' },
            { m: 'ADD A,C', o: '81', b: 1, c: '4', f: 'SZ*V0C', d: 'Add C to A', g: 'arith' },
            { m: 'ADD A,D', o: '82', b: 1, c: '4', f: 'SZ*V0C', d: 'Add D to A', g: 'arith' },
            { m: 'ADD A,E', o: '83', b: 1, c: '4', f: 'SZ*V0C', d: 'Add E to A', g: 'arith' },
            { m: 'ADD A,H', o: '84', b: 1, c: '4', f: 'SZ*V0C', d: 'Add H to A', g: 'arith' },
            { m: 'ADD A,L', o: '85', b: 1, c: '4', f: 'SZ*V0C', d: 'Add L to A', g: 'arith' },
            { m: 'ADD A,n', o: 'C6 nn', b: 2, c: '7', f: 'SZ*V0C', d: 'Add immediate to A', g: 'arith' },
            { m: 'ADD A,(HL)', o: '86', b: 1, c: '7', f: 'SZ*V0C', d: 'Add (HL) to A', g: 'arith' },
            { m: 'ADD A,(IX+d)', o: 'DD 86 dd', b: 3, c: '19', f: 'SZ*V0C', d: 'Add (IX+d) to A', g: 'arith' },
            { m: 'ADD A,(IY+d)', o: 'FD 86 dd', b: 3, c: '19', f: 'SZ*V0C', d: 'Add (IY+d) to A', g: 'arith' },
            { m: 'ADD A,IXH', o: 'DD 84', b: 2, c: '8', f: 'SZ*V0C', d: 'Add IXH to A', g: 'arith', u: true },
            { m: 'ADD A,IXL', o: 'DD 85', b: 2, c: '8', f: 'SZ*V0C', d: 'Add IXL to A', g: 'arith', u: true },
            { m: 'ADD A,IYH', o: 'FD 84', b: 2, c: '8', f: 'SZ*V0C', d: 'Add IYH to A', g: 'arith', u: true },
            { m: 'ADD A,IYL', o: 'FD 85', b: 2, c: '8', f: 'SZ*V0C', d: 'Add IYL to A', g: 'arith', u: true },
            { m: 'ADC A,A', o: '8F', b: 1, c: '4', f: 'SZ*V0C', d: 'Add with carry A to A', g: 'arith' },
            { m: 'ADC A,B', o: '88', b: 1, c: '4', f: 'SZ*V0C', d: 'Add with carry B to A', g: 'arith' },
            { m: 'ADC A,C', o: '89', b: 1, c: '4', f: 'SZ*V0C', d: 'Add with carry C to A', g: 'arith' },
            { m: 'ADC A,D', o: '8A', b: 1, c: '4', f: 'SZ*V0C', d: 'Add with carry D to A', g: 'arith' },
            { m: 'ADC A,E', o: '8B', b: 1, c: '4', f: 'SZ*V0C', d: 'Add with carry E to A', g: 'arith' },
            { m: 'ADC A,H', o: '8C', b: 1, c: '4', f: 'SZ*V0C', d: 'Add with carry H to A', g: 'arith' },
            { m: 'ADC A,L', o: '8D', b: 1, c: '4', f: 'SZ*V0C', d: 'Add with carry L to A', g: 'arith' },
            { m: 'ADC A,n', o: 'CE nn', b: 2, c: '7', f: 'SZ*V0C', d: 'Add with carry immediate to A', g: 'arith' },
            { m: 'ADC A,(HL)', o: '8E', b: 1, c: '7', f: 'SZ*V0C', d: 'Add with carry (HL) to A', g: 'arith' },
            { m: 'ADC A,(IX+d)', o: 'DD 8E dd', b: 3, c: '19', f: 'SZ*V0C', d: 'Add with carry (IX+d) to A', g: 'arith' },
            { m: 'ADC A,(IY+d)', o: 'FD 8E dd', b: 3, c: '19', f: 'SZ*V0C', d: 'Add with carry (IY+d) to A', g: 'arith' },
            { m: 'SUB A', o: '97', b: 1, c: '4', f: 'SZ*V1C', d: 'Subtract A from A', g: 'arith' },
            { m: 'SUB B', o: '90', b: 1, c: '4', f: 'SZ*V1C', d: 'Subtract B from A', g: 'arith' },
            { m: 'SUB C', o: '91', b: 1, c: '4', f: 'SZ*V1C', d: 'Subtract C from A', g: 'arith' },
            { m: 'SUB D', o: '92', b: 1, c: '4', f: 'SZ*V1C', d: 'Subtract D from A', g: 'arith' },
            { m: 'SUB E', o: '93', b: 1, c: '4', f: 'SZ*V1C', d: 'Subtract E from A', g: 'arith' },
            { m: 'SUB H', o: '94', b: 1, c: '4', f: 'SZ*V1C', d: 'Subtract H from A', g: 'arith' },
            { m: 'SUB L', o: '95', b: 1, c: '4', f: 'SZ*V1C', d: 'Subtract L from A', g: 'arith' },
            { m: 'SUB n', o: 'D6 nn', b: 2, c: '7', f: 'SZ*V1C', d: 'Subtract immediate from A', g: 'arith' },
            { m: 'SUB (HL)', o: '96', b: 1, c: '7', f: 'SZ*V1C', d: 'Subtract (HL) from A', g: 'arith' },
            { m: 'SUB (IX+d)', o: 'DD 96 dd', b: 3, c: '19', f: 'SZ*V1C', d: 'Subtract (IX+d) from A', g: 'arith' },
            { m: 'SUB (IY+d)', o: 'FD 96 dd', b: 3, c: '19', f: 'SZ*V1C', d: 'Subtract (IY+d) from A', g: 'arith' },
            { m: 'SBC A,A', o: '9F', b: 1, c: '4', f: 'SZ*V1C', d: 'Subtract with carry A from A', g: 'arith' },
            { m: 'SBC A,B', o: '98', b: 1, c: '4', f: 'SZ*V1C', d: 'Subtract with carry B from A', g: 'arith' },
            { m: 'SBC A,C', o: '99', b: 1, c: '4', f: 'SZ*V1C', d: 'Subtract with carry C from A', g: 'arith' },
            { m: 'SBC A,D', o: '9A', b: 1, c: '4', f: 'SZ*V1C', d: 'Subtract with carry D from A', g: 'arith' },
            { m: 'SBC A,E', o: '9B', b: 1, c: '4', f: 'SZ*V1C', d: 'Subtract with carry E from A', g: 'arith' },
            { m: 'SBC A,H', o: '9C', b: 1, c: '4', f: 'SZ*V1C', d: 'Subtract with carry H from A', g: 'arith' },
            { m: 'SBC A,L', o: '9D', b: 1, c: '4', f: 'SZ*V1C', d: 'Subtract with carry L from A', g: 'arith' },
            { m: 'SBC A,n', o: 'DE nn', b: 2, c: '7', f: 'SZ*V1C', d: 'Subtract with carry immediate from A', g: 'arith' },
            { m: 'SBC A,(HL)', o: '9E', b: 1, c: '7', f: 'SZ*V1C', d: 'Subtract with carry (HL) from A', g: 'arith' },
            { m: 'SBC A,(IX+d)', o: 'DD 9E dd', b: 3, c: '19', f: 'SZ*V1C', d: 'Subtract with carry (IX+d) from A', g: 'arith' },
            { m: 'SBC A,(IY+d)', o: 'FD 9E dd', b: 3, c: '19', f: 'SZ*V1C', d: 'Subtract with carry (IY+d) from A', g: 'arith' },
            { m: 'CP A', o: 'BF', b: 1, c: '4', f: 'SZ*V1C', d: 'Compare A with A', g: 'arith' },
            { m: 'CP B', o: 'B8', b: 1, c: '4', f: 'SZ*V1C', d: 'Compare B with A', g: 'arith' },
            { m: 'CP C', o: 'B9', b: 1, c: '4', f: 'SZ*V1C', d: 'Compare C with A', g: 'arith' },
            { m: 'CP D', o: 'BA', b: 1, c: '4', f: 'SZ*V1C', d: 'Compare D with A', g: 'arith' },
            { m: 'CP E', o: 'BB', b: 1, c: '4', f: 'SZ*V1C', d: 'Compare E with A', g: 'arith' },
            { m: 'CP H', o: 'BC', b: 1, c: '4', f: 'SZ*V1C', d: 'Compare H with A', g: 'arith' },
            { m: 'CP L', o: 'BD', b: 1, c: '4', f: 'SZ*V1C', d: 'Compare L with A', g: 'arith' },
            { m: 'CP n', o: 'FE nn', b: 2, c: '7', f: 'SZ*V1C', d: 'Compare immediate with A', g: 'arith' },
            { m: 'CP (HL)', o: 'BE', b: 1, c: '7', f: 'SZ*V1C', d: 'Compare (HL) with A', g: 'arith' },
            { m: 'CP (IX+d)', o: 'DD BE dd', b: 3, c: '19', f: 'SZ*V1C', d: 'Compare (IX+d) with A', g: 'arith' },
            { m: 'CP (IY+d)', o: 'FD BE dd', b: 3, c: '19', f: 'SZ*V1C', d: 'Compare (IY+d) with A', g: 'arith' },
            { m: 'INC A', o: '3C', b: 1, c: '4', f: 'SZ*V0-', d: 'Increment A', g: 'arith' },
            { m: 'INC B', o: '04', b: 1, c: '4', f: 'SZ*V0-', d: 'Increment B', g: 'arith' },
            { m: 'INC C', o: '0C', b: 1, c: '4', f: 'SZ*V0-', d: 'Increment C', g: 'arith' },
            { m: 'INC D', o: '14', b: 1, c: '4', f: 'SZ*V0-', d: 'Increment D', g: 'arith' },
            { m: 'INC E', o: '1C', b: 1, c: '4', f: 'SZ*V0-', d: 'Increment E', g: 'arith' },
            { m: 'INC H', o: '24', b: 1, c: '4', f: 'SZ*V0-', d: 'Increment H', g: 'arith' },
            { m: 'INC L', o: '2C', b: 1, c: '4', f: 'SZ*V0-', d: 'Increment L', g: 'arith' },
            { m: 'INC (HL)', o: '34', b: 1, c: '11', f: 'SZ*V0-', d: 'Increment (HL)', g: 'arith' },
            { m: 'INC (IX+d)', o: 'DD 34 dd', b: 3, c: '23', f: 'SZ*V0-', d: 'Increment (IX+d)', g: 'arith' },
            { m: 'INC (IY+d)', o: 'FD 34 dd', b: 3, c: '23', f: 'SZ*V0-', d: 'Increment (IY+d)', g: 'arith' },
            { m: 'INC IXH', o: 'DD 24', b: 2, c: '8', f: 'SZ*V0-', d: 'Increment IXH', g: 'arith', u: true },
            { m: 'INC IXL', o: 'DD 2C', b: 2, c: '8', f: 'SZ*V0-', d: 'Increment IXL', g: 'arith', u: true },
            { m: 'INC IYH', o: 'FD 24', b: 2, c: '8', f: 'SZ*V0-', d: 'Increment IYH', g: 'arith', u: true },
            { m: 'INC IYL', o: 'FD 2C', b: 2, c: '8', f: 'SZ*V0-', d: 'Increment IYL', g: 'arith', u: true },
            { m: 'DEC A', o: '3D', b: 1, c: '4', f: 'SZ*V1-', d: 'Decrement A', g: 'arith' },
            { m: 'DEC B', o: '05', b: 1, c: '4', f: 'SZ*V1-', d: 'Decrement B', g: 'arith' },
            { m: 'DEC C', o: '0D', b: 1, c: '4', f: 'SZ*V1-', d: 'Decrement C', g: 'arith' },
            { m: 'DEC D', o: '15', b: 1, c: '4', f: 'SZ*V1-', d: 'Decrement D', g: 'arith' },
            { m: 'DEC E', o: '1D', b: 1, c: '4', f: 'SZ*V1-', d: 'Decrement E', g: 'arith' },
            { m: 'DEC H', o: '25', b: 1, c: '4', f: 'SZ*V1-', d: 'Decrement H', g: 'arith' },
            { m: 'DEC L', o: '2D', b: 1, c: '4', f: 'SZ*V1-', d: 'Decrement L', g: 'arith' },
            { m: 'DEC (HL)', o: '35', b: 1, c: '11', f: 'SZ*V1-', d: 'Decrement (HL)', g: 'arith' },
            { m: 'DEC (IX+d)', o: 'DD 35 dd', b: 3, c: '23', f: 'SZ*V1-', d: 'Decrement (IX+d)', g: 'arith' },
            { m: 'DEC (IY+d)', o: 'FD 35 dd', b: 3, c: '23', f: 'SZ*V1-', d: 'Decrement (IY+d)', g: 'arith' },
            { m: 'DEC IXH', o: 'DD 25', b: 2, c: '8', f: 'SZ*V1-', d: 'Decrement IXH', g: 'arith', u: true },
            { m: 'DEC IXL', o: 'DD 2D', b: 2, c: '8', f: 'SZ*V1-', d: 'Decrement IXL', g: 'arith', u: true },
            { m: 'DEC IYH', o: 'FD 25', b: 2, c: '8', f: 'SZ*V1-', d: 'Decrement IYH', g: 'arith', u: true },
            { m: 'DEC IYL', o: 'FD 2D', b: 2, c: '8', f: 'SZ*V1-', d: 'Decrement IYL', g: 'arith', u: true },
            { m: 'DAA', o: '27', b: 1, c: '4', f: 'SZ*P-C', d: 'Decimal adjust A', g: 'arith' },
            { m: 'NEG', o: 'ED 44', b: 2, c: '8', f: 'SZ*V1C', d: 'Negate A (two\'s complement)', g: 'arith' },
            // Arithmetic 16-bit
            { m: 'ADD HL,BC', o: '09', b: 1, c: '11', f: '--*-0C', d: 'Add BC to HL', g: 'arith' },
            { m: 'ADD HL,DE', o: '19', b: 1, c: '11', f: '--*-0C', d: 'Add DE to HL', g: 'arith' },
            { m: 'ADD HL,HL', o: '29', b: 1, c: '11', f: '--*-0C', d: 'Add HL to HL', g: 'arith' },
            { m: 'ADD HL,SP', o: '39', b: 1, c: '11', f: '--*-0C', d: 'Add SP to HL', g: 'arith' },
            { m: 'ADC HL,BC', o: 'ED 4A', b: 2, c: '15', f: 'SZ*V0C', d: 'Add with carry BC to HL', g: 'arith' },
            { m: 'ADC HL,DE', o: 'ED 5A', b: 2, c: '15', f: 'SZ*V0C', d: 'Add with carry DE to HL', g: 'arith' },
            { m: 'ADC HL,HL', o: 'ED 6A', b: 2, c: '15', f: 'SZ*V0C', d: 'Add with carry HL to HL', g: 'arith' },
            { m: 'ADC HL,SP', o: 'ED 7A', b: 2, c: '15', f: 'SZ*V0C', d: 'Add with carry SP to HL', g: 'arith' },
            { m: 'SBC HL,BC', o: 'ED 42', b: 2, c: '15', f: 'SZ*V1C', d: 'Subtract with carry BC from HL', g: 'arith' },
            { m: 'SBC HL,DE', o: 'ED 52', b: 2, c: '15', f: 'SZ*V1C', d: 'Subtract with carry DE from HL', g: 'arith' },
            { m: 'SBC HL,HL', o: 'ED 62', b: 2, c: '15', f: 'SZ*V1C', d: 'Subtract with carry HL from HL', g: 'arith' },
            { m: 'SBC HL,SP', o: 'ED 72', b: 2, c: '15', f: 'SZ*V1C', d: 'Subtract with carry SP from HL', g: 'arith' },
            { m: 'ADD IX,BC', o: 'DD 09', b: 2, c: '15', f: '--*-0C', d: 'Add BC to IX', g: 'arith' },
            { m: 'ADD IX,DE', o: 'DD 19', b: 2, c: '15', f: '--*-0C', d: 'Add DE to IX', g: 'arith' },
            { m: 'ADD IX,IX', o: 'DD 29', b: 2, c: '15', f: '--*-0C', d: 'Add IX to IX', g: 'arith' },
            { m: 'ADD IX,SP', o: 'DD 39', b: 2, c: '15', f: '--*-0C', d: 'Add SP to IX', g: 'arith' },
            { m: 'ADD IY,BC', o: 'FD 09', b: 2, c: '15', f: '--*-0C', d: 'Add BC to IY', g: 'arith' },
            { m: 'ADD IY,DE', o: 'FD 19', b: 2, c: '15', f: '--*-0C', d: 'Add DE to IY', g: 'arith' },
            { m: 'ADD IY,IY', o: 'FD 29', b: 2, c: '15', f: '--*-0C', d: 'Add IY to IY', g: 'arith' },
            { m: 'ADD IY,SP', o: 'FD 39', b: 2, c: '15', f: '--*-0C', d: 'Add SP to IY', g: 'arith' },
            { m: 'INC BC', o: '03', b: 1, c: '6', f: '------', d: 'Increment BC', g: 'arith' },
            { m: 'INC DE', o: '13', b: 1, c: '6', f: '------', d: 'Increment DE', g: 'arith' },
            { m: 'INC HL', o: '23', b: 1, c: '6', f: '------', d: 'Increment HL', g: 'arith' },
            { m: 'INC SP', o: '33', b: 1, c: '6', f: '------', d: 'Increment SP', g: 'arith' },
            { m: 'INC IX', o: 'DD 23', b: 2, c: '10', f: '------', d: 'Increment IX', g: 'arith' },
            { m: 'INC IY', o: 'FD 23', b: 2, c: '10', f: '------', d: 'Increment IY', g: 'arith' },
            { m: 'DEC BC', o: '0B', b: 1, c: '6', f: '------', d: 'Decrement BC', g: 'arith' },
            { m: 'DEC DE', o: '1B', b: 1, c: '6', f: '------', d: 'Decrement DE', g: 'arith' },
            { m: 'DEC HL', o: '2B', b: 1, c: '6', f: '------', d: 'Decrement HL', g: 'arith' },
            { m: 'DEC SP', o: '3B', b: 1, c: '6', f: '------', d: 'Decrement SP', g: 'arith' },
            { m: 'DEC IX', o: 'DD 2B', b: 2, c: '10', f: '------', d: 'Decrement IX', g: 'arith' },
            { m: 'DEC IY', o: 'FD 2B', b: 2, c: '10', f: '------', d: 'Decrement IY', g: 'arith' },
            // Logic
            { m: 'AND A', o: 'A7', b: 1, c: '4', f: 'SZ*P10', d: 'Logical AND A with A', g: 'logic' },
            { m: 'AND B', o: 'A0', b: 1, c: '4', f: 'SZ*P10', d: 'Logical AND B with A', g: 'logic' },
            { m: 'AND C', o: 'A1', b: 1, c: '4', f: 'SZ*P10', d: 'Logical AND C with A', g: 'logic' },
            { m: 'AND D', o: 'A2', b: 1, c: '4', f: 'SZ*P10', d: 'Logical AND D with A', g: 'logic' },
            { m: 'AND E', o: 'A3', b: 1, c: '4', f: 'SZ*P10', d: 'Logical AND E with A', g: 'logic' },
            { m: 'AND H', o: 'A4', b: 1, c: '4', f: 'SZ*P10', d: 'Logical AND H with A', g: 'logic' },
            { m: 'AND L', o: 'A5', b: 1, c: '4', f: 'SZ*P10', d: 'Logical AND L with A', g: 'logic' },
            { m: 'AND n', o: 'E6 nn', b: 2, c: '7', f: 'SZ*P10', d: 'Logical AND immediate with A', g: 'logic' },
            { m: 'AND (HL)', o: 'A6', b: 1, c: '7', f: 'SZ*P10', d: 'Logical AND (HL) with A', g: 'logic' },
            { m: 'AND (IX+d)', o: 'DD A6 dd', b: 3, c: '19', f: 'SZ*P10', d: 'Logical AND (IX+d) with A', g: 'logic' },
            { m: 'AND (IY+d)', o: 'FD A6 dd', b: 3, c: '19', f: 'SZ*P10', d: 'Logical AND (IY+d) with A', g: 'logic' },
            { m: 'OR A', o: 'B7', b: 1, c: '4', f: 'SZ*P00', d: 'Logical OR A with A', g: 'logic' },
            { m: 'OR B', o: 'B0', b: 1, c: '4', f: 'SZ*P00', d: 'Logical OR B with A', g: 'logic' },
            { m: 'OR C', o: 'B1', b: 1, c: '4', f: 'SZ*P00', d: 'Logical OR C with A', g: 'logic' },
            { m: 'OR D', o: 'B2', b: 1, c: '4', f: 'SZ*P00', d: 'Logical OR D with A', g: 'logic' },
            { m: 'OR E', o: 'B3', b: 1, c: '4', f: 'SZ*P00', d: 'Logical OR E with A', g: 'logic' },
            { m: 'OR H', o: 'B4', b: 1, c: '4', f: 'SZ*P00', d: 'Logical OR H with A', g: 'logic' },
            { m: 'OR L', o: 'B5', b: 1, c: '4', f: 'SZ*P00', d: 'Logical OR L with A', g: 'logic' },
            { m: 'OR n', o: 'F6 nn', b: 2, c: '7', f: 'SZ*P00', d: 'Logical OR immediate with A', g: 'logic' },
            { m: 'OR (HL)', o: 'B6', b: 1, c: '7', f: 'SZ*P00', d: 'Logical OR (HL) with A', g: 'logic' },
            { m: 'OR (IX+d)', o: 'DD B6 dd', b: 3, c: '19', f: 'SZ*P00', d: 'Logical OR (IX+d) with A', g: 'logic' },
            { m: 'OR (IY+d)', o: 'FD B6 dd', b: 3, c: '19', f: 'SZ*P00', d: 'Logical OR (IY+d) with A', g: 'logic' },
            { m: 'XOR A', o: 'AF', b: 1, c: '4', f: 'SZ*P00', d: 'Logical XOR A with A', g: 'logic' },
            { m: 'XOR B', o: 'A8', b: 1, c: '4', f: 'SZ*P00', d: 'Logical XOR B with A', g: 'logic' },
            { m: 'XOR C', o: 'A9', b: 1, c: '4', f: 'SZ*P00', d: 'Logical XOR C with A', g: 'logic' },
            { m: 'XOR D', o: 'AA', b: 1, c: '4', f: 'SZ*P00', d: 'Logical XOR D with A', g: 'logic' },
            { m: 'XOR E', o: 'AB', b: 1, c: '4', f: 'SZ*P00', d: 'Logical XOR E with A', g: 'logic' },
            { m: 'XOR H', o: 'AC', b: 1, c: '4', f: 'SZ*P00', d: 'Logical XOR H with A', g: 'logic' },
            { m: 'XOR L', o: 'AD', b: 1, c: '4', f: 'SZ*P00', d: 'Logical XOR L with A', g: 'logic' },
            { m: 'XOR n', o: 'EE nn', b: 2, c: '7', f: 'SZ*P00', d: 'Logical XOR immediate with A', g: 'logic' },
            { m: 'XOR (HL)', o: 'AE', b: 1, c: '7', f: 'SZ*P00', d: 'Logical XOR (HL) with A', g: 'logic' },
            { m: 'XOR (IX+d)', o: 'DD AE dd', b: 3, c: '19', f: 'SZ*P00', d: 'Logical XOR (IX+d) with A', g: 'logic' },
            { m: 'XOR (IY+d)', o: 'FD AE dd', b: 3, c: '19', f: 'SZ*P00', d: 'Logical XOR (IY+d) with A', g: 'logic' },
            { m: 'CPL', o: '2F', b: 1, c: '4', f: '--1-1-', d: 'Complement A (one\'s complement)', g: 'logic' },
            { m: 'CCF', o: '3F', b: 1, c: '4', f: '--*-0C', d: 'Complement carry flag', g: 'logic' },
            { m: 'SCF', o: '37', b: 1, c: '4', f: '--0-01', d: 'Set carry flag', g: 'logic' },
            // Rotate & Shift
            { m: 'RLCA', o: '07', b: 1, c: '4', f: '--0-0C', d: 'Rotate A left circular', g: 'rotate' },
            { m: 'RLA', o: '17', b: 1, c: '4', f: '--0-0C', d: 'Rotate A left through carry', g: 'rotate' },
            { m: 'RRCA', o: '0F', b: 1, c: '4', f: '--0-0C', d: 'Rotate A right circular', g: 'rotate' },
            { m: 'RRA', o: '1F', b: 1, c: '4', f: '--0-0C', d: 'Rotate A right through carry', g: 'rotate' },
            { m: 'RLC A', o: 'CB 07', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate A left circular', g: 'rotate' },
            { m: 'RLC B', o: 'CB 00', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate B left circular', g: 'rotate' },
            { m: 'RLC C', o: 'CB 01', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate C left circular', g: 'rotate' },
            { m: 'RLC D', o: 'CB 02', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate D left circular', g: 'rotate' },
            { m: 'RLC E', o: 'CB 03', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate E left circular', g: 'rotate' },
            { m: 'RLC H', o: 'CB 04', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate H left circular', g: 'rotate' },
            { m: 'RLC L', o: 'CB 05', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate L left circular', g: 'rotate' },
            { m: 'RLC (HL)', o: 'CB 06', b: 2, c: '15', f: 'SZ*P0C', d: 'Rotate (HL) left circular', g: 'rotate' },
            { m: 'RLC (IX+d)', o: 'DD CB dd 06', b: 4, c: '23', f: 'SZ*P0C', d: 'Rotate (IX+d) left circular', g: 'rotate' },
            { m: 'RLC (IY+d)', o: 'FD CB dd 06', b: 4, c: '23', f: 'SZ*P0C', d: 'Rotate (IY+d) left circular', g: 'rotate' },
            { m: 'RL A', o: 'CB 17', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate A left through carry', g: 'rotate' },
            { m: 'RL B', o: 'CB 10', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate B left through carry', g: 'rotate' },
            { m: 'RL C', o: 'CB 11', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate C left through carry', g: 'rotate' },
            { m: 'RL D', o: 'CB 12', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate D left through carry', g: 'rotate' },
            { m: 'RL E', o: 'CB 13', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate E left through carry', g: 'rotate' },
            { m: 'RL H', o: 'CB 14', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate H left through carry', g: 'rotate' },
            { m: 'RL L', o: 'CB 15', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate L left through carry', g: 'rotate' },
            { m: 'RL (HL)', o: 'CB 16', b: 2, c: '15', f: 'SZ*P0C', d: 'Rotate (HL) left through carry', g: 'rotate' },
            { m: 'RL (IX+d)', o: 'DD CB dd 16', b: 4, c: '23', f: 'SZ*P0C', d: 'Rotate (IX+d) left through carry', g: 'rotate' },
            { m: 'RL (IY+d)', o: 'FD CB dd 16', b: 4, c: '23', f: 'SZ*P0C', d: 'Rotate (IY+d) left through carry', g: 'rotate' },
            { m: 'RRC A', o: 'CB 0F', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate A right circular', g: 'rotate' },
            { m: 'RRC B', o: 'CB 08', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate B right circular', g: 'rotate' },
            { m: 'RRC C', o: 'CB 09', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate C right circular', g: 'rotate' },
            { m: 'RRC D', o: 'CB 0A', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate D right circular', g: 'rotate' },
            { m: 'RRC E', o: 'CB 0B', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate E right circular', g: 'rotate' },
            { m: 'RRC H', o: 'CB 0C', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate H right circular', g: 'rotate' },
            { m: 'RRC L', o: 'CB 0D', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate L right circular', g: 'rotate' },
            { m: 'RRC (HL)', o: 'CB 0E', b: 2, c: '15', f: 'SZ*P0C', d: 'Rotate (HL) right circular', g: 'rotate' },
            { m: 'RRC (IX+d)', o: 'DD CB dd 0E', b: 4, c: '23', f: 'SZ*P0C', d: 'Rotate (IX+d) right circular', g: 'rotate' },
            { m: 'RRC (IY+d)', o: 'FD CB dd 0E', b: 4, c: '23', f: 'SZ*P0C', d: 'Rotate (IY+d) right circular', g: 'rotate' },
            { m: 'RR A', o: 'CB 1F', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate A right through carry', g: 'rotate' },
            { m: 'RR B', o: 'CB 18', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate B right through carry', g: 'rotate' },
            { m: 'RR C', o: 'CB 19', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate C right through carry', g: 'rotate' },
            { m: 'RR D', o: 'CB 1A', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate D right through carry', g: 'rotate' },
            { m: 'RR E', o: 'CB 1B', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate E right through carry', g: 'rotate' },
            { m: 'RR H', o: 'CB 1C', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate H right through carry', g: 'rotate' },
            { m: 'RR L', o: 'CB 1D', b: 2, c: '8', f: 'SZ*P0C', d: 'Rotate L right through carry', g: 'rotate' },
            { m: 'RR (HL)', o: 'CB 1E', b: 2, c: '15', f: 'SZ*P0C', d: 'Rotate (HL) right through carry', g: 'rotate' },
            { m: 'RR (IX+d)', o: 'DD CB dd 1E', b: 4, c: '23', f: 'SZ*P0C', d: 'Rotate (IX+d) right through carry', g: 'rotate' },
            { m: 'RR (IY+d)', o: 'FD CB dd 1E', b: 4, c: '23', f: 'SZ*P0C', d: 'Rotate (IY+d) right through carry', g: 'rotate' },
            { m: 'SLA A', o: 'CB 27', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift A left arithmetic', g: 'rotate' },
            { m: 'SLA B', o: 'CB 20', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift B left arithmetic', g: 'rotate' },
            { m: 'SLA C', o: 'CB 21', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift C left arithmetic', g: 'rotate' },
            { m: 'SLA D', o: 'CB 22', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift D left arithmetic', g: 'rotate' },
            { m: 'SLA E', o: 'CB 23', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift E left arithmetic', g: 'rotate' },
            { m: 'SLA H', o: 'CB 24', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift H left arithmetic', g: 'rotate' },
            { m: 'SLA L', o: 'CB 25', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift L left arithmetic', g: 'rotate' },
            { m: 'SLA (HL)', o: 'CB 26', b: 2, c: '15', f: 'SZ*P0C', d: 'Shift (HL) left arithmetic', g: 'rotate' },
            { m: 'SLA (IX+d)', o: 'DD CB dd 26', b: 4, c: '23', f: 'SZ*P0C', d: 'Shift (IX+d) left arithmetic', g: 'rotate' },
            { m: 'SLA (IY+d)', o: 'FD CB dd 26', b: 4, c: '23', f: 'SZ*P0C', d: 'Shift (IY+d) left arithmetic', g: 'rotate' },
            { m: 'SLL A', o: 'CB 37', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift A left logical (bit0=1)', g: 'rotate', u: true },
            { m: 'SLL B', o: 'CB 30', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift B left logical (bit0=1)', g: 'rotate', u: true },
            { m: 'SLL C', o: 'CB 31', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift C left logical (bit0=1)', g: 'rotate', u: true },
            { m: 'SLL D', o: 'CB 32', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift D left logical (bit0=1)', g: 'rotate', u: true },
            { m: 'SLL E', o: 'CB 33', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift E left logical (bit0=1)', g: 'rotate', u: true },
            { m: 'SLL H', o: 'CB 34', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift H left logical (bit0=1)', g: 'rotate', u: true },
            { m: 'SLL L', o: 'CB 35', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift L left logical (bit0=1)', g: 'rotate', u: true },
            { m: 'SLL (HL)', o: 'CB 36', b: 2, c: '15', f: 'SZ*P0C', d: 'Shift (HL) left logical (bit0=1)', g: 'rotate', u: true },
            { m: 'SRA A', o: 'CB 2F', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift A right arithmetic', g: 'rotate' },
            { m: 'SRA B', o: 'CB 28', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift B right arithmetic', g: 'rotate' },
            { m: 'SRA C', o: 'CB 29', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift C right arithmetic', g: 'rotate' },
            { m: 'SRA D', o: 'CB 2A', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift D right arithmetic', g: 'rotate' },
            { m: 'SRA E', o: 'CB 2B', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift E right arithmetic', g: 'rotate' },
            { m: 'SRA H', o: 'CB 2C', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift H right arithmetic', g: 'rotate' },
            { m: 'SRA L', o: 'CB 2D', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift L right arithmetic', g: 'rotate' },
            { m: 'SRA (HL)', o: 'CB 2E', b: 2, c: '15', f: 'SZ*P0C', d: 'Shift (HL) right arithmetic', g: 'rotate' },
            { m: 'SRA (IX+d)', o: 'DD CB dd 2E', b: 4, c: '23', f: 'SZ*P0C', d: 'Shift (IX+d) right arithmetic', g: 'rotate' },
            { m: 'SRA (IY+d)', o: 'FD CB dd 2E', b: 4, c: '23', f: 'SZ*P0C', d: 'Shift (IY+d) right arithmetic', g: 'rotate' },
            { m: 'SRL A', o: 'CB 3F', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift A right logical', g: 'rotate' },
            { m: 'SRL B', o: 'CB 38', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift B right logical', g: 'rotate' },
            { m: 'SRL C', o: 'CB 39', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift C right logical', g: 'rotate' },
            { m: 'SRL D', o: 'CB 3A', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift D right logical', g: 'rotate' },
            { m: 'SRL E', o: 'CB 3B', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift E right logical', g: 'rotate' },
            { m: 'SRL H', o: 'CB 3C', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift H right logical', g: 'rotate' },
            { m: 'SRL L', o: 'CB 3D', b: 2, c: '8', f: 'SZ*P0C', d: 'Shift L right logical', g: 'rotate' },
            { m: 'SRL (HL)', o: 'CB 3E', b: 2, c: '15', f: 'SZ*P0C', d: 'Shift (HL) right logical', g: 'rotate' },
            { m: 'SRL (IX+d)', o: 'DD CB dd 3E', b: 4, c: '23', f: 'SZ*P0C', d: 'Shift (IX+d) right logical', g: 'rotate' },
            { m: 'SRL (IY+d)', o: 'FD CB dd 3E', b: 4, c: '23', f: 'SZ*P0C', d: 'Shift (IY+d) right logical', g: 'rotate' },
            { m: 'RLD', o: 'ED 6F', b: 2, c: '18', f: 'SZ*P0-', d: 'Rotate left digit', g: 'rotate' },
            { m: 'RRD', o: 'ED 67', b: 2, c: '18', f: 'SZ*P0-', d: 'Rotate right digit', g: 'rotate' },
            // Bit Operations (example opcodes for bit 0)
            { m: 'BIT 0,A', o: 'CB 47', b: 2, c: '8', f: 'SZ?10-', d: 'Test bit 0 of A', g: 'bit' },
            { m: 'BIT 0,B', o: 'CB 40', b: 2, c: '8', f: 'SZ?10-', d: 'Test bit 0 of B', g: 'bit' },
            { m: 'BIT 0,C', o: 'CB 41', b: 2, c: '8', f: 'SZ?10-', d: 'Test bit 0 of C', g: 'bit' },
            { m: 'BIT 0,D', o: 'CB 42', b: 2, c: '8', f: 'SZ?10-', d: 'Test bit 0 of D', g: 'bit' },
            { m: 'BIT 0,E', o: 'CB 43', b: 2, c: '8', f: 'SZ?10-', d: 'Test bit 0 of E', g: 'bit' },
            { m: 'BIT 0,H', o: 'CB 44', b: 2, c: '8', f: 'SZ?10-', d: 'Test bit 0 of H', g: 'bit' },
            { m: 'BIT 0,L', o: 'CB 45', b: 2, c: '8', f: 'SZ?10-', d: 'Test bit 0 of L', g: 'bit' },
            { m: 'BIT 0,(HL)', o: 'CB 46', b: 2, c: '12', f: 'SZ?10-', d: 'Test bit 0 of (HL)', g: 'bit' },
            { m: 'BIT b,r', o: 'CB 40+8*b+r', b: 2, c: '8', f: 'SZ?10-', d: 'Test bit b of register (b=0-7)', g: 'bit' },
            { m: 'BIT b,(HL)', o: 'CB 46+8*b', b: 2, c: '12', f: 'SZ?10-', d: 'Test bit b of (HL) (b=0-7)', g: 'bit' },
            { m: 'BIT b,(IX+d)', o: 'DD CB dd 46+8*b', b: 4, c: '20', f: 'SZ?10-', d: 'Test bit b of (IX+d)', g: 'bit' },
            { m: 'BIT b,(IY+d)', o: 'FD CB dd 46+8*b', b: 4, c: '20', f: 'SZ?10-', d: 'Test bit b of (IY+d)', g: 'bit' },
            { m: 'SET 0,A', o: 'CB C7', b: 2, c: '8', f: '------', d: 'Set bit 0 of A', g: 'bit' },
            { m: 'SET 0,B', o: 'CB C0', b: 2, c: '8', f: '------', d: 'Set bit 0 of B', g: 'bit' },
            { m: 'SET 0,C', o: 'CB C1', b: 2, c: '8', f: '------', d: 'Set bit 0 of C', g: 'bit' },
            { m: 'SET 0,D', o: 'CB C2', b: 2, c: '8', f: '------', d: 'Set bit 0 of D', g: 'bit' },
            { m: 'SET 0,E', o: 'CB C3', b: 2, c: '8', f: '------', d: 'Set bit 0 of E', g: 'bit' },
            { m: 'SET 0,H', o: 'CB C4', b: 2, c: '8', f: '------', d: 'Set bit 0 of H', g: 'bit' },
            { m: 'SET 0,L', o: 'CB C5', b: 2, c: '8', f: '------', d: 'Set bit 0 of L', g: 'bit' },
            { m: 'SET 0,(HL)', o: 'CB C6', b: 2, c: '15', f: '------', d: 'Set bit 0 of (HL)', g: 'bit' },
            { m: 'SET b,r', o: 'CB C0+8*b+r', b: 2, c: '8', f: '------', d: 'Set bit b of register (b=0-7)', g: 'bit' },
            { m: 'SET b,(HL)', o: 'CB C6+8*b', b: 2, c: '15', f: '------', d: 'Set bit b of (HL) (b=0-7)', g: 'bit' },
            { m: 'SET b,(IX+d)', o: 'DD CB dd C6+8*b', b: 4, c: '23', f: '------', d: 'Set bit b of (IX+d)', g: 'bit' },
            { m: 'SET b,(IY+d)', o: 'FD CB dd C6+8*b', b: 4, c: '23', f: '------', d: 'Set bit b of (IY+d)', g: 'bit' },
            { m: 'RES 0,A', o: 'CB 87', b: 2, c: '8', f: '------', d: 'Reset bit 0 of A', g: 'bit' },
            { m: 'RES 0,B', o: 'CB 80', b: 2, c: '8', f: '------', d: 'Reset bit 0 of B', g: 'bit' },
            { m: 'RES 0,C', o: 'CB 81', b: 2, c: '8', f: '------', d: 'Reset bit 0 of C', g: 'bit' },
            { m: 'RES 0,D', o: 'CB 82', b: 2, c: '8', f: '------', d: 'Reset bit 0 of D', g: 'bit' },
            { m: 'RES 0,E', o: 'CB 83', b: 2, c: '8', f: '------', d: 'Reset bit 0 of E', g: 'bit' },
            { m: 'RES 0,H', o: 'CB 84', b: 2, c: '8', f: '------', d: 'Reset bit 0 of H', g: 'bit' },
            { m: 'RES 0,L', o: 'CB 85', b: 2, c: '8', f: '------', d: 'Reset bit 0 of L', g: 'bit' },
            { m: 'RES 0,(HL)', o: 'CB 86', b: 2, c: '15', f: '------', d: 'Reset bit 0 of (HL)', g: 'bit' },
            { m: 'RES b,r', o: 'CB 80+8*b+r', b: 2, c: '8', f: '------', d: 'Reset bit b of register (b=0-7)', g: 'bit' },
            { m: 'RES b,(HL)', o: 'CB 86+8*b', b: 2, c: '15', f: '------', d: 'Reset bit b of (HL) (b=0-7)', g: 'bit' },
            { m: 'RES b,(IX+d)', o: 'DD CB dd 86+8*b', b: 4, c: '23', f: '------', d: 'Reset bit b of (IX+d)', g: 'bit' },
            { m: 'RES b,(IY+d)', o: 'FD CB dd 86+8*b', b: 4, c: '23', f: '------', d: 'Reset bit b of (IY+d)', g: 'bit' },
            // Jump
            { m: 'JP nn', o: 'C3 nn nn', b: 3, c: '10', f: '------', d: 'Jump to address', g: 'jump' },
            { m: 'JP NZ,nn', o: 'C2 nn nn', b: 3, c: '10', f: '------', d: 'Jump if not zero', g: 'jump' },
            { m: 'JP Z,nn', o: 'CA nn nn', b: 3, c: '10', f: '------', d: 'Jump if zero', g: 'jump' },
            { m: 'JP NC,nn', o: 'D2 nn nn', b: 3, c: '10', f: '------', d: 'Jump if no carry', g: 'jump' },
            { m: 'JP C,nn', o: 'DA nn nn', b: 3, c: '10', f: '------', d: 'Jump if carry', g: 'jump' },
            { m: 'JP PO,nn', o: 'E2 nn nn', b: 3, c: '10', f: '------', d: 'Jump if parity odd', g: 'jump' },
            { m: 'JP PE,nn', o: 'EA nn nn', b: 3, c: '10', f: '------', d: 'Jump if parity even', g: 'jump' },
            { m: 'JP P,nn', o: 'F2 nn nn', b: 3, c: '10', f: '------', d: 'Jump if positive', g: 'jump' },
            { m: 'JP M,nn', o: 'FA nn nn', b: 3, c: '10', f: '------', d: 'Jump if minus', g: 'jump' },
            { m: 'JR e', o: '18 ee', b: 2, c: '12', f: '------', d: 'Relative jump', g: 'jump' },
            { m: 'JR C,e', o: '38 ee', b: 2, c: '12/7', f: '------', d: 'Relative jump if carry', g: 'jump' },
            { m: 'JR NC,e', o: '30 ee', b: 2, c: '12/7', f: '------', d: 'Relative jump if no carry', g: 'jump' },
            { m: 'JR Z,e', o: '28 ee', b: 2, c: '12/7', f: '------', d: 'Relative jump if zero', g: 'jump' },
            { m: 'JR NZ,e', o: '20 ee', b: 2, c: '12/7', f: '------', d: 'Relative jump if not zero', g: 'jump' },
            { m: 'JP (HL)', o: 'E9', b: 1, c: '4', f: '------', d: 'Jump to address in HL', g: 'jump' },
            { m: 'JP (IX)', o: 'DD E9', b: 2, c: '8', f: '------', d: 'Jump to address in IX', g: 'jump' },
            { m: 'JP (IY)', o: 'FD E9', b: 2, c: '8', f: '------', d: 'Jump to address in IY', g: 'jump' },
            { m: 'DJNZ e', o: '10 ee', b: 2, c: '13/8', f: '------', d: 'Decrement B and jump if not zero', g: 'jump' },
            // Call & Return
            { m: 'CALL nn', o: 'CD nn nn', b: 3, c: '17', f: '------', d: 'Call subroutine', g: 'jump' },
            { m: 'CALL NZ,nn', o: 'C4 nn nn', b: 3, c: '17/10', f: '------', d: 'Call if not zero', g: 'jump' },
            { m: 'CALL Z,nn', o: 'CC nn nn', b: 3, c: '17/10', f: '------', d: 'Call if zero', g: 'jump' },
            { m: 'CALL NC,nn', o: 'D4 nn nn', b: 3, c: '17/10', f: '------', d: 'Call if no carry', g: 'jump' },
            { m: 'CALL C,nn', o: 'DC nn nn', b: 3, c: '17/10', f: '------', d: 'Call if carry', g: 'jump' },
            { m: 'CALL PO,nn', o: 'E4 nn nn', b: 3, c: '17/10', f: '------', d: 'Call if parity odd', g: 'jump' },
            { m: 'CALL PE,nn', o: 'EC nn nn', b: 3, c: '17/10', f: '------', d: 'Call if parity even', g: 'jump' },
            { m: 'CALL P,nn', o: 'F4 nn nn', b: 3, c: '17/10', f: '------', d: 'Call if positive', g: 'jump' },
            { m: 'CALL M,nn', o: 'FC nn nn', b: 3, c: '17/10', f: '------', d: 'Call if minus', g: 'jump' },
            { m: 'RET', o: 'C9', b: 1, c: '10', f: '------', d: 'Return from subroutine', g: 'jump' },
            { m: 'RET NZ', o: 'C0', b: 1, c: '11/5', f: '------', d: 'Return if not zero', g: 'jump' },
            { m: 'RET Z', o: 'C8', b: 1, c: '11/5', f: '------', d: 'Return if zero', g: 'jump' },
            { m: 'RET NC', o: 'D0', b: 1, c: '11/5', f: '------', d: 'Return if no carry', g: 'jump' },
            { m: 'RET C', o: 'D8', b: 1, c: '11/5', f: '------', d: 'Return if carry', g: 'jump' },
            { m: 'RET PO', o: 'E0', b: 1, c: '11/5', f: '------', d: 'Return if parity odd', g: 'jump' },
            { m: 'RET PE', o: 'E8', b: 1, c: '11/5', f: '------', d: 'Return if parity even', g: 'jump' },
            { m: 'RET P', o: 'F0', b: 1, c: '11/5', f: '------', d: 'Return if positive', g: 'jump' },
            { m: 'RET M', o: 'F8', b: 1, c: '11/5', f: '------', d: 'Return if minus', g: 'jump' },
            { m: 'RETI', o: 'ED 4D', b: 2, c: '14', f: '------', d: 'Return from interrupt', g: 'jump' },
            { m: 'RETN', o: 'ED 45', b: 2, c: '14', f: '------', d: 'Return from NMI', g: 'jump' },
            { m: 'RST 00H', o: 'C7', b: 1, c: '11', f: '------', d: 'Restart at 0000H', g: 'jump' },
            { m: 'RST 08H', o: 'CF', b: 1, c: '11', f: '------', d: 'Restart at 0008H', g: 'jump' },
            { m: 'RST 10H', o: 'D7', b: 1, c: '11', f: '------', d: 'Restart at 0010H', g: 'jump' },
            { m: 'RST 18H', o: 'DF', b: 1, c: '11', f: '------', d: 'Restart at 0018H', g: 'jump' },
            { m: 'RST 20H', o: 'E7', b: 1, c: '11', f: '------', d: 'Restart at 0020H', g: 'jump' },
            { m: 'RST 28H', o: 'EF', b: 1, c: '11', f: '------', d: 'Restart at 0028H', g: 'jump' },
            { m: 'RST 30H', o: 'F7', b: 1, c: '11', f: '------', d: 'Restart at 0030H', g: 'jump' },
            { m: 'RST 38H', o: 'FF', b: 1, c: '11', f: '------', d: 'Restart at 0038H', g: 'jump' },
            // I/O
            { m: 'IN A,(n)', o: 'DB nn', b: 2, c: '11', f: '------', d: 'Input from port n', g: 'io' },
            { m: 'IN A,(C)', o: 'ED 78', b: 2, c: '12', f: 'SZ*P0-', d: 'Input from port C to A', g: 'io' },
            { m: 'IN B,(C)', o: 'ED 40', b: 2, c: '12', f: 'SZ*P0-', d: 'Input from port C to B', g: 'io' },
            { m: 'IN C,(C)', o: 'ED 48', b: 2, c: '12', f: 'SZ*P0-', d: 'Input from port C to C', g: 'io' },
            { m: 'IN D,(C)', o: 'ED 50', b: 2, c: '12', f: 'SZ*P0-', d: 'Input from port C to D', g: 'io' },
            { m: 'IN E,(C)', o: 'ED 58', b: 2, c: '12', f: 'SZ*P0-', d: 'Input from port C to E', g: 'io' },
            { m: 'IN H,(C)', o: 'ED 60', b: 2, c: '12', f: 'SZ*P0-', d: 'Input from port C to H', g: 'io' },
            { m: 'IN L,(C)', o: 'ED 68', b: 2, c: '12', f: 'SZ*P0-', d: 'Input from port C to L', g: 'io' },
            { m: 'IN F,(C)', o: 'ED 70', b: 2, c: '12', f: 'SZ*P0-', d: 'Input port C, set flags only', g: 'io', u: true },
            { m: 'INI', o: 'ED A2', b: 2, c: '16', f: '?Z???-', d: 'Input and increment', g: 'io' },
            { m: 'INIR', o: 'ED B2', b: 2, c: '21/16', f: '?1???-', d: 'Input, increment and repeat', g: 'io' },
            { m: 'IND', o: 'ED AA', b: 2, c: '16', f: '?Z???-', d: 'Input and decrement', g: 'io' },
            { m: 'INDR', o: 'ED BA', b: 2, c: '21/16', f: '?1???-', d: 'Input, decrement and repeat', g: 'io' },
            { m: 'OUT (n),A', o: 'D3 nn', b: 2, c: '11', f: '------', d: 'Output A to port n', g: 'io' },
            { m: 'OUT (C),A', o: 'ED 79', b: 2, c: '12', f: '------', d: 'Output A to port C', g: 'io' },
            { m: 'OUT (C),B', o: 'ED 41', b: 2, c: '12', f: '------', d: 'Output B to port C', g: 'io' },
            { m: 'OUT (C),C', o: 'ED 49', b: 2, c: '12', f: '------', d: 'Output C to port C', g: 'io' },
            { m: 'OUT (C),D', o: 'ED 51', b: 2, c: '12', f: '------', d: 'Output D to port C', g: 'io' },
            { m: 'OUT (C),E', o: 'ED 59', b: 2, c: '12', f: '------', d: 'Output E to port C', g: 'io' },
            { m: 'OUT (C),H', o: 'ED 61', b: 2, c: '12', f: '------', d: 'Output H to port C', g: 'io' },
            { m: 'OUT (C),L', o: 'ED 69', b: 2, c: '12', f: '------', d: 'Output L to port C', g: 'io' },
            { m: 'OUT (C),0', o: 'ED 71', b: 2, c: '12', f: '------', d: 'Output 0 to port C', g: 'io', u: true },
            { m: 'OUTI', o: 'ED A3', b: 2, c: '16', f: '?Z???-', d: 'Output and increment', g: 'io' },
            { m: 'OTIR', o: 'ED B3', b: 2, c: '21/16', f: '?1???-', d: 'Output, increment and repeat', g: 'io' },
            { m: 'OUTD', o: 'ED AB', b: 2, c: '16', f: '?Z???-', d: 'Output and decrement', g: 'io' },
            { m: 'OTDR', o: 'ED BB', b: 2, c: '21/16', f: '?1???-', d: 'Output, decrement and repeat', g: 'io' },
            // Block Transfer
            { m: 'LDI', o: 'ED A0', b: 2, c: '16', f: '--0*0-', d: 'Load and increment', g: 'block' },
            { m: 'LDIR', o: 'ED B0', b: 2, c: '21/16', f: '--000-', d: 'Load, increment and repeat', g: 'block' },
            { m: 'LDD', o: 'ED A8', b: 2, c: '16', f: '--0*0-', d: 'Load and decrement', g: 'block' },
            { m: 'LDDR', o: 'ED B8', b: 2, c: '21/16', f: '--000-', d: 'Load, decrement and repeat', g: 'block' },
            { m: 'CPI', o: 'ED A1', b: 2, c: '16', f: 'SZ*?1-', d: 'Compare and increment', g: 'block' },
            { m: 'CPIR', o: 'ED B1', b: 2, c: '21/16', f: 'SZ*?1-', d: 'Compare, increment and repeat', g: 'block' },
            { m: 'CPD', o: 'ED A9', b: 2, c: '16', f: 'SZ*?1-', d: 'Compare and decrement', g: 'block' },
            { m: 'CPDR', o: 'ED B9', b: 2, c: '21/16', f: 'SZ*?1-', d: 'Compare, decrement and repeat', g: 'block' },
            // Misc
            { m: 'NOP', o: '00', b: 1, c: '4', f: '------', d: 'No operation', g: 'misc' },
            { m: 'HALT', o: '76', b: 1, c: '4', f: '------', d: 'Halt CPU until interrupt', g: 'misc' },
            { m: 'DI', o: 'F3', b: 1, c: '4', f: '------', d: 'Disable interrupts', g: 'misc' },
            { m: 'EI', o: 'FB', b: 1, c: '4', f: '------', d: 'Enable interrupts', g: 'misc' },
            { m: 'IM 0', o: 'ED 46', b: 2, c: '8', f: '------', d: 'Set interrupt mode 0', g: 'misc' },
            { m: 'IM 1', o: 'ED 56', b: 2, c: '8', f: '------', d: 'Set interrupt mode 1', g: 'misc' },
            { m: 'IM 2', o: 'ED 5E', b: 2, c: '8', f: '------', d: 'Set interrupt mode 2', g: 'misc' },
        ];

        function renderOpcodes(filter = '', group = 'all', cycles = 'all', sortBy = 'mnemonic') {
            const tbody = document.getElementById('opcodesBody');
            const filterLower = filter.toLowerCase();
            const filtered = z80Opcodes
                .filter(op => {
                    const matchesFilter = !filter ||
                        op.m.toLowerCase().includes(filterLower) ||
                        op.d.toLowerCase().includes(filterLower) ||
                        (op.o && op.o.toLowerCase().includes(filterLower));
                    const matchesGroup = group === 'all' || op.g === group;
                    const matchesCycles = cycles === 'all' || op.c.split('/').some(c => c.trim() === cycles);
                    return matchesFilter && matchesGroup && matchesCycles;
                })
                .sort((a, b) => {
                    if (sortBy === 'opcode') {
                        const oCmp = (a.o || 'ZZ').localeCompare(b.o || 'ZZ');
                        if (oCmp !== 0) return oCmp;
                        return a.m.localeCompare(b.m);
                    }
                    // Default: sort by mnemonic
                    const mCmp = a.m.localeCompare(b.m);
                    if (mCmp !== 0) return mCmp;
                    return (a.o || '').localeCompare(b.o || '');
                });
            const rows = filtered.map(op => `<tr>
                    <td class="op-mnemonic${op.u ? ' undoc' : ''}">${op.m}</td>
                    <td class="op-opcode">${op.o || ''}</td>
                    <td class="op-bytes">${op.b}</td>
                    <td class="op-cycles">${op.c}</td>
                    <td class="op-flags">${op.f}</td>
                    <td class="op-desc">${op.d}</td>
                </tr>`).join('');
            tbody.innerHTML = rows;
        }

        // Populate T-states dropdown with unique values
        const cyclesSet = new Set();
        z80Opcodes.forEach(op => {
            // Handle both simple (e.g., '4') and conditional (e.g., '17/10') cycles
            op.c.split('/').forEach(c => cyclesSet.add(c.trim()));
        });
        const cyclesSorted = [...cyclesSet].sort((a, b) => parseInt(a) - parseInt(b));
        const opcodeCyclesSelect = document.getElementById('opcodeCycles');
        cyclesSorted.forEach(c => {
            const opt = document.createElement('option');
            opt.value = c;
            opt.textContent = c + 'T';
            opcodeCyclesSelect.appendChild(opt);
        });

        function getOpcodeFilters() {
            return {
                search: document.getElementById('opcodeSearch').value,
                group: document.getElementById('opcodeGroup').value,
                cycles: document.getElementById('opcodeCycles').value,
                sort: document.getElementById('opcodeSort').value
            };
        }

        function applyOpcodeFilters() {
            const f = getOpcodeFilters();
            renderOpcodes(f.search, f.group, f.cycles, f.sort);
        }

        document.getElementById('opcodeSearch').addEventListener('input', applyOpcodeFilters);
        document.getElementById('opcodeGroup').addEventListener('change', applyOpcodeFilters);
        document.getElementById('opcodeCycles').addEventListener('change', applyOpcodeFilters);
        document.getElementById('opcodeSort').addEventListener('change', applyOpcodeFilters);

        // Initial render
        renderOpcodes();

        // ========== Graphics Viewer ==========
        const gfxDumpCanvas = document.getElementById('gfxDumpCanvas');
        const gfxDumpCtx = gfxDumpCanvas.getContext('2d');
        const gfxDumpWrap = document.querySelector('.graphics-dump-wrap');
        const gfxPreviewCanvas = document.getElementById('gfxPreviewCanvas');
        const gfxPreviewCtx = gfxPreviewCanvas.getContext('2d');
        const gfxAddress = document.getElementById('gfxAddress');
        const gfxWidth = document.getElementById('gfxWidth');
        const gfxHeight = document.getElementById('gfxHeight');
        const gfxGrid = document.getElementById('gfxGrid');
        const gfxInvert = document.getElementById('gfxInvert');
        const gfxCharMode = document.getElementById('gfxCharMode');
        const gfxInfo = document.getElementById('gfxInfo');

        // Graphics viewer state
        let gfxSpriteAddress = 0x3000; // Current sprite/view address
        const GFX_DUMP_COLS = 32;  // Bytes per row in dump view
        const GFX_DUMP_ROWS = 302;  // Rows visible

        function getGfxParams() {
            const widthBytes = Math.max(1, Math.min(32, parseInt(gfxWidth.value) || 1));
            const heightRows = Math.max(1, Math.min(64, parseInt(gfxHeight.value) || 8));
            const invert = gfxInvert.checked;
            const showGrid = gfxGrid.checked;
            const charMode = gfxCharMode.checked;
            const widthPx = widthBytes * 8;
            const bytesPerSprite = widthBytes * heightRows;
            return { widthBytes, heightRows, widthPx, bytesPerSprite, invert, showGrid, charMode };
        }

        function renderGfxDump() {
            if (!spectrum) return;

            const params = getGfxParams();
            const zoom = document.getElementById('gfxZoom3').checked ? 3 :
                         document.getElementById('gfxZoom2').checked ? 2 : 1;
            const canvasWidth = params.widthBytes * 8 * zoom;
            const canvasHeight = GFX_DUMP_ROWS * zoom;
            const anchorRow = 8;  // Selection anchored at row 8 (row 1 in 8-row terms)

            // Calculate view start so selected address appears at row 8, column 0
            // In both modes: 8 rows of context = widthBytes * 8 bytes
            const viewStartAddr = (gfxSpriteAddress - params.widthBytes * 8) & 0xffff;

            gfxDumpCanvas.width = canvasWidth;
            gfxDumpCanvas.height = canvasHeight;
            gfxDumpWrap.style.height = canvasHeight + 'px';

            // Clear with gray background
            gfxDumpCtx.fillStyle = '#808080';
            gfxDumpCtx.fillRect(0, 0, canvasWidth, canvasHeight);

            // Region colors for graphics
            const GFX_REGION_COLORS = {
                code: '#4080ff', smc: '#ff4040', db: '#ffcc00', dw: '#ff8800',
                text: '#40cc40', graphics: '#cc40cc', default: '#00cc00'
            };

            // Render sprite width bytes as graphics (canvas width stays at 256px)
            for (let row = 0; row < GFX_DUMP_ROWS; row++) {
                for (let col = 0; col < params.widthBytes; col++) {
                    let addr;
                    if (params.charMode) {
                        // Character-based: 8x8 cells stored sequentially
                        const charRow = Math.floor(row / 8);
                        const lineInChar = row % 8;
                        addr = (viewStartAddr + (charRow * params.widthBytes + col) * 8 + lineInChar) & 0xffff;
                    } else {
                        // Linear: row by row
                        addr = (viewStartAddr + row * params.widthBytes + col) & 0xffff;
                    }
                    const byte = spectrum.memory.read(addr);
                    const x = col * 8 * zoom;
                    const y = row * zoom;

                    // Get region color for this address
                    const region = regionManager.get(addr);
                    const hasRegion = region && GFX_REGION_COLORS[region.type];
                    let pixelColor = hasRegion ? GFX_REGION_COLORS[region.type] : GFX_REGION_COLORS.default;
                    // Zero bits: black if unmarked, dark gray if marked
                    const zeroBitColor = hasRegion ? '#333333' : '#000000';
                    // Invert mode swaps fg/bg
                    const actualBg = params.invert ? pixelColor : zeroBitColor;
                    const actualFg = params.invert ? zeroBitColor : pixelColor;

                    // Draw background for this byte
                    gfxDumpCtx.fillStyle = actualBg;
                    gfxDumpCtx.fillRect(x, y, 8 * zoom, zoom);

                    // Draw foreground pixels with region color
                    gfxDumpCtx.fillStyle = actualFg;
                    for (let bit = 0; bit < 8; bit++) {
                        if ((byte >> (7 - bit)) & 1) {
                            gfxDumpCtx.fillRect(x + bit * zoom, y, zoom, zoom);
                        }
                    }
                }
            }

            // Draw red rectangle at fixed anchor position (column 0, row 8)
            const rectX = 0;
            const rectY = anchorRow * zoom;
            const rectW = params.widthBytes * 8 * zoom;
            const rectH = params.heightRows * zoom;

            gfxDumpCtx.strokeStyle = '#ff0000';
            gfxDumpCtx.lineWidth = 2;
            gfxDumpCtx.strokeRect(rectX + 1, rectY + 1, rectW - 2, rectH - 2);

            // Draw grid lines between bytes if enabled (vertical and horizontal)
            if (params.showGrid) {
                gfxDumpCtx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                gfxDumpCtx.lineWidth = 1;
                const spriteWidthPx = params.widthBytes * 8 * zoom;
                // Vertical lines
                for (let col = 0; col <= params.widthBytes; col++) {
                    const x = col * 8 * zoom;
                    gfxDumpCtx.beginPath();
                    gfxDumpCtx.moveTo(x + 0.5, 0);
                    gfxDumpCtx.lineTo(x + 0.5, canvasHeight);
                    gfxDumpCtx.stroke();
                }
                // Horizontal lines every 8 rows
                for (let row = 0; row <= GFX_DUMP_ROWS; row += 8) {
                    const y = row * zoom;
                    gfxDumpCtx.beginPath();
                    gfxDumpCtx.moveTo(0, y + 0.5);
                    gfxDumpCtx.lineTo(spriteWidthPx, y + 0.5);
                    gfxDumpCtx.stroke();
                }
            }
        }

        function renderGfxPreview() {
            if (!spectrum) return;

            const params = getGfxParams();
            const previewZoom = 2;  // Fixed zoom for small preview
            // No context rows - sprite starts at row 0
            const totalRows = params.heightRows;
            const canvasW = params.widthPx * previewZoom;
            const canvasH = totalRows * previewZoom;

            gfxPreviewCanvas.width = canvasW;
            gfxPreviewCanvas.height = canvasH;

            // Region colors for graphics
            const GFX_REGION_COLORS = {
                code: '#4080ff', smc: '#ff4040', db: '#ffcc00', dw: '#ff8800',
                text: '#40cc40', graphics: '#cc40cc', default: '#00cc00'
            };

            // Fill with black background
            gfxPreviewCtx.fillStyle = '#000000';
            gfxPreviewCtx.fillRect(0, 0, canvasW, canvasH);

            for (let row = 0; row < totalRows; row++) {
                for (let byteX = 0; byteX < params.widthBytes; byteX++) {
                    let addr;
                    if (params.charMode) {
                        // Character-based: 8x8 cells stored sequentially
                        const charRow = Math.floor(row / 8);
                        const lineInChar = row % 8;
                        addr = (gfxSpriteAddress + (charRow * params.widthBytes + byteX) * 8 + lineInChar) & 0xffff;
                    } else {
                        // Linear: row by row, starting from gfxSpriteAddress
                        addr = (gfxSpriteAddress + row * params.widthBytes + byteX) & 0xffff;
                    }
                    const byte = spectrum.memory.read(addr);

                    // Get region color for this address
                    const region = regionManager.get(addr);
                    const hasRegion = region && GFX_REGION_COLORS[region.type];
                    let pixelColor = hasRegion ? GFX_REGION_COLORS[region.type] : GFX_REGION_COLORS.default;
                    // Zero bits: black if unmarked, dark gray if marked
                    const zeroBitColor = hasRegion ? '#333333' : '#000000';
                    // Invert mode swaps fg/bg
                    const fgColor = params.invert ? zeroBitColor : pixelColor;
                    const bgColor = params.invert ? pixelColor : zeroBitColor;

                    // Draw background for this byte
                    gfxPreviewCtx.fillStyle = bgColor;
                    gfxPreviewCtx.fillRect(byteX * 8 * previewZoom, row * previewZoom, 8 * previewZoom, previewZoom);

                    // Draw foreground pixels
                    gfxPreviewCtx.fillStyle = fgColor;
                    for (let bit = 0; bit < 8; bit++) {
                        if ((byte >> (7 - bit)) & 1) {
                            const px = byteX * 8 + bit;
                            gfxPreviewCtx.fillRect(px * previewZoom, row * previewZoom, previewZoom, previewZoom);
                        }
                    }
                }
            }

            // Draw red rectangle around entire sprite
            gfxPreviewCtx.strokeStyle = '#ff0000';
            gfxPreviewCtx.lineWidth = 2;
            gfxPreviewCtx.strokeRect(1, 1, canvasW - 2, canvasH - 2);

            // Draw grid overlay if enabled
            if (params.showGrid) {
                gfxPreviewCtx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                gfxPreviewCtx.lineWidth = 1;
                // Vertical lines every 8 pixels
                for (let x = 8; x < params.widthPx; x += 8) {
                    gfxPreviewCtx.beginPath();
                    gfxPreviewCtx.moveTo(x * previewZoom + 0.5, 0);
                    gfxPreviewCtx.lineTo(x * previewZoom + 0.5, canvasH);
                    gfxPreviewCtx.stroke();
                }
                // Horizontal lines every 8 rows
                for (let y = 8; y <= totalRows; y += 8) {
                    gfxPreviewCtx.beginPath();
                    gfxPreviewCtx.moveTo(0, y * previewZoom + 0.5);
                    gfxPreviewCtx.lineTo(canvasW, y * previewZoom + 0.5);
                    gfxPreviewCtx.stroke();
                }
            }

            // Update info
            const addrHex = gfxSpriteAddress.toString(16).toUpperCase().padStart(4, '0');
            gfxInfo.textContent = `${addrHex}h: ${params.widthPx}x${params.heightRows}`;
        }

        function updateGfxSpinnerButtons() {
            const width = parseInt(gfxWidth.value) || 1;
            const height = parseInt(gfxHeight.value) || 8;
            // Width buttons
            document.getElementById('btnGfxWidthMin').disabled = width <= 1;
            document.getElementById('btnGfxWidthDec').disabled = width <= 1;
            document.getElementById('btnGfxWidthInc').disabled = width >= 32;
            document.getElementById('btnGfxWidthMax').disabled = width >= 32;
            // Height buttons
            document.getElementById('btnGfxHeightDec8').disabled = height <= 8;
            document.getElementById('btnGfxHeightDec').disabled = height <= 1;
            document.getElementById('btnGfxHeightInc').disabled = height >= 64;
            document.getElementById('btnGfxHeightInc8').disabled = height >= 64;
        }

        function updateGraphicsViewer() {
            renderGfxDump();
            renderGfxPreview();
            updateGfxSpinnerButtons();
        }

        function gfxNavigate(delta) {
            gfxSpriteAddress = (gfxSpriteAddress + delta) & 0xffff;
            gfxAddress.value = gfxSpriteAddress.toString(16).toUpperCase().padStart(4, '0');
            updateGraphicsViewer();
        }

        // Navigation buttons (different behavior in char mode vs linear mode)
        document.getElementById('btnGfxByte1').addEventListener('click', () => {
            const params = getGfxParams();
            // Char mode: move by sprite height (next/prev char column); Linear: move by 1 byte
            gfxNavigate(params.charMode ? -params.heightRows : -1);
        });
        document.getElementById('btnGfxByte2').addEventListener('click', () => {
            const params = getGfxParams();
            gfxNavigate(params.charMode ? params.heightRows : 1);
        });
        document.getElementById('btnGfxLine1').addEventListener('click', () => {
            const params = getGfxParams();
            // Char mode: move by 1 byte; Linear: move by width bytes
            gfxNavigate(params.charMode ? -1 : -params.widthBytes);
        });
        document.getElementById('btnGfxLine2').addEventListener('click', () => {
            const params = getGfxParams();
            gfxNavigate(params.charMode ? 1 : params.widthBytes);
        });
        document.getElementById('btnGfxRow1').addEventListener('click', () => {
            const params = getGfxParams();
            // Move by one character row (width * 8 bytes)
            gfxNavigate(-params.widthBytes * 8);
        });
        document.getElementById('btnGfxRow2').addEventListener('click', () => {
            const params = getGfxParams();
            gfxNavigate(params.widthBytes * 8);
        });
        document.getElementById('btnGfxSprite1').addEventListener('click', () => {
            const params = getGfxParams();
            gfxNavigate(-params.bytesPerSprite);
        });
        document.getElementById('btnGfxSprite2').addEventListener('click', () => {
            const params = getGfxParams();
            gfxNavigate(params.bytesPerSprite);
        });
        document.getElementById('btnGfxPage1').addEventListener('click', () => {
            const params = getGfxParams();
            gfxNavigate(-params.widthBytes * 8 * 24);
        });
        document.getElementById('btnGfxPage2').addEventListener('click', () => {
            const params = getGfxParams();
            gfxNavigate(params.widthBytes * 8 * 24);
        });

        // Width/Height spinners
        document.getElementById('btnGfxWidthMin').addEventListener('click', () => {
            gfxWidth.value = 1;
            updateGraphicsViewer();
        });
        document.getElementById('btnGfxWidthDec').addEventListener('click', () => {
            const val = Math.max(1, (parseInt(gfxWidth.value) || 1) - 1);
            gfxWidth.value = val;
            updateGraphicsViewer();
        });
        document.getElementById('btnGfxWidthInc').addEventListener('click', () => {
            const val = Math.min(32, (parseInt(gfxWidth.value) || 1) + 1);
            gfxWidth.value = val;
            updateGraphicsViewer();
        });
        document.getElementById('btnGfxWidthMax').addEventListener('click', () => {
            gfxWidth.value = 32;
            updateGraphicsViewer();
        });
        document.getElementById('btnGfxHeightDec8').addEventListener('click', () => {
            const current = parseInt(gfxHeight.value) || 8;
            const remainder = current % 8;
            const val = remainder === 0 ? Math.max(8, current - 8) : Math.max(8, current - remainder);
            gfxHeight.value = val;
            updateGraphicsViewer();
        });
        document.getElementById('btnGfxHeightDec').addEventListener('click', () => {
            const val = Math.max(1, (parseInt(gfxHeight.value) || 8) - 1);
            gfxHeight.value = val;
            updateGraphicsViewer();
        });
        document.getElementById('btnGfxHeightInc').addEventListener('click', () => {
            const val = Math.min(64, (parseInt(gfxHeight.value) || 8) + 1);
            gfxHeight.value = val;
            updateGraphicsViewer();
        });
        document.getElementById('btnGfxHeightInc8').addEventListener('click', () => {
            const current = parseInt(gfxHeight.value) || 8;
            const remainder = current % 8;
            const val = remainder === 0 ? Math.min(64, current + 8) : Math.min(64, current + (8 - remainder));
            gfxHeight.value = val;
            updateGraphicsViewer();
        });

        // Address input
        gfxAddress.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                gfxSpriteAddress = parseInt(gfxAddress.value, 16) || 0;
                gfxViewAddress = gfxSpriteAddress;
                updateGraphicsViewer();
            }
        });

        gfxWidth.addEventListener('change', updateGraphicsViewer);
        gfxHeight.addEventListener('change', updateGraphicsViewer);
        gfxGrid.addEventListener('change', updateGraphicsViewer);
        gfxInvert.addEventListener('change', updateGraphicsViewer);
        gfxCharMode.addEventListener('change', updateGraphicsViewer);
        document.getElementById('gfxZoom1').addEventListener('change', updateGraphicsViewer);
        document.getElementById('gfxZoom2').addEventListener('change', updateGraphicsViewer);
        document.getElementById('gfxZoom3').addEventListener('change', updateGraphicsViewer);

        // Scroll dump view (char mode: 1 byte per scroll; linear: widthBytes per scroll)
        document.querySelector('.graphics-dump-wrap').addEventListener('wheel', (e) => {
            e.preventDefault();
            const params = getGfxParams();
            const step = params.charMode ? 1 : params.widthBytes;
            const delta = e.deltaY > 0 ? step : -step;
            gfxSpriteAddress = (gfxSpriteAddress + delta) & 0xffff;
            gfxAddress.value = gfxSpriteAddress.toString(16).toUpperCase().padStart(4, '0');
            updateGraphicsViewer();
        }, { passive: false });

        // Tooltip for gfx dump
        const gfxTooltip = document.createElement('div');
        gfxTooltip.style.cssText = 'position:fixed;background:rgba(0,0,0,0.9);color:#fff;padding:4px 8px;border-radius:4px;font-size:12px;font-family:monospace;pointer-events:none;z-index:1000;display:none';
        document.body.appendChild(gfxTooltip);
        let gfxTooltipTimeout = null;

        // Click on dump to show address popup near cursor
        gfxDumpCanvas.addEventListener('click', (e) => {
            const params = getGfxParams();
            const zoom = document.getElementById('gfxZoom3').checked ? 3 :
                         document.getElementById('gfxZoom2').checked ? 2 : 1;
            const rect = gfxDumpCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Calculate byte position
            const col = Math.floor(x / (8 * zoom));
            const row = Math.floor(y / zoom);

            if (col >= params.widthBytes) return;

            // Calculate view start (same as in renderGfxDump)
            const anchorRow = 8;
            const viewStartAddr = (gfxSpriteAddress - params.widthBytes * anchorRow) & 0xffff;

            // Calculate address for clicked position
            let addr;
            if (params.charMode) {
                const charRow = Math.floor(row / 8);
                const lineInChar = row % 8;
                addr = (viewStartAddr + (charRow * params.widthBytes + col) * 8 + lineInChar) & 0xffff;
            } else {
                addr = (viewStartAddr + row * params.widthBytes + col) & 0xffff;
            }

            // Format address based on machine type
            let addrStr;
            if (spectrum.memory.machineType === '48k') {
                addrStr = addr.toString(16).toUpperCase().padStart(4, '0') + 'h';
            } else {
                // 128K: show page:address
                let page;
                if (addr < 0x4000) page = 'ROM' + spectrum.memory.currentRomBank;
                else if (addr < 0x8000) page = '5';
                else if (addr < 0xC000) page = '2';
                else page = spectrum.memory.currentRamBank.toString();
                const offset = addr & 0x3FFF;
                addrStr = page + ':' + offset.toString(16).toUpperCase().padStart(4, '0') + 'h';
            }

            // Show tooltip near cursor
            gfxTooltip.textContent = addrStr;
            gfxTooltip.style.left = (e.clientX + 10) + 'px';
            gfxTooltip.style.top = (e.clientY - 25) + 'px';
            gfxTooltip.style.display = 'block';

            // Hide after 2 seconds
            if (gfxTooltipTimeout) clearTimeout(gfxTooltipTimeout);
            gfxTooltipTimeout = setTimeout(() => {
                gfxTooltip.style.display = 'none';
            }, 2000);
        });

        // Action buttons
        document.getElementById('btnGfxGoDisasm').addEventListener('click', () => {
            document.querySelector('[data-tab="debugger"]').click();
            setTimeout(() => {
                goToAddress(gfxSpriteAddress);
                updateDebugger();
            }, 100);
        });

        document.getElementById('btnGfxGoMem').addEventListener('click', () => {
            document.querySelector('[data-tab="debugger"]').click();
            setTimeout(() => {
                goToMemoryAddress(gfxSpriteAddress);
            }, 100);
        });

        document.getElementById('btnGfxMarkRegion').addEventListener('click', () => {
            const params = getGfxParams();
            const endAddr = (gfxSpriteAddress + params.bytesPerSprite - 1) & 0xffff;
            const userComment = document.getElementById('gfxComment').value.trim();
            const comment = userComment || `Sprite ${params.widthPx}x${params.heightRows}`;

            const result = regionManager.add({
                start: gfxSpriteAddress,
                end: endAddr,
                type: REGION_TYPES.GRAPHICS,
                comment: comment,
                width: params.widthBytes,
                height: params.heightRows,
                charMode: params.charMode
            });

            if (result.error === 'overlap') {
                const r = result.regions[0];
                const existingRange = `${r.start.toString(16).toUpperCase()}-${r.end.toString(16).toUpperCase()}`;
                const existingType = r.type.toUpperCase();
                showMessage(`Overlap with existing ${existingType} region at ${existingRange}. Remove it first.`);
                return;
            }

            showMessage(`Marked ${gfxSpriteAddress.toString(16).toUpperCase()}-${endAddr.toString(16).toUpperCase()} as Graphics`);
            // Immediately update graphics preview to show region colors
            renderGfxDump();
            renderGfxPreview();
        });

        // Generate sprite as assembler DB statements
        function generateSpriteAsm() {
            const params = getGfxParams();
            const userComment = document.getElementById('gfxComment').value.trim();
            const lines = [];

            // Header comment
            const addrHex = gfxSpriteAddress.toString(16).toUpperCase().padStart(4, '0');
            if (userComment) {
                lines.push(`; ${userComment}`);
            }
            const charNote = params.charMode ? ', char-based' : '';
            lines.push(`; ${addrHex}h: ${params.widthPx}x${params.heightRows} (${params.bytesPerSprite} bytes${charNote})`);

            if (params.charMode) {
                // For char-based: first show visual preview, then output bytes in memory order
                lines.push(';');
                lines.push('; Visual:');

                // Generate visual preview (screen order)
                for (let row = 0; row < params.heightRows; row++) {
                    let visualLine = ';   ';
                    for (let col = 0; col < params.widthBytes; col++) {
                        const charRow = Math.floor(row / 8);
                        const lineInChar = row % 8;
                        const addr = (gfxSpriteAddress + (charRow * params.widthBytes + col) * 8 + lineInChar) & 0xffff;
                        const byte = spectrum.memory.read(addr);
                        for (let bit = 7; bit >= 0; bit--) {
                            visualLine += (byte >> bit) & 1 ? '█' : '·';
                        }
                    }
                    lines.push(visualLine);
                }
                lines.push('');

                // Output bytes in memory order (character by character)
                const charsWide = params.widthBytes;
                const charsTall = Math.ceil(params.heightRows / 8);

                for (let charY = 0; charY < charsTall; charY++) {
                    for (let charX = 0; charX < charsWide; charX++) {
                        const charIndex = charY * charsWide + charX;
                        const charBaseAddr = gfxSpriteAddress + charIndex * 8;

                        lines.push(`; Char ${charX},${charY}`);

                        const rowBytes = [];
                        for (let line = 0; line < 8; line++) {
                            const addr = (charBaseAddr + line) & 0xffff;
                            const byte = spectrum.memory.read(addr);
                            rowBytes.push('$' + byte.toString(16).toUpperCase().padStart(2, '0'));
                        }
                        lines.push('        db ' + rowBytes.join(', '));
                    }
                }
            } else {
                // Linear mode: output row by row with visual comments
                lines.push('');

                for (let row = 0; row < params.heightRows; row++) {
                    const rowBytes = [];
                    const visualParts = [];

                    for (let col = 0; col < params.widthBytes; col++) {
                        const addr = (gfxSpriteAddress + row * params.widthBytes + col) & 0xffff;
                        const byte = spectrum.memory.read(addr);
                        rowBytes.push('$' + byte.toString(16).toUpperCase().padStart(2, '0'));

                        // Create visual binary: █ for 1, · for 0
                        let visual = '';
                        for (let bit = 7; bit >= 0; bit--) {
                            visual += (byte >> bit) & 1 ? '█' : '·';
                        }
                        visualParts.push(visual);
                    }

                    const dbLine = '        db ' + rowBytes.join(', ');
                    const visualComment = ' ; ' + visualParts.join(' ');
                    lines.push(dbLine + visualComment);
                }
            }

            return lines.join('\n');
        }

        // Copy ASM to clipboard
        document.getElementById('btnGfxCopyAsm').addEventListener('click', () => {
            const text = generateSpriteAsm();
            navigator.clipboard.writeText(text).then(() => {
                showMessage('Copied to clipboard');
            }).catch(() => {
                alert(text);
            });
        });

        // Save ASM to file
        document.getElementById('btnGfxSaveAsm').addEventListener('click', () => {
            const text = generateSpriteAsm();
            const userComment = document.getElementById('gfxComment').value.trim();
            const addrHex = gfxSpriteAddress.toString(16).toUpperCase().padStart(4, '0');

            // Generate filename
            let filename;
            if (userComment) {
                filename = userComment.replace(/[^a-zA-Z0-9_-]/g, '_') + '.asm';
            } else {
                filename = 'sprite_' + addrHex + '.asm';
            }

            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
            showMessage('Saved ' + filename);
        });

        // Generate ASM for a specific graphics region
        function generateRegionSpriteAsm(region) {
            const lines = [];
            const addrHex = region.start.toString(16).toUpperCase().padStart(4, '0');
            const widthBytes = region.width || 1;
            const totalBytes = region.end - region.start + 1;
            const heightRows = region.height || Math.ceil(totalBytes / widthBytes);
            const widthPx = widthBytes * 8;
            const charMode = region.charMode || false;

            // Helper to read byte from region (handles 128K banks)
            function readByte(addr) {
                addr = addr & 0xffff;
                if (region.page !== null && region.page !== undefined && spectrum.memory.machineType !== '48k') {
                    if (region.page === 5 && addr >= 0x4000 && addr < 0x8000) {
                        return spectrum.memory.ram[5][addr - 0x4000];
                    } else if (region.page === 2 && addr >= 0x8000 && addr < 0xC000) {
                        return spectrum.memory.ram[2][addr - 0x8000];
                    } else if (addr >= 0xC000) {
                        return spectrum.memory.ram[region.page][addr - 0xC000];
                    }
                }
                return spectrum.memory.read(addr);
            }

            // Header comment
            if (region.comment) {
                lines.push(`; ${region.comment}`);
            }
            const charNote = charMode ? ', char-based' : '';
            lines.push(`; ${addrHex}h: ${widthPx}x${heightRows} (${totalBytes} bytes${charNote})`);
            if (region.page !== null && region.page !== undefined) {
                lines.push(`; Bank ${region.page}`);
            }

            if (charMode) {
                // For char-based: first show visual preview, then output bytes in memory order
                lines.push(';');
                lines.push('; Visual:');

                // Generate visual preview (screen order)
                for (let row = 0; row < heightRows; row++) {
                    let visualLine = ';   ';
                    for (let col = 0; col < widthBytes; col++) {
                        const charRow = Math.floor(row / 8);
                        const lineInChar = row % 8;
                        const addr = region.start + (charRow * widthBytes + col) * 8 + lineInChar;
                        const byte = readByte(addr);
                        for (let bit = 7; bit >= 0; bit--) {
                            visualLine += (byte >> bit) & 1 ? '█' : '·';
                        }
                    }
                    lines.push(visualLine);
                }
                lines.push('');

                // Output bytes in memory order (character by character)
                const charsWide = widthBytes;
                const charsTall = Math.ceil(heightRows / 8);

                for (let charY = 0; charY < charsTall; charY++) {
                    for (let charX = 0; charX < charsWide; charX++) {
                        const charIndex = charY * charsWide + charX;
                        const charBaseAddr = region.start + charIndex * 8;

                        lines.push(`; Char ${charX},${charY}`);

                        const rowBytes = [];
                        for (let line = 0; line < 8; line++) {
                            const byte = readByte(charBaseAddr + line);
                            rowBytes.push('$' + byte.toString(16).toUpperCase().padStart(2, '0'));
                        }
                        lines.push('        db ' + rowBytes.join(', '));
                    }
                }
            } else {
                // Linear mode: output row by row with visual comments
                lines.push('');

                for (let row = 0; row < heightRows; row++) {
                    const rowBytes = [];
                    const visualParts = [];

                    for (let col = 0; col < widthBytes; col++) {
                        const offset = row * widthBytes + col;
                        if (offset >= totalBytes) break;

                        const byte = readByte(region.start + offset);
                        rowBytes.push('$' + byte.toString(16).toUpperCase().padStart(2, '0'));

                        // Create visual binary: █ for 1, · for 0
                        let visual = '';
                        for (let bit = 7; bit >= 0; bit--) {
                            visual += (byte >> bit) & 1 ? '█' : '·';
                        }
                        visualParts.push(visual);
                    }

                    if (rowBytes.length > 0) {
                        const dbLine = '        db ' + rowBytes.join(', ');
                        const visualComment = ' ; ' + visualParts.join(' ');
                        lines.push(dbLine + visualComment);
                    }
                }
            }

            return lines.join('\n');
        }

        // Export All Sprites - finds all graphics regions and exports them
        document.getElementById('btnGfxExportAll').addEventListener('click', () => {
            const graphicsRegions = regionManager.getAll().filter(r => r.type === REGION_TYPES.GRAPHICS);

            if (graphicsRegions.length === 0) {
                showMessage('No graphics regions marked. Use "Mark Region" to mark sprites first.');
                return;
            }

            // Sort by address
            graphicsRegions.sort((a, b) => {
                if (a.page !== b.page) return (a.page || 0) - (b.page || 0);
                return a.start - b.start;
            });

            const allLines = [
                '; ================================================',
                '; Exported Sprites',
                '; ' + graphicsRegions.length + ' graphics regions',
                '; ================================================',
                ''
            ];

            for (const region of graphicsRegions) {
                allLines.push(generateRegionSpriteAsm(region));
                allLines.push('');
            }

            const text = allLines.join('\n');
            const filename = 'sprites_export.asm';

            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
            showMessage(`Exported ${graphicsRegions.length} sprites to ${filename}`);
        });

        // Verify modules
        if (typeof Z80 === 'undefined' || typeof Memory === 'undefined' ||
            typeof ULA === 'undefined' || typeof Spectrum === 'undefined') {
            alert('Failed to load emulator modules.');
            throw new Error('Missing modules');
        }

        // ========== Label Manager ==========
        class LabelManager {
            constructor() {
                this.labels = new Map();  // key = "page:address", value = label object
                this.romLabels = new Map(); // ROM labels loaded from file
                this.showRomLabels = true;
                this.currentFile = null;
                this.autoSaveEnabled = true;
            }

            // Generate key for label lookup
            _key(address, page = null) {
                const pageStr = page === null ? 'g' : page.toString();
                return `${pageStr}:${address.toString(16).padStart(4, '0')}`;
            }

            // Add or update a label
            add(label) {
                const key = this._key(label.address, label.page);
                const entry = {
                    address: label.address & 0xffff,
                    page: label.page ?? null,
                    name: label.name || '',
                    comment: label.comment || '',
                    size: label.size || 1
                };
                this.labels.set(key, entry);
                if (this.autoSaveEnabled) this._autoSave();
                return entry;
            }

            // Remove a label
            remove(address, page = null) {
                const key = this._key(address, page);
                const existed = this.labels.delete(key);
                if (existed && this.autoSaveEnabled) this._autoSave();
                return existed;
            }

            // Get label at exact address and page
            get(address, page = null) {
                // First try user labels (exact page match)
                let label = this.labels.get(this._key(address, page));
                if (label) return label;
                // Fall back to global user label
                if (page !== null) {
                    label = this.labels.get(this._key(address, null));
                    if (label) return label;
                }
                // Fall back to ROM labels if enabled
                if (this.showRomLabels) {
                    label = this.romLabels.get(this._key(address, page));
                    if (label) return label;
                    if (page !== null) {
                        label = this.romLabels.get(this._key(address, null));
                    }
                }
                return label || null;
            }

            // Find label by name
            findByName(name) {
                const nameLower = name.toLowerCase();
                for (const label of this.labels.values()) {
                    if (label.name.toLowerCase() === nameLower) return label;
                }
                return null;
            }

            // Get all labels, optionally filtered by page
            getAll(pageFilter = undefined) {
                const result = [];
                for (const label of this.labels.values()) {
                    if (pageFilter === undefined || label.page === pageFilter || label.page === null) {
                        result.push(label);
                    }
                }
                return result.sort((a, b) => a.address - b.address);
            }

            // Clear all labels
            clear() {
                this.labels.clear();
                if (this.autoSaveEnabled) this._autoSave();
            }

            // Set current file (for auto-save key)
            setCurrentFile(filename) {
                this.currentFile = filename;
                this._autoLoad();
            }

            // Get storage key for current file
            _storageKey() {
                if (!this.currentFile) return null;
                return `zx_labels_${this.currentFile.toLowerCase()}`;
            }

            // Auto-save to localStorage
            _autoSave() {
                const key = this._storageKey();
                if (!key) return;
                const data = JSON.stringify(Array.from(this.labels.values()));
                try {
                    localStorage.setItem(key, data);
                } catch (e) {
                    console.warn('Failed to save labels:', e);
                }
            }

            // Auto-load from localStorage
            _autoLoad() {
                this.labels.clear();
                const key = this._storageKey();
                if (!key) return;
                try {
                    const data = localStorage.getItem(key);
                    if (data) {
                        const arr = JSON.parse(data);
                        for (const label of arr) {
                            this.labels.set(this._key(label.address, label.page), label);
                        }
                    }
                } catch (e) {
                    console.warn('Failed to load labels:', e);
                }
            }

            // Export labels to JSON string
            exportJSON() {
                return JSON.stringify(Array.from(this.labels.values()), null, 2);
            }

            // Import labels from JSON string
            importJSON(jsonStr, merge = false) {
                try {
                    const arr = JSON.parse(jsonStr);
                    if (!merge) this.labels.clear();
                    for (const label of arr) {
                        this.labels.set(this._key(label.address, label.page), label);
                    }
                    if (this.autoSaveEnabled) this._autoSave();
                    return arr.length;
                } catch (e) {
                    console.error('Failed to import labels:', e);
                    return -1;
                }
            }

            // Load ROM labels from JSON string
            loadRomLabels(jsonStr) {
                try {
                    const arr = JSON.parse(jsonStr);
                    this.romLabels.clear();
                    for (const label of arr) {
                        const entry = {
                            address: label.address & 0xffff,
                            page: label.page ?? null,
                            name: label.name || '',
                            comment: label.comment || '',
                            size: label.size || 1,
                            isRom: true
                        };
                        this.romLabels.set(this._key(entry.address, entry.page), entry);
                    }
                    return arr.length;
                } catch (e) {
                    console.error('Failed to load ROM labels:', e);
                    return -1;
                }
            }

            // Get count of ROM labels
            getRomLabelCount() {
                return this.romLabels.size;
            }
        }

        // Memory region types for marking code/data/etc
        const REGION_TYPES = {
            CODE: 'code',
            DB: 'db',       // Data bytes
            DW: 'dw',       // Data words (16-bit)
            TEXT: 'text',   // Text strings
            GRAPHICS: 'graphics',
            SMC: 'smc'      // Self-modifying code
        };

        class RegionManager {
            constructor() {
                this.regions = [];  // Array of {start, end, type, page, comment}
                this.currentFile = null;
                this.autoSaveEnabled = true;
            }

            // Check if a range overlaps with existing regions
            getOverlapping(start, end, page = null) {
                start = start & 0xffff;
                end = end & 0xffff;
                return this.regions.filter(r => {
                    if (r.page !== page && r.page !== null && page !== null) return false;
                    // Check for overlap
                    return !(r.end < start || r.start > end);
                });
            }

            // Add or update a region
            add(region, allowOverwrite = false) {
                const entry = {
                    start: region.start & 0xffff,
                    end: region.end & 0xffff,
                    type: region.type || REGION_TYPES.CODE,
                    page: region.page ?? null,
                    comment: region.comment || ''
                };
                // Store width/height/charMode for graphics regions
                if (region.width) entry.width = region.width;
                if (region.height) entry.height = region.height;
                if (region.charMode) entry.charMode = region.charMode;

                // Check for overlapping regions
                const overlapping = this.getOverlapping(entry.start, entry.end, entry.page);
                if (overlapping.length > 0 && !allowOverwrite) {
                    return { error: 'overlap', regions: overlapping };
                }

                // Remove overlapping regions if overwrite allowed
                if (allowOverwrite) {
                    this.regions = this.regions.filter(r => {
                        if (r.page !== entry.page && r.page !== null && entry.page !== null) return true;
                        return r.end < entry.start || r.start > entry.end;
                    });
                }

                this.regions.push(entry);
                this.regions.sort((a, b) => a.start - b.start);
                if (this.autoSaveEnabled) this._autoSave();
                return entry;
            }

            // Remove region containing address
            remove(address, page = null) {
                const before = this.regions.length;
                this.regions = this.regions.filter(r => {
                    if (r.page !== page && r.page !== null && page !== null) return true;
                    return !(address >= r.start && address <= r.end);
                });
                if (this.regions.length !== before && this.autoSaveEnabled) {
                    this._autoSave();
                }
                return this.regions.length !== before;
            }

            // Get region at address
            get(address, page = null) {
                for (const r of this.regions) {
                    if ((r.page === page || r.page === null) &&
                        address >= r.start && address <= r.end) {
                        return r;
                    }
                }
                return null;
            }

            // Get region type at address (for quick checks)
            getType(address, page = null) {
                const region = this.get(address, page);
                return region ? region.type : REGION_TYPES.CODE;
            }

            // Check if address is in a non-code region
            isData(address, page = null) {
                const type = this.getType(address, page);
                return type !== REGION_TYPES.CODE && type !== REGION_TYPES.SMC;
            }

            // Get all regions
            getAll(pageFilter = undefined) {
                if (pageFilter === undefined) return [...this.regions];
                return this.regions.filter(r => r.page === pageFilter || r.page === null);
            }

            // Clear all regions
            clear() {
                this.regions = [];
                if (this.autoSaveEnabled) this._autoSave();
            }

            // Set current file (for auto-save key)
            setCurrentFile(filename) {
                this.currentFile = filename;
                this._autoLoad();
            }

            // Get storage key for current file
            _storageKey() {
                if (!this.currentFile) return null;
                return `zx_regions_${this.currentFile.toLowerCase()}`;
            }

            // Auto-save to localStorage
            _autoSave() {
                const key = this._storageKey();
                if (!key) return;
                try {
                    localStorage.setItem(key, JSON.stringify(this.regions));
                } catch (e) {
                    console.warn('Failed to save regions:', e);
                }
            }

            // Auto-load from localStorage
            _autoLoad() {
                this.regions = [];
                const key = this._storageKey();
                if (!key) return;
                try {
                    const data = localStorage.getItem(key);
                    if (data) {
                        this.regions = JSON.parse(data);
                    }
                } catch (e) {
                    console.warn('Failed to load regions:', e);
                }
            }

            // Export to JSON
            exportJSON() {
                return JSON.stringify(this.regions, null, 2);
            }

            // Import from JSON
            importJSON(jsonStr, merge = false) {
                try {
                    const arr = JSON.parse(jsonStr);
                    if (!merge) this.regions = [];
                    for (const r of arr) {
                        this.regions.push(r);
                    }
                    this.regions.sort((a, b) => a.start - b.start);
                    if (this.autoSaveEnabled) this._autoSave();
                    return arr.length;
                } catch (e) {
                    console.error('Failed to import regions:', e);
                    return -1;
                }
            }
        }

        const regionManager = new RegionManager();
        const labelManager = new LabelManager();

        // ========== Comment Manager ==========
        class CommentManager {
            constructor() {
                this.comments = new Map();  // Map<address, {before, inline, after, separator}>
                this.currentFile = null;
                this.autoSaveEnabled = true;
            }

            // Add or update comment at address
            set(address, comment) {
                address = address & 0xffff;
                const existing = this.comments.get(address) || {};
                const entry = {
                    before: comment.before !== undefined ? comment.before : (existing.before || ''),
                    inline: comment.inline !== undefined ? comment.inline : (existing.inline || ''),
                    after: comment.after !== undefined ? comment.after : (existing.after || ''),
                    separator: comment.separator !== undefined ? comment.separator : (existing.separator || false)
                };
                // Remove if all empty
                if (!entry.before && !entry.inline && !entry.after && !entry.separator) {
                    this.comments.delete(address);
                } else {
                    this.comments.set(address, entry);
                }
                if (this.autoSaveEnabled) this._autoSave();
                return entry;
            }

            // Get comment at address
            get(address) {
                return this.comments.get(address & 0xffff) || null;
            }

            // Remove all comments at address
            remove(address) {
                const had = this.comments.has(address & 0xffff);
                this.comments.delete(address & 0xffff);
                if (had && this.autoSaveEnabled) this._autoSave();
                return had;
            }

            // Get all comments as array
            getAll() {
                const result = [];
                for (const [addr, comment] of this.comments) {
                    result.push({ address: addr, ...comment });
                }
                return result.sort((a, b) => a.address - b.address);
            }

            // Clear all comments
            clear() {
                this.comments.clear();
                if (this.autoSaveEnabled) this._autoSave();
            }

            // Set current file for auto-save
            setCurrentFile(filename) {
                this.currentFile = filename;
                this._autoLoad();
            }

            _storageKey() {
                if (!this.currentFile) return null;
                return `zx_comments_${this.currentFile.toLowerCase()}`;
            }

            _autoSave() {
                const key = this._storageKey();
                if (!key) return;
                try {
                    localStorage.setItem(key, JSON.stringify(this.getAll()));
                } catch (e) {
                    console.warn('Failed to save comments:', e);
                }
            }

            _autoLoad() {
                this.comments.clear();
                const key = this._storageKey();
                if (!key) return;
                try {
                    const data = localStorage.getItem(key);
                    if (data) {
                        const arr = JSON.parse(data);
                        for (const c of arr) {
                            this.comments.set(c.address, {
                                before: c.before || '',
                                inline: c.inline || '',
                                after: c.after || '',
                                separator: c.separator || false
                            });
                        }
                    }
                } catch (e) {
                    console.warn('Failed to load comments:', e);
                }
            }

            exportJSON() {
                return JSON.stringify(this.getAll(), null, 2);
            }

            importJSON(jsonStr, merge = false) {
                try {
                    const arr = JSON.parse(jsonStr);
                    if (!merge) this.comments.clear();
                    for (const c of arr) {
                        this.comments.set(c.address, {
                            before: c.before || '',
                            inline: c.inline || '',
                            after: c.after || '',
                            separator: c.separator || false
                        });
                    }
                    if (this.autoSaveEnabled) this._autoSave();
                    return arr.length;
                } catch (e) {
                    console.error('Failed to import comments:', e);
                    return -1;
                }
            }
        }

        const commentManager = new CommentManager();

        // ========== Operand Format Manager ==========
        // Stores custom display formats for operands (hex/dec/bin/char)
        const OPERAND_FORMATS = {
            HEX: 'hex',
            DEC: 'dec',
            BIN: 'bin',
            CHAR: 'char'
        };

        class OperandFormatManager {
            constructor() {
                this.formats = new Map();  // Map<address, format>
                this.currentFile = null;
                this.autoSaveEnabled = true;
            }

            // Set format for operand at instruction address
            set(address, format) {
                address = address & 0xffff;
                if (format === OPERAND_FORMATS.HEX) {
                    // Default format - remove entry
                    this.formats.delete(address);
                } else {
                    this.formats.set(address, format);
                }
                if (this.autoSaveEnabled) this._autoSave();
            }

            // Get format at address (returns 'hex' as default)
            get(address) {
                return this.formats.get(address & 0xffff) || OPERAND_FORMATS.HEX;
            }

            // Remove format at address
            remove(address) {
                const had = this.formats.has(address & 0xffff);
                this.formats.delete(address & 0xffff);
                if (had && this.autoSaveEnabled) this._autoSave();
                return had;
            }

            // Get all formats as array
            getAll() {
                const result = [];
                for (const [addr, format] of this.formats) {
                    result.push({ address: addr, format });
                }
                return result.sort((a, b) => a.address - b.address);
            }

            // Clear all formats
            clear() {
                this.formats.clear();
                if (this.autoSaveEnabled) this._autoSave();
            }

            // Format a value according to format type
            formatValue(value, format, is16bit = false) {
                const val = is16bit ? (value & 0xffff) : (value & 0xff);
                switch (format) {
                    case OPERAND_FORMATS.DEC:
                        return val.toString(10);
                    case OPERAND_FORMATS.BIN:
                        return '%' + val.toString(2).padStart(is16bit ? 16 : 8, '0');
                    case OPERAND_FORMATS.CHAR:
                        if (!is16bit && val >= 32 && val < 127) {
                            const ch = String.fromCharCode(val);
                            // Escape quotes
                            if (ch === "'") return '"\'"';
                            return "'" + ch + "'";
                        }
                        // Fall back to hex for non-printable or 16-bit
                        return val.toString(16).toUpperCase().padStart(is16bit ? 4 : 2, '0') + 'h';
                    case OPERAND_FORMATS.HEX:
                    default:
                        return val.toString(16).toUpperCase().padStart(is16bit ? 4 : 2, '0') + 'h';
                }
            }

            // Set current file for auto-save
            setCurrentFile(filename) {
                this.currentFile = filename;
                this._autoLoad();
            }

            _storageKey() {
                if (!this.currentFile) return null;
                return `zx_opformats_${this.currentFile.toLowerCase()}`;
            }

            _autoSave() {
                const key = this._storageKey();
                if (!key) return;
                try {
                    localStorage.setItem(key, JSON.stringify(this.getAll()));
                } catch (e) {
                    console.warn('Failed to save operand formats:', e);
                }
            }

            _autoLoad() {
                this.formats.clear();
                const key = this._storageKey();
                if (!key) return;
                try {
                    const data = localStorage.getItem(key);
                    if (data) {
                        const arr = JSON.parse(data);
                        for (const f of arr) {
                            this.formats.set(f.address, f.format);
                        }
                    }
                } catch (e) {
                    console.warn('Failed to load operand formats:', e);
                }
            }
        }

        const operandFormatManager = new OperandFormatManager();

        // ========== Cross-Reference Manager ==========
        class XRefManager {
            constructor() {
                this.xrefs = new Map();  // "page:addr" -> [{fromAddr, type, page}]
                this.currentFile = null;
                this.autoSaveEnabled = true;
            }

            _key(address, page = null) {
                const pageStr = page === null ? 'g' : page.toString();
                return `${pageStr}:${address.toString(16).padStart(4, '0')}`;
            }

            add(targetAddr, fromAddr, type, page = null) {
                const key = this._key(targetAddr, page);
                if (!this.xrefs.has(key)) {
                    this.xrefs.set(key, []);
                }
                const refs = this.xrefs.get(key);
                // Avoid duplicates
                if (!refs.some(r => r.fromAddr === fromAddr && r.type === type && r.page === page)) {
                    refs.push({ fromAddr, type, page });
                }
            }

            get(targetAddr, page = null) {
                const key = this._key(targetAddr, page);
                const refs = this.xrefs.get(key) || [];
                // Also check global refs if page-specific
                if (page !== null) {
                    const globalRefs = this.xrefs.get(this._key(targetAddr, null)) || [];
                    return [...refs, ...globalRefs];
                }
                return [...refs];
            }

            hasRefs(targetAddr, page = null) {
                return this.get(targetAddr, page).length > 0;
            }

            getCount() {
                let count = 0;
                for (const refs of this.xrefs.values()) {
                    count += refs.length;
                }
                return count;
            }

            scanRange(startAddr, endAddr, page = null) {
                if (!disasm) return 0;
                let count = 0;
                let addr = startAddr;

                while (addr <= endAddr && addr < 0x10000) {
                    const instr = disasm.disassemble(addr, true);
                    if (instr.refs) {
                        for (const ref of instr.refs) {
                            this.add(ref.target, addr, ref.type, page);
                            count++;
                        }
                    }
                    addr = (addr + instr.length) & 0xffff;
                    // Prevent infinite loop if we wrap around
                    if (addr <= startAddr && addr !== 0) break;
                }
                if (this.autoSaveEnabled) this._autoSave();
                return count;
            }

            // Async version for large scans - processes in chunks to avoid blocking UI
            async scanRangeAsync(startAddr, endAddr, onProgress = null, page = null) {
                if (!disasm) return 0;
                let count = 0;
                let addr = startAddr;
                let bytesProcessed = 0;
                const totalBytes = endAddr - startAddr + 1;  // Don't mask - can be up to 0x10000
                let lastYield = Date.now();

                while (addr <= endAddr && addr < 0x10000 && bytesProcessed < totalBytes) {
                    const instr = disasm.disassemble(addr, true);
                    if (instr.refs) {
                        for (const ref of instr.refs) {
                            this.add(ref.target, addr, ref.type, page);
                            count++;
                        }
                    }
                    bytesProcessed += instr.length;
                    addr = (addr + instr.length) & 0xffff;

                    // Yield to UI every 20ms
                    if (Date.now() - lastYield > 20) {
                        if (onProgress) onProgress(bytesProcessed, totalBytes, count);
                        await new Promise(r => setTimeout(r, 0));
                        lastYield = Date.now();
                    }
                }
                if (this.autoSaveEnabled) this._autoSave();
                return count;
            }

            clear() {
                this.xrefs.clear();
                if (this.autoSaveEnabled) this._autoSave();
            }

            setCurrentFile(filename) {
                // Save current file's xrefs before switching
                if (this.currentFile && this.autoSaveEnabled) {
                    this._autoSave();
                }
                this.currentFile = filename;
                if (filename) {
                    this._autoLoad();
                } else {
                    this.xrefs.clear();
                }
            }

            _storageKey() {
                if (!this.currentFile) return null;
                return `zx_xrefs_${this.currentFile.toLowerCase()}`;
            }

            _autoSave() {
                const key = this._storageKey();
                if (!key) return;
                try {
                    const data = this.exportJSON();
                    if (data) {
                        localStorage.setItem(key, data);
                    } else {
                        localStorage.removeItem(key);
                    }
                } catch (e) {
                    console.warn('Failed to save xrefs:', e);
                }
            }

            _autoLoad() {
                const key = this._storageKey();
                if (!key) return;
                try {
                    const data = localStorage.getItem(key);
                    if (data) {
                        this.importJSON(data, false);
                    }
                } catch (e) {
                    console.warn('Failed to load xrefs:', e);
                }
            }

            exportJSON() {
                if (this.xrefs.size === 0) return null;
                const arr = [];
                for (const [key, refs] of this.xrefs.entries()) {
                    arr.push({ key, refs });
                }
                return JSON.stringify(arr);
            }

            importJSON(jsonStr, merge = false) {
                try {
                    const arr = JSON.parse(jsonStr);
                    if (!merge) this.xrefs.clear();
                    for (const item of arr) {
                        if (merge && this.xrefs.has(item.key)) {
                            const existing = this.xrefs.get(item.key);
                            for (const ref of item.refs) {
                                if (!existing.some(r => r.fromAddr === ref.fromAddr && r.type === ref.type)) {
                                    existing.push(ref);
                                }
                            }
                        } else {
                            this.xrefs.set(item.key, item.refs);
                        }
                    }
                    return arr.length;
                } catch (e) {
                    console.error('Failed to import xrefs:', e);
                    return -1;
                }
            }
        }

        const xrefManager = new XRefManager();
        let xrefRuntimeEnabled = false;

        // ========== Subroutine Manager ==========
        class SubroutineManager {
            constructor() {
                this.subs = new Map();  // address -> {name, comment, auto, endAddress}
                this.currentFile = null;
                this.autoSaveEnabled = true;
            }

            add(address, name = null, comment = null, auto = false) {
                address = address & 0xffff;
                const existing = this.subs.get(address);
                const endAddress = this._findEndAddress(address);
                this.subs.set(address, {
                    name: name || (existing ? existing.name : null),
                    comment: comment || (existing ? existing.comment : null),
                    auto: auto || (existing ? existing.auto : false),
                    endAddress: endAddress
                });
                if (this.autoSaveEnabled) this._autoSave();
            }

            // Scan forward to find subroutine end address
            _findEndAddress(startAddr) {
                if (!disasm) return null;

                let addr = startAddr;
                let lastUnconditionalRet = null;
                const maxScan = 1024; // max bytes to scan
                const endAddr = Math.min(startAddr + maxScan, 0x10000);

                while (addr < endAddr) {
                    const instr = disasm.disassemble(addr);
                    const mnem = (instr.mnemonic || '').replace(/<[^>]+>/g, '').toUpperCase().trim();
                    const instrLen = instr.length || 1;

                    // Check for unconditional RET
                    if (mnem === 'RET' || mnem === 'RETI' || mnem === 'RETN') {
                        lastUnconditionalRet = addr;
                        // This could be the end, but there might be more code after
                        // (e.g., error handlers, alternate entry points)
                        // For now, treat first unconditional RET as the end
                        return addr;
                    }

                    // Check for unconditional JP/JR back into subroutine (tail loop)
                    if (mnem.startsWith('JP ') || mnem.startsWith('JR ')) {
                        // Check if it's unconditional (no condition after JP/JR)
                        const afterOp = mnem.slice(3).trim();
                        const isConditional = /^(NZ|Z|NC|C|PO|PE|P|M),/.test(afterOp);
                        if (!isConditional && instr.refs) {
                            const target = instr.refs[0]?.target;
                            if (target !== undefined && target >= startAddr && target <= addr) {
                                // Unconditional jump back into sub body - this is the end
                                return addr;
                            }
                        }
                    }

                    // Stop if we hit another subroutine
                    if (addr > startAddr && this.has(addr)) {
                        break;
                    }

                    addr += instrLen;
                }

                return lastUnconditionalRet;
            }

            // Recalculate end addresses for all subroutines
            recalculateEnds() {
                for (const [addr, data] of this.subs) {
                    data.endAddress = this._findEndAddress(addr);
                }
                if (this.autoSaveEnabled) this._autoSave();
            }

            remove(address) {
                address = address & 0xffff;
                if (this.subs.delete(address)) {
                    if (this.autoSaveEnabled) this._autoSave();
                    return true;
                }
                return false;
            }

            get(address) {
                return this.subs.get(address & 0xffff);
            }

            has(address) {
                return this.subs.has(address & 0xffff);
            }

            // Check if address is the end of any subroutine(s)
            // Returns array of all subs ending here, sorted by start address descending (reverse order)
            getAllEndingAt(address) {
                address = address & 0xffff;
                const results = [];
                for (const [startAddr, data] of this.subs) {
                    if (data.endAddress === address) {
                        results.push({ address: startAddr, ...data });
                    }
                }
                // Sort by start address descending (reverse order of how they appear)
                return results.sort((a, b) => b.address - a.address);
            }

            getAll() {
                return Array.from(this.subs.entries())
                    .map(([addr, data]) => ({ address: addr, ...data }))
                    .sort((a, b) => a.address - b.address);
            }

            getCount() {
                return this.subs.size;
            }

            clear(autoOnly = false) {
                if (autoOnly) {
                    for (const [addr, data] of this.subs) {
                        if (data.auto) this.subs.delete(addr);
                    }
                } else {
                    this.subs.clear();
                }
                if (this.autoSaveEnabled) this._autoSave();
            }

            // Detect subroutines from executed addresses by scanning for CALL targets
            detectFromCode(executedAddrs) {
                if (!disasm) return 0;
                let count = 0;

                for (const key of executedAddrs.keys()) {
                    const { addr } = spectrum.parseAutoMapKey(key);
                    const instr = disasm.disassemble(addr, true);

                    // Check if this is a CALL instruction
                    if (instr.refs) {
                        for (const ref of instr.refs) {
                            if (ref.type === 'call' && !this.has(ref.target)) {
                                this.add(ref.target, null, null, true);
                                count++;
                            }
                        }
                    }
                }

                if (this.autoSaveEnabled) this._autoSave();
                return count;
            }

            setCurrentFile(filename) {
                if (this.currentFile && this.autoSaveEnabled) {
                    this._autoSave();
                }
                this.currentFile = filename;
                if (filename) {
                    this._autoLoad();
                }
            }

            _autoSave() {
                if (!this.currentFile) return;
                try {
                    const key = `zxm8_subs_${this.currentFile}`;
                    localStorage.setItem(key, this.exportJSON());
                } catch (e) { }
            }

            _autoLoad() {
                if (!this.currentFile) return;
                try {
                    const key = `zxm8_subs_${this.currentFile}`;
                    const json = localStorage.getItem(key);
                    if (json) this.importJSON(json);
                } catch (e) { }
            }

            exportJSON() {
                const arr = [];
                for (const [addr, data] of this.subs) {
                    arr.push({ address: addr, ...data });
                }
                return JSON.stringify(arr);
            }

            importJSON(jsonStr, merge = false) {
                try {
                    const arr = JSON.parse(jsonStr);
                    if (!merge) this.subs.clear();
                    for (const item of arr) {
                        this.subs.set(item.address, {
                            name: item.name || null,
                            comment: item.comment || null,
                            auto: item.auto || false,
                            endAddress: item.endAddress || null
                        });
                    }
                    // Recalculate end addresses if disasm is available
                    if (disasm) {
                        this.recalculateEnds();
                    }
                    return arr.length;
                } catch (e) {
                    console.error('Failed to import subroutines:', e);
                    return -1;
                }
            }
        }

        const subroutineManager = new SubroutineManager();

        // ========== Fold Manager (Code Folding) ==========
        class FoldManager {
            constructor() {
                this.userFolds = new Map();    // address -> {endAddress, name}
                this.collapsed = new Set();    // Set of collapsed start addresses (both sub and user)
                this.currentFile = null;
                this.autoSaveEnabled = true;
            }

            // Add a user-defined fold
            addUserFold(startAddr, endAddr, name = null) {
                this.userFolds.set(startAddr, {
                    endAddress: endAddr,
                    name: name
                });
                this._autoSave();
            }

            // Remove a user-defined fold
            removeUserFold(addr) {
                const existed = this.userFolds.has(addr);
                this.userFolds.delete(addr);
                this.collapsed.delete(addr);
                this._autoSave();
                return existed;
            }

            // Get user fold at address
            getUserFold(addr) {
                return this.userFolds.get(addr) || null;
            }

            // Toggle collapse state for any fold (subroutine or user)
            toggle(addr) {
                if (this.collapsed.has(addr)) {
                    this.collapsed.delete(addr);
                } else {
                    this.collapsed.add(addr);
                }
                this._autoSave();
            }

            // Collapse a fold
            collapse(addr) {
                this.collapsed.add(addr);
                this._autoSave();
            }

            // Expand a fold
            expand(addr) {
                this.collapsed.delete(addr);
                this._autoSave();
            }

            // Check if an address is the start of a collapsed fold
            isCollapsed(addr) {
                return this.collapsed.has(addr);
            }

            // Get the collapsed range containing an address, if any
            // Returns {start, end} or null
            getCollapsedRangeContaining(addr) {
                // Check subroutines
                for (const collapsedAddr of this.collapsed) {
                    const sub = subroutineManager.get(collapsedAddr);
                    if (sub && sub.endAddress !== null) {
                        if (addr >= collapsedAddr && addr <= sub.endAddress) {
                            return { start: collapsedAddr, end: sub.endAddress };
                        }
                    }
                    // Check user folds
                    const userFold = this.userFolds.get(collapsedAddr);
                    if (userFold) {
                        if (addr >= collapsedAddr && addr <= userFold.endAddress) {
                            return { start: collapsedAddr, end: userFold.endAddress };
                        }
                    }
                }
                return null;
            }

            // Collapse all foldable items
            collapseAll() {
                // Collapse all subroutines
                for (const [addr, sub] of subroutineManager.subs) {
                    if (sub.endAddress !== null) {
                        this.collapsed.add(addr);
                    }
                }
                // Collapse all user folds
                for (const addr of this.userFolds.keys()) {
                    this.collapsed.add(addr);
                }
                this._autoSave();
            }

            // Expand all folds
            expandAll() {
                this.collapsed.clear();
                this._autoSave();
            }

            // Clear all state
            clear() {
                this.userFolds.clear();
                this.collapsed.clear();
            }

            // Set current file (for localStorage key)
            setCurrentFile(filename) {
                this.currentFile = filename;
                this._autoLoad();
            }

            _autoSave() {
                if (!this.autoSaveEnabled || !this.currentFile) return;
                try {
                    const key = `folds_${this.currentFile}`;
                    localStorage.setItem(key, this.exportJSON());
                } catch (e) {
                    console.warn('Failed to auto-save folds:', e);
                }
            }

            _autoLoad() {
                if (!this.currentFile) return;
                try {
                    const key = `folds_${this.currentFile}`;
                    const data = localStorage.getItem(key);
                    if (data) {
                        this.importJSON(data, false);
                    }
                } catch (e) {
                    console.warn('Failed to auto-load folds:', e);
                }
            }

            exportJSON() {
                const userFoldsArr = [];
                for (const [addr, data] of this.userFolds) {
                    userFoldsArr.push({
                        start: addr,
                        end: data.endAddress,
                        name: data.name
                    });
                }
                return JSON.stringify({
                    userFolds: userFoldsArr,
                    collapsed: Array.from(this.collapsed)
                });
            }

            importJSON(jsonStr, merge = false) {
                try {
                    const data = JSON.parse(jsonStr);
                    if (!merge) {
                        this.userFolds.clear();
                        this.collapsed.clear();
                    }
                    if (data.userFolds) {
                        for (const fold of data.userFolds) {
                            this.userFolds.set(fold.start, {
                                endAddress: fold.end,
                                name: fold.name || null
                            });
                        }
                    }
                    if (data.collapsed) {
                        for (const addr of data.collapsed) {
                            this.collapsed.add(addr);
                        }
                    }
                    return true;
                } catch (e) {
                    console.error('Failed to import folds:', e);
                    return false;
                }
            }
        }

        const foldManager = new FoldManager();

        // ========== Undo/Redo System ==========
        class UndoManager {
            constructor(maxHistory = 50) {
                this.undoStack = [];
                this.redoStack = [];
                this.maxHistory = maxHistory;
            }

            push(action) {
                // action = {type, description, undo(), redo()}
                this.undoStack.push(action);
                this.redoStack = [];
                if (this.undoStack.length > this.maxHistory) {
                    this.undoStack.shift();
                }
                this.updateButtons();
            }

            undo() {
                if (this.undoStack.length === 0) return false;
                const action = this.undoStack.pop();
                action.undo();
                this.redoStack.push(action);
                this.updateButtons();
                updateDebugger();
                showMessage(`Undo: ${action.description}`);
                return true;
            }

            redo() {
                if (this.redoStack.length === 0) return false;
                const action = this.redoStack.pop();
                action.redo();
                this.undoStack.push(action);
                this.updateButtons();
                updateDebugger();
                showMessage(`Redo: ${action.description}`);
                return true;
            }

            clear() {
                this.undoStack = [];
                this.redoStack = [];
                this.updateButtons();
            }

            updateButtons() {
                const btnUndo = document.getElementById('btnUndo');
                const btnRedo = document.getElementById('btnRedo');
                if (btnUndo) btnUndo.disabled = this.undoStack.length === 0;
                if (btnRedo) btnRedo.disabled = this.redoStack.length === 0;
            }
        }

        const undoManager = new UndoManager();

        // ========== Execution Trace ==========
        class TraceManager {
            constructor(maxHistory = 100000) {
                this.history = [];        // Array of trace entries
                this.maxHistory = maxHistory;
                this.enabled = true;      // Can be toggled for performance
                this.position = -1;       // Current viewing position (-1 = live)
                this.stopAfter = 0;       // Stop recording after N entries (0 = no limit)
                this.stopped = false;     // Recording stopped due to limit
                this.onStopped = null;    // Callback when recording stops (for pausing emulator)
                this.skipROM = true;      // Skip recording when PC < 0x4000 (ROM area)
            }

            record(cpu, memory, instrPC = null, portOps = null, memOps = null, instrBytes = null) {
                if (this.stopped) return;

                // Use provided PC (before execution) or fall back to current PC
                const pc = instrPC !== null ? instrPC : cpu.pc;

                // Skip ROM area if option enabled
                if (this.skipROM && pc < 0x4000) return;

                // Check stop limit
                if (this.stopAfter > 0 && this.history.length >= this.stopAfter) {
                    this.stopped = true;
                    if (this.onStopped) this.onStopped();
                    return;
                }
                const entry = {
                    pc: pc,
                    sp: cpu.sp,
                    af: cpu.af,
                    bc: cpu.bc,
                    de: cpu.de,
                    hl: cpu.hl,
                    ix: cpu.ix,
                    iy: cpu.iy,
                    af_: (cpu.a_ << 8) | cpu.f_,
                    bc_: (cpu.b_ << 8) | cpu.c_,
                    de_: (cpu.d_ << 8) | cpu.e_,
                    hl_: (cpu.h_ << 8) | cpu.l_,
                    i: cpu.i,
                    r: (cpu.r7 & 0x80) | (cpu.r & 0x7f),
                    iff1: cpu.iff1,
                    iff2: cpu.iff2,
                    im: cpu.im,
                    tStates: cpu.tStates,
                    // Use pre-captured bytes (before instruction modified memory) or read from memory
                    bytes: instrBytes || [
                        memory.read(pc & 0xffff),
                        memory.read((pc + 1) & 0xffff),
                        memory.read((pc + 2) & 0xffff),
                        memory.read((pc + 3) & 0xffff)
                    ],
                    // Port I/O operations during this instruction
                    ports: portOps && portOps.length > 0 ? portOps.slice() : null,
                    // Memory write operations during this instruction
                    mem: memOps && memOps.length > 0 ? memOps.slice() : null
                };

                this.history.push(entry);
                if (this.history.length > this.maxHistory) {
                    this.history.shift();
                }
                this.position = -1; // Reset to live view
            }

            getEntry(index) {
                if (index < 0 || index >= this.history.length) return null;
                return this.history[index];
            }

            getRecent(count = 50) {
                const start = Math.max(0, this.history.length - count);
                return this.history.slice(start);
            }

            // Get entries around a specific position (for navigation view)
            getEntriesAround(pos, count = 20) {
                if (pos < 0 || pos >= this.history.length) {
                    return { entries: [], startIdx: 0, viewIdx: -1 };
                }
                const half = Math.floor(count / 2);
                let start = Math.max(0, pos - half);
                let end = Math.min(this.history.length, start + count);
                // Adjust start if we hit the end
                if (end - start < count) {
                    start = Math.max(0, end - count);
                }
                return {
                    entries: this.history.slice(start, end),
                    startIdx: start,
                    viewIdx: pos - start  // Index within returned array
                };
            }

            get length() {
                return this.history.length;
            }

            clear() {
                this.history = [];
                this.position = -1;
                this.stopped = false;
            }

            goBack() {
                if (this.history.length === 0) return null;
                if (this.position === -1) {
                    this.position = this.history.length - 1;
                } else if (this.position > 0) {
                    this.position--;
                }
                return this.history[this.position];
            }

            goForward() {
                if (this.position === -1 || this.history.length === 0) return null;
                if (this.position < this.history.length - 1) {
                    this.position++;
                    return this.history[this.position];
                } else {
                    this.position = -1; // Back to live
                    return null;
                }
            }

            goToLive() {
                this.position = -1;
            }

            isViewingHistory() {
                return this.position !== -1;
            }

            getCurrentPosition() {
                return this.position;
            }

            // Export trace to text format for file download (Excel-compatible TSV)
            exportToText(options = {}) {
                const {
                    includeBytes = true,     // Include instruction bytes
                    includeAlt = false,      // Include alternate registers
                    includeSys = false,      // Include system regs (I, R, IFF, IM, T)
                    includePorts = false,    // Include port I/O
                    includeMem = false,      // Include memory writes
                    collapseBlock = false,   // Collapse block commands (LDIR, LDDR, etc.) to single line
                    startIdx = 0,            // Start index in history
                    endIdx = -1              // End index (-1 = to end)
                } = options;

                // Block commands that repeat until BC=0 or condition met
                const blockCommands = ['LDIR', 'LDDR', 'CPIR', 'CPDR', 'INIR', 'INDR', 'OTIR', 'OTDR'];

                const lines = [];
                let prev = null;  // Previous entry for change detection
                const hex4 = v => v.toString(16).toUpperCase().padStart(4,'0');
                const hex2 = v => v.toString(16).toUpperCase().padStart(2,'0');

                // Calculate actual range
                const start = Math.max(0, startIdx);
                const end = endIdx < 0 ? this.history.length : Math.min(endIdx, this.history.length);

                // Build header row
                const headers = ['ADDR'];
                if (includeBytes) headers.push('BYTES');
                headers.push('INSTR', 'AF', 'BC', 'DE', 'HL', 'SP', 'IX', 'IY');
                if (includeSys) headers.push('I', 'R', 'IFF', 'IM', 'T');
                if (includeAlt) headers.push("AF'", "BC'", "DE'", "HL'");
                if (includePorts) headers.push('PORT');
                if (includeMem) headers.push('MEM');
                lines.push(headers.join('\t'));

                let lastBlockPC = -1;      // PC of last block command (for collapse detection)
                let lastBlockMnemonic = '';  // Mnemonic of last block command
                let blockRepeatCount = 0;  // How many times block command repeated

                for (let i = start; i < end; i++) {
                    const e = this.history[i];
                    const isFirst = (i === start);

                    // Create a fake memory object that reads from stored bytes
                    const fakeMemory = { read: (addr) => e.bytes[(addr - e.pc) & 3] || 0 };
                    const disasm = new Disassembler(fakeMemory);

                    // Disassemble instruction
                    const result = disasm.disassemble(e.pc);
                    const mnemonic = result.mnemonic || '???';
                    const bytesHex = e.bytes.slice(0, result.length).map(b => hex2(b)).join(' ');

                    // Block command collapsing
                    if (collapseBlock) {
                        const isBlockCmd = blockCommands.includes(mnemonic);
                        if (isBlockCmd && e.pc === lastBlockPC && mnemonic === lastBlockMnemonic) {
                            // Same block command at same PC - skip this iteration
                            blockRepeatCount++;
                            continue;
                        }
                        // If we were tracking a block command and now moved on, add repeat count to last line
                        if (blockRepeatCount > 0 && lines.length > 1) {
                            lines[lines.length - 1] += `\t(x${blockRepeatCount + 1})`;
                        }
                        // Update tracking
                        if (isBlockCmd) {
                            lastBlockPC = e.pc;
                            lastBlockMnemonic = mnemonic;
                            blockRepeatCount = 0;
                        } else {
                            lastBlockPC = -1;
                            lastBlockMnemonic = '';
                            blockRepeatCount = 0;
                        }
                    }

                    // Build columns array
                    const cols = [];

                    // Address (always shown)
                    cols.push(hex4(e.pc));

                    // Bytes (optional)
                    if (includeBytes) cols.push(bytesHex);

                    // Instruction (always shown)
                    cols.push(mnemonic);

                    // Registers - show value if first row or changed, empty otherwise
                    cols.push(isFirst || e.af !== prev.af ? hex4(e.af) : '');
                    cols.push(isFirst || e.bc !== prev.bc ? hex4(e.bc) : '');
                    cols.push(isFirst || e.de !== prev.de ? hex4(e.de) : '');
                    cols.push(isFirst || e.hl !== prev.hl ? hex4(e.hl) : '');
                    cols.push(isFirst || e.sp !== prev.sp ? hex4(e.sp) : '');
                    cols.push(isFirst || e.ix !== prev.ix ? hex4(e.ix) : '');
                    cols.push(isFirst || e.iy !== prev.iy ? hex4(e.iy) : '');

                    // System registers (optional)
                    if (includeSys) {
                        cols.push(isFirst || e.i !== prev.i ? hex2(e.i) : '');
                        cols.push(isFirst || e.r !== prev.r ? hex2(e.r) : '');
                        cols.push(isFirst || e.iff1 !== prev.iff1 || e.iff2 !== prev.iff2 ? `${e.iff1?1:0}/${e.iff2?1:0}` : '');
                        cols.push(isFirst || e.im !== prev.im ? e.im.toString() : '');
                        cols.push(e.tStates.toString());  // T-states always shown
                    }

                    // Alternate registers (optional)
                    if (includeAlt) {
                        cols.push(isFirst || e.af_ !== prev.af_ ? hex4(e.af_) : '');
                        cols.push(isFirst || e.bc_ !== prev.bc_ ? hex4(e.bc_) : '');
                        cols.push(isFirst || e.de_ !== prev.de_ ? hex4(e.de_) : '');
                        cols.push(isFirst || e.hl_ !== prev.hl_ ? hex4(e.hl_) : '');
                    }

                    // Port I/O (optional)
                    if (includePorts) {
                        if (e.ports && e.ports.length > 0) {
                            const portStr = e.ports.map(p => `${p.dir}:${hex4(p.port)}=${hex2(p.val||0)}`).join(' ');
                            cols.push(portStr);
                        } else {
                            cols.push('');
                        }
                    }

                    // Memory writes (optional)
                    if (includeMem) {
                        if (e.mem && e.mem.length > 0) {
                            const memStr = e.mem.map(m => `${hex4(m.addr)}=${hex2(m.val||0)}`).join(' ');
                            cols.push(memStr);
                        } else {
                            cols.push('');
                        }
                    }

                    lines.push(cols.join('\t'));
                    prev = e;
                }

                // Handle case where trace ends with a block command
                if (collapseBlock && blockRepeatCount > 0 && lines.length > 1) {
                    lines[lines.length - 1] += `\t(x${blockRepeatCount + 1})`;
                }

                return lines.join('\n');
            }
        }

        const traceManager = new TraceManager();

        // ========== Signature Pack Manager ==========
        class SignaturePackManager {
            constructor() {
                this.packs = [];        // Array of { id, file, type, enabled, name }
                this.loadedPacks = {};  // id → full pack data (loaded on demand)
                this.indexUrl = 'signatures/index.json';
            }

            // Load the index file listing all available packs
            async loadIndex() {
                try {
                    const resp = await fetch(this.indexUrl);
                    if (!resp.ok) {
                        console.warn('Signature index not found');
                        this.packs = [];
                        return;
                    }
                    const idx = await resp.json();
                    this.packs = idx.packs || [];
                    // Restore enabled/disabled state from localStorage
                    const saved = this._loadEnabledState();
                    if (saved) {
                        for (const p of this.packs) {
                            if (saved[p.id] !== undefined) p.enabled = saved[p.id];
                        }
                    }
                } catch (e) {
                    console.warn('Failed to load signature index:', e);
                    this.packs = [];
                }
            }

            // Load a single pack file by ID
            async loadPack(id) {
                if (this.loadedPacks[id]) return this.loadedPacks[id];
                const entry = this.packs.find(p => p.id === id);
                if (!entry) return null;
                try {
                    const resp = await fetch('signatures/' + entry.file);
                    if (!resp.ok) return null;
                    const pack = await resp.json();
                    this.loadedPacks[id] = pack;
                    return pack;
                } catch (e) {
                    console.warn('Failed to load pack:', id, e);
                    return null;
                }
            }

            // Toggle enabled state for a pack
            setEnabled(id, enabled) {
                const entry = this.packs.find(p => p.id === id);
                if (entry) {
                    entry.enabled = enabled;
                    this._saveEnabledState();
                }
            }

            // Get all enabled packs
            getEnabledPacks() {
                return this.packs.filter(p => p.enabled);
            }

            // Add a new pack from imported data (e.g., parsed .skool file)
            addPack(pack) {
                // Remove existing pack with same ID
                this.packs = this.packs.filter(p => p.id !== pack.id);
                delete this.loadedPacks[pack.id];

                const entry = {
                    id: pack.id,
                    file: pack.id + '.json',
                    type: pack.type || 'game',
                    enabled: true,
                    name: pack.name || pack.id,
                    source: pack.source || ''
                };
                this.packs.push(entry);
                this.loadedPacks[pack.id] = pack;

                // Save pack to localStorage (can't write to filesystem from browser)
                this._savePackToStorage(pack);
                this._saveEnabledState();
                this._saveCustomIndex();
                return entry;
            }

            // Remove a pack
            removePack(id) {
                this.packs = this.packs.filter(p => p.id !== id);
                delete this.loadedPacks[id];
                try { localStorage.removeItem('zxm8_sigpack_' + id); } catch(e) {}
                this._saveEnabledState();
                this._saveCustomIndex();
            }

            // Load all enabled packs into memory
            async loadAllEnabled() {
                const enabled = this.getEnabledPacks();
                for (const entry of enabled) {
                    // Try localStorage first (user-imported packs)
                    if (!this.loadedPacks[entry.id]) {
                        const stored = this._loadPackFromStorage(entry.id);
                        if (stored) {
                            this.loadedPacks[entry.id] = stored;
                            continue;
                        }
                    }
                    // Then try fetching from signatures/ directory
                    await this.loadPack(entry.id);
                }
            }

            // --- Matching engine ---

            // Scan memory for matching anchors across all enabled packs.
            // Each anchor is searched independently anywhere in memory (address-independent).
            // Returns array of { pack, matched, total, confidence, anchorMatches[] }
            scanMemory(readByte, startAddr, endAddr) {
                const results = [];
                for (const entry of this.getEnabledPacks()) {
                    const pack = this.loadedPacks[entry.id];
                    if (!pack || !pack.anchors || pack.anchors.length === 0) continue;

                    const matchResult = this._matchAnchors(pack, readByte, startAddr, endAddr);
                    if (matchResult.matched > 0) {
                        results.push({
                            packId: entry.id,
                            pack: pack,
                            matched: matchResult.matched,
                            total: pack.anchors.length,
                            confidence: matchResult.matched / pack.anchors.length,
                            anchorMatches: matchResult.anchorMatches
                        });
                    }
                }
                results.sort((a, b) => b.confidence - a.confidence);
                return results;
            }

            // Match anchors by scanning all of memory for each anchor's byte pattern.
            // Each anchor can be found at any address — not tied to a base offset.
            _matchAnchors(pack, readByte, startAddr, endAddr) {
                // Two-pass matching with per-anchor offsets and voting.
                //
                // Pass 1 (exact): match all bytes exactly — highest confidence,
                //   catches same-game and same-engine at same addresses.
                // Pass 2 (masked): for unmatched anchors, use mask to ignore
                //   16-bit address operands — catches relocated code where only
                //   CALL/JP/LD addresses changed but opcodes are identical.
                //
                // Both passes contribute to the offset vote histogram.
                // Each anchor is resolved to the highest-voted offset where it matched.

                const anchorData = pack.anchors.map(anchor => ({
                    anchor,
                    origAddr: anchor.address,
                    exactAddrs: [],     // pass 1 matches (all bytes identical)
                    maskedAddrs: []     // pass 2 matches (address operands ignored)
                }));

                // Pass 1: exact matching (no masks)
                for (const ad of anchorData) {
                    const bytes = ad.anchor.bytes;
                    const len = bytes.length;
                    for (let addr = startAddr; addr <= endAddr - len + 1; addr++) {
                        let match = true;
                        for (let i = 0; i < len; i++) {
                            if (readByte(addr + i) !== bytes[i]) { match = false; break; }
                        }
                        if (match) ad.exactAddrs.push(addr);
                    }
                }

                // Pass 2: masked matching for anchors with no exact matches
                for (const ad of anchorData) {
                    if (ad.exactAddrs.length > 0) continue;    // already matched exactly
                    const mask = ad.anchor.mask;
                    if (!mask) continue;                        // no mask = no address operands to relax
                    const bytes = ad.anchor.bytes;
                    const len = bytes.length;
                    for (let addr = startAddr; addr <= endAddr - len + 1; addr++) {
                        let match = true;
                        for (let i = 0; i < len; i++) {
                            if ((readByte(addr + i) & mask[i]) !== (bytes[i] & mask[i])) { match = false; break; }
                        }
                        if (match) ad.maskedAddrs.push(addr);
                    }
                }

                // Build offset histogram from both passes.
                // Exact matches get double weight (more trustworthy).
                const offsetVotes = {};
                for (const ad of anchorData) {
                    for (const addr of ad.exactAddrs) {
                        const offset = addr - ad.origAddr;
                        offsetVotes[offset] = (offsetVotes[offset] || 0) + 2;
                    }
                    for (const addr of ad.maskedAddrs) {
                        const offset = addr - ad.origAddr;
                        offsetVotes[offset] = (offsetVotes[offset] || 0) + 1;
                    }
                }

                // Rank offsets by votes
                const rankedOffsets = Object.entries(offsetVotes)
                    .map(([off, votes]) => ({ offset: parseInt(off), votes }))
                    .sort((a, b) => b.votes - a.votes);

                // Resolve each anchor to its best match
                const anchorMatches = [];
                for (const ad of anchorData) {
                    const allAddrs = ad.exactAddrs.length > 0 ? ad.exactAddrs : ad.maskedAddrs;
                    if (allAddrs.length === 0) continue;

                    const matchSet = new Set(allAddrs);
                    let resolved = null;

                    // Prefer highest-voted offset where this anchor matched
                    for (const { offset } of rankedOffsets) {
                        const target = ad.origAddr + offset;
                        if (matchSet.has(target)) {
                            resolved = { foundAddr: target, offset };
                            break;
                        }
                    }

                    // Unique match: only one place in memory
                    if (!resolved && allAddrs.length === 1) {
                        resolved = {
                            foundAddr: allAddrs[0],
                            offset: allAddrs[0] - ad.origAddr
                        };
                    }

                    if (resolved) {
                        anchorMatches.push({
                            anchor: ad.anchor,
                            origAddr: ad.origAddr,
                            foundAddr: resolved.foundAddr,
                            offset: resolved.offset
                        });
                    }
                }

                return { matched: anchorMatches.length, anchorMatches };
            }

            // Apply labels from matched anchors using per-anchor offsets.
            // Each label is assigned to its nearest matched anchor (by source address)
            // and relocated using that anchor's offset. This correctly handles both
            // uniform relocation and shuffled procedures.
            applyLabels(matchResult, targetLabelManager, targetRegionManager, page) {
                const pack = matchResult.pack;
                const anchorMatches = matchResult.anchorMatches;
                if (!anchorMatches || anchorMatches.length === 0) return { labelCount: 0, regionCount: 0, offset: 0, uniqueOffsets: 0 };

                const labelPage = page !== undefined ? page : null;
                let labelCount = 0;
                let regionCount = 0;

                // Sort anchors by original address for nearest-anchor lookup
                const sorted = [...anchorMatches].sort((a, b) => a.origAddr - b.origAddr);

                // Check if all offsets are the same (common case)
                const offsetSet = new Set(sorted.map(m => m.offset));
                const uniformOffset = offsetSet.size === 1 ? sorted[0].offset : null;

                // Disable auto-save during bulk insert, save once at end
                const prevAutoSave = targetLabelManager.autoSaveEnabled;
                targetLabelManager.autoSaveEnabled = false;

                if (uniformOffset !== null) {
                    // Uniform offset — efficient bulk apply
                    labelCount = this._applyLabelsWithOffset(pack, uniformOffset, targetLabelManager, labelPage);
                    regionCount = this._applyRegionsWithOffset(pack, uniformOffset, targetRegionManager, labelPage);
                } else {
                    // Per-anchor offsets — each label uses its nearest anchor's offset
                    if (pack.labels) {
                        for (const [addrStr, name] of Object.entries(pack.labels)) {
                            const addr = parseInt(addrStr, 16) || parseInt(addrStr, 10);
                            if (isNaN(addr)) continue;
                            const nearest = this._findNearestAnchor(sorted, addr);
                            if (!nearest) continue;
                            const mapped = (addr + nearest.offset) & 0xFFFF;
                            const key = targetLabelManager._key(mapped, labelPage);
                            if (!targetLabelManager.labels.has(key)) {
                                targetLabelManager.add({ address: mapped, page: labelPage, name: name });
                                labelCount++;
                            }
                        }
                    }
                    if (pack.regions && targetRegionManager) {
                        for (const region of pack.regions) {
                            const nearest = this._findNearestAnchor(sorted, region.start);
                            if (!nearest) continue;
                            const start = (region.start + nearest.offset) & 0xFFFF;
                            const end = (region.end + nearest.offset) & 0xFFFF;
                            if (start > end) continue;
                            if (!targetRegionManager.get(start, labelPage)) {
                                targetRegionManager.add({
                                    start, end,
                                    type: region.type || 'code', page: labelPage,
                                    comment: region.comment || ''
                                });
                                regionCount++;
                            }
                        }
                    }
                }

                targetLabelManager.autoSaveEnabled = prevAutoSave;
                if (prevAutoSave) targetLabelManager._autoSave();

                // Compute dominant offset for display
                const offsetCounts = {};
                for (const m of sorted) offsetCounts[m.offset] = (offsetCounts[m.offset] || 0) + 1;
                const dominantOffset = parseInt(Object.entries(offsetCounts).sort((a, b) => b[1] - a[1])[0][0]);

                return { labelCount, regionCount, offset: dominantOffset, uniqueOffsets: offsetSet.size };
            }

            // Find nearest anchor to an address using binary search on sorted array
            _findNearestAnchor(sortedAnchors, addr) {
                let lo = 0, hi = sortedAnchors.length - 1;
                while (lo < hi) {
                    const mid = (lo + hi) >> 1;
                    if (sortedAnchors[mid].origAddr < addr) lo = mid + 1;
                    else hi = mid;
                }
                // lo = first anchor with origAddr >= addr; check lo and lo-1
                let best = null, bestDist = Infinity;
                for (const i of [lo - 1, lo]) {
                    if (i >= 0 && i < sortedAnchors.length) {
                        const dist = Math.abs(sortedAnchors[i].origAddr - addr);
                        if (dist < bestDist) { bestDist = dist; best = sortedAnchors[i]; }
                    }
                }
                return best;
            }

            // Apply all pack labels shifted by a global offset
            _applyLabelsWithOffset(pack, offset, targetLabelManager, page) {
                let count = 0;
                if (!pack.labels) return 0;
                for (const [addrStr, name] of Object.entries(pack.labels)) {
                    const addr = parseInt(addrStr, 16) || parseInt(addrStr, 10);
                    if (isNaN(addr)) continue;
                    const mapped = (addr + offset) & 0xFFFF;
                    const key = targetLabelManager._key(mapped, page);
                    if (!targetLabelManager.labels.has(key)) {
                        targetLabelManager.add({ address: mapped, page: page, name: name });
                        count++;
                    }
                }
                return count;
            }

            // Apply all pack regions shifted by a global offset
            _applyRegionsWithOffset(pack, offset, targetRegionManager, page) {
                let count = 0;
                if (!pack.regions || !targetRegionManager) return 0;
                for (const region of pack.regions) {
                    const start = (region.start + offset) & 0xFFFF;
                    const end = (region.end + offset) & 0xFFFF;
                    if (start > end) continue;
                    const existing = targetRegionManager.get(start, page);
                    if (!existing) {
                        targetRegionManager.add({
                            start: start, end: end,
                            type: region.type || 'code', page: page,
                            comment: region.comment || ''
                        });
                        count++;
                    }
                }
                return count;
            }

            // --- .skool file parser ---

            // Parse a SkoolKit .skool file into a signature pack
            parseSkoolFile(text, packId, packName) {
                const lines = text.split(/\r?\n/);
                const labels = {};
                const regions = [];
                const comments = {};
                const asmLines = []; // collect source lines for assembler pass
                let lastAsmAddr = null;
                let currentLabel = null;
                let currentRegionStart = null;
                let currentRegionType = null;
                let lastAddr = null;
                let baseAddress = null;
                let equs = {};

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];

                    // @equ directive: symbolic constants
                    const equMatch = line.match(/^@equ=(\w+)=\$([0-9a-fA-F]+)/);
                    if (equMatch) {
                        equs[equMatch[1]] = parseInt(equMatch[2], 16);
                        continue;
                    }

                    // @label directive: next instruction gets this label
                    const labelMatch = line.match(/^@label=(\S+)/);
                    if (labelMatch) {
                        currentLabel = labelMatch[1];
                        continue;
                    }

                    // Skip other directives and blank lines
                    if (line.startsWith('@') || line.trim() === '') {
                        // End of entry — close current region
                        if (line.trim() === '' && currentRegionStart !== null && lastAddr !== null) {
                            regions.push({
                                start: currentRegionStart,
                                end: lastAddr,
                                type: currentRegionType
                            });
                            currentRegionStart = null;
                            currentRegionType = null;
                        }
                        continue;
                    }

                    // Pure comment line (entry header)
                    if (line.startsWith(';')) continue;

                    // Instruction line: control char + address + instruction [; comment]
                    const instrMatch = line.match(/^([cbtwsugir* ])(\$[0-9a-fA-F]+|\d+)\s+(.*)/);
                    if (!instrMatch) continue;

                    const control = instrMatch[1];
                    const addrStr = instrMatch[2];
                    const rest = instrMatch[3];
                    let addr;

                    if (addrStr.startsWith('$')) {
                        addr = parseInt(addrStr.substring(1), 16);
                    } else {
                        addr = parseInt(addrStr, 10);
                    }

                    if (isNaN(addr)) continue;

                    if (baseAddress === null) baseAddress = addr;
                    lastAddr = addr;

                    // Apply pending label
                    if (currentLabel) {
                        labels[addr.toString(16)] = currentLabel;
                        currentLabel = null;
                    }

                    // Map control chars to region types
                    const regionTypeMap = {
                        'c': 'code', '*': 'code',
                        'b': 'db', 'g': 'db',
                        't': 'text',
                        'w': 'dw',
                        's': 'db',
                        'u': 'db'
                    };

                    // Start new region if control char is an entry start
                    if (control !== ' ' && control !== 'i' && regionTypeMap[control]) {
                        // Close previous region
                        if (currentRegionStart !== null && lastAddr !== null) {
                            const prevAddr = lastAddr === addr ? addr - 1 : lastAddr;
                            if (prevAddr >= currentRegionStart) {
                                regions.push({
                                    start: currentRegionStart,
                                    end: prevAddr,
                                    type: currentRegionType
                                });
                            }
                        }
                        currentRegionStart = addr;
                        currentRegionType = regionTypeMap[control];
                    }

                    // Extract inline comment
                    const commentIdx = rest.indexOf(';');
                    const instrText = commentIdx >= 0 ? rest.substring(0, commentIdx).trim() : rest.trim();
                    if (commentIdx >= 0) {
                        const commentText = rest.substring(commentIdx + 1).trim()
                            .replace(/^\{/, '').replace(/\}$/, '').trim();
                        if (commentText) {
                            comments[addr.toString(16)] = commentText;
                        }
                    }

                    // Collect instruction text for assembler pass
                    if (instrText) {
                        // Insert ORG when address is not contiguous with previous
                        // (first line, or gap > 4 bytes which exceeds any single Z80 instruction)
                        if (lastAsmAddr === null || addr < lastAsmAddr || addr > lastAsmAddr + 4) {
                            asmLines.push('        ORG $' + addr.toString(16));
                        }
                        asmLines.push('        ' + instrText);
                        lastAsmAddr = addr;
                    }

                    // Auto-generate label from entry header comment
                    // If this is an entry start (c, b, t, etc.) and no @label was given
                    if (control !== ' ' && control !== 'i' && !labels[addr.toString(16)]) {
                        // Look back for a header comment like "; Routine at XXXX"
                        for (let j = i - 1; j >= Math.max(0, i - 5); j--) {
                            const prevLine = lines[j].trim();
                            if (prevLine === '') break;
                            if (prevLine.startsWith(';')) {
                                // Use first header comment as auto-label only if short
                                const headerText = prevLine.replace(/^;\s*/, '');
                                if (headerText.length <= 40 && !headerText.match(/^(Data|Routine|Unused) (block )?at /i)) {
                                    // Convert to label-safe name
                                    const safeName = headerText
                                        .replace(/[^a-zA-Z0-9_\s]/g, '')
                                        .trim()
                                        .replace(/\s+/g, '_')
                                        .toLowerCase();
                                    if (safeName.length >= 2 && safeName.length <= 32) {
                                        labels[addr.toString(16)] = safeName;
                                    }
                                }
                                break;
                            }
                        }
                    }
                }

                // Close final region
                if (currentRegionStart !== null && lastAddr !== null) {
                    regions.push({
                        start: currentRegionStart,
                        end: lastAddr,
                        type: currentRegionType
                    });
                }

                // Assemble collected lines using sjasmplus to get actual bytes
                const anchors = this._assembleSourceAndBuildAnchors(asmLines.join('\n'), labels);

                return {
                    id: packId,
                    name: packName,
                    type: 'game',
                    source: 'skool-import',
                    baseAddress: baseAddress || 0,
                    machineType: '48k',
                    anchors: anchors,
                    labels: labels,
                    regions: regions,
                    comments: comments,
                    stats: {
                        labels: Object.keys(labels).length,
                        regions: regions.length,
                        comments: Object.keys(comments).length,
                        anchors: anchors.length
                    }
                };
            }

            // Parse Z80 assembly files (sjasmplus/pasmo/z80asm format)
            // fileTexts: array of { path, text } for multi-file repos (INCLUDEs resolved)
            // or single string for one file
            parseAsmFiles(fileTexts, packId, packName) {
                // Normalize to array
                if (typeof fileTexts === 'string') {
                    fileTexts = [{ path: 'main.asm', text: fileTexts }];
                }

                // Build a lookup of path → text for INCLUDE resolution
                const fileMap = {};
                for (const f of fileTexts) {
                    // Store by multiple key variants for flexible matching
                    fileMap[f.path] = f.text;
                    fileMap[f.path.replace(/\\/g, '/')] = f.text;
                    // Also store by filename only
                    const name = f.path.split('/').pop().split('\\').pop();
                    if (!fileMap[name]) fileMap[name] = f.text;
                }

                const labels = {};
                const regions = [];
                const comments = {};
                const equs = {};
                let pc = 0;
                let baseAddress = null;
                let currentRegionStart = null;
                let currentRegionType = null;
                const processedFiles = new Set();

                // Resolve an INCLUDE path
                const resolveInclude = (includePath) => {
                    // Try exact path
                    const normalized = includePath.replace(/\\/g, '/').replace(/^\//, '');
                    if (fileMap[normalized]) return fileMap[normalized];
                    // Try without leading directory
                    const name = normalized.split('/').pop();
                    if (fileMap[name]) return fileMap[name];
                    // Try all partial matches
                    for (const key of Object.keys(fileMap)) {
                        if (key.endsWith(normalized) || key.endsWith('/' + normalized)) {
                            return fileMap[key];
                        }
                    }
                    return null;
                };

                // Process a single file's lines
                const processFile = (text, filePath) => {
                    if (processedFiles.has(filePath)) return;
                    processedFiles.add(filePath);
                    const lines = text.split(/\r?\n/);

                    for (let i = 0; i < lines.length; i++) {
                        let line = lines[i];

                        // Strip comments (but preserve for label comments)
                        const commentIdx = line.indexOf(';');
                        let comment = '';
                        if (commentIdx >= 0) {
                            comment = line.substring(commentIdx + 1).trim();
                            line = line.substring(0, commentIdx);
                        }
                        line = line.trim();
                        if (!line) continue;

                        // INCLUDE directive
                        const includeMatch = line.match(/^\s*(?:INCLUDE|include)\s+["']([^"']+)["']/i);
                        if (includeMatch) {
                            const inclText = resolveInclude(includeMatch[1]);
                            if (inclText) {
                                processFile(inclText, includeMatch[1]);
                            }
                            continue;
                        }

                        // ORG directive
                        const orgMatch = line.match(/^\s*(?:ORG|org)\s+(.+)/i);
                        if (orgMatch) {
                            // Close current region
                            if (currentRegionStart !== null && pc > currentRegionStart) {
                                regions.push({ start: currentRegionStart, end: pc - 1, type: currentRegionType });
                            }
                            currentRegionStart = null;
                            pc = this._parseAsmValue(orgMatch[1].trim(), equs);
                            if (baseAddress === null) baseAddress = pc;
                            continue;
                        }

                        // EQU / = constant
                        const equMatch = line.match(/^(\w+)\s+(?:EQU|equ|=)\s+(.+)/i);
                        if (equMatch) {
                            equs[equMatch[1]] = this._parseAsmValue(equMatch[2].trim(), equs);
                            continue;
                        }

                        // DEFINE (sjasmplus) — treat like EQU with value 1
                        const defMatch = line.match(/^\s*(?:DEFINE|define)\s+(\w+)/i);
                        if (defMatch) {
                            equs[defMatch[1]] = 1;
                            continue;
                        }

                        // Skip assembler directives we don't process
                        if (/^\s*(?:MACRO|macro|ENDM|endm|IF|IFDEF|IFNDEF|ELSE|ENDIF|STRUCT|ENDS|MODULE|ENDMODULE|OUTPUT|DEVICE|SLOT|PAGE|PHASE|DEPHASE|UNPHASE|ALIGN|ASSERT|DISPLAY|EMPTYTAP|SAVETAP|SAVEBIN|SAVESNA)/i.test(line)) {
                            continue;
                        }

                        // Label at start of line (with or without colon)
                        let label = null;
                        const labelMatch = line.match(/^(\w+):?\s*(.*)/);
                        if (labelMatch) {
                            const potentialLabel = labelMatch[1];
                            const rest = labelMatch[2].trim();

                            // Distinguish label from instruction: if rest is empty or starts with
                            // an instruction/directive, then potentialLabel is a label.
                            // If potentialLabel is a known mnemonic, it's an instruction.
                            if (!this._isZ80Mnemonic(potentialLabel)) {
                                label = potentialLabel;
                                line = rest;

                                // Store label at current PC
                                if (baseAddress !== null) {
                                    labels[pc.toString(16)] = label;
                                    if (comment) {
                                        comments[pc.toString(16)] = comment;
                                    }
                                }
                            }
                        }

                        // If line is now empty (label-only line), continue
                        if (!line) continue;

                        // Data directives
                        const dataMatch = line.match(/^\s*(DEFB|defb|DB|db|DEFM|defm|DM|dm)\s+(.*)/i);
                        if (dataMatch) {
                            const size = this._countDataBytes(dataMatch[2]);
                            if (currentRegionStart === null) {
                                currentRegionStart = pc;
                                currentRegionType = 'db';
                            }
                            pc += size;
                            continue;
                        }

                        const dwMatch = line.match(/^\s*(DEFW|defw|DW|dw)\s+(.*)/i);
                        if (dwMatch) {
                            const items = this._splitDataItems(dwMatch[2]);
                            if (currentRegionStart === null) {
                                currentRegionStart = pc;
                                currentRegionType = 'dw';
                            }
                            pc += items.length * 2;
                            continue;
                        }

                        const dsMatch = line.match(/^\s*(DEFS|defs|DS|ds)\s+(.*)/i);
                        if (dsMatch) {
                            const val = this._parseAsmValue(dsMatch[2].split(',')[0].trim(), equs);
                            if (currentRegionStart === null) {
                                currentRegionStart = pc;
                                currentRegionType = 'db';
                            }
                            pc += (val > 0 ? val : 1);
                            continue;
                        }

                        // Instruction — calculate size and advance PC
                        const instrSize = this._z80InstrSize(line, equs);
                        if (instrSize > 0) {
                            // Start code region if not in one
                            if (currentRegionStart === null) {
                                currentRegionStart = pc;
                                currentRegionType = 'code';
                            } else if (currentRegionType !== 'code') {
                                // Close data region, start code
                                regions.push({ start: currentRegionStart, end: pc - 1, type: currentRegionType });
                                currentRegionStart = pc;
                                currentRegionType = 'code';
                            }
                            pc += instrSize;
                        }
                    }
                };

                // Find main file — look for one with INCLUDE directives or ORG
                let mainFile = fileTexts[0];
                for (const f of fileTexts) {
                    if (/\bINCLUDE\b/i.test(f.text) && /\bORG\b/i.test(f.text)) {
                        mainFile = f;
                        break;
                    }
                }

                processFile(mainFile.text, mainFile.path);

                // Close final region
                if (currentRegionStart !== null && pc > currentRegionStart) {
                    regions.push({ start: currentRegionStart, end: pc - 1, type: currentRegionType });
                }

                // Assemble using the existing sjasmplus assembler to get actual bytes
                const asmResult = this._assembleAndBuildAnchors(fileTexts, mainFile, labels);
                const anchors = asmResult.anchors;

                // When the assembler provides symbols, use them to correct label
                // addresses. parseAsmFiles PC tracking drifts on macros/DUP/etc,
                // but the real assembler handles them correctly.
                let correctedLabels = labels;
                let correctedComments = comments;
                let correctedRegions = regions;
                if (asmResult.symbols) {
                    // Build labels directly from assembler symbols instead of
                    // correcting parseAsmFiles labels. The assembler handles macros,
                    // DUP, etc. correctly — its symbol addresses are authoritative.
                    const outputStart = asmResult.outputStart;
                    const outputEnd = asmResult.outputEnd;

                    // Build name→comment map from parseAsmFiles for comment preservation
                    const nameToComment = {};
                    for (const [addrStr, name] of Object.entries(labels)) {
                        if (comments[addrStr]) {
                            nameToComment[name] = comments[addrStr];
                            nameToComment[name.toLowerCase()] = comments[addrStr];
                        }
                    }

                    // Build labels from ALL assembler symbols (labels + EQU constants).
                    // EQU constants often define CALL/JP targets outside the main
                    // disassembled range — these are valid labels for a signature pack.
                    correctedLabels = {};
                    correctedComments = {};
                    const seenSymNames = new Set();
                    for (const sym of asmResult.symbols) {
                        if (!sym.name || typeof sym.value !== 'number') continue;
                        if (sym.value < 0 || sym.value > 0xFFFF) continue;
                        if (sym.name.startsWith('__')) continue;
                        // Deduplicate by name — macro expansions can create multiple
                        // symbols with the same name at different addresses
                        const lname = sym.name.toLowerCase();
                        if (seenSymNames.has(lname)) continue;
                        seenSymNames.add(lname);
                        const addrKey = sym.value.toString(16);
                        correctedLabels[addrKey] = sym.name;
                        const cmt = nameToComment[sym.name] || nameToComment[sym.name.toLowerCase()];
                        if (cmt) correctedComments[addrKey] = cmt;
                    }

                    // Replace regions with a single code extent from the assembler output
                    if (typeof asmResult.outputStart === 'number' && typeof asmResult.outputEnd === 'number') {
                        correctedRegions = [{ start: asmResult.outputStart, end: asmResult.outputEnd, type: 'code' }];
                    }

                    // Update baseAddress from assembler if available
                    if (typeof asmResult.outputStart === 'number') {
                        baseAddress = asmResult.outputStart;
                    }

                }

                return {
                    id: packId,
                    name: packName,
                    type: 'game',
                    source: 'asm-import',
                    baseAddress: baseAddress || 0,
                    machineType: '48k',
                    anchors: anchors,
                    labels: correctedLabels,
                    regions: correctedRegions,
                    comments: correctedComments,
                    stats: {
                        labels: Object.keys(correctedLabels).length,
                        regions: correctedRegions.length,
                        comments: Object.keys(correctedComments).length,
                        anchors: anchors.length
                    }
                };
            }

            // Parse a numeric value from ASM: $FF, 0FFh, 0xFF, 0b1010, 255, label
            _parseAsmValue(str, equs) {
                str = str.trim().split(/[\s,;]/)[0]; // take first token
                if (str.startsWith('$')) return parseInt(str.substring(1), 16) || 0;
                if (str.startsWith('0x') || str.startsWith('0X')) return parseInt(str.substring(2), 16) || 0;
                if (str.startsWith('0b') || str.startsWith('0B')) return parseInt(str.substring(2), 2) || 0;
                if (/^[0-9][0-9a-fA-F]*h$/i.test(str)) return parseInt(str, 16) || 0;
                if (/^\d+$/.test(str)) return parseInt(str, 10) || 0;
                if (equs && equs[str] !== undefined) return equs[str];
                return 0;
            }

            // Count bytes in a DEFB/DB/DEFM operand list
            _countDataBytes(operands) {
                let count = 0;
                let inString = false;
                let strChar = '';
                let i = 0;
                while (i < operands.length) {
                    const ch = operands[i];
                    if (inString) {
                        if (ch === strChar) { inString = false; }
                        else { count++; }
                        i++;
                    } else if (ch === '"' || ch === "'") {
                        inString = true;
                        strChar = ch;
                        i++;
                    } else if (ch === ',') {
                        i++;
                    } else if (/\s/.test(ch)) {
                        i++;
                    } else {
                        // Numeric value = 1 byte
                        count++;
                        // Skip to next comma or end
                        while (i < operands.length && operands[i] !== ',' && operands[i] !== '"' && operands[i] !== "'") i++;
                    }
                }
                return Math.max(count, 1);
            }

            // Split comma-separated data items (respecting strings)
            _splitDataItems(operands) {
                const items = [];
                let current = '';
                let inString = false;
                let strChar = '';
                for (const ch of operands) {
                    if (inString) {
                        current += ch;
                        if (ch === strChar) inString = false;
                    } else if (ch === '"' || ch === "'") {
                        current += ch;
                        inString = true;
                        strChar = ch;
                    } else if (ch === ',') {
                        if (current.trim()) items.push(current.trim());
                        current = '';
                    } else {
                        current += ch;
                    }
                }
                if (current.trim()) items.push(current.trim());
                return items;
            }

            // Check if a token is a Z80 mnemonic (not a label)
            _isZ80Mnemonic(token) {
                const upper = token.toUpperCase();
                return /^(NOP|LD|INC|DEC|RLCA|RRCA|ADD|ADC|SUB|SBC|AND|XOR|OR|CP|RLA|RRA|DAA|CPL|SCF|CCF|HALT|RET|RETI|RETN|POP|PUSH|EX|EXX|DI|EI|NEG|IM|RLC|RRC|RL|RR|SLA|SRA|SRL|SLL|BIT|RES|SET|JP|JR|DJNZ|CALL|RST|IN|OUT|OUTI|OTIR|OUTD|OTDR|INI|INIR|IND|INDR|LDI|LDIR|LDD|LDDR|CPI|CPIR|CPD|CPDR|RLD|RRD|DEFB|DB|DEFW|DW|DEFS|DS|DEFM|DM|ORG|EQU|INCLUDE)$/.test(upper);
            }

            // Calculate Z80 instruction size from mnemonic line
            _z80InstrSize(line, equs) {
                // Normalize: uppercase, collapse whitespace
                const norm = line.replace(/\s+/g, ' ').trim().toUpperCase();
                const parts = norm.split(/[\s,]+/);
                const mnem = parts[0];

                // No-operand single byte
                if (/^(NOP|RLCA|RRCA|RLA|RRA|DAA|CPL|SCF|CCF|HALT|DI|EI|EXX|RET|RETI|RETN)$/.test(mnem) && parts.length <= 1) return 1;
                if (mnem === 'RET' && parts.length > 1) return 1; // RET cc

                // EX instructions
                if (mnem === 'EX') return (norm.includes('IX') || norm.includes('IY')) ? 2 : 1;

                // RST
                if (mnem === 'RST') return 1;

                // DJNZ, JR: 2 bytes
                if (mnem === 'DJNZ' || mnem === 'JR') return 2;

                // JP: 3 bytes, except JP (HL/IX/IY)
                if (mnem === 'JP') {
                    if (norm.includes('(HL)')) return 1;
                    if (norm.includes('(IX)') || norm.includes('(IY)')) return 2;
                    return 3;
                }

                // CALL: 3 bytes
                if (mnem === 'CALL') return 3;

                // PUSH/POP: 1 byte (2 for IX/IY)
                if (mnem === 'PUSH' || mnem === 'POP') {
                    return (norm.includes('IX') || norm.includes('IY')) ? 2 : 1;
                }

                // INC/DEC
                if (mnem === 'INC' || mnem === 'DEC') {
                    if (norm.includes('(IX') || norm.includes('(IY')) return 3;
                    if (norm.includes('IX') || norm.includes('IY')) return 2;
                    return 1;
                }

                // IM
                if (mnem === 'IM') return 2;
                // NEG
                if (mnem === 'NEG') return 2;

                // Block instructions
                if (/^(LDI|LDIR|LDD|LDDR|CPI|CPIR|CPD|CPDR|INI|INIR|IND|INDR|OUTI|OTIR|OUTD|OTDR|RLD|RRD)$/.test(mnem)) return 2;

                // IN/OUT
                if (mnem === 'IN') {
                    if (norm.includes('(C)')) return 2;
                    return 2; // IN A,(n)
                }
                if (mnem === 'OUT') {
                    if (norm.includes('(C)')) return 2;
                    return 2; // OUT (n),A
                }

                // BIT/RES/SET
                if (mnem === 'BIT' || mnem === 'RES' || mnem === 'SET') {
                    if (norm.includes('(IX') || norm.includes('(IY')) return 4;
                    return 2;
                }

                // Shifts/rotates: RLC, RRC, RL, RR, SLA, SRA, SRL, SLL
                if (/^(RLC|RRC|RL|RR|SLA|SRA|SRL|SLL)$/.test(mnem)) {
                    if (norm.includes('(IX') || norm.includes('(IY')) return 4;
                    return 2;
                }

                // LD — the complex one
                if (mnem === 'LD') {
                    // LD with IX/IY+d and immediate: 4 bytes (e.g., LD (IX+d),n)
                    if ((norm.includes('(IX') || norm.includes('(IY')) && /\d+$/.test(norm.replace(/\)/g, ''))) {
                        // LD r,(IX+d) or LD (IX+d),r = 3
                        // LD (IX+d),n = 4
                        const operands = norm.substring(2).trim();
                        if (/\(I[XY][+-]\w+\)\s*,\s*[A-E,H,L]/.test(operands)) return 3;
                        if (/[A-E,H,L]\s*,\s*\(I[XY]/.test(operands)) return 3;
                        return 4; // LD (IX+d),n
                    }
                    if (norm.includes('(IX') || norm.includes('(IY')) return 3;

                    // LD SP,HL/IX/IY
                    if (/SP\s*,\s*(HL|IX|IY)/.test(norm)) {
                        return norm.includes('IX') || norm.includes('IY') ? 2 : 1;
                    }

                    // LD rr,(nn) or LD (nn),rr — ED prefix for non-HL
                    if (/\(\w+\)\s*,\s*(HL|BC|DE|SP)/.test(norm) && !/\(I[XY]/.test(norm)) {
                        const reg = norm.match(/(HL|BC|DE|SP)/);
                        if (reg && reg[1] === 'HL') return 3;
                        return 4; // ED prefix
                    }
                    if (/(BC|DE|SP|HL)\s*,\s*\(\w+\)/.test(norm) && !/\(I[XY]/.test(norm)) {
                        const reg = norm.match(/(HL|BC|DE|SP)/);
                        if (reg && reg[1] === 'HL') return 3;
                        return 4; // ED prefix
                    }

                    // LD (nn),A or LD A,(nn): 3 bytes
                    if (/\(\$?\w+\)\s*,\s*A/.test(norm) && !/\([BCDEHL]\)/.test(norm) && !/\(I[XY]/.test(norm)) return 3;
                    if (/A\s*,\s*\(\$?\w+\)/.test(norm) && !/\([BCDEHL]\)/.test(norm) && !/\(I[XY]/.test(norm)) return 3;

                    // LD r,n (immediate byte): 2 bytes
                    if (/^LD\s+[A-E,H,L]\s*,\s*/.test(norm) && !/\(/.test(norm)) {
                        const operand = parts[parts.length - 1];
                        // If operand is a register, it's LD r,r = 1 byte
                        if (/^[A-E,H,L]$/.test(operand)) return 1;
                        return 2; // LD r,n
                    }

                    // LD A,I / LD A,R / LD I,A / LD R,A: 2 bytes (ED prefix)
                    if (/[AIR]\s*,\s*[IR]/.test(norm)) return 2;

                    // LD rr,nn (16-bit immediate): 3 bytes (4 for IX/IY)
                    if (/(BC|DE|HL|SP|IX|IY)\s*,/.test(norm)) {
                        if (norm.includes('IX') || norm.includes('IY')) return 4;
                        return 3;
                    }

                    // LD r,(HL) or LD (HL),r or LD r,r: 1 byte
                    if (/\(HL\)/.test(norm)) {
                        // LD (HL),n = 2 bytes
                        const afterComma = norm.split(',')[1]?.trim();
                        if (afterComma && !/^[A-E,H,L]$/.test(afterComma) && afterComma !== '(HL)') return 2;
                        return 1;
                    }
                    if (/\((BC|DE)\)/.test(norm)) return 1;

                    return 1; // LD r,r fallback
                }

                // ADD/ADC/SUB/SBC/AND/XOR/OR/CP
                if (/^(ADD|ADC|SUB|SBC|AND|XOR|OR|CP)$/.test(mnem)) {
                    if (norm.includes('IX') || norm.includes('IY')) {
                        if (norm.includes('(IX') || norm.includes('(IY')) return 3;
                        return 2;
                    }
                    // ADD HL,rr = 1 byte; ADD A,n = 2; ADD A,r = 1
                    if (/(HL|BC|DE|SP)\s*,\s*(HL|BC|DE|SP)/.test(norm)) {
                        return /^(ADC|SBC)$/.test(mnem) ? 2 : 1; // ADC/SBC HL,rr = ED prefix
                    }
                    if (norm.includes('(HL)')) return 1;
                    // Check if operand is register
                    const lastOp = parts[parts.length - 1];
                    if (/^[A-E,H,L]$/.test(lastOp) || lastOp === 'A') return 1;
                    return 2; // immediate
                }

                // Fallback: assume 1 byte for unknown
                return 1;
            }

            // Build a mask for anchor bytes that marks 16-bit address operands as
            // don't-care (0x00). This allows anchors to match even when absolute
            // addresses differ between games (e.g. CALL $8100 vs CALL $8050).
            // Opcode and 8-bit operand bytes are marked 0xFF (must match exactly).
            _z80AddrMask(bytes) {
                const n = bytes.length;
                const mask = new Array(n).fill(0xFF);
                let i = 0;
                while (i < n) {
                    const b = bytes[i];

                    // DD/FD prefix (IX/IY instructions)
                    if ((b === 0xDD || b === 0xFD) && i + 1 < n) {
                        const b2 = bytes[i + 1];
                        if (b2 === 0xCB) {
                            i += 4; continue;                                   // DD/FD CB d op — 4 bytes, no addr
                        }
                        if (b2 === 0x21 || b2 === 0x22 || b2 === 0x2A) {        // LD IX/IY,nn / LD (nn),IX/IY / LD IX/IY,(nn)
                            if (i + 3 < n) { mask[i + 2] = 0; mask[i + 3] = 0; }
                            i += 4; continue;
                        }
                        // DD/FD + CALL/JP nn variants
                        if (b2 === 0xCD || b2 === 0xC3 || (b2 & 0xC7) === 0xC2 || (b2 & 0xC7) === 0xC4) {
                            if (i + 3 < n) { mask[i + 2] = 0; mask[i + 3] = 0; }
                            i += 4; continue;
                        }
                        // DD/FD + instruction with displacement byte (e.g. LD (IX+d),r)
                        // These are 3 bytes: prefix, opcode, displacement — no 16-bit addr
                        // Most DD/FD instructions: check if next byte is a normal 1-byte op
                        // Treat prefix as transparent, process next byte normally
                        i++; continue;
                    }

                    // ED prefix
                    if (b === 0xED && i + 1 < n) {
                        const b2 = bytes[i + 1];
                        // LD (nn),rr / LD rr,(nn): ED 43/4B/53/5B/63/6B/73/7B nn nn
                        if ((b2 & 0xC7) === 0x43 || (b2 & 0xC7) === 0x4B) {
                            if (i + 3 < n) { mask[i + 2] = 0; mask[i + 3] = 0; }
                            i += 4; continue;
                        }
                        i += 2; continue;                                       // Other ED ops are 2 bytes
                    }

                    // CB prefix — all 2 bytes, no addresses
                    if (b === 0xCB) { i += 2; continue; }

                    // Unprefixed instructions with 16-bit immediate (3 bytes)
                    if (b === 0x01 || b === 0x11 || b === 0x21 || b === 0x31 || // LD rr,nn
                        b === 0x22 || b === 0x2A ||                             // LD (nn),HL / LD HL,(nn)
                        b === 0x32 || b === 0x3A ||                             // LD (nn),A / LD A,(nn)
                        b === 0xC3 || b === 0xCD ||                             // JP nn / CALL nn
                        (b & 0xC7) === 0xC2 ||                                  // JP cc,nn
                        (b & 0xC7) === 0xC4) {                                  // CALL cc,nn
                        if (i + 2 < n) { mask[i + 1] = 0; mask[i + 2] = 0; }
                        i += 3; continue;
                    }

                    // 2-byte instructions (8-bit immediate, relative jumps)
                    if (b === 0x06 || b === 0x0E || b === 0x16 || b === 0x1E || // LD r,n
                        b === 0x26 || b === 0x2E || b === 0x36 || b === 0x3E || // LD r,n / LD (HL),n
                        b === 0xC6 || b === 0xCE || b === 0xD6 || b === 0xDE || // ADD/ADC/SUB/SBC A,n
                        b === 0xE6 || b === 0xEE || b === 0xF6 || b === 0xFE || // AND/XOR/OR/CP n
                        b === 0xD3 || b === 0xDB ||                             // OUT (n),A / IN A,(n)
                        b === 0x10 || b === 0x18 ||                             // DJNZ / JR
                        b === 0x20 || b === 0x28 || b === 0x30 || b === 0x38) { // JR cc
                        i += 2; continue;
                    }

                    // Everything else: 1-byte instruction
                    i++;
                }

                // If mask is all 0xFF, return null (no masking needed — slightly faster matching)
                return mask.some(m => m === 0) ? mask : null;
            }

            // Use the existing sjasmplus assembler to assemble source files into bytes,
            // then build anchors from the output at each labeled address.
            _assembleAndBuildAnchors(fileTexts, mainFile, labels, anchorLen = 16) {
                if (typeof Assembler === 'undefined' || typeof VFS === 'undefined') return { anchors: [], symbols: null };
                try {
                    // Add all files to VFS for INCLUDE resolution
                    VFS.reset();
                    for (const f of fileTexts) {
                        VFS.addFile(f.path, f.text);
                    }
                    // Assemble
                    const result = Assembler.assembleProject(mainFile.path);
                    if (!result || !result.success || !result.output || result.output.length === 0) return { anchors: [], symbols: null };

                    const output = result.output;
                    const outputStart = result.outputStart;
                    const symbols = result.symbols || [];

                    // Build anchors from assembled bytes at each symbol address.
                    // Uses assembler symbols directly (not parseAsmFiles labels).
                    // EQU constants outside the output range are naturally skipped
                    // by the offset bounds check below.
                    const anchors = [];
                    const anchoredNames = new Set();
                    for (const sym of symbols) {
                        if (!sym.name || typeof sym.value !== 'number') continue;
                        if (sym.value < 0 || sym.value > 0xFFFF) continue;
                        if (sym.name.startsWith('__')) continue;
                        const lname = sym.name.toLowerCase();
                        if (anchoredNames.has(lname)) continue;
                        anchoredNames.add(lname);

                        const addr = sym.value;
                        const offset = addr - outputStart;
                        if (offset < 0 || offset >= output.length) continue;

                        // Collect up to anchorLen consecutive bytes
                        const bytes = [];
                        let allZero = true, allFF = true;
                        for (let i = 0; i < anchorLen && offset + i < output.length; i++) {
                            const b = output[offset + i];
                            bytes.push(b);
                            if (b !== 0x00) allZero = false;
                            if (b !== 0xFF) allFF = false;
                        }

                        if (bytes.length < 4) continue;
                        if (allZero || allFF) continue;

                        anchors.push({ address: addr, bytes: bytes, mask: this._z80AddrMask(bytes), label: sym.name });
                    }
                    return { anchors, symbols, outputStart, outputEnd: outputStart + output.length - 1 };
                } catch (e) {
                    console.warn('Signature assembler failed, anchors not built:', e.message);
                    return { anchors: [], symbols: null };
                }
            }

            // Assemble a single source string and build anchors from the output.
            // Used by the skool parser (which converts skool → ASM text first).
            _assembleSourceAndBuildAnchors(source, labels, anchorLen = 16) {
                if (typeof Assembler === 'undefined' || !source.trim()) return [];
                try {
                    const result = Assembler.assemble(source, '<skool-import>');
                    if (!result || !result.success || !result.output || result.output.length === 0) return [];

                    const output = result.output;
                    const outputStart = result.outputStart;
                    const anchors = [];

                    for (const [addrStr, name] of Object.entries(labels)) {
                        const addr = parseInt(addrStr, 16) || parseInt(addrStr, 10);
                        if (isNaN(addr)) continue;

                        const offset = addr - outputStart;
                        if (offset < 0 || offset >= output.length) continue;

                        const bytes = [];
                        let allZero = true, allFF = true;
                        for (let i = 0; i < anchorLen && offset + i < output.length; i++) {
                            const b = output[offset + i];
                            bytes.push(b);
                            if (b !== 0x00) allZero = false;
                            if (b !== 0xFF) allFF = false;
                        }

                        if (bytes.length < 4) continue;
                        if (allZero || allFF) continue;

                        anchors.push({ address: addr, bytes: bytes, mask: this._z80AddrMask(bytes), label: name });
                    }
                    return anchors;
                } catch (e) {
                    console.warn('Skool assembler failed, anchors not built:', e.message);
                    return [];
                }
            }

            // Build/rebuild anchors from current emulator memory for a pack.
            // Use this when anchors weren't auto-built at import time (e.g., JSON pack
            // without anchors), or to refresh anchors using the actual loaded game binary.
            buildAnchorsFromMemory(pack, readByte) {
                const anchors = [];
                const anchorLen = 16; // bytes per anchor

                // Build anchor for every label in the pack
                const entries = [];
                for (const [addrStr, name] of Object.entries(pack.labels)) {
                    const addr = parseInt(addrStr, 16) || parseInt(addrStr, 10);
                    if (isNaN(addr) || addr > 0xFFFF) continue;
                    entries.push({ addr, name });
                }
                entries.sort((a, b) => a.addr - b.addr);

                for (const entry of entries) {
                    const addr = entry.addr;
                    // Skip if too close to end of address space
                    if (addr + anchorLen > 0x10000) continue;

                    // Read bytes from memory
                    const bytes = [];
                    let allZero = true;
                    let allFF = true;
                    for (let j = 0; j < anchorLen; j++) {
                        const b = readByte(addr + j);
                        bytes.push(b);
                        if (b !== 0x00) allZero = false;
                        if (b !== 0xFF) allFF = false;
                    }

                    // Skip trivial patterns (all zeros, all FF — likely uninitialised memory)
                    if (allZero || allFF) continue;

                    anchors.push({
                        address: addr,
                        bytes: bytes,
                        mask: this._z80AddrMask(bytes),
                        label: entry.name
                    });
                }
                return anchors;
            }

            // --- Persistence ---

            _saveEnabledState() {
                try {
                    const state = {};
                    for (const p of this.packs) state[p.id] = p.enabled;
                    localStorage.setItem('zxm8_sigpacks_enabled', JSON.stringify(state));
                } catch(e) {}
            }

            _loadEnabledState() {
                try {
                    const json = localStorage.getItem('zxm8_sigpacks_enabled');
                    return json ? JSON.parse(json) : null;
                } catch(e) { return null; }
            }

            _savePackToStorage(pack) {
                try {
                    localStorage.setItem('zxm8_sigpack_' + pack.id, JSON.stringify(pack));
                } catch(e) {
                    console.warn('Failed to save pack to localStorage:', pack.id, e);
                }
            }

            _loadPackFromStorage(id) {
                try {
                    const json = localStorage.getItem('zxm8_sigpack_' + id);
                    return json ? JSON.parse(json) : null;
                } catch(e) { return null; }
            }

            // Save index of user-imported packs to localStorage
            _saveCustomIndex() {
                try {
                    const customPacks = this.packs.filter(p =>
                        this._loadPackFromStorage(p.id) !== null
                    );
                    localStorage.setItem('zxm8_sigpacks_custom', JSON.stringify(customPacks));
                } catch(e) {}
            }

            // Merge custom packs from localStorage into the index
            _loadCustomIndex() {
                try {
                    const json = localStorage.getItem('zxm8_sigpacks_custom');
                    if (!json) return;
                    const custom = JSON.parse(json);
                    for (const entry of custom) {
                        if (!this.packs.find(p => p.id === entry.id)) {
                            this.packs.push(entry);
                        }
                    }
                } catch(e) {}
            }

            // Full init: load index + merge custom + load enabled
            async init() {
                await this.loadIndex();
                this._loadCustomIndex();
                // Restore enabled state after merge
                const saved = this._loadEnabledState();
                if (saved) {
                    for (const p of this.packs) {
                        if (saved[p.id] !== undefined) p.enabled = saved[p.id];
                    }
                }
            }

            // Export pack as downloadable JSON
            exportPack(id) {
                const pack = this.loadedPacks[id];
                if (!pack) return null;
                return JSON.stringify(pack, null, 2);
            }

            // Import pack from JSON string
            importPackJSON(jsonStr) {
                try {
                    const pack = JSON.parse(jsonStr);
                    if (!pack.id || !pack.name) {
                        console.warn('Invalid pack: missing id or name');
                        return null;
                    }
                    return this.addPack(pack);
                } catch(e) {
                    console.warn('Failed to parse pack JSON:', e);
                    return null;
                }
            }

            getPackCount() { return this.packs.length; }
            getEnabledCount() { return this.packs.filter(p => p.enabled).length; }
        }

        const signaturePackManager = new SignaturePackManager();

        // ========== Test Runner ==========
        class TestRunner {
            constructor(spectrum) {
                this.spectrum = spectrum;
                this.tests = [];
                this.results = [];
                this.running = false;
                this.aborted = false;
                this.currentTest = null;
                this.currentStep = 0;
                this.totalTstates = 0;

                // UI elements
                this.elements = {
                    status: document.getElementById('testsStatus'),
                    tableBody: document.getElementById('testsTableBody'),
                    selectAll: document.getElementById('testsSelectAll'),
                    btnRunSelected: document.getElementById('btnRunSelectedTests'),
                    btnAbort: document.getElementById('btnAbortTests'),
                    btnReload: document.getElementById('btnReloadTests'),
                    progressSection: document.getElementById('testsProgressSection'),
                    progressText: document.getElementById('testsProgressText'),
                    progressPercent: document.getElementById('testsProgressPercent'),
                    progressFill: document.getElementById('testsProgressFill'),
                    frameCount: document.getElementById('testsFrameCount'),
                    tstateCount: document.getElementById('testsTstateCount'),
                    comparisonSection: document.getElementById('testsComparisonSection'),
                    comparisonResult: document.getElementById('testsComparisonResult'),
                    expectedCanvas: document.getElementById('testsExpectedCanvas'),
                    actualCanvas: document.getElementById('testsActualCanvas'),
                    chkHighlightDiff: document.getElementById('chkHighlightDiff'),
                    summarySection: document.getElementById('testsSummarySection'),
                    passed: document.getElementById('testsPassed'),
                    failed: document.getElementById('testsFailed'),
                    skipped: document.getElementById('testsSkipped'),
                    time: document.getElementById('testsTime'),
                    fps: document.getElementById('testsFps'),
                    resultsBody: document.getElementById('testsResultsBody'),
                    // Preview mode elements
                    btnPreview: document.getElementById('btnPreviewTest'),
                    btnPausePreview: document.getElementById('btnPausePreview'),
                    btnCopyFrame: document.getElementById('btnCopyFrame'),
                    btnScreenshot: document.getElementById('btnTestScreenshot'),
                    btnStopPreview: document.getElementById('btnStopPreview'),
                    previewSection: document.getElementById('testsPreviewSection'),
                    previewFrame: document.getElementById('testsPreviewFrame'),
                    previewCanvas: document.getElementById('testsPreviewCanvas'),
                    previewInfo: document.getElementById('testsPreviewInfo')
                };

                // Preview mode state
                this.previewing = false;
                this.previewPaused = false;
                this.previewFrameCount = 0;

                // Category filtering
                this.currentCategory = 'all';
                this.categoryTabs = document.getElementById('testsCategoryTabs');

                // Keyboard map for special keys
                this.keyMap = {
                    'ENTER': 'Enter', 'SPACE': ' ', 'SHIFT': 'Shift', 'CTRL': 'Control',
                    'UP': 'ArrowUp', 'DOWN': 'ArrowDown', 'LEFT': 'ArrowLeft', 'RIGHT': 'ArrowRight',
                    'BREAK': 'Escape', 'CAPS': 'CapsLock'
                };

                this.bindEvents();
            }

            bindEvents() {
                this.elements.btnReload?.addEventListener('click', () => this.loadTests());
                this.elements.btnRunSelected?.addEventListener('click', () => this.runSelected());
                this.elements.btnAbort?.addEventListener('click', () => this.abort());
                this.elements.selectAll?.addEventListener('change', (e) => this.toggleSelectAll(e.target.checked));
                this.elements.btnPreview?.addEventListener('click', () => this.startPreview());
                this.elements.btnPausePreview?.addEventListener('click', () => this.togglePausePreview());
                this.elements.btnCopyFrame?.addEventListener('click', () => this.copyFrameCount());
                this.elements.btnScreenshot?.addEventListener('click', () => this.saveScreenshot());
                this.elements.btnStopPreview?.addEventListener('click', () => this.stopPreview());

                // Category tab clicks
                this.categoryTabs?.addEventListener('click', (e) => {
                    const tab = e.target.closest('.tests-category-tab');
                    if (tab) {
                        this.setCategory(tab.dataset.category);
                    }
                });
            }

            async loadTests(url = 'tests.json') {
                this.updateStatus('Loading tests...');
                try {
                    // Add cache-busting to ensure fresh data
                    const cacheBuster = `?_=${Date.now()}`;
                    const response = await fetch(url + cacheBuster);
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    const data = await response.json();
                    this.tests = data.tests || [];
                    this.renderTestList();
                    this.updateCategoryCounts();
                    this.updateStatus(`${this.tests.length} tests loaded`);
                    this.elements.btnRunSelected.disabled = false;
                    this.elements.btnPreview.disabled = false;
                } catch (e) {
                    this.updateStatus(`Failed to load tests: ${e.message}`);
                    this.tests = [];
                    this.renderTestList();
                }
            }

            renderTestList() {
                const tbody = this.elements.tableBody;
                tbody.innerHTML = '';

                for (const test of this.tests) {
                    const isEnabled = test.enabled !== false; // Default to true
                    const category = test.category || 'other';
                    const isVisible = this.currentCategory === 'all' || category === this.currentCategory;

                    const tr = document.createElement('tr');
                    tr.dataset.testId = test.id;
                    tr.dataset.category = category;
                    if (!isEnabled) tr.classList.add('tests-row-disabled');
                    if (!isVisible) tr.style.display = 'none';
                    tr.innerHTML = `
                        <td class="tests-col-check"><input type="checkbox" class="test-checkbox" ${isEnabled ? 'checked' : 'disabled'}></td>
                        <td class="tests-col-name">${this.escapeHtml(test.name)}</td>
                        <td class="tests-col-machine">${test.machine || '48k'}</td>
                        <td class="tests-col-file">${this.escapeHtml(test.file)}</td>
                        <td class="tests-col-result tests-result-pending">${isEnabled ? '-' : 'disabled'}</td>
                    `;
                    tbody.appendChild(tr);
                }
            }

            setCategory(category) {
                this.currentCategory = category;

                // Update tab styling
                const tabs = this.categoryTabs?.querySelectorAll('.tests-category-tab');
                tabs?.forEach(tab => {
                    tab.classList.toggle('active', tab.dataset.category === category);
                });

                // Filter visible rows
                const rows = this.elements.tableBody.querySelectorAll('tr');
                rows.forEach(row => {
                    const rowCategory = row.dataset.category;
                    const isVisible = category === 'all' || rowCategory === category;
                    row.style.display = isVisible ? '' : 'none';
                });

                // Update select-all checkbox state
                this.updateSelectAllState();
            }

            updateSelectAllState() {
                const visibleCheckboxes = Array.from(this.elements.tableBody.querySelectorAll('tr'))
                    .filter(row => row.style.display !== 'none')
                    .map(row => row.querySelector('.test-checkbox:not(:disabled)'))
                    .filter(Boolean);

                const allChecked = visibleCheckboxes.length > 0 && visibleCheckboxes.every(cb => cb.checked);
                if (this.elements.selectAll) {
                    this.elements.selectAll.checked = allChecked;
                }
            }

            updateCategoryCounts() {
                const counts = { all: this.tests.length };
                for (const test of this.tests) {
                    const cat = test.category || 'other';
                    counts[cat] = (counts[cat] || 0) + 1;
                }

                const tabs = this.categoryTabs?.querySelectorAll('.tests-category-tab');
                tabs?.forEach(tab => {
                    const cat = tab.dataset.category;
                    const count = counts[cat] || 0;
                    const countSpan = tab.querySelector('.count');
                    if (countSpan) {
                        countSpan.textContent = `(${count})`;
                    } else if (count > 0 || cat === 'all') {
                        tab.innerHTML = `${tab.textContent.split('(')[0].trim()} <span class="count">(${count})</span>`;
                    }
                });
            }

            escapeHtml(str) {
                const div = document.createElement('div');
                div.textContent = str;
                return div.innerHTML;
            }

            toggleSelectAll(checked) {
                // Only toggle visible (filtered) tests
                const rows = this.elements.tableBody.querySelectorAll('tr');
                rows.forEach(row => {
                    if (row.style.display !== 'none') {
                        const cb = row.querySelector('.test-checkbox:not(:disabled)');
                        if (cb) cb.checked = checked;
                    }
                });
            }

            getSelectedTests() {
                const selected = [];
                const rows = this.elements.tableBody.querySelectorAll('tr');
                rows.forEach(row => {
                    // Only include visible (filtered) rows
                    if (row.style.display === 'none') return;
                    const checkbox = row.querySelector('.test-checkbox');
                    if (checkbox?.checked) {
                        const testId = row.dataset.testId;
                        const test = this.tests.find(t => t.id === testId);
                        if (test) selected.push(test);
                    }
                });
                return selected;
            }

            updateStatus(text) {
                if (this.elements.status) this.elements.status.textContent = text;
            }

            async runAll() {
                // Only run enabled tests
                const enabledTests = this.tests.filter(t => t.enabled !== false);
                await this.runTests(enabledTests);
            }

            async runSelected() {
                const selected = this.getSelectedTests();
                if (selected.length === 0) {
                    this.updateStatus('No tests selected');
                    return;
                }
                await this.runTests(selected);
            }

            async runTests(tests) {
                if (this.running) return;
                this.running = true;
                this.aborted = false;
                this.results = [];

                let passed = 0, failed = 0, skipped = 0;
                const startTime = performance.now();
                let totalFramesRun = 0;

                try {
                    // UI updates
                    this.elements.btnRunSelected.disabled = true;
                    this.elements.btnAbort.classList.remove('hidden');
                    this.elements.progressSection.classList.remove('hidden');
                    this.elements.previewSection.classList.add('hidden');
                    this.elements.comparisonSection.classList.add('hidden');
                    this.elements.summarySection.classList.add('hidden');

                    // Reset result column for enabled tests only
                    this.elements.tableBody.querySelectorAll('tr').forEach(row => {
                        const testId = row.dataset.testId;
                        const test = this.tests.find(t => t.id === testId);
                        const td = row.querySelector('.tests-col-result');
                        if (td && test && test.enabled !== false) {
                            td.textContent = '-';
                            td.className = 'tests-col-result tests-result-pending';
                        }
                    });

                    for (let i = 0; i < tests.length; i++) {
                        if (this.aborted) {
                            skipped = tests.length - i;
                            break;
                        }

                        const test = tests[i];
                        this.currentTest = test;
                        this.updateProgress(i + 1, tests.length, test.name, 0, 1, 1, test.steps.length);

                        // Update row to show running
                        this.setTestResult(test.id, 'running', '...');

                        try {
                            const result = await this.runSingleTest(test);
                            totalFramesRun += this.totalFrames;
                            this.results.push({ test, result });

                            if (result.passed) {
                                passed++;
                                this.setTestResult(test.id, 'pass', 'PASS');
                            } else {
                                failed++;
                                const detail = result.diff ? `${result.diff.diffCount} pixels` : result.error || 'FAIL';
                                this.setTestResult(test.id, 'fail', detail);
                            }
                        } catch (e) {
                            failed++;
                            totalFramesRun += this.totalFrames;
                            this.results.push({ test, result: { passed: false, error: e.message } });
                            this.setTestResult(test.id, 'fail', e.message);
                        }
                    }

                    // Show summary
                    const elapsedMs = performance.now() - startTime;
                    const elapsedSec = elapsedMs / 1000;
                    const avgFps = totalFramesRun > 0 ? Math.round(totalFramesRun / elapsedSec) : 0;

                    this.elements.passed.textContent = passed;
                    this.elements.failed.textContent = failed;
                    this.elements.skipped.textContent = skipped;
                    this.elements.time.textContent = elapsedSec.toFixed(1);
                    this.elements.fps.textContent = avgFps;
                    this.renderResultsSummary();
                    this.elements.summarySection.classList.remove('hidden');
                    this.updateStatus(`Done: ${passed} passed, ${failed} failed, ${skipped} skipped (${elapsedSec.toFixed(1)}s, ${avgFps} fps)`);

                } finally {
                    // Always reset state
                    this.running = false;
                    this.currentTest = null;
                    this.elements.btnRunSelected.disabled = false;
                    this.elements.btnPreview.disabled = false;
                    this.elements.btnAbort.classList.add('hidden');
                    this.elements.progressSection.classList.add('hidden');

                    // Always update canvas size after tests (in case dimensions changed)
                    if (typeof updateCanvasSize === 'function') {
                        updateCanvasSize();
                    }

                    // Refresh main canvas after tests complete
                    this.spectrum.redraw();
                }
            }

            setTestResult(testId, status, text) {
                const row = this.elements.tableBody.querySelector(`tr[data-test-id="${testId}"]`);
                if (row) {
                    const td = row.querySelector('.tests-col-result');
                    td.textContent = text;
                    td.className = `tests-col-result tests-result-${status}`;
                }
            }

            updateProgress(testNum, totalTests, testName, frame, totalFrames, stepNum, totalSteps) {
                const percent = Math.round((frame / totalFrames) * 100);
                const stepInfo = totalSteps > 1 ? ` (${stepNum}/${totalSteps})` : '';
                this.elements.progressText.textContent = `Test ${testNum}/${totalTests}: ${testName}${stepInfo}`;
                this.elements.progressPercent.textContent = `${percent}%`;
                this.elements.progressFill.style.width = `${percent}%`;
                this.elements.frameCount.textContent = `Frame: ${frame}/${totalFrames}`;
                this.elements.tstateCount.textContent = `T-states: ${this.totalTstates.toLocaleString()}`;
            }

            async runSingleTest(test) {
                // Save current machine state
                const savedMachine = this.spectrum.machineType;
                const savedPalette = paletteSelect?.value || 'default';
                const savedFullBorder = this.spectrum.ula.fullBorderMode;
                const savedLateTimings = this.spectrum.lateTimings;
                const wasRunning = this.spectrum.running;
                if (wasRunning) this.spectrum.stop();

                try {
                    // Configure machine if needed
                    if (test.machine && test.machine !== this.spectrum.machineType) {
                        await this.switchMachine(test.machine);
                    }

                    // Apply timing settings if specified
                    if (test.earlyTimings !== undefined) {
                        this.spectrum.setEarlyTimings?.(test.earlyTimings);
                    }

                    // Apply full border mode if specified (default to true for tests)
                    const useFullBorder = test.fullBorder !== undefined ? test.fullBorder : true;
                    if (this.spectrum.ula.setFullBorder(useFullBorder)) {
                        this.spectrum.updateDisplayDimensions();
                    }

                    // Reset and load file
                    this.spectrum.reset();

                    // Apply ULAplus AFTER reset (default: disabled)
                    // Must be after reset to avoid being cleared
                    // Always reset ULA+ first to clear palette from previous tests
                    this.spectrum.ula.resetULAplus();
                    const enableUlaplus = test.ulaplus === true;
                    this.spectrum.ula.ulaplus.enabled = enableUlaplus;
                    if (enableUlaplus) {
                        this.spectrum.ula.ulaplus.paletteEnabled = true;  // Enable palette mode for tests
                    }
                    updateULAplusStatus?.();

                    // Apply palette if specified
                    if (test.palette && typeof applyPalette === 'function') {
                        applyPalette(test.palette);
                    }
                    this.spectrum.tapeLoader.rewind();

                    // Recreate tape trap to ensure clean state
                    this.spectrum.tapeTrap = new TapeTrapHandler(
                        this.spectrum.cpu,
                        this.spectrum.memory,
                        this.spectrum.tapeLoader
                    );
                    this.spectrum.tapeTrap.setEnabled(this.spectrum.tapeTrapsEnabled);

                    // Ensure keyboard is fully released
                    this.spectrum.ula.keyboardState.fill(0xFF);

                    this.currentTest = test;
                    await this.loadTestFile(test.file, test.zipEntry);

                    this.totalTstates = 0;
                    this.totalFrames = 0;

                    // Execute each step (frames are absolute from test start)
                    for (let stepIdx = 0; stepIdx < test.steps.length; stepIdx++) {
                        if (this.aborted) return { passed: false, error: 'Aborted' };

                        const step = test.steps[stepIdx];
                        this.currentStep = stepIdx;

                        const stepResult = await this.runStep(step, test, stepIdx);
                        if (!stepResult.passed) {
                            return stepResult;
                        }
                    }

                    return { passed: true };

                } finally {
                    // Restore machine state FIRST (creates new ULA)
                    if (test.machine && test.machine !== savedMachine) {
                        await this.switchMachine(savedMachine);
                    }
                    // Restore full border mode AFTER machine switch (new ULA loses settings)
                    if (this.spectrum.ula.setFullBorder(savedFullBorder)) {
                        this.spectrum.updateDisplayDimensions();
                    }
                    // Restore palette if changed
                    if (test.palette && typeof applyPalette === 'function') {
                        applyPalette(savedPalette);
                    }
                    // Restore timing settings
                    this.spectrum.setLateTimings(savedLateTimings);
                }
            }

            async switchMachine(machineType) {
                // Map test machine types to spectrum machine types
                const machineMap = {
                    '48k': '48k',
                    '128k': '128k',
                    '+2': '+2', 'plus2': '+2',
                    '+2a': '+2a', 'plus2a': '+2a',
                    '+3': '+3', 'plus3': '+3',
                    'pentagon': 'pentagon', 'p128': 'pentagon',
                    'pentagon1024': 'pentagon1024',
                    'scorpion': 'scorpion'
                };
                const targetMachine = machineMap[machineType.toLowerCase()] || '48k';

                if (this.spectrum.machineType !== targetMachine) {
                    this.spectrum.setMachineType(targetMachine);

                    // Load appropriate ROM for the new machine type
                    loadRomsForMachineType(this.spectrum, targetMachine);

                    this.spectrum.reset();

                    // Reset disassembler to use fresh memory reference
                    if (typeof disasm !== 'undefined') disasm = null;

                    // Update ULAplus status UI
                    if (typeof updateULAplusStatus === 'function') updateULAplusStatus();
                }
            }

            // Reload ROM if snapshot loading changed machine type and invalidated ROM
            reloadRomIfNeeded() {
                if (this.spectrum.romLoaded) return;
                loadRomsForMachineType(this.spectrum, this.spectrum.machineType);
            }

            async loadTestFile(filePath, zipEntry) {
                const response = await fetch(filePath);
                if (!response.ok) throw new Error(`Failed to load ${filePath}`);
                const data = new Uint8Array(await response.arrayBuffer());

                // Determine file type and load
                const ext = filePath.split('.').pop().toLowerCase();

                // Update filename display (extract just the filename from path)
                const displayName = zipEntry || filePath.split('/').pop();
                if (typeof updateMediaIndicator === 'function') {
                    updateMediaIndicator(displayName, ext === 'tap' ? 'tape' : (ext === 'trd' || ext === 'scl') ? 'disk' : null);
                }

                if (ext === 'tap') {
                    // Load TAP file and set trap BEFORE simulating LOAD command
                    this.spectrum.tapeLoader.load(data);
                    this.spectrum.tapeTrap.setTape(this.spectrum.tapeLoader);

                    // Simulate LOAD "" keypresses (trap is now ready)
                    await this.injectLoadCommand();
                } else if (ext === 'sna') {
                    this.spectrum.loadSnapshot(data);  // Auto-switches machine
                    this.reloadRomIfNeeded();
                } else if (ext === 'z80') {
                    this.spectrum.loadZ80Snapshot(data);  // Auto-switches machine
                    this.reloadRomIfNeeded();
                } else if (ext === 'szx') {
                    this.spectrum.loadSZXSnapshot(data);
                    this.reloadRomIfNeeded();
                } else if (ext === 'rzx') {
                    await this.spectrum.loadRZX(data);
                    this.reloadRomIfNeeded();
                } else if (ext === 'zip') {
                    // Handle ZIP files - extract specific entry or first compatible file
                    const spectrumFiles = await ZipLoader.findAllSpectrum(data.buffer);

                    if (spectrumFiles.length === 0) {
                        throw new Error('No compatible files found in ZIP');
                    }

                    let fileToLoad;
                    if (zipEntry) {
                        // Find specific entry by name
                        fileToLoad = spectrumFiles.find(f =>
                            f.name === zipEntry ||
                            f.name.toLowerCase() === zipEntry.toLowerCase() ||
                            f.name.endsWith('/' + zipEntry) ||
                            f.name.toLowerCase().endsWith('/' + zipEntry.toLowerCase())
                        );
                        if (!fileToLoad) {
                            throw new Error(`ZIP entry not found: ${zipEntry}`);
                        }
                    } else {
                        // Use first compatible file
                        fileToLoad = spectrumFiles[0];
                    }

                    // Load the extracted file
                    const innerExt = fileToLoad.name.split('.').pop().toLowerCase();
                    await this.loadExtractedFile(fileToLoad.data, fileToLoad.name, innerExt);
                } else if (ext === 'trd' || ext === 'scl') {
                    // Disk images - load disk, boot TR-DOS, run program
                    this.spectrum.loadDiskImage(data.buffer, ext, filePath);
                    const diskRun = this.currentTest ? (this.currentTest.diskRun || 'boot') : 'boot';
                    await this.injectDiskRunCommand(diskRun);
                } else if (ext === 'dsk') {
                    // DSK disk image - load into FDC, boot +3 from disk
                    this.spectrum.loadDSKImage(new Uint8Array(data.buffer), filePath);
                    await this.bootPlus3Disk();
                } else {
                    throw new Error(`Unsupported file format: ${ext}`);
                }
            }

            async loadExtractedFile(data, fileName, ext) {
                // Update filename display for extracted file
                if (typeof updateMediaIndicator === 'function') {
                    updateMediaIndicator(fileName, ext === 'tap' ? 'tape' : (ext === 'trd' || ext === 'scl' || ext === 'dsk') ? 'disk' : null);
                }

                if (ext === 'tap') {
                    this.spectrum.tapeLoader.load(new Uint8Array(data));
                    this.spectrum.tapeTrap.setTape(this.spectrum.tapeLoader);
                    await this.injectLoadCommand();
                } else if (ext === 'sna') {
                    this.spectrum.loadSnapshot(new Uint8Array(data));  // Auto-switches machine
                    this.reloadRomIfNeeded();
                } else if (ext === 'z80') {
                    this.spectrum.loadZ80Snapshot(new Uint8Array(data));  // Auto-switches machine
                    this.reloadRomIfNeeded();
                } else if (ext === 'szx') {
                    this.spectrum.loadSZXSnapshot(new Uint8Array(data));
                    this.reloadRomIfNeeded();
                } else if (ext === 'rzx') {
                    await this.spectrum.loadRZX(new Uint8Array(data));
                    this.reloadRomIfNeeded();
                } else if (ext === 'trd' || ext === 'scl') {
                    this.spectrum.loadDiskImage(data, ext, fileName);
                    const diskRun = this.currentTest ? (this.currentTest.diskRun || 'boot') : 'boot';
                    await this.injectDiskRunCommand(diskRun);
                } else if (ext === 'dsk') {
                    this.spectrum.loadDSKImage(new Uint8Array(data), fileName);
                    await this.bootPlus3Disk();
                } else {
                    throw new Error(`Unsupported extracted file format: ${ext}`);
                }
            }

            // Helper to run frames with abort checking and UI yielding
            async runFramesWithAbortCheck(count, callback = null) {
                for (let i = 0; i < count; i++) {
                    // Check if preview or test was stopped
                    if (!this.previewing && !this.running) return false;

                    if (callback) callback();
                    this.spectrum.runFrame();

                    // Yield every 10 frames to allow UI updates (Stop button)
                    if (i % 10 === 9) {
                        await new Promise(r => setTimeout(r, 0));
                    }
                }
                return true;
            }

            // Inject LOAD "" command into edit line and trigger execution
            async injectLoadCommand() {
                const mem = this.spectrum.memory;
                const cpu = this.spectrum.cpu;
                const ula = this.spectrum.ula;
                const machType = this.spectrum.machineType;
                const isAmsMenu = machType === '+2' || machType === '+2a' || machType === '+3';
                const is128K = is128kCompat(machType);

                if (isAmsMenu) {
                    // +2/+2A/+3: Amstrad menu — same approach as main auto-load:
                    // wait for menu, press Enter to select "Tape Loader" (default option)
                    // which runs LOAD "" automatically, no typing needed
                    ula.keyboardState.fill(0xFF);

                    // Wait for menu to fully appear (150 frames = 3000ms at 50fps)
                    if (!await this.runFramesWithAbortCheck(150, () => ula.keyboardState.fill(0xFF))) return;

                    // Press Enter to select Tape Loader
                    ula.keyDown('Enter');
                    for (let i = 0; i < 15; i++) {
                        this.spectrum.runFrame();
                    }
                    ula.keyUp('Enter');
                    ula.keyboardState.fill(0xFF);

                    // Run frames for flash load to complete
                    await this.runFramesWithAbortCheck(300, () => {
                        ula.keyboardState.fill(0xFF);
                    });
                    return;
                }

                if (is128K) {
                    // 128K/Pentagon: Sinclair menu — press "1" for BASIC, then type LOAD ""
                    ula.keyboardState.fill(0xFF);

                    // Run frames until menu is fully ready
                    if (!await this.runFramesWithAbortCheck(200, () => ula.keyboardState.fill(0xFF))) return;

                    // Press "1" to select 128 BASIC
                    ula.keyDown('1');
                    for (let i = 0; i < 15; i++) {
                        this.spectrum.runFrame();
                    }
                    ula.keyUp('1');
                    ula.keyboardState.fill(0xFF);

                    // Wait for BASIC to initialize
                    if (!await this.runFramesWithAbortCheck(100, () => ula.keyboardState.fill(0xFF))) return;

                    // Now type LOAD "" just like 48K mode
                    // In 128K BASIC, J key also gives LOAD in K mode

                    // J = LOAD
                    ula.keyDown('j');
                    for (let i = 0; i < 15; i++) {
                        this.spectrum.runFrame();
                    }
                    ula.keyUp('j');
                    ula.keyboardState.fill(0xFF);
                    for (let i = 0; i < 10; i++) {
                        this.spectrum.runFrame();
                    }

                    // Symbol + P = "
                    ula.keyDown('Alt');
                    ula.keyDown('p');
                    for (let i = 0; i < 15; i++) {
                        this.spectrum.runFrame();
                    }
                    ula.keyUp('p');
                    ula.keyUp('Alt');
                    ula.keyboardState.fill(0xFF);
                    for (let i = 0; i < 10; i++) {
                        this.spectrum.runFrame();
                    }

                    // Symbol + P = " again
                    ula.keyDown('Alt');
                    ula.keyDown('p');
                    for (let i = 0; i < 15; i++) {
                        this.spectrum.runFrame();
                    }
                    ula.keyUp('p');
                    ula.keyUp('Alt');
                    ula.keyboardState.fill(0xFF);
                    for (let i = 0; i < 10; i++) {
                        this.spectrum.runFrame();
                    }

                    // ENTER
                    ula.keyDown('Enter');
                    for (let i = 0; i < 5; i++) {
                        this.spectrum.runFrame();
                    }
                    ula.keyUp('Enter');
                    ula.keyboardState.fill(0xFF);

                    // Clear ROM keyboard variables
                    for (let i = 0x5C00; i <= 0x5C08; i++) {
                        mem.write(i, 0xFF);
                    }

                    // Run frames for loading with keyboard clear
                    await this.runFramesWithAbortCheck(300, () => {
                        ula.keyboardState.fill(0xFF);
                        for (let j = 0x5C00; j <= 0x5C08; j++) {
                            mem.write(j, 0xFF);
                        }
                    });
                    return;
                }

                // 48K mode: type LOAD "" and press ENTER
                // Run frames until ROM reaches main input loop
                let frameCount = 0;

                for (let i = 0; i < 200; i++) {
                    // Check if preview or test was stopped
                    if (!this.previewing && !this.running) return;

                    this.spectrum.runFrame();
                    frameCount++;

                    // Yield every 10 frames
                    if (i % 10 === 9) {
                        await new Promise(r => setTimeout(r, 0));
                    }

                    const curDfSz = mem.read(0x5C6B);
                    const curEline = mem.read(0x5C59) | (mem.read(0x5C5A) << 8);

                    // Check if ROM has initialized
                    if (curDfSz === 2 && curEline >= 0x5B00 && curEline < 0x6000) {
                        break;
                    }
                }

                // ROM init doesn't always CLS after setting ATTR_P - fix attrs manually
                const attrP = mem.read(0x5C8D);
                if (attrP !== 0 && mem.read(0x5800) === 0) {
                    for (let i = 0x5800; i < 0x5B00; i++) {
                        mem.write(i, attrP);
                    }
                }

                // Get E_LINE address
                const elineAddr = mem.read(0x5C59) | (mem.read(0x5C5A) << 8);

                // Validate E_LINE
                if (elineAddr < 0x5B00 || elineAddr >= 0x6000) {
                    console.warn('E_LINE not valid:', elineAddr.toString(16));
                    return; // Can't inject, ROM not ready
                }

                // Run a few more frames to ensure ROM is fully in input loop
                if (!await this.runFramesWithAbortCheck(50)) return;

                // Ensure all keys are released before we start
                this.spectrum.ula.keyboardState.fill(0xFF);

                // Simulate typing LOAD "" and pressing ENTER
                await this.simulateLoadCommand();
            }

            // Simulate typing LOAD "" and ENTER using keyboard emulation
            async simulateLoadCommand() {
                const ula = this.spectrum.ula;

                // Helper to check if aborted
                const isAborted = () => !this.previewing && !this.running;

                // Helper to press a single key using ULA methods (with abort check)
                const pressKey = async (key, holdFrames = 25, releaseFrames = 15) => {
                    if (isAborted()) return false;
                    ula.keyDown(key);
                    for (let i = 0; i < holdFrames; i++) {
                        this.spectrum.runFrame();
                    }
                    ula.keyUp(key);
                    for (let i = 0; i < releaseFrames; i++) {
                        this.spectrum.runFrame();
                    }
                    // Yield after each key press
                    await new Promise(r => setTimeout(r, 0));
                    return !isAborted();
                };

                // Helper to press key with Symbol Shift (Alt in browser terms)
                const pressWithSymbol = async (key, holdFrames = 25, releaseFrames = 15) => {
                    if (isAborted()) return false;
                    ula.keyDown('Alt'); // Symbol Shift
                    ula.keyDown(key);
                    for (let i = 0; i < holdFrames; i++) {
                        this.spectrum.runFrame();
                    }
                    ula.keyUp(key);
                    ula.keyUp('Alt');
                    for (let i = 0; i < releaseFrames; i++) {
                        this.spectrum.runFrame();
                    }
                    // Yield after each key press
                    await new Promise(r => setTimeout(r, 0));
                    return !isAborted();
                };

                // J = LOAD in K mode
                if (!await pressKey('j')) return;

                // Symbol Shift + P = " (quote)
                if (!await pressWithSymbol('p')) return;

                // Symbol Shift + P again for closing "
                if (!await pressWithSymbol('p')) return;

                // Check abort before ENTER
                if (isAborted()) return;

                // ENTER - press briefly then clear keyboard immediately
                ula.keyDown('Enter');
                for (let i = 0; i < 5; i++) {
                    this.spectrum.runFrame();
                }
                ula.keyUp('Enter');
                ula.keyboardState.fill(0xFF);

                // Clear ROM keyboard system variables
                const mem = this.spectrum.memory;
                for (let i = 0x5C00; i <= 0x5C07; i++) {
                    mem.write(i, 0xFF);
                }
                mem.write(0x5C08, 0xFF);

                // Run frames with keyboard continuously cleared
                // The tape trap will load instantly, then BASIC autorun executes
                await this.runFramesWithAbortCheck(200, () => ula.keyboardState.fill(0xFF));
            }

            // Boot TR-DOS and type RUN "filename" (or just RUN for boot file)
            async injectDiskRunCommand(diskRun) {
                const ula = this.spectrum.ula;
                const isAborted = () => !this.previewing && !this.running;

                // Boot TR-DOS
                if (!this.spectrum.bootTrdos()) {
                    console.warn('[TestRunner] Cannot boot TR-DOS');
                    return;
                }

                // Run frames for TR-DOS to initialize
                if (!await this.runFramesWithAbortCheck(200, () => ula.keyboardState.fill(0xFF))) return;

                // Helper to press a single key
                const pressKey = async (key, holdFrames = 15, releaseFrames = 10) => {
                    if (isAborted()) return false;
                    ula.keyDown(key);
                    for (let i = 0; i < holdFrames; i++) {
                        this.spectrum.runFrame();
                    }
                    ula.keyUp(key);
                    for (let i = 0; i < releaseFrames; i++) {
                        this.spectrum.runFrame();
                    }
                    ula.keyboardState.fill(0xFF);
                    await new Promise(r => setTimeout(r, 0));
                    return !isAborted();
                };

                // Helper to press key with Symbol Shift
                const pressWithSymbol = async (key, holdFrames = 15, releaseFrames = 10) => {
                    if (isAborted()) return false;
                    ula.keyDown('Alt');
                    ula.keyDown(key);
                    for (let i = 0; i < holdFrames; i++) {
                        this.spectrum.runFrame();
                    }
                    ula.keyUp(key);
                    ula.keyUp('Alt');
                    for (let i = 0; i < releaseFrames; i++) {
                        this.spectrum.runFrame();
                    }
                    ula.keyboardState.fill(0xFF);
                    await new Promise(r => setTimeout(r, 0));
                    return !isAborted();
                };

                // Type R (in TR-DOS, R gives RUN keyword)
                if (!await pressKey('r')) return;

                // If diskRun is not empty/"boot", add "filename"
                if (diskRun && diskRun.toLowerCase() !== 'boot') {
                    // Space between RUN and "
                    if (!await pressKey(' ')) return;

                    // Opening quote: Symbol + P
                    if (!await pressWithSymbol('p')) return;

                    // Type filename characters
                    for (const ch of diskRun) {
                        if (isAborted()) return;
                        const lower = ch.toLowerCase();
                        if (lower >= 'a' && lower <= 'z') {
                            if (!await pressKey(lower)) return;
                        } else if (lower >= '0' && lower <= '9') {
                            if (!await pressKey(lower)) return;
                        } else if (lower === '.') {
                            if (!await pressWithSymbol('m')) return;
                        } else if (lower === ' ') {
                            if (!await pressKey(' ')) return;
                        }
                    }

                    // Closing quote: Symbol + P
                    if (!await pressWithSymbol('p')) return;
                }

                // Press Enter
                if (!await pressKey('Enter')) return;

                // Run frames for loading
                await this.runFramesWithAbortCheck(300, () => ula.keyboardState.fill(0xFF));
            }

            // Boot +3 from DSK disk image
            // Reset machine, preserve disk, press Enter at Amstrad menu to select "Loader"
            // The +3 ROM's Loader routine auto-detects disk and boots from it
            async bootPlus3Disk() {
                const ula = this.spectrum.ula;

                if (!this.spectrum.fdc) {
                    console.warn('[TestRunner] Cannot boot +3 disk: no FDC');
                    return;
                }

                // Save disk before reset
                const disk = this.spectrum.fdc.drives[0].disk;

                // Reset machine
                this.spectrum.reset();

                // Restore disk after reset
                if (disk) {
                    this.spectrum.fdc.drives[0].disk = disk;
                }

                // Wait for +3 Amstrad menu to appear (150 frames = 3s at 50fps)
                ula.keyboardState.fill(0xFF);
                if (!await this.runFramesWithAbortCheck(150, () => ula.keyboardState.fill(0xFF))) return;

                // Press Enter to select "Loader" (default option)
                // ROM will detect disk and boot from it automatically
                ula.keyDown('Enter');
                for (let i = 0; i < 15; i++) {
                    this.spectrum.runFrame();
                }
                ula.keyUp('Enter');
                ula.keyboardState.fill(0xFF);

                // Run frames for ROM to boot from disk
                await this.runFramesWithAbortCheck(500, () => ula.keyboardState.fill(0xFF));
            }

            // Directly load tape contents into memory, bypassing ROM (kept for reference)
            directTapeLoad() {
                const tape = this.spectrum.tapeLoader;
                const mem = this.spectrum.memory;
                const cpu = this.spectrum.cpu;

                if (!tape || tape.getBlockCount() === 0) {
                    console.warn('No tape data to load');
                    return;
                }

                tape.rewind();
                let pendingHeader = null;

                // Process ALL tape blocks - load CODE files directly, skip BASIC
                let lastCodeAddr = null;
                let lastCodeExec = null;

                while (tape.hasMoreBlocks()) {
                    const block = tape.getNextBlock();
                    if (!block || !block.data || block.data.length < 2) continue;

                    const flag = block.flag;
                    const data = block.data;

                    if (flag === 0x00 && data.length >= 17) {
                        // Header block
                        const type = data[0];
                        const name = String.fromCharCode(...data.slice(1, 11)).trim();
                        const dataLen = data[11] | (data[12] << 8);
                        const param1 = data[13] | (data[14] << 8);
                        const param2 = data[15] | (data[16] << 8);

                        pendingHeader = { type, name, dataLen, param1, param2 };

                    } else if (flag === 0xFF && pendingHeader) {
                        // Data block
                        const h = pendingHeader;
                        const dataBytes = data.slice(0, data.length - 1); // Remove checksum

                        if (h.type === 3) {
                            // CODE file - load directly to memory
                            for (let i = 0; i < dataBytes.length; i++) {
                                mem.write(h.param1 + i, dataBytes[i]);
                            }
                            lastCodeAddr = h.param1;
                            lastCodeExec = h.param2;
                        }
                        pendingHeader = null;
                    }
                }

                // Execute the last CODE file loaded
                if (lastCodeAddr !== null) {
                    const execAddr = (lastCodeExec !== 0 && lastCodeExec < 0x10000) ? lastCodeExec : lastCodeAddr;
                    cpu.pc = execAddr;
                    cpu.iff1 = false;
                    cpu.iff2 = false;
                    cpu.sp = 0xFF40; // Set stack below screen
                }

                tape.rewind();
            }

            async runStep(step, test, stepIdx) {
                // Press keys if specified
                if (step.keys) {
                    await this.pressKeys(step.keys);
                }

                // Calculate target frames (absolute from test start)
                const tstatesPerFrame = this.spectrum.timing.tstatesPerFrame;
                let targetFrames = step.frames || 0;
                if (step.tstates) {
                    targetFrames = Math.ceil(step.tstates / tstatesPerFrame);
                }

                // Calculate how many frames to run (absolute - already run)
                const framesToRun = Math.max(0, targetFrames - this.totalFrames);

                // Run frames at full speed
                for (let f = 0; f < framesToRun; f++) {
                    if (this.aborted) return { passed: false, error: 'Aborted' };

                    const tstates = this.spectrum.runFrameHeadless();
                    this.totalTstates += tstates;
                    this.totalFrames++;

                    // Update progress
                    if (f % 10 === 0) {
                        this.updateProgress(
                            this.tests.indexOf(test) + 1,
                            this.tests.length,
                            test.name,
                            this.totalFrames,
                            targetFrames,
                            stepIdx + 1,
                            test.steps.length
                        );
                        // Yield to UI
                        await new Promise(r => setTimeout(r, 0));
                    }
                }

                // Final progress update
                this.updateProgress(
                    this.tests.indexOf(test) + 1,
                    this.tests.length,
                    test.name,
                    this.totalFrames,
                    targetFrames,
                    stepIdx + 1,
                    test.steps.length
                );

                // Compare screen if specified
                if (step.screen) {
                    // Render final frame for comparison
                    const frameBuffer = this.spectrum.renderAndCaptureScreen();
                    const dims = this.spectrum.getScreenDimensions();

                    // Create ImageData from frame buffer
                    const actualImageData = new ImageData(
                        new Uint8ClampedArray(frameBuffer),
                        dims.width,
                        dims.height
                    );

                    // Load pristine image
                    let expectedImageData;
                    try {
                        expectedImageData = await this.loadPristineImage(step.screen);
                    } catch (e) {
                        return { passed: false, error: `Failed to load pristine: ${e.message}` };
                    }

                    // Compare
                    const tolerance = step.tolerance || 0;
                    const diff = this.compareScreens(actualImageData, expectedImageData, tolerance);

                    // Display comparison
                    this.displayComparison(expectedImageData, actualImageData, diff, this.totalFrames);

                    if (!diff.matches) {
                        return { passed: false, diff, step: stepIdx, frame: this.totalFrames };
                    }
                }

                return { passed: true };
            }

            async pressKeys(keyString) {
                const parts = keyString.split(',');

                for (const part of parts) {
                    const trimmed = part.trim();

                    // Check for delay: "500ms"
                    const delayMatch = trimmed.match(/^(\d+)ms$/);
                    if (delayMatch) {
                        const ms = parseInt(delayMatch[1]);
                        const frames = Math.ceil(ms / 20); // ~50fps
                        for (let f = 0; f < frames; f++) {
                            this.spectrum.runFrameHeadless();
                        }
                        continue;
                    }

                    // Simultaneous keys: "a+b"
                    const keys = trimmed.split('+').map(k => this.mapKey(k.trim()));

                    // Press all keys
                    for (const key of keys) {
                        this.spectrum.ula.keyDown(key);
                    }

                    // Hold for a few frames
                    for (let f = 0; f < 5; f++) {
                        this.spectrum.runFrameHeadless();
                    }

                    // Release all keys
                    for (const key of keys) {
                        this.spectrum.ula.keyUp(key);
                    }

                    // Wait a frame after release
                    this.spectrum.runFrameHeadless();
                }
            }

            mapKey(key) {
                // Check special key names
                const upper = key.toUpperCase();
                if (this.keyMap[upper]) return this.keyMap[upper];
                // Return as-is for regular characters
                return key.toLowerCase();
            }

            async loadPristineImage(path) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);
                        resolve(ctx.getImageData(0, 0, img.width, img.height));
                    };
                    img.onerror = () => reject(new Error(`Failed to load image: ${path}`));
                    img.src = path;
                });
            }

            compareScreens(actual, expected, tolerance = 0) {
                // Handle size mismatch by comparing overlapping region
                const width = Math.min(actual.width, expected.width);
                const height = Math.min(actual.height, expected.height);
                let diffCount = 0;

                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const aIdx = (y * actual.width + x) * 4;
                        const eIdx = (y * expected.width + x) * 4;

                        const dr = Math.abs(actual.data[aIdx] - expected.data[eIdx]);
                        const dg = Math.abs(actual.data[aIdx + 1] - expected.data[eIdx + 1]);
                        const db = Math.abs(actual.data[aIdx + 2] - expected.data[eIdx + 2]);

                        if (dr > tolerance || dg > tolerance || db > tolerance) {
                            diffCount++;
                        }
                    }
                }

                const totalPixels = width * height;
                return {
                    matches: diffCount === 0,
                    diffCount,
                    diffPercent: (diffCount / totalPixels * 100).toFixed(2),
                    width,
                    height
                };
            }

            displayComparison(expected, actual, diff, frame) {
                // Show comparison section
                this.elements.comparisonSection.classList.remove('hidden');

                // Draw expected
                const expCtx = this.elements.expectedCanvas.getContext('2d');
                this.elements.expectedCanvas.width = expected.width;
                this.elements.expectedCanvas.height = expected.height;
                expCtx.putImageData(expected, 0, 0);

                // Draw actual
                const actCtx = this.elements.actualCanvas.getContext('2d');
                this.elements.actualCanvas.width = actual.width;
                this.elements.actualCanvas.height = actual.height;
                actCtx.putImageData(actual, 0, 0);

                // Draw difference highlight overlay if enabled and there are differences
                if (this.elements.chkHighlightDiff?.checked && !diff.matches) {
                    this.drawDiffHighlight(expCtx, actCtx, expected, actual, diff);
                }

                // Update result text
                const resultEl = this.elements.comparisonResult;
                if (diff.matches) {
                    resultEl.textContent = 'MATCH - Screens are identical';
                    resultEl.className = 'tests-comparison-result pass';
                } else {
                    resultEl.textContent = `MISMATCH at frame ${frame} - ${diff.diffCount} pixels differ (${diff.diffPercent}%)`;
                    resultEl.className = 'tests-comparison-result fail';
                }
            }

            // Draw soft cloud highlight around difference pixels
            drawDiffHighlight(expCtx, actCtx, expected, actual, diff) {
                const width = Math.min(expected.width, actual.width);
                const height = Math.min(expected.height, actual.height);
                const tolerance = diff.tolerance || 0;
                const cloudRadius = 5;

                // Find all diff pixels
                const diffPixels = [];
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const aIdx = (y * actual.width + x) * 4;
                        const eIdx = (y * expected.width + x) * 4;

                        const dr = Math.abs(actual.data[aIdx] - expected.data[eIdx]);
                        const dg = Math.abs(actual.data[aIdx + 1] - expected.data[eIdx + 1]);
                        const db = Math.abs(actual.data[aIdx + 2] - expected.data[eIdx + 2]);

                        if (dr > tolerance || dg > tolerance || db > tolerance) {
                            diffPixels.push({ x, y });
                        }
                    }
                }

                if (diffPixels.length === 0) return;

                // Create offscreen canvas for clouds to prevent opacity accumulation
                const offscreen = document.createElement('canvas');
                offscreen.width = width;
                offscreen.height = height;
                const offCtx = offscreen.getContext('2d');

                // Draw clouds to offscreen canvas (will accumulate here)
                for (const { x, y } of diffPixels) {
                    const gradient = offCtx.createRadialGradient(x, y, 0, x, y, cloudRadius);
                    gradient.addColorStop(0, 'rgba(255, 255, 0, 1)');
                    gradient.addColorStop(1, 'rgba(255, 255, 0, 0)');
                    offCtx.fillStyle = gradient;
                    offCtx.fillRect(x - cloudRadius, y - cloudRadius, cloudRadius * 2, cloudRadius * 2);
                }

                // Composite offscreen canvas onto both canvases with limited opacity
                actCtx.globalAlpha = 0.4;
                actCtx.drawImage(offscreen, 0, 0);
                actCtx.globalAlpha = 1.0;

                expCtx.globalAlpha = 0.4;
                expCtx.drawImage(offscreen, 0, 0);
                expCtx.globalAlpha = 1.0;
            }

            renderResultsSummary() {
                const tbody = this.elements.resultsBody;
                tbody.innerHTML = '';

                for (const { test, result } of this.results) {
                    const tr = document.createElement('tr');
                    const status = result.passed ? 'PASS' : 'FAIL';
                    const statusClass = result.passed ? 'tests-result-pass' : 'tests-result-fail';
                    let detail = '-';
                    if (!result.passed) {
                        if (result.error) detail = result.error;
                        else if (result.diff) detail = `Step ${(result.step || 0) + 1}, frame ${result.frame}: ${result.diff.diffCount} pixels differ`;
                    }
                    tr.innerHTML = `
                        <td>${this.escapeHtml(test.name)}</td>
                        <td class="${statusClass}">${status}</td>
                        <td>${this.escapeHtml(detail)}</td>
                    `;
                    tbody.appendChild(tr);
                }
            }

            abort() {
                this.aborted = true;
                this.previewing = false;
                this.previewPaused = false;
                this.updateStatus('Aborting...');
            }

            // Preview mode - run test file and show live screen with frame counter
            async startPreview() {
                const selected = this.getSelectedTests();
                if (selected.length === 0) {
                    this.updateStatus('Select a test to preview');
                    return;
                }

                const test = selected[0]; // Preview first selected test
                if (this.running || this.previewing) return;

                // Save current state before any changes
                const savedMachine = this.spectrum.machineType;
                const savedPalette = paletteSelect?.value || 'default';
                const savedFullBorder = this.spectrum.ula.fullBorderMode;
                const savedLateTimings = this.spectrum.lateTimings;
                const wasRunning = this.spectrum.running;

                this.previewing = true;
                this.previewFrameCount = 0;

                try {
                    if (wasRunning) this.spectrum.stop();

                    // UI updates
                    this.elements.btnRunSelected.disabled = true;
                    this.elements.btnPreview.disabled = true;
                    this.elements.previewSection.classList.remove('hidden');
                    this.elements.progressSection.classList.add('hidden');
                    this.elements.comparisonSection.classList.add('hidden');
                    this.elements.summarySection.classList.add('hidden');
                    this.elements.previewFrame.textContent = '0';
                    this.updateStatus(`Preview: ${test.name}`);
                    // Configure machine
                    if (test.machine && test.machine !== this.spectrum.machineType) {
                        await this.switchMachine(test.machine);
                    }

                    if (test.earlyTimings !== undefined) {
                        this.spectrum.setEarlyTimings?.(test.earlyTimings);
                    }

                    if (test.palette && typeof applyPalette === 'function') {
                        applyPalette(test.palette);
                    }

                    // Apply full border mode if specified (default to true for tests)
                    const useFullBorder = test.fullBorder !== undefined ? test.fullBorder : true;
                    if (this.spectrum.ula.setFullBorder(useFullBorder)) {
                        this.spectrum.updateDisplayDimensions();
                    }

                    // Setup preview canvas (after full border mode is set)
                    const dims = this.spectrum.getScreenDimensions();
                    const previewCanvas = this.elements.previewCanvas;
                    previewCanvas.width = dims.width;
                    previewCanvas.height = dims.height;
                    const previewCtx = previewCanvas.getContext('2d');

                    // Full reset including tape state
                    this.spectrum.reset();
                    this.spectrum.tapeLoader.rewind();

                    // Apply ULAplus AFTER reset (default: disabled)
                    // Must be after reset to avoid being cleared
                    // Always reset ULA+ first to clear palette from previous tests
                    this.spectrum.ula.resetULAplus();
                    const enableUlaplus = test.ulaplus === true;
                    this.spectrum.ula.ulaplus.enabled = enableUlaplus;
                    if (enableUlaplus) {
                        this.spectrum.ula.ulaplus.paletteEnabled = true;  // Enable palette mode for tests
                    }
                    updateULAplusStatus?.();

                    // Recreate tape trap to ensure clean state
                    this.spectrum.tapeTrap = new TapeTrapHandler(
                        this.spectrum.cpu,
                        this.spectrum.memory,
                        this.spectrum.tapeLoader
                    );
                    this.spectrum.tapeTrap.setEnabled(this.spectrum.tapeTrapsEnabled);

                    // Ensure keyboard is fully released
                    this.spectrum.ula.keyboardState.fill(0xFF);

                    try {
                        await this.loadTestFile(test.file, test.zipEntry);
                    } catch (loadErr) {
                        this.elements.previewInfo.textContent = `Load error: ${loadErr.message}`;
                        this.updateStatus(`Load error: ${loadErr.message}`);
                        this.previewing = false;
                        return;
                    }

                    // Run frames with live display
                    while (this.previewing) {
                        // Wait while paused
                        while (this.previewPaused && this.previewing) {
                            await new Promise(r => setTimeout(r, 100));
                        }
                        if (!this.previewing) break;

                        // runFrame() does cycle-accurate scanline rendering including border changes
                        // and already puts the result on spectrum.ctx.canvas
                        this.spectrum.runFrame();
                        this.previewFrameCount++;

                        // Update frame counter every frame so Copy Frame# is accurate
                        this.elements.previewFrame.textContent = this.previewFrameCount;

                        // Update canvas every 2 frames for performance
                        if (this.previewFrameCount % 2 === 0) {
                            // Use renderAndCaptureScreen for consistent border rendering
                            const frameBuffer = this.spectrum.renderAndCaptureScreen();
                            const imageData = new ImageData(
                                new Uint8ClampedArray(frameBuffer),
                                dims.width,
                                dims.height
                            );
                            previewCtx.putImageData(imageData, 0, 0);
                        }

                        // Yield to UI every frame so Stop button works
                        await new Promise(r => setTimeout(r, 0));
                    }

                } catch (err) {
                    this.elements.previewInfo.textContent = `Error: ${err.message}`;
                    this.updateStatus(`Preview error: ${err.message}`);
                    console.error('Preview error:', err);
                } finally {
                    // Always reset preview state
                    this.previewing = false;
                    this.previewPaused = false;

                    // Restore machine state FIRST (creates new ULA)
                    if (test.machine && test.machine !== savedMachine) {
                        await this.switchMachine(savedMachine);
                    }
                    // Restore full border mode AFTER machine switch (new ULA loses settings)
                    if (this.spectrum.ula.setFullBorder(savedFullBorder)) {
                        this.spectrum.updateDisplayDimensions();
                    }
                    // Restore palette if changed
                    if (test.palette && typeof applyPalette === 'function') {
                        applyPalette(savedPalette);
                    }
                    // Restore timing settings
                    this.spectrum.setLateTimings(savedLateTimings);

                    // Always update canvas size after preview (in case dimensions changed)
                    if (typeof updateCanvasSize === 'function') {
                        updateCanvasSize();
                    }

                    // Refresh main canvas after preview ends
                    this.spectrum.redraw();

                    this.elements.btnRunSelected.disabled = false;
                    this.elements.btnPreview.disabled = false;
                }
            }

            togglePausePreview() {
                if (!this.previewing) return;

                this.previewPaused = !this.previewPaused;

                if (this.previewPaused) {
                    this.elements.btnPausePreview.textContent = 'Resume';
                    this.elements.previewInfo.textContent =
                        `Paused at frame ${this.previewFrameCount}. Copy frame#, then Resume or Stop.`;
                    this.updateStatus(`Preview paused at frame ${this.previewFrameCount}`);
                } else {
                    this.elements.btnPausePreview.textContent = 'Pause';
                    this.elements.previewInfo.textContent = 'Running...';
                    this.updateStatus(`Preview resumed from frame ${this.previewFrameCount}`);
                }
            }

            async copyFrameCount() {
                const frameCount = this.previewFrameCount;
                try {
                    await navigator.clipboard.writeText(frameCount.toString());
                    this.elements.previewInfo.textContent =
                        `Frame ${frameCount} copied to clipboard!`;
                    this.updateStatus(`Frame count ${frameCount} copied`);
                } catch (e) {
                    this.elements.previewInfo.textContent =
                        `Frame count: ${frameCount} (copy failed, note it manually)`;
                }
            }

            saveScreenshot() {
                const canvas = this.elements.previewCanvas;
                const frameCount = this.previewFrameCount;

                // Get selected test name for filename
                const selected = this.getSelectedTests();
                const testName = selected.length > 0 ? selected[0].id : 'preview';
                const filename = `${testName}_${frameCount}.png`;

                // Create download link and trigger download
                const link = document.createElement('a');
                link.download = filename;
                link.href = canvas.toDataURL('image/png');
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                this.elements.previewInfo.textContent =
                    `Screenshot saved: ${filename}`;
                this.updateStatus(`Screenshot saved: ${filename}`);
            }

            stopPreview() {
                if (!this.previewing) return;

                this.previewing = false;
                this.previewPaused = false;
                this.elements.btnPausePreview.textContent = 'Pause';
                this.elements.previewInfo.textContent =
                    `Stopped at frame ${this.previewFrameCount}.`;
                this.updateStatus(`Preview stopped at frame ${this.previewFrameCount}`);

                // Keep preview section visible so user can see the final frame
            }
        }

        let testRunner = null;

        // ========== Navigation History (per-panel) ==========
        const NAV_HISTORY_MAX = 50;

        // Left panel history
        const leftNavHistory = [];
        let leftNavHistoryIndex = -1;

        // Right panel history
        const rightNavHistory = [];
        let rightNavHistoryIndex = -1;

        function navPushHistory(addr, panel = 'left') {
            if (addr === null || addr === undefined) return;
            addr = addr & 0xffff;
            const history = panel === 'right' ? rightNavHistory : leftNavHistory;
            let index = panel === 'right' ? rightNavHistoryIndex : leftNavHistoryIndex;

            // Don't push if same as current
            if (index >= 0 && history[index] === addr) return;
            // Truncate forward history
            history.length = index + 1;
            history.push(addr);
            // Limit size
            if (history.length > NAV_HISTORY_MAX) {
                history.shift();
            }
            if (panel === 'right') {
                rightNavHistoryIndex = history.length - 1;
            } else {
                leftNavHistoryIndex = history.length - 1;
            }
            updateNavButtons();
        }

        function navBack(panel = 'left') {
            const history = panel === 'right' ? rightNavHistory : leftNavHistory;
            let index = panel === 'right' ? rightNavHistoryIndex : leftNavHistoryIndex;

            if (index > 0) {
                index--;
                if (panel === 'right') {
                    rightNavHistoryIndex = index;
                } else {
                    leftNavHistoryIndex = index;
                }
                const addr = history[index];
                goToAddressNoHistory(addr, panel);
                updateNavButtons();
            }
        }

        function navForward(panel = 'left') {
            const history = panel === 'right' ? rightNavHistory : leftNavHistory;
            let index = panel === 'right' ? rightNavHistoryIndex : leftNavHistoryIndex;

            if (index < history.length - 1) {
                index++;
                if (panel === 'right') {
                    rightNavHistoryIndex = index;
                } else {
                    leftNavHistoryIndex = index;
                }
                const addr = history[index];
                goToAddressNoHistory(addr, panel);
                updateNavButtons();
            }
        }

        function updateNavButtons() {
            // Left panel buttons
            const btnLeftBack = document.getElementById('btnDisasmPgUp');
            const btnLeftFwd = document.getElementById('btnDisasmPgDn');
            if (btnLeftBack) btnLeftBack.disabled = leftNavHistoryIndex <= 0;
            if (btnLeftFwd) btnLeftFwd.disabled = leftNavHistoryIndex >= leftNavHistory.length - 1;

            // Right panel buttons
            const btnRightBack = document.getElementById('btnRightDisasmPgUp');
            const btnRightFwd = document.getElementById('btnRightDisasmPgDn');
            if (btnRightBack) btnRightBack.disabled = rightNavHistoryIndex <= 0;
            if (btnRightFwd) btnRightFwd.disabled = rightNavHistoryIndex >= rightNavHistory.length - 1;
        }

        // ========== Region Parsing Helpers ==========
        // Shared constants for region display
        const REGION_MAX_TEXT = 50;   // sjasmplus compatible
        const REGION_MAX_BYTES = 8;   // bytes per DB line
        const REGION_MAX_WORDS = 4;   // words per DW line

        // Parse text region, returns {text, bytes, bit7Terminated, nextAddr}
        function parseTextRegion(memory, startAddr, endAddr, maxChars = REGION_MAX_TEXT) {
            let text = '';
            let bytes = [];
            let bit7Terminated = false;
            let addr = startAddr;

            while (addr <= endAddr && text.length < maxChars && addr <= 0xffff) {
                const byte = memory.read(addr);
                bytes.push(byte);

                const hasBit7 = (byte & 0x80) !== 0;
                const charByte = hasBit7 ? (byte & 0x7F) : byte;

                if (charByte >= 32 && charByte < 127 && charByte !== 34) {
                    text += String.fromCharCode(charByte);
                    if (hasBit7) {
                        bit7Terminated = true;
                        addr++;
                        break;
                    }
                } else if (charByte === 34) {
                    text += '""'; // Escape quote
                    if (hasBit7) {
                        bit7Terminated = true;
                        addr++;
                        break;
                    }
                } else if (byte === 0) {
                    text += '\\0';
                } else if (byte === 10) {
                    text += '\\n';
                } else if (byte === 13) {
                    text += '\\r';
                } else {
                    // Non-printable - stop here
                    if (text.length === 0) {
                        // Return single byte as non-text
                        return { text: '', bytes: [byte], bit7Terminated: false, nextAddr: addr + 1, singleByte: true };
                    }
                    bytes.pop(); // Don't include this byte
                    break;
                }
                addr++;
            }

            return { text, bytes, bit7Terminated, nextAddr: addr, singleByte: false };
        }

        // Parse byte region (DB), returns {byteStrs, bytes, nextAddr}
        function parseByteRegion(memory, startAddr, endAddr, maxBytes = REGION_MAX_BYTES) {
            let byteStrs = [];
            let bytes = [];
            let addr = startAddr;

            while (addr <= endAddr && byteStrs.length < maxBytes && addr <= 0xffff) {
                const byte = memory.read(addr);
                byteStrs.push(`$${hex8(byte)}`);
                bytes.push(byte);
                addr++;
            }

            return { byteStrs, bytes, nextAddr: addr };
        }

        // Parse word region (DW), returns {wordStrs, bytes, nextAddr}
        function parseWordRegion(memory, startAddr, endAddr, maxWords = REGION_MAX_WORDS) {
            let wordStrs = [];
            let bytes = [];
            let addr = startAddr;

            while (addr <= endAddr && wordStrs.length < maxWords && addr < 0xffff) {
                const lo = memory.read(addr);
                const hi = memory.read((addr + 1) & 0xffff);
                const word = lo | (hi << 8);
                wordStrs.push(`$${hex16(word)}`);
                bytes.push(lo, hi);
                addr += 2;
                if (addr > endAddr + 1) break;
            }

            return { wordStrs, bytes, nextAddr: addr };
        }
        // ========== End Region Parsing Helpers ==========

        // ROM storage — keyed by ROM filename (shared across machines using same ROM)
        const romData = {};    // { 'filename': ArrayBuffer, ... }

        // Legacy accessors for backward compatibility within ROM dialog handlers
        // These are getters/setters that map to romData entries
        function getRomByType(type) {
            const fileMap = { '48k': '48.rom', '128k': '128.rom', 'plus2': 'plus2.rom', 'plus2a': 'plus2a.rom', 'plus3': 'plus3.rom', 'pentagon': 'pentagon.rom', 'scorpion': 'scorpion.rom', 'trdos': 'trdos.rom' };
            return romData[fileMap[type]] || null;
        }
        function setRomByType(type, data) {
            const fileMap = { '48k': '48.rom', '128k': '128.rom', 'plus2': 'plus2.rom', 'plus2a': 'plus2a.rom', 'plus3': 'plus3.rom', 'pentagon': 'pentagon.rom', 'scorpion': 'scorpion.rom', 'trdos': 'trdos.rom' };
            if (fileMap[type]) romData[fileMap[type]] = data;
        }

        // Try to auto-load ROMs from roms/ directory
        async function tryLoadRomsFromDirectory() {
            // Build unique ROM file list from machine profiles + trdos
            const romPaths = [];
            const seen = new Set();
            for (const p of Object.values(MACHINE_PROFILES)) {
                if (!seen.has(p.romFile)) {
                    seen.add(p.romFile);
                    romPaths.push({ path: 'roms/' + p.romFile, file: p.romFile });
                }
            }
            // TR-DOS ROM (shared across all machines)
            if (!seen.has('trdos.rom')) {
                romPaths.push({ path: 'roms/trdos.rom', file: 'trdos.rom' });
            }

            for (const rom of romPaths) {
                try {
                    const response = await fetch(rom.path);
                    if (response.ok) {
                        romData[rom.file] = await response.arrayBuffer();
                        console.log(`Loaded ${rom.path}`);
                    }
                } catch (e) {
                    // ROM not found, continue
                }
            }

            // Try to load ROM labels
            await tryLoadRomLabels();

            updateRomStatus();

            if (romData['48.rom']) {
                // ROMs found, initialize directly
                initializeEmulator();
            } else {
                // No 48K ROM, show dialog
                romModal.classList.remove('hidden');
            }
        }

        // Try to load ROM labels from labels/ directory
        async function tryLoadRomLabels() {
            const labelPaths = [
                'labels/48k.json',
                'labels/rom48.json',
                'labels/spectrum48.json'
            ];

            for (const path of labelPaths) {
                try {
                    const response = await fetch(path);
                    if (response.ok) {
                        const jsonStr = await response.text();
                        const count = labelManager.loadRomLabels(jsonStr);
                        if (count > 0) {
                            console.log(`Loaded ${count} ROM labels from ${path}`);
                            return;
                        }
                    }
                } catch (e) {
                    // Labels file not found, continue
                }
            }
        }

        // UI Elements
        const canvas = document.getElementById('screen');
        const overlayCanvas = document.getElementById('overlayCanvas');
        const romModal = document.getElementById('romModal');
        const btnSelect48Rom = document.getElementById('btnSelect48Rom');
        const btnSelect128Rom = document.getElementById('btnSelect128Rom');
        const btnSelectPlus2Rom = document.getElementById('btnSelectPlus2Rom');
        const btnSelectPlus2aRom = document.getElementById('btnSelectPlus2aRom');
        const btnSelectPlus3Rom = document.getElementById('btnSelectPlus3Rom');
        const btnSelectPentagonRom = document.getElementById('btnSelectPentagonRom');
        const btnSelectScorpionRom = document.getElementById('btnSelectScorpionRom');
        const btnSelectTrdosRom = document.getElementById('btnSelectTrdosRom');
        const btnStartEmulator = document.getElementById('btnStartEmulator');
        const status48Rom = document.getElementById('status48Rom');
        const status128Rom = document.getElementById('status128Rom');
        const statusPlus2Rom = document.getElementById('statusPlus2Rom');
        const statusPlus2aRom = document.getElementById('statusPlus2aRom');
        const statusPlus3Rom = document.getElementById('statusPlus3Rom');
        const statusPentagonRom = document.getElementById('statusPentagonRom');
        const statusScorpionRom = document.getElementById('statusScorpionRom');
        const rom48Input = document.getElementById('rom48Input');
        const rom128Input = document.getElementById('rom128Input');
        const romPlus2Input = document.getElementById('romPlus2Input');
        const romPlus2aInput = document.getElementById('romPlus2aInput');
        const romPlus3Input = document.getElementById('romPlus3Input');
        const romPentagonInput = document.getElementById('romPentagonInput');
        const romScorpionInput = document.getElementById('romScorpionInput');
        const romTrdosInput = document.getElementById('romTrdosInput');
        
        const btnRun = document.getElementById('btnRun');
        const btnReset = document.getElementById('btnReset');
        const loadSelect = document.getElementById('loadSelect');
        const saveSelect = document.getElementById('saveSelect');
        const machineSelect = document.getElementById('machineSelect');
        const speedSelect = document.getElementById('speedSelect');
        const btnSound = document.getElementById('btnSound');
        const chkKempston = document.getElementById('chkKempston');
        const borderSizeSelect = document.getElementById('borderSizeSelect');
        const chkSound = document.getElementById('chkSound');
        const chkAY48k = document.getElementById('chkAY48k');
        const btnMute = document.getElementById('btnMute');
        const volumeSlider = document.getElementById('volumeSlider');
        const volumeValue = document.getElementById('volumeValue');
        const stereoMode = document.getElementById('stereoMode');
        const btnFullscreen = document.getElementById('btnFullscreen');
        const fullscreenMode = document.getElementById('fullscreenMode');
        const screenWrapper = document.querySelector('.screen-wrapper');
        const fileInput = document.getElementById('fileInput');
        const fpsEl = document.getElementById('fps');
        const dropZone = document.getElementById('dropZone');

        // RZX playback UI
        const rzxInfo = document.getElementById('rzxInfo');
        const rzxStatus = document.getElementById('rzxStatus');
        const btnRzxStop = document.getElementById('btnRzxStop');

        // ZIP selection modal
        const zipModal = document.getElementById('zipModal');
        const zipFileList = document.getElementById('zipFileList');
        const btnZipCancel = document.getElementById('btnZipCancel');
        const btnBootTrdos = document.getElementById('btnBootTrdos');
        let pendingZipResult = null;  // Stores ZIP result while user selects file
        let bootTrdData = null;       // Stores boot TRD file data for injection
        let bootTrdName = null;       // Name of the boot TRD file
        let bootFileType = null;      // Type of boot file: 'trd' or 'hobeta'

        // ========== Machine Dropdown & Settings ==========

        function getVisibleMachines() {
            try {
                const stored = localStorage.getItem('zx-visible-machines');
                if (stored) {
                    const arr = JSON.parse(stored);
                    // Ensure 48k is always included
                    if (!arr.includes('48k')) arr.unshift('48k');
                    return arr;
                }
            } catch (e) {}
            return DEFAULT_VISIBLE_MACHINES.slice();
        }

        function setVisibleMachines(arr) {
            localStorage.setItem('zx-visible-machines', JSON.stringify(arr));
        }

        function populateMachineDropdown() {
            const visible = getVisibleMachines();
            visible.sort((a, b) => (MACHINE_PROFILES[a]?.name || a).localeCompare(MACHINE_PROFILES[b]?.name || b));
            const currentValue = machineSelect.value;
            machineSelect.innerHTML = '';
            for (const id of visible) {
                const p = MACHINE_PROFILES[id];
                if (p) {
                    const opt = document.createElement('option');
                    opt.value = id;
                    opt.textContent = p.name;
                    machineSelect.appendChild(opt);
                }
            }
            // Restore selection if still visible, otherwise select first
            if (visible.includes(currentValue)) {
                machineSelect.value = currentValue;
            }
        }

        function buildMachineCheckboxes() {
            const container = document.getElementById('machineCheckboxes');
            if (!container) return;
            container.innerHTML = '';
            const visible = getVisibleMachines();

            // Group machines by group
            const groups = {};
            for (const [id, p] of Object.entries(MACHINE_PROFILES)) {
                (groups[p.group] ||= []).push(p);
            }

            for (const [group, machines] of Object.entries(groups)) {
                const groupDiv = document.createElement('div');
                groupDiv.style.cssText = 'margin-bottom: 8px;';
                const groupLabel = document.createElement('div');
                groupLabel.style.cssText = 'color: var(--text-secondary); font-size: 11px; margin-bottom: 4px; font-weight: bold;';
                groupLabel.textContent = group;
                groupDiv.appendChild(groupLabel);

                for (const p of machines) {
                    const label = document.createElement('label');
                    label.className = 'checkbox-label';
                    label.style.cssText = 'display: block; margin-left: 8px; margin-bottom: 2px;';
                    const cb = document.createElement('input');
                    cb.type = 'checkbox';
                    cb.checked = visible.includes(p.id);
                    cb.dataset.machineId = p.id;
                    // 48K always visible (cannot uncheck)
                    if (p.id === '48k') {
                        cb.disabled = true;
                        cb.checked = true;
                    }
                    cb.addEventListener('change', () => {
                        const current = getVisibleMachines();
                        if (cb.checked) {
                            if (!current.includes(p.id)) {
                                // Insert in profile order
                                const allIds = getMachineTypes();
                                const idx = allIds.indexOf(p.id);
                                let insertAt = current.length;
                                for (let i = 0; i < current.length; i++) {
                                    if (allIds.indexOf(current[i]) > idx) {
                                        insertAt = i;
                                        break;
                                    }
                                }
                                current.splice(insertAt, 0, p.id);
                            }
                        } else {
                            const idx = current.indexOf(p.id);
                            if (idx > -1) current.splice(idx, 1);
                        }
                        setVisibleMachines(current);
                        populateMachineDropdown();
                    });
                    label.appendChild(cb);
                    label.appendChild(document.createTextNode(' ' + p.name));
                    groupDiv.appendChild(label);
                }
                container.appendChild(groupDiv);
            }
        }

        // Populate dropdown on startup
        populateMachineDropdown();
        buildMachineCheckboxes();

        // ========== Signature Packs UI ==========
        function renderSigPackList() {
            const container = document.getElementById('sigPackList');
            if (!container) return;
            container.innerHTML = '';

            if (signaturePackManager.packs.length === 0) {
                container.innerHTML = '<div style="color: var(--text-secondary); font-size: 11px; font-style: italic;">No signature packs loaded. Import a .skool or pack JSON file.</div>';
                return;
            }

            for (const entry of signaturePackManager.packs) {
                const wrapper = document.createElement('div');
                wrapper.style.cssText = 'margin-bottom: 4px;';

                const row = document.createElement('div');
                row.style.cssText = 'display: flex; align-items: center; gap: 8px; padding: 3px 6px; background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: 3px;';

                const cb = document.createElement('input');
                cb.type = 'checkbox';
                cb.checked = entry.enabled;
                cb.title = 'Enable/disable this pack';
                cb.addEventListener('change', () => {
                    signaturePackManager.setEnabled(entry.id, cb.checked);
                });

                const typeSpan = document.createElement('span');
                typeSpan.style.cssText = 'font-size: 9px; text-transform: uppercase; letter-spacing: 0.5px; padding: 1px 4px; border-radius: 2px; background: var(--bg-button); color: var(--text-secondary);';
                typeSpan.textContent = entry.type || 'game';

                const nameSpan = document.createElement('span');
                nameSpan.style.cssText = 'flex: 1; font-size: 11px; color: var(--text-primary);';
                nameSpan.textContent = entry.name || entry.id;

                const pack = signaturePackManager.loadedPacks[entry.id];
                const statsSpan = document.createElement('span');
                statsSpan.style.cssText = 'font-size: 10px; color: var(--text-secondary);';
                if (pack && pack.stats) {
                    statsSpan.textContent = `${pack.stats.labels}L ${pack.stats.regions}R ${pack.stats.anchors}A`;
                    statsSpan.title = `${pack.stats.labels} labels, ${pack.stats.regions} regions, ${pack.stats.anchors} anchors`;
                }

                const btnExport = document.createElement('button');
                btnExport.textContent = 'Export';
                btnExport.style.cssText = 'font-size: 10px; padding: 1px 6px;';
                btnExport.title = 'Export pack as JSON';
                btnExport.addEventListener('click', async () => {
                    await signaturePackManager.loadPack(entry.id);
                    const json = signaturePackManager.exportPack(entry.id);
                    if (json) {
                        const blob = new Blob([json], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = entry.id + '.json';
                        a.click();
                        URL.revokeObjectURL(url);
                    }
                });

                // Anchor detail panel (collapsible, below the row)
                const anchorPanel = document.createElement('div');
                anchorPanel.style.cssText = 'display: none; background: var(--bg-primary); border: 1px solid var(--border-primary); border-top: none; border-radius: 0 0 3px 3px; padding: 4px 6px; max-height: 200px; overflow-y: auto;';

                function renderAnchorPanel(targetPack) {
                    anchorPanel.innerHTML = '';
                    if (!targetPack || !targetPack.anchors || targetPack.anchors.length === 0) {
                        anchorPanel.innerHTML = '<div style="color: var(--text-secondary); font-size: 10px; font-style: italic;">No anchors. Load the game in emulator and click Build to create anchors from memory.</div>';
                        return;
                    }
                    const header = document.createElement('div');
                    header.style.cssText = 'font-size: 10px; color: var(--cyan); margin-bottom: 3px;';
                    header.textContent = `${targetPack.anchors.length} anchors (${targetPack.anchors[0].bytes.length} bytes each)`;
                    anchorPanel.appendChild(header);

                    const table = document.createElement('div');
                    table.style.cssText = 'font-family: monospace; font-size: 10px; line-height: 1.4;';
                    for (const anchor of targetPack.anchors) {
                        const line = document.createElement('div');
                        line.style.cssText = 'display: flex; gap: 8px; padding: 1px 0; border-bottom: 1px solid var(--bg-tertiary);';
                        const addrSpan = document.createElement('span');
                        addrSpan.style.cssText = 'color: var(--cyan); min-width: 36px;';
                        addrSpan.textContent = '$' + anchor.address.toString(16).toUpperCase().padStart(4, '0');
                        const labelSpan = document.createElement('span');
                        labelSpan.style.cssText = 'color: var(--green); min-width: 120px; max-width: 160px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;';
                        labelSpan.textContent = anchor.label;
                        labelSpan.title = anchor.label;
                        const hexSpan = document.createElement('span');
                        hexSpan.style.cssText = 'white-space: nowrap;';
                        if (anchor.mask) {
                            // Show masked bytes dimmed (address operands that are ignored during matching)
                            hexSpan.innerHTML = anchor.bytes.map((b, i) => {
                                const hex = b.toString(16).toUpperCase().padStart(2, '0');
                                return anchor.mask[i] === 0
                                    ? `<span style="opacity:0.3" title="masked (address operand)">${hex}</span>`
                                    : `<span style="color:var(--text-secondary)">${hex}</span>`;
                            }).join(' ');
                        } else {
                            hexSpan.style.color = 'var(--text-secondary)';
                            hexSpan.textContent = anchor.bytes.map(b => b.toString(16).toUpperCase().padStart(2, '0')).join(' ');
                        }
                        line.appendChild(addrSpan);
                        line.appendChild(labelSpan);
                        line.appendChild(hexSpan);
                        table.appendChild(line);
                    }
                    anchorPanel.appendChild(table);
                }

                const btnBuildAnchors = document.createElement('button');
                btnBuildAnchors.textContent = 'Build';
                btnBuildAnchors.style.cssText = 'font-size: 10px; padding: 1px 6px;';
                btnBuildAnchors.title = 'Build anchor patterns from current memory';
                btnBuildAnchors.addEventListener('click', async () => {
                    if (!pack) {
                        await signaturePackManager.loadPack(entry.id);
                    }
                    const loadedPack = signaturePackManager.loadedPacks[entry.id];
                    if (!loadedPack) { showMessage('Pack not loaded'); return; }
                    const readByte = (addr) => spectrum.memory.read(addr);
                    const anchors = signaturePackManager.buildAnchorsFromMemory(loadedPack, readByte);
                    loadedPack.anchors = anchors;
                    loadedPack.stats.anchors = anchors.length;
                    signaturePackManager._savePackToStorage(loadedPack);
                    // Update stats display
                    statsSpan.textContent = `${loadedPack.stats.labels}L ${loadedPack.stats.regions}R ${loadedPack.stats.anchors}A`;
                    statsSpan.title = `${loadedPack.stats.labels} labels, ${loadedPack.stats.regions} regions, ${loadedPack.stats.anchors} anchors`;
                    // Show anchor panel
                    renderAnchorPanel(loadedPack);
                    anchorPanel.style.display = 'block';
                    row.style.borderRadius = '3px 3px 0 0';
                    showMessage(`Built ${anchors.length} anchors for "${loadedPack.name}"`);
                });

                const btnDirectApply = document.createElement('button');
                btnDirectApply.textContent = 'Apply';
                btnDirectApply.style.cssText = 'font-size: 10px; padding: 1px 6px;';
                btnDirectApply.title = 'Apply all labels from this pack directly (no scanning)';
                btnDirectApply.addEventListener('click', async () => {
                    if (!signaturePackManager.loadedPacks[entry.id]) {
                        const stored = signaturePackManager._loadPackFromStorage(entry.id);
                        if (stored) signaturePackManager.loadedPacks[entry.id] = stored;
                        else await signaturePackManager.loadPack(entry.id);
                    }
                    const loadedPack = signaturePackManager.loadedPacks[entry.id];
                    if (!loadedPack || !loadedPack.labels) { showMessage('Pack has no labels'); return; }
                    // Apply all labels at offset 0 (direct, no matching)
                    const prevAutoSave = labelManager.autoSaveEnabled;
                    labelManager.autoSaveEnabled = false;
                    const labelCount = signaturePackManager._applyLabelsWithOffset(loadedPack, 0, labelManager, null);
                    const regionCount = signaturePackManager._applyRegionsWithOffset(loadedPack, 0, regionManager, null);
                    labelManager.autoSaveEnabled = prevAutoSave;
                    if (prevAutoSave) labelManager._autoSave();
                    showMessage(`Applied ${labelCount} labels, ${regionCount} regions from "${loadedPack.name}"`);
                    if (typeof updateDebugger === 'function') updateDebugger();
                });

                const btnViewAnchors = document.createElement('button');
                btnViewAnchors.textContent = 'View';
                btnViewAnchors.style.cssText = 'font-size: 10px; padding: 1px 6px;';
                btnViewAnchors.title = 'View/hide anchor patterns';
                btnViewAnchors.addEventListener('click', async () => {
                    if (anchorPanel.style.display !== 'none') {
                        anchorPanel.style.display = 'none';
                        row.style.borderRadius = '3px';
                        return;
                    }
                    if (!pack) {
                        await signaturePackManager.loadPack(entry.id);
                    }
                    const loadedPack = signaturePackManager.loadedPacks[entry.id];
                    renderAnchorPanel(loadedPack);
                    anchorPanel.style.display = 'block';
                    row.style.borderRadius = '3px 3px 0 0';
                });

                const btnRemove = document.createElement('button');
                btnRemove.textContent = '\u00D7';
                btnRemove.style.cssText = 'font-size: 12px; padding: 1px 5px; color: var(--error);';
                btnRemove.title = 'Remove this pack';
                btnRemove.addEventListener('click', () => {
                    signaturePackManager.removePack(entry.id);
                    renderSigPackList();
                    showMessage(`Removed pack "${entry.name || entry.id}"`);
                });

                row.appendChild(cb);
                row.appendChild(typeSpan);
                row.appendChild(nameSpan);
                row.appendChild(statsSpan);
                row.appendChild(btnDirectApply);
                row.appendChild(btnBuildAnchors);
                row.appendChild(btnViewAnchors);
                row.appendChild(btnExport);
                row.appendChild(btnRemove);
                wrapper.appendChild(row);
                wrapper.appendChild(anchorPanel);
                container.appendChild(wrapper);
            }
        }

        // Import source files (.skool, .asm, .a80, .zip containing any mix)
        document.getElementById('btnSigImportSkool').addEventListener('click', () => {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.skool,.asm,.a80,.z80asm,.txt,.zip';
            input.multiple = true;
            input.addEventListener('change', async (e) => {
                const files = Array.from(e.target.files);
                if (files.length === 0) return;

                // Collect all source file texts (from direct files and ZIP contents)
                const allFileTexts = [];
                const decoder = new TextDecoder('utf-8');

                for (const file of files) {
                    const lower = file.name.toLowerCase();
                    if (lower.endsWith('.zip')) {
                        // Extract source files from ZIP
                        const zipData = await new Promise(resolve => {
                            const reader = new FileReader();
                            reader.onload = () => resolve(reader.result);
                            reader.readAsArrayBuffer(file);
                        });
                        const zipFiles = await ZipLoader.extract(zipData);
                        const zipName = file.name.replace(/\.zip$/i, '');
                        for (const zf of zipFiles) {
                            const zfLower = zf.name.toLowerCase();
                            if (zfLower.endsWith('.skool') || zfLower.endsWith('.asm') ||
                                zfLower.endsWith('.a80') || zfLower.endsWith('.z80asm') || zfLower.endsWith('.txt')) {
                                allFileTexts.push({ path: zf.name, text: decoder.decode(zf.data), fileName: zf.name, zipName });
                            }
                        }
                    } else {
                        // Direct source file
                        const text = await new Promise(resolve => {
                            const reader = new FileReader();
                            reader.onload = () => resolve(reader.result);
                            reader.readAsText(file);
                        });
                        allFileTexts.push({ path: file.name, text, fileName: file.name, zipName: null });
                    }
                }

                if (allFileTexts.length === 0) {
                    showMessage('No source files found');
                    return;
                }

                // Separate by type
                const skoolFiles = allFileTexts.filter(f => f.fileName.toLowerCase().endsWith('.skool'));
                const asmFiles = allFileTexts.filter(f => {
                    const lower = f.fileName.toLowerCase();
                    return lower.endsWith('.asm') || lower.endsWith('.a80') || lower.endsWith('.z80asm') ||
                           (lower.endsWith('.txt') && !lower.endsWith('.skool'));
                });

                // Process .skool files individually
                for (const f of skoolFiles) {
                    const baseName = f.fileName.replace(/\.(skool|txt)$/i, '');
                    const packId = baseName.toLowerCase().replace(/[^a-z0-9_-]/g, '_');
                    const pack = signaturePackManager.parseSkoolFile(f.text, packId, baseName);
                    signaturePackManager.addPack(pack);
                    showMessage(`Imported "${baseName}": ${pack.stats.labels} labels, ${pack.stats.anchors} anchors`);
                }

                // Process .asm files as a batch
                if (asmFiles.length > 0) {
                    const mainName = (asmFiles[0].zipName || asmFiles[0].fileName).replace(/\.(asm|a80|z80asm|txt|zip)$/i, '');
                    const packId = mainName.toLowerCase().replace(/[^a-z0-9_-]/g, '_');
                    const pack = signaturePackManager.parseAsmFiles(asmFiles, packId, mainName);
                    signaturePackManager.addPack(pack);
                    showMessage(`Imported "${mainName}": ${pack.stats.labels} labels, ${pack.stats.anchors} anchors`);
                }

                renderSigPackList();
            });
            input.click();
        });

        // Import pack JSON
        document.getElementById('btnSigImportPack').addEventListener('click', () => {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = () => {
                    const entry = signaturePackManager.importPackJSON(reader.result);
                    if (entry) {
                        renderSigPackList();
                        showMessage(`Imported pack "${entry.name}"`);
                    } else {
                        showMessage('Failed to import pack');
                    }
                };
                reader.readAsText(file);
            });
            input.click();
        });

        // Scan memory for matches
        document.getElementById('btnSigScanMemory').addEventListener('click', async () => {
            const resultsDiv = document.getElementById('sigScanResults');
            resultsDiv.classList.remove('hidden');
            resultsDiv.textContent = 'Scanning...';

            await signaturePackManager.loadAllEnabled();

            // Build memory segments to scan:
            // - Current mapped memory $5C00-$FFFF (skip screen $4000-$5BFF)
            // - All RAM pages (128K+) that aren't currently mapped
            const mem = spectrum.memory;
            const segments = [];

            if (mem.profile.ramPages === 1) {
                // 48K: single block, skip screen area
                segments.push({
                    label: 'RAM',
                    readByte: (addr) => mem.read(addr),
                    start: 0x5C00,
                    end: 0xFFFF
                });
            } else {
                // 128K+: scan each RAM page as a flat 16K block
                const pageCount = mem.ram.length;
                for (let page = 0; page < pageCount; page++) {
                    const pageData = mem.ram[page];
                    segments.push({
                        label: `Page ${page}`,
                        page: page,
                        readByte: (addr) => pageData[addr],
                        start: 0,
                        end: 0x3FFF
                    });
                }
            }

            // Scan all segments, merge results
            let allResults = [];
            for (const seg of segments) {
                resultsDiv.textContent = `Scanning ${seg.label}...`;
                const results = signaturePackManager.scanMemory(seg.readByte, seg.start, seg.end);
                for (const r of results) {
                    r.segment = seg.label;
                    r.page = seg.page;
                }
                allResults.push(...results);
            }

            // Deduplicate: if same pack matched in multiple segments, keep best
            const bestByPack = {};
            for (const r of allResults) {
                const existing = bestByPack[r.packId];
                if (!existing || r.confidence > existing.confidence ||
                    (r.confidence === existing.confidence && r.matched > existing.matched)) {
                    bestByPack[r.packId] = r;
                }
            }
            const results = Object.values(bestByPack).sort((a, b) => b.confidence - a.confidence);

            if (results.length === 0) {
                resultsDiv.innerHTML = '<span style="color: var(--text-secondary);">No matches found. Load a program and ensure packs have anchors built.</span>';
                return;
            }

            resultsDiv.innerHTML = '';
            const header = document.createElement('div');
            header.style.cssText = 'margin-bottom: 4px; color: var(--cyan); font-size: 10px; text-transform: uppercase; letter-spacing: 0.5px;';
            header.textContent = 'Scan Results';
            resultsDiv.appendChild(header);

            for (const r of results) {
                const block = document.createElement('div');
                block.style.cssText = 'margin-bottom: 6px; padding: 4px 6px; background: var(--bg-primary); border-radius: 2px;';

                const row = document.createElement('div');
                row.style.cssText = 'display: flex; align-items: center; gap: 8px; margin-bottom: 2px;';

                const confidence = Math.round(r.confidence * 100);
                const confSpan = document.createElement('span');
                confSpan.style.cssText = `font-size: 10px; min-width: 36px; font-weight: bold; color: ${confidence >= 75 ? 'var(--green)' : confidence >= 50 ? 'var(--yellow)' : 'var(--error)'};`;
                confSpan.textContent = confidence + '%';

                const nameSpan = document.createElement('span');
                nameSpan.style.cssText = 'flex: 1; font-size: 11px;';
                const segInfo = r.segment ? ` [${r.segment}]` : '';
                nameSpan.textContent = r.pack.name + ` (${r.matched}/${r.total} anchors)${segInfo}`;

                // Determine offset mode
                const offsets = r.anchorMatches.map(m => m.offset);
                const uniqueOffsets = [...new Set(offsets)];
                const modeSpan = document.createElement('span');
                modeSpan.style.cssText = 'font-size: 9px; padding: 1px 4px; border-radius: 2px; background: var(--bg-button); color: var(--text-secondary);';
                if (uniqueOffsets.length === 1) {
                    const off = uniqueOffsets[0];
                    modeSpan.textContent = off === 0 ? 'exact' : `offset ${off >= 0 ? '+' : ''}${off}`;
                    modeSpan.title = 'All matched anchors at consistent offset';
                } else {
                    // Count how many anchors have the dominant offset
                    const offCounts = {};
                    for (const o of offsets) offCounts[o] = (offCounts[o] || 0) + 1;
                    const topOff = Object.entries(offCounts).sort((a, b) => b[1] - a[1]);
                    modeSpan.textContent = `${uniqueOffsets.length} offsets`;
                    const details = topOff.slice(0, 3).map(([o, c]) => {
                        const n = parseInt(o);
                        return `${n === 0 ? '0' : (n >= 0 ? '+' : '') + n}: ${c}`;
                    }).join(', ');
                    modeSpan.title = `Procedures at different offsets (${details})`;
                }

                const btnApply = document.createElement('button');
                btnApply.textContent = 'Apply';
                btnApply.style.cssText = 'font-size: 10px; padding: 1px 8px;';
                btnApply.title = 'Apply labels using per-anchor offsets';
                btnApply.addEventListener('click', () => {
                    const result = signaturePackManager.applyLabels(r, labelManager, regionManager, r.page);
                    let offStr = '';
                    if (result.uniqueOffsets === 1) {
                        offStr = result.offset === 0 ? '' : ` at offset ${result.offset >= 0 ? '+' : ''}${result.offset}`;
                    } else {
                        offStr = ` across ${result.uniqueOffsets} offsets`;
                    }
                    showMessage(`Applied ${result.labelCount} labels, ${result.regionCount} regions from "${r.pack.name}"${offStr}`);
                    if (typeof updateDebugger === 'function') updateDebugger();
                });

                row.appendChild(confSpan);
                row.appendChild(nameSpan);
                row.appendChild(modeSpan);
                row.appendChild(btnApply);
                block.appendChild(row);

                // Show per-anchor details
                const details = document.createElement('div');
                details.style.cssText = 'font-size: 10px; color: var(--text-secondary); margin-left: 44px;';
                for (const m of r.anchorMatches) {
                    const hex4 = (v) => v.toString(16).toUpperCase().padStart(4, '0');
                    const line = document.createElement('div');
                    const label = m.anchor.label || '?';
                    const offStr = m.offset === 0 ? '' : ` (${m.offset >= 0 ? '+' : ''}${m.offset})`;
                    const pagePrefix = r.page !== undefined ? `p${r.page}:` : '';
                    line.textContent = `${label}: ${hex4(m.origAddr)} → ${pagePrefix}${hex4(m.foundAddr)}${offStr}`;
                    details.appendChild(line);
                }
                block.appendChild(details);

                resultsDiv.appendChild(block);
            }
        });

        // ========== GitHub Repository Browser ==========
        const sigGitHubBrowser = document.getElementById('sigGitHubBrowser');
        const sigGitHubUrl = document.getElementById('sigGitHubUrl');
        const sigGitHubStatus = document.getElementById('sigGitHubStatus');
        const sigGitHubFileList = document.getElementById('sigGitHubFileList');
        const sigGitHubActions = document.getElementById('sigGitHubActions');
        const sigGitHubSelected = document.getElementById('sigGitHubSelected');
        let sigGitHubFiles = [];  // Array of { path, name, download_url, size, checked }
        let sigGitHubCurrentPath = '';  // Current browsed path within repo
        let sigGitHubOwnerRepo = '';    // "owner/repo"

        // Parse GitHub URL into owner/repo
        function parseGitHubRepo(input) {
            input = input.trim();
            // Full URL: https://github.com/owner/repo/...
            const urlMatch = input.match(/github\.com\/([^\/]+\/[^\/]+)/);
            if (urlMatch) return urlMatch[1].replace(/\.git$/, '');
            // Short form: owner/repo
            if (/^[a-zA-Z0-9_.-]+\/[a-zA-Z0-9_.-]+$/.test(input)) return input;
            return null;
        }

        // Fetch directory listing from GitHub API
        async function fetchGitHubDir(ownerRepo, path) {
            const apiUrl = `https://api.github.com/repos/${ownerRepo}/contents/${path}`;
            const resp = await fetch(apiUrl);
            if (!resp.ok) {
                if (resp.status === 403) throw new Error('GitHub API rate limit exceeded. Try again later.');
                if (resp.status === 404) throw new Error('Repository or path not found.');
                throw new Error(`GitHub API error: ${resp.status}`);
            }
            return await resp.json();
        }

        // Recursively find .skool and .json files in a repo
        async function scanGitHubRepo(ownerRepo, path, depth) {
            if (depth > 3) return []; // Limit recursion depth
            const items = await fetchGitHubDir(ownerRepo, path);
            if (!Array.isArray(items)) return [];

            const results = [];
            const subdirs = [];

            for (const item of items) {
                if (item.type === 'file') {
                    const lower = item.name.toLowerCase();
                    if (lower.endsWith('.skool') || lower.endsWith('.json') ||
                        lower.endsWith('.asm') || lower.endsWith('.a80') || lower.endsWith('.z80asm')) {
                        results.push({
                            path: item.path,
                            name: item.name,
                            download_url: item.download_url,
                            size: item.size,
                            checked: !lower.endsWith('.json') // pre-check .skool and .asm files
                        });
                    }
                } else if (item.type === 'dir') {
                    subdirs.push(item.path);
                }
            }

            // Scan subdirectories
            for (const subdir of subdirs) {
                sigGitHubStatus.textContent = `Scanning ${subdir}...`;
                const subResults = await scanGitHubRepo(ownerRepo, subdir, depth + 1);
                results.push(...subResults);
            }

            return results;
        }

        // Render the file list with checkboxes
        function renderGitHubFileList() {
            sigGitHubFileList.innerHTML = '';
            if (sigGitHubFiles.length === 0) {
                sigGitHubFileList.innerHTML = '<div style="color: var(--text-secondary); font-size: 11px; font-style: italic;">No .skool or .json files found.</div>';
                sigGitHubActions.classList.add('hidden');
                return;
            }

            for (let i = 0; i < sigGitHubFiles.length; i++) {
                const f = sigGitHubFiles[i];
                const row = document.createElement('div');
                row.style.cssText = 'display: flex; align-items: center; gap: 6px; padding: 2px 0;';

                const cb = document.createElement('input');
                cb.type = 'checkbox';
                cb.checked = f.checked;
                cb.dataset.idx = i;
                cb.addEventListener('change', () => {
                    sigGitHubFiles[i].checked = cb.checked;
                    updateGitHubSelectedCount();
                });

                const icon = document.createElement('span');
                icon.style.cssText = 'font-size: 10px; color: var(--text-secondary);';
                const ext = f.name.split('.').pop().toLowerCase();
                icon.textContent = ext === 'skool' ? 'SKOOL' : ext === 'json' ? 'JSON' : 'ASM';

                const nameSpan = document.createElement('span');
                nameSpan.style.cssText = 'flex: 1; font-size: 11px; color: var(--text-primary);';
                nameSpan.textContent = f.path;
                nameSpan.title = f.download_url;

                const sizeSpan = document.createElement('span');
                sizeSpan.style.cssText = 'font-size: 10px; color: var(--text-secondary); min-width: 50px; text-align: right;';
                sizeSpan.textContent = f.size > 1024 ? Math.round(f.size / 1024) + ' KB' : f.size + ' B';

                row.appendChild(cb);
                row.appendChild(icon);
                row.appendChild(nameSpan);
                row.appendChild(sizeSpan);
                sigGitHubFileList.appendChild(row);
            }

            sigGitHubActions.classList.remove('hidden');
            updateGitHubSelectedCount();
        }

        function updateGitHubSelectedCount() {
            const count = sigGitHubFiles.filter(f => f.checked).length;
            sigGitHubSelected.textContent = `${count} of ${sigGitHubFiles.length} selected`;
        }

        // Toggle GitHub browser
        document.getElementById('btnSigGitHub').addEventListener('click', () => {
            sigGitHubBrowser.classList.toggle('hidden');
            if (!sigGitHubBrowser.classList.contains('hidden')) {
                sigGitHubUrl.focus();
            }
        });

        document.getElementById('btnSigGitHubClose').addEventListener('click', () => {
            sigGitHubBrowser.classList.add('hidden');
        });

        // Browse repo
        document.getElementById('btnSigGitHubFetch').addEventListener('click', async () => {
            const ownerRepo = parseGitHubRepo(sigGitHubUrl.value);
            if (!ownerRepo) {
                sigGitHubStatus.textContent = 'Enter a valid GitHub URL or owner/repo';
                return;
            }
            sigGitHubOwnerRepo = ownerRepo;
            sigGitHubStatus.textContent = `Scanning ${ownerRepo}...`;
            sigGitHubFileList.innerHTML = '';
            sigGitHubActions.classList.add('hidden');

            try {
                sigGitHubFiles = await scanGitHubRepo(ownerRepo, '', 0);
                sigGitHubStatus.textContent = `Found ${sigGitHubFiles.length} file(s) in ${ownerRepo}`;
                renderGitHubFileList();
            } catch (e) {
                sigGitHubStatus.textContent = e.message;
                sigGitHubFiles = [];
            }
        });

        // Handle Enter key in URL input
        sigGitHubUrl.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                document.getElementById('btnSigGitHubFetch').click();
            }
        });

        // Import selected files
        document.getElementById('btnSigGitHubImport').addEventListener('click', async () => {
            const selected = sigGitHubFiles.filter(f => f.checked);
            if (selected.length === 0) {
                sigGitHubStatus.textContent = 'No files selected';
                return;
            }

            let imported = 0;
            let failed = 0;

            // Separate files by type
            const skoolFiles = selected.filter(f => f.name.toLowerCase().endsWith('.skool'));
            const jsonFiles = selected.filter(f => f.name.toLowerCase().endsWith('.json'));
            const asmFiles = selected.filter(f => {
                const lower = f.name.toLowerCase();
                return lower.endsWith('.asm') || lower.endsWith('.a80') || lower.endsWith('.z80asm');
            });

            // Process .skool files individually
            for (const file of skoolFiles) {
                sigGitHubStatus.textContent = `Downloading ${file.name}...`;
                try {
                    const resp = await fetch(file.download_url);
                    if (!resp.ok) { failed++; continue; }
                    const text = await resp.text();
                    const baseName = file.name.replace(/\.(skool|txt)$/i, '');
                    const packId = baseName.toLowerCase().replace(/[^a-z0-9_-]/g, '_');
                    const pack = signaturePackManager.parseSkoolFile(text, packId, baseName);
                    pack.source = `github:${sigGitHubOwnerRepo}/${file.path}`;
                    signaturePackManager.addPack(pack);
                    imported++;
                } catch (e) {
                    console.warn('Failed to import:', file.path, e);
                    failed++;
                }
            }

            // Process .json files individually
            for (const file of jsonFiles) {
                sigGitHubStatus.textContent = `Downloading ${file.name}...`;
                try {
                    const resp = await fetch(file.download_url);
                    if (!resp.ok) { failed++; continue; }
                    const text = await resp.text();
                    const entry = signaturePackManager.importPackJSON(text);
                    if (entry) imported++; else failed++;
                } catch (e) {
                    console.warn('Failed to import:', file.path, e);
                    failed++;
                }
            }

            // Process .asm files as a batch (for INCLUDE resolution)
            if (asmFiles.length > 0) {
                sigGitHubStatus.textContent = `Downloading ${asmFiles.length} ASM files...`;
                const fileTexts = [];
                let allOk = true;

                // Also download all unchecked .asm files in the repo for INCLUDE resolution
                const allAsmInRepo = sigGitHubFiles.filter(f => {
                    const lower = f.name.toLowerCase();
                    return lower.endsWith('.asm') || lower.endsWith('.a80') || lower.endsWith('.z80asm');
                });

                for (const file of allAsmInRepo) {
                    sigGitHubStatus.textContent = `Downloading ${file.name}...`;
                    try {
                        const resp = await fetch(file.download_url);
                        if (!resp.ok) { if (file.checked) allOk = false; continue; }
                        const text = await resp.text();
                        fileTexts.push({ path: file.path, text: text });
                    } catch (e) {
                        console.warn('Failed to download:', file.path, e);
                        if (file.checked) allOk = false;
                    }
                }

                if (fileTexts.length > 0) {
                    sigGitHubStatus.textContent = 'Parsing ASM files...';
                    try {
                        const repoName = sigGitHubOwnerRepo.split('/').pop();
                        const packId = repoName.toLowerCase().replace(/[^a-z0-9_-]/g, '_');
                        const pack = signaturePackManager.parseAsmFiles(fileTexts, packId, repoName);
                        pack.source = `github:${sigGitHubOwnerRepo}`;
                        signaturePackManager.addPack(pack);
                        imported++;
                    } catch (e) {
                        console.warn('Failed to parse ASM files:', e);
                        failed++;
                    }
                }
            }

            sigGitHubStatus.textContent = `Imported ${imported} pack(s)` + (failed ? `, ${failed} failed` : '');
            renderSigPackList();
            if (imported > 0) showMessage(`Imported ${imported} pack(s) from GitHub`);
        });

        // Initialize signature packs on startup
        signaturePackManager.init().then(() => renderSigPackList());

        // Create emulator
        const savedMachineType = localStorage.getItem('zx-machine-type') || '48k';
        let spectrum = new Spectrum(canvas, {
            machineType: savedMachineType,
            tapeTrapsEnabled: true,
            overlayCanvas: overlayCanvas
        });
        window.spectrum = spectrum;

        // Set up boot TRD callback for injection during disk loading
        spectrum.onBeforeTrdLoad = (data, filename) => processTrdWithBoot(data, filename);

        // Disk activity indicator
        const diskActivityEl = document.getElementById('diskActivity');
        const diskLedEl = document.getElementById('diskLed');
        const diskStatusEl = document.getElementById('diskStatus');
        let diskActivityTimeout = null;

        function setupDiskActivityCallback() {
            const activityHandler = (type, track, sector, side, driveNum) => {
                // Show disk activity indicator
                diskActivityEl.style.display = 'inline-block';

                // Update LED color based on operation
                if (type === 'read') {
                    diskLedEl.style.color = '#0f0';  // Green for read
                    diskLedEl.title = 'Reading from disk';
                } else if (type === 'write') {
                    diskLedEl.style.color = '#f80';  // Orange for write
                    diskLedEl.title = 'Writing to disk';
                }

                // Show drive letter + track/sector info (padded to fixed width)
                const driveLetter = String.fromCharCode(65 + (driveNum || 0));
                const sideStr = side ? 'B' : 'A';
                const trackStr = String(track).padStart(2, '0');
                const sectorStr = String(sector).padStart(2, '0');
                diskStatusEl.textContent = `${driveLetter}:T${trackStr}:S${sectorStr}:${sideStr}`;

                // Clear timeout and set new one to show idle state
                if (diskActivityTimeout) clearTimeout(diskActivityTimeout);
                diskActivityTimeout = setTimeout(() => {
                    diskLedEl.style.color = '';  // Reset color
                    diskLedEl.title = 'Disk idle';
                    diskStatusEl.textContent = 'idle';
                }, 200);
            };

            if (spectrum.betaDisk) {
                spectrum.betaDisk.onDiskActivity = activityHandler;
            }
            if (spectrum.fdc) {
                spectrum.fdc.onDiskActivity = activityHandler;
            }
        }
        setupDiskActivityCallback();

        // Initialize test runner
        testRunner = new TestRunner(spectrum);

        // ========== Compare Tool ==========
        const compareFileA = document.getElementById('compareFileA');
        const compareFileB = document.getElementById('compareFileB');
        const compareFileBContainer = document.getElementById('compareFileBContainer');
        const btnCompare = document.getElementById('btnCompare');
        const chkCompareShowEqual = document.getElementById('chkCompareShowEqual');
        const chkCompareHexDump = document.getElementById('chkCompareHexDump');
        const chkCompareExcludeScreen = document.getElementById('chkCompareExcludeScreen');
        const compareHeaderResults = document.getElementById('compareHeaderResults');
        const compareHeaderTable = document.getElementById('compareHeaderTable');
        const compareDataResults = document.getElementById('compareDataResults');
        const compareDataTitle = document.getElementById('compareDataTitle');
        const compareDiffCount = document.getElementById('compareDiffCount');
        const compareDataTable = document.getElementById('compareDataTable');
        const compareNoResults = document.getElementById('compareNoResults');
        const comparePagination = document.getElementById('comparePagination');
        const compareDiffCountNoPage = document.getElementById('compareDiffCountNoPage');
        const comparePrevPage = document.getElementById('comparePrevPage');
        const compareNextPage = document.getElementById('compareNextPage');
        const comparePageInfo = document.getElementById('comparePageInfo');
        const compareGoToPage = document.getElementById('compareGoToPage');
        const compareGoPage = document.getElementById('compareGoPage');

        let compareDataA = null;
        let compareDataB = null;

        // Pagination state
        const DIFFS_PER_PAGE = 50;  // Number of diff blocks per page
        let compareDiffsData = null;  // Stored diffs for pagination
        let compareCurrentPage = 1;
        let compareTotalPages = 1;
        let compareRenderOptions = {};  // Store render options for re-rendering

        // Detect snapshot type from data
        function detectSnapshotType(data) {
            const size = data.byteLength;
            // SNA sizes
            if (size === 49179) return 'sna48';
            if (size === 131103 || size === 147487) return 'sna128';
            // Z80 detection - check header structure
            if (size >= 30) {
                const pc = data[6] | (data[7] << 8);
                if (pc === 0 && size >= 55) {
                    // V2 or V3 z80
                    const extLen = data[30] | (data[31] << 8);
                    if (extLen === 23 || extLen === 54 || extLen === 55) {
                        const hwMode = data[34];
                        if (extLen === 23) {
                            return (hwMode === 3 || hwMode === 4) ? 'z80-128' : 'z80-48';
                        } else {
                            return (hwMode >= 4 && hwMode <= 6) ? 'z80-128' : 'z80-48';
                        }
                    }
                } else if (pc !== 0) {
                    return 'z80-48'; // V1 z80
                }
            }
            return 'binary';
        }

        // Decompress Z80 block
        function decompressZ80Block(data, maxLen, compressed) {
            if (!compressed) return data.slice(0, maxLen);
            const result = new Uint8Array(maxLen);
            let srcIdx = 0, dstIdx = 0;
            while (srcIdx < data.length && dstIdx < maxLen) {
                if (srcIdx + 3 < data.length && data[srcIdx] === 0xED && data[srcIdx + 1] === 0xED) {
                    const count = data[srcIdx + 2];
                    const value = data[srcIdx + 3];
                    for (let i = 0; i < count && dstIdx < maxLen; i++) result[dstIdx++] = value;
                    srcIdx += 4;
                } else if (data[srcIdx] === 0x00 && srcIdx + 3 < data.length &&
                           data[srcIdx + 1] === 0xED && data[srcIdx + 2] === 0xED && data[srcIdx + 3] === 0x00) {
                    break;
                } else {
                    result[dstIdx++] = data[srcIdx++];
                }
            }
            return result.slice(0, dstIdx);
        }

        // Parse Z80 file into normalized format
        function parseZ80File(data) {
            const bytes = data;
            if (bytes.length < 30) return null;

            const result = {
                registers: {},
                memory: new Uint8Array(65536),
                is128K: false,
                border: 0,
                port7FFD: 0
            };

            // Read header
            result.registers.A = bytes[0];
            result.registers.F = bytes[1];
            result.registers.BC = bytes[2] | (bytes[3] << 8);
            result.registers.HL = bytes[4] | (bytes[5] << 8);
            let pc = bytes[6] | (bytes[7] << 8);
            result.registers.SP = bytes[8] | (bytes[9] << 8);
            result.registers.I = bytes[10];
            result.registers.R = (bytes[11] & 0x7f) | ((bytes[12] & 0x01) << 7);

            const byte12 = bytes[12];
            result.border = (byte12 >> 1) & 0x07;
            const compressed = (byte12 & 0x20) !== 0;

            result.registers.DE = bytes[13] | (bytes[14] << 8);
            result.registers["BC'"] = bytes[15] | (bytes[16] << 8);
            result.registers["DE'"] = bytes[17] | (bytes[18] << 8);
            result.registers["HL'"] = bytes[19] | (bytes[20] << 8);
            result.registers["AF'"] = (bytes[21] << 8) | bytes[22];
            result.registers.IY = bytes[23] | (bytes[24] << 8);
            result.registers.IX = bytes[25] | (bytes[26] << 8);
            result.registers.IFF1 = bytes[27] !== 0 ? 1 : 0;
            result.registers.IFF2 = bytes[28] !== 0 ? 1 : 0;
            result.registers.IM = bytes[29] & 0x03;

            if (pc !== 0) {
                // Version 1 - 48K only
                result.registers.PC = pc;
                const memData = decompressZ80Block(bytes.subarray(30), 49152, compressed);
                for (let i = 0; i < memData.length; i++) result.memory[0x4000 + i] = memData[i];
                return result;
            }

            // Version 2 or 3
            const extHeaderLen = bytes[30] | (bytes[31] << 8);
            result.registers.PC = bytes[32] | (bytes[33] << 8);
            const hwMode = bytes[34];

            if (extHeaderLen === 23) {
                result.is128K = (hwMode === 3 || hwMode === 4);
            } else {
                result.is128K = (hwMode >= 4 && hwMode <= 6);
            }

            if (result.is128K && bytes.length > 35) {
                result.port7FFD = bytes[35];
            }

            // Load memory pages
            let offset = 32 + extHeaderLen;
            while (offset < bytes.length - 3) {
                const blockLen = bytes[offset] | (bytes[offset + 1] << 8);
                const pageNum = bytes[offset + 2];
                offset += 3;
                if (blockLen === 0xffff) {
                    // Uncompressed
                    for (let i = 0; i < 16384 && offset + i < bytes.length; i++) {
                        const addr = getZ80PageAddress(pageNum, result.is128K);
                        if (addr >= 0) result.memory[addr + i] = bytes[offset + i];
                    }
                    offset += 16384;
                } else {
                    const blockData = bytes.subarray(offset, offset + blockLen);
                    const pageData = decompressZ80Block(blockData, 16384, true);
                    const addr = getZ80PageAddress(pageNum, result.is128K);
                    if (addr >= 0) {
                        for (let i = 0; i < pageData.length; i++) result.memory[addr + i] = pageData[i];
                    }
                    offset += blockLen;
                }
            }
            return result;
        }

        function getZ80PageAddress(pageNum, is128K) {
            if (is128K) {
                // 128K: page 3=bank0, 4=bank1, 5=bank2, 6=bank3, 7=bank4, 8=bank5, 9=bank6, 10=bank7
                // Banks 5,2,paged map to 4000,8000,C000
                if (pageNum === 8) return 0x4000; // Bank 5
                if (pageNum === 4) return 0x8000; // Bank 2
                // For simplicity, we only support the main 48K view
                return -1;
            } else {
                // 48K: page 4=8000-BFFF, 5=C000-FFFF, 8=4000-7FFF
                if (pageNum === 8) return 0x4000;
                if (pageNum === 4) return 0x8000;
                if (pageNum === 5) return 0xC000;
            }
            return -1;
        }

        // Parse SNA file into normalized format
        function parseSnaFile(data) {
            const is128K = data.byteLength > 49179;
            const result = {
                registers: {},
                memory: new Uint8Array(65536),
                is128K: is128K,
                border: data[26],
                port7FFD: is128K ? data[49181] : 0
            };

            result.registers.I = data[0];
            result.registers["HL'"] = data[1] | (data[2] << 8);
            result.registers["DE'"] = data[3] | (data[4] << 8);
            result.registers["BC'"] = data[5] | (data[6] << 8);
            result.registers["AF'"] = data[7] | (data[8] << 8);
            result.registers.HL = data[9] | (data[10] << 8);
            result.registers.DE = data[11] | (data[12] << 8);
            result.registers.BC = data[13] | (data[14] << 8);
            result.registers.IY = data[15] | (data[16] << 8);
            result.registers.IX = data[17] | (data[18] << 8);
            result.registers.IFF2 = (data[19] & 0x04) ? 1 : 0;
            result.registers.IFF1 = result.registers.IFF2;
            result.registers.R = data[20];
            result.registers.AF = data[21] | (data[22] << 8);
            result.registers.A = data[22];
            result.registers.F = data[21];
            result.registers.SP = data[23] | (data[24] << 8);
            result.registers.IM = data[25];

            // Copy memory (48K: 0x4000-0xFFFF)
            for (let i = 0; i < 49152 && 27 + i < data.length; i++) {
                result.memory[0x4000 + i] = data[27 + i];
            }

            // For 48K SNA, PC is on stack
            if (!is128K) {
                const sp = result.registers.SP;
                if (sp >= 0x4000 && sp < 0xFFFF) {
                    result.registers.PC = result.memory[sp] | (result.memory[sp + 1] << 8);
                }
            } else {
                result.registers.PC = data[49179] | (data[49180] << 8);
            }

            return result;
        }

        // Parse any snapshot file
        function parseSnapshotFile(data) {
            const type = detectSnapshotType(data);
            if (type.startsWith('sna')) return parseSnaFile(data);
            if (type.startsWith('z80')) return parseZ80File(data);
            return null;
        }

        // SNA header field definitions
        const SNA_HEADER_48K = [
            { offset: 0, size: 1, name: 'I' },
            { offset: 1, size: 2, name: "HL'" },
            { offset: 3, size: 2, name: "DE'" },
            { offset: 5, size: 2, name: "BC'" },
            { offset: 7, size: 2, name: "AF'" },
            { offset: 9, size: 2, name: 'HL' },
            { offset: 11, size: 2, name: 'DE' },
            { offset: 13, size: 2, name: 'BC' },
            { offset: 15, size: 2, name: 'IY' },
            { offset: 17, size: 2, name: 'IX' },
            { offset: 19, size: 1, name: 'IFF2', format: v => v & 0x04 ? '1' : '0' },
            { offset: 20, size: 1, name: 'R' },
            { offset: 21, size: 2, name: 'AF' },
            { offset: 23, size: 2, name: 'SP' },
            { offset: 25, size: 1, name: 'IM', format: v => v.toString() },
            { offset: 26, size: 1, name: 'Border', format: v => v.toString() }
        ];
        const SNA_HEADER_128K = [
            ...SNA_HEADER_48K,
            { offset: 49179, size: 2, name: 'PC' },
            { offset: 49181, size: 1, name: 'Port 7FFD' },
            { offset: 49182, size: 1, name: 'TR-DOS ROM', format: v => v ? 'Yes' : 'No' }
        ];

        // Update mode UI
        document.querySelectorAll('input[name="compareMode"]').forEach(radio => {
            radio.addEventListener('change', () => {
                const mode = document.querySelector('input[name="compareMode"]:checked').value;
                if (mode === 'sna-emu') {
                    compareFileBContainer.style.display = 'none';
                } else {
                    compareFileBContainer.style.display = 'block';
                }
                // Exclude screen only makes sense for snapshot comparisons
                const excludeScreenLabel = chkCompareExcludeScreen.parentElement;
                if (mode === 'bin-bin') {
                    excludeScreenLabel.style.opacity = '0.4';
                    chkCompareExcludeScreen.disabled = true;
                } else {
                    excludeScreenLabel.style.opacity = '1';
                    chkCompareExcludeScreen.disabled = false;
                }
                clearCompareResults();
            });
        });

        function clearCompareResults() {
            compareHeaderResults.style.display = 'none';
            compareDataResults.style.display = 'none';
            compareNoResults.style.display = 'none';
            comparePagination.style.display = 'none';
            compareDiffCountNoPage.style.display = 'none';
            compareDiffsData = null;
            compareCurrentPage = 1;
            compareTotalPages = 1;
        }

        compareFileA.addEventListener('change', async (e) => {
            if (e.target.files[0]) {
                compareDataA = await extractCompareData(e.target.files[0]);
            }
        });

        compareFileB.addEventListener('change', async (e) => {
            if (e.target.files[0]) {
                compareDataB = await extractCompareData(e.target.files[0]);
            }
        });

        // Extract data for comparison - handles RZX and SZX by extracting embedded snapshots
        async function extractCompareData(file) {
            const data = new Uint8Array(await file.arrayBuffer());
            const ext = file.name.toLowerCase().split('.').pop();

            // RZX: extract embedded snapshot
            if (ext === 'rzx' || RZXLoader.isRZX(data.buffer)) {
                try {
                    const rzxLoader = new RZXLoader();
                    await rzxLoader.parse(data.buffer);
                    const snapshot = rzxLoader.getSnapshot();
                    if (snapshot) {
                        return snapshot;
                    }
                } catch (e) {
                    console.error('RZX extraction failed:', e);
                }
            }

            // SZX: extract 48K memory view for comparison
            if (ext === 'szx' || SZXLoader.isSZX(data.buffer)) {
                try {
                    const info = SZXLoader.parse(data.buffer);
                    // Build a synthetic SNA-like structure for comparison
                    const memory = new Uint8Array(49152);
                    // Extract pages 5, 2, and the paged bank
                    const page5 = SZXLoader.extractRAMPage(data.buffer, info, 5);
                    const page2 = SZXLoader.extractRAMPage(data.buffer, info, 2);
                    const page0 = SZXLoader.extractRAMPage(data.buffer, info, 0);
                    if (page5) memory.set(page5.slice(0, 16384), 0);
                    if (page2) memory.set(page2.slice(0, 16384), 16384);
                    if (page0) memory.set(page0.slice(0, 16384), 32768);
                    // Return as fake SNA (27-byte header + memory)
                    const result = new Uint8Array(27 + 49152);
                    result.set(memory, 27);
                    return result;
                } catch (e) {
                    console.error('SZX extraction failed:', e);
                }
            }

            return data;
        }

        btnCompare.addEventListener('click', () => {
            const mode = document.querySelector('input[name="compareMode"]:checked').value;
            clearCompareResults();

            if (mode === 'sna-emu') {
                if (!compareDataA) {
                    alert('Please select a snapshot file (.SNA or .Z80)');
                    return;
                }
                compareSnapshotVsEmulator(compareDataA);
            } else if (mode === 'sna-sna') {
                if (!compareDataA || !compareDataB) {
                    alert('Please select two snapshot files (.SNA or .Z80)');
                    return;
                }
                compareSnapshotFiles(compareDataA, compareDataB);
            } else {
                if (!compareDataA || !compareDataB) {
                    alert('Please select two files');
                    return;
                }
                compareBinaryFiles(compareDataA, compareDataB);
            }
        });

        function formatHex8(v) { return v.toString(16).toUpperCase().padStart(2, '0'); }
        function formatHex16(v) { return v.toString(16).toUpperCase().padStart(4, '0'); }

        function readWord(data, offset) {
            return data[offset] | (data[offset + 1] << 8);
        }

        function parseSnaHeader(data) {
            const is128K = data.byteLength > 49179;
            const fields = is128K ? SNA_HEADER_128K : SNA_HEADER_48K;
            const result = {};
            for (const field of fields) {
                let value;
                if (field.size === 1) {
                    value = data[field.offset];
                } else {
                    value = readWord(data, field.offset);
                }
                result[field.name] = { value, field };
            }
            // For 48K SNA, PC is on stack
            if (!is128K) {
                const sp = readWord(data, 23);
                const stackOffset = 27 + sp - 0x4000;
                if (stackOffset >= 27 && stackOffset < data.byteLength - 1) {
                    result['PC (from stack)'] = { value: readWord(data, stackOffset), field: { size: 2 } };
                }
            }
            return result;
        }

        function compareHeaders(headerA, headerB, showEqual) {
            const rows = [];
            const allKeys = new Set([...Object.keys(headerA), ...Object.keys(headerB)]);
            for (const key of allKeys) {
                const a = headerA[key];
                const b = headerB[key];
                if (!a || !b) continue;
                const valA = a.field.format ? a.field.format(a.value) : (a.field.size === 2 ? formatHex16(a.value) : formatHex8(a.value));
                const valB = b.field.format ? b.field.format(b.value) : (b.field.size === 2 ? formatHex16(b.value) : formatHex8(b.value));
                const isDiff = a.value !== b.value;
                if (isDiff || showEqual) {
                    const color = isDiff ? 'color:var(--red)' : 'color:var(--text-secondary)';
                    rows.push(`<div style="${color}">${key.padEnd(12)}: ${valA.padEnd(6)} vs ${valB}${isDiff ? ' ◄' : ''}</div>`);
                }
            }
            return rows.join('');
        }

        // Escape HTML special characters for ASCII display
        function escapeHtmlChar(charCode) {
            if (charCode < 32 || charCode >= 127) return '.';
            if (charCode === 32) return '&nbsp;';  // space - use non-breaking space
            if (charCode === 60) return '&lt;';    // <
            if (charCode === 62) return '&gt;';    // >
            if (charCode === 38) return '&amp;';   // &
            return String.fromCharCode(charCode);
        }

        function compareBinaryData(dataA, dataB, offsetA = 0, offsetB = 0, length = null, showEqual = false, showHexDump = true) {
            const len = length || Math.max(dataA.byteLength - offsetA, dataB.byteLength - offsetB);
            const diffs = [];

            for (let i = 0; i < len; i++) {
                const addrA = offsetA + i;
                const addrB = offsetB + i;
                const a = addrA < dataA.byteLength ? dataA[addrA] : null;
                const b = addrB < dataB.byteLength ? dataB[addrB] : null;
                const isDiff = a !== b;
                if (isDiff || showEqual) {
                    diffs.push({ offset: i, addrA, addrB, a, b, isDiff });
                }
            }

            if (diffs.length === 0) return { count: 0, html: '' };

            // Group consecutive differences for hex dump
            let html = '';
            if (showHexDump && diffs.length > 0) {
                const diffCount = diffs.filter(d => d.isDiff).length;
                // Show in groups of 16 bytes
                let i = 0;
                while (i < diffs.length && i < 1000) { // Limit display
                    const startOffset = diffs[i].offset & ~0xF; // Align to 16
                    const rows = [];

                    // Find range of diffs in this area
                    let endI = i;
                    while (endI < diffs.length && diffs[endI].offset < startOffset + 32) endI++;

                    // Output one or two lines
                    for (let lineStart = startOffset; lineStart < startOffset + 32 && i < endI; lineStart += 16) {
                        let hexA = '', hexB = '', ascA = '', ascB = '';
                        for (let j = 0; j < 16; j++) {
                            const off = lineStart + j;
                            const diff = diffs.find(d => d.offset === off);
                            const a = offsetA + off < dataA.byteLength ? dataA[offsetA + off] : null;
                            const b = offsetB + off < dataB.byteLength ? dataB[offsetB + off] : null;
                            const isDiff = diff && diff.isDiff;
                            const diffStyle = isDiff ? 'color:#ff6b6b;font-weight:bold' : '';
                            hexA += `<span style="${diffStyle}">${a !== null ? formatHex8(a) : '--'}</span> `;
                            hexB += `<span style="${diffStyle}">${b !== null ? formatHex8(b) : '--'}</span> `;
                            const ascCharA = a !== null ? escapeHtmlChar(a) : '.';
                            const ascCharB = b !== null ? escapeHtmlChar(b) : '.';
                            ascA += `<span style="${diffStyle}">${ascCharA}</span>`;
                            ascB += `<span style="${diffStyle}">${ascCharB}</span>`;
                        }
                        rows.push(`<div style="white-space:nowrap">${formatHex16(lineStart)}: ${hexA}|${ascA}|</div>`);
                        rows.push(`<div style="white-space:nowrap;color:var(--cyan)">${formatHex16(lineStart)}: ${hexB}|${ascB}|</div>`);
                    }
                    html += rows.join('') + '<hr style="border-color:var(--border);margin:5px 0">';
                    i = endI;
                }
                return { count: diffCount, html };
            } else {
                // Simple list
                const lines = diffs.slice(0, 500).map(d => {
                    const color = d.isDiff ? 'color:#ff6b6b' : '';
                    return `<div style="${color}">${formatHex16(d.offset)}: ${d.a !== null ? formatHex8(d.a) : '--'} vs ${d.b !== null ? formatHex8(d.b) : '--'}${d.isDiff ? ' ◄' : ''}</div>`;
                });
                if (diffs.length > 500) lines.push(`<div>... and ${diffs.length - 500} more</div>`);
                return { count: diffs.filter(d => d.isDiff).length, html: lines.join('') };
            }
        }

        function compareSnapshotFiles(dataA, dataB) {
            const showEqual = chkCompareShowEqual.checked;
            const showHexDump = chkCompareHexDump.checked;
            const excludeScreen = chkCompareExcludeScreen.checked;

            // Parse both files into normalized format
            const typeA = detectSnapshotType(dataA);
            const typeB = detectSnapshotType(dataB);

            if (typeA === 'binary' || typeB === 'binary') {
                compareDataResults.style.display = 'block';
                compareDataTitle.textContent = 'Error';
                compareDiffCount.textContent = '';
                compareDataTable.innerHTML = '<div style="color:var(--red)">One or both files are not valid snapshot files (.SNA or .Z80)</div>';
                return;
            }

            const snapA = parseSnapshotFile(dataA);
            const snapB = parseSnapshotFile(dataB);

            if (!snapA || !snapB) {
                compareDataResults.style.display = 'block';
                compareDataTitle.textContent = 'Error';
                compareDiffCount.textContent = '';
                compareDataTable.innerHTML = '<div style="color:var(--red)">Failed to parse snapshot files</div>';
                return;
            }

            // Compare registers
            const headerHtml = compareSnapshotRegisters(snapA, snapB, showEqual, typeA, typeB);
            if (headerHtml) {
                compareHeaderResults.style.display = 'block';
                compareHeaderTable.innerHTML = headerHtml;
            }

            // Check for machine type mismatch
            if (snapA.is128K !== snapB.is128K) {
                compareDataResults.style.display = 'block';
                compareDataTitle.textContent = 'Memory Comparison';
                compareDiffCount.textContent = '(different machine types: 48K vs 128K)';
                compareDataTable.innerHTML = '<div style="color:var(--yellow)">Cannot compare 48K and 128K snapshots directly</div>';
                return;
            }

            // Compare memory (0x4000-0xFFFF range that both formats have)
            const result = compareMemoryData(snapA.memory, snapB.memory, 0x4000, 49152, showEqual, showHexDump, excludeScreen, snapA.is128K);
            if (result.count === 0 && !headerHtml) {
                compareNoResults.style.display = 'block';
                comparePagination.style.display = 'none';
            } else {
                compareDataResults.style.display = 'block';
                const blocksNote = result.totalBlocks ? `, ${result.totalBlocks} blocks` : '';
                compareDiffCount.textContent = `${result.count} bytes differ${blocksNote}`;
                compareDataTable.innerHTML = result.html || '<div style="color:var(--green)">Memory is identical</div>';
                updateComparePagination();
            }
        }

        // Compare registers from normalized snapshot format
        function compareSnapshotRegisters(snapA, snapB, showEqual, typeA, typeB) {
            // Helper to format a register comparison cell
            function regCell(name, a, b, is16bit) {
                if (a === undefined || b === undefined) return '';
                const isDiff = a !== b;
                const valA = is16bit ? formatHex16(a) : formatHex8(a);
                const valB = is16bit ? formatHex16(b) : formatHex8(b);
                const color = isDiff ? 'color:#ff6b6b;font-weight:bold' : '';
                const marker = isDiff ? ' ◄' : '';
                return `<span style="${color}">${name.padEnd(4)} ${valA} ${valB}${marker}</span>`;
            }

            // Main registers paired with alternate registers
            const pairs = [
                ['AF', "AF'"], ['BC', "BC'"], ['DE', "DE'"], ['HL', "HL'"]
            ];

            // Other register pairs
            const otherPairs = [
                ['PC', 'SP'], ['IX', 'IY']
            ];

            // 8-bit registers
            const reg8Pairs = [
                ['I', 'R'], ['IM', 'IFF1'], ['', 'IFF2']
            ];

            let html = '<div style="display:flex;gap:40px">';

            // Left column: main registers
            html += '<div>';
            for (const [main, alt] of pairs) {
                const mainCell = regCell(main, snapA.registers[main], snapB.registers[main], true);
                html += `<div style="white-space:nowrap">${mainCell}</div>`;
            }
            html += '<div style="height:8px"></div>';
            for (const [r1, r2] of otherPairs) {
                const cell = regCell(r1, snapA.registers[r1], snapB.registers[r1], true);
                html += `<div style="white-space:nowrap">${cell}</div>`;
            }
            html += '<div style="height:8px"></div>';
            for (const [r1, r2] of reg8Pairs) {
                if (r1) {
                    const is16 = false;
                    const cell = regCell(r1, snapA.registers[r1], snapB.registers[r1], is16);
                    html += `<div style="white-space:nowrap">${cell}</div>`;
                }
            }
            // Border
            const borderDiff = snapA.border !== snapB.border;
            const borderColor = borderDiff ? 'color:#ff6b6b;font-weight:bold' : '';
            const borderMarker = borderDiff ? ' ◄' : '';
            html += `<div style="height:8px"></div>`;
            html += `<div style="white-space:nowrap;${borderColor}">Bord ${snapA.border}    ${snapB.border}${borderMarker}</div>`;
            // Port 7FFD for 128K
            if (snapA.is128K) {
                const pageDiff = snapA.port7FFD !== snapB.port7FFD;
                const pageColor = pageDiff ? 'color:#ff6b6b;font-weight:bold' : '';
                const pageMarker = pageDiff ? ' ◄' : '';
                html += `<div style="white-space:nowrap;${pageColor}">7FFD ${formatHex8(snapA.port7FFD)} ${formatHex8(snapB.port7FFD)}${pageMarker}</div>`;
            }
            html += '</div>';

            // Right column: alternate registers
            html += '<div>';
            for (const [main, alt] of pairs) {
                const altCell = regCell(alt, snapA.registers[alt], snapB.registers[alt], true);
                html += `<div style="white-space:nowrap">${altCell}</div>`;
            }
            html += '<div style="height:8px"></div>';
            for (const [r1, r2] of otherPairs) {
                const cell = regCell(r2, snapA.registers[r2], snapB.registers[r2], true);
                html += `<div style="white-space:nowrap">${cell}</div>`;
            }
            html += '<div style="height:8px"></div>';
            for (const [r1, r2] of reg8Pairs) {
                const is16 = false;
                const cell = regCell(r2, snapA.registers[r2], snapB.registers[r2], is16);
                html += `<div style="white-space:nowrap">${cell}</div>`;
            }
            html += '</div>';

            html += '</div>';
            return html;
        }

        // Check if address is in screen memory area
        function isScreenAddress(addr, is128K) {
            // Main screen: $4000-$5AFF (6912 bytes: 6144 bitmap + 768 attrs)
            if (addr >= 0x4000 && addr < 0x5B00) return true;
            // 128K shadow screen in bank 7: $C000-$DAFF when bank 7 is paged
            // For comparison we check the logical address range
            if (is128K && addr >= 0xC000 && addr < 0xDB00) return true;
            return false;
        }

        // Compare memory arrays
        function compareMemoryData(memA, memB, startAddr, length, showEqual, showHexDump, excludeScreen = false, is128K = false, labelB = 'File B') {
            const diffs = [];
            for (let i = 0; i < length; i++) {
                const addr = startAddr + i;
                // Skip screen memory if requested
                if (excludeScreen && isScreenAddress(addr, is128K)) continue;
                const a = memA[addr];
                const b = memB[addr];
                const isDiff = a !== b;
                if (isDiff || showEqual) {
                    diffs.push({ offset: addr, a, b, isDiff });
                }
            }

            if (diffs.length === 0) return { count: 0, html: '', paginated: false };

            const diffCount = diffs.filter(d => d.isDiff).length;

            // Group diffs into blocks (16-byte aligned)
            const blocks = [];
            let i = 0;
            while (i < diffs.length) {
                const startOffset = diffs[i].offset & ~0xF;
                let endI = i;
                while (endI < diffs.length && diffs[endI].offset < startOffset + 32) endI++;
                blocks.push({ startOffset, diffIndices: { start: i, end: endI } });
                i = endI;
            }

            // Store for pagination
            compareDiffsData = { diffs, blocks, memA, memB, startAddr, length, excludeScreen, is128K };
            compareRenderOptions = { showHexDump, labelB };
            compareTotalPages = Math.ceil(blocks.length / DIFFS_PER_PAGE);
            compareCurrentPage = 1;

            // Render first page
            const html = renderComparePage(1);
            const paginated = blocks.length > DIFFS_PER_PAGE;

            return { count: diffCount, html, paginated, totalBlocks: blocks.length };
        }

        // Render a specific page of diffs
        function renderComparePage(page) {
            if (!compareDiffsData) return '';

            const { diffs, blocks, memA, memB, startAddr, length, excludeScreen, is128K } = compareDiffsData;
            const { showHexDump, labelB } = compareRenderOptions;

            const startBlock = (page - 1) * DIFFS_PER_PAGE;
            const endBlock = Math.min(startBlock + DIFFS_PER_PAGE, blocks.length);

            if (showHexDump) {
                // Build content for both columns
                let linesA = '';
                let linesB = '';

                for (let bi = startBlock; bi < endBlock; bi++) {
                    const block = blocks[bi];
                    const startOffset = block.startOffset;

                    for (let lineStart = startOffset; lineStart < startOffset + 32; lineStart += 16) {
                        let hexA = '', hexB = '', ascA = '', ascB = '';
                        for (let j = 0; j < 16; j++) {
                            const off = lineStart + j;
                            if (off < startAddr || off >= startAddr + length || (excludeScreen && isScreenAddress(off, is128K))) {
                                hexA += '<span style="color:var(--text-secondary)">--</span> ';
                                hexB += '<span style="color:var(--text-secondary)">--</span> ';
                                ascA += '<span> </span>';
                                ascB += '<span> </span>';
                                continue;
                            }
                            const diff = diffs.find(d => d.offset === off);
                            const a = memA[off];
                            const b = memB[off];
                            const isDiff = diff && diff.isDiff;
                            const diffStyle = isDiff ? 'color:#ff6b6b;font-weight:bold' : '';
                            hexA += `<span style="${diffStyle}">${formatHex8(a)}</span> `;
                            hexB += `<span style="${diffStyle}">${formatHex8(b)}</span> `;
                            // ASCII - always wrap in span, with red for differences
                            const ascCharA = escapeHtmlChar(a);
                            const ascCharB = escapeHtmlChar(b);
                            ascA += `<span style="${diffStyle}">${ascCharA}</span>`;
                            ascB += `<span style="${diffStyle}">${ascCharB}</span>`;
                        }
                        linesA += `<div style="white-space:nowrap">${formatHex16(lineStart)}: ${hexA}|${ascA}|</div>`;
                        linesB += `<div style="white-space:nowrap">${formatHex16(lineStart)}: ${hexB}|${ascB}|</div>`;
                    }
                    linesA += '<hr style="border-color:var(--border);margin:3px 0">';
                    linesB += '<hr style="border-color:var(--border);margin:3px 0">';
                }

                // Build side-by-side layout
                return `<div style="display:flex;gap:20px">
                    <div style="flex:1;min-width:380px">
                        <div style="color:var(--cyan);margin-bottom:5px">File A:</div>
                        ${linesA}
                    </div>
                    <div style="flex:1;min-width:380px">
                        <div style="color:var(--cyan);margin-bottom:5px">${labelB}:</div>
                        ${linesB}
                    </div>
                </div>`;
            } else {
                // Simple list mode - show diffs from blocks on this page
                const pageStart = blocks[startBlock].diffIndices.start;
                const pageEnd = blocks[endBlock - 1].diffIndices.end;
                const pageDiffs = diffs.slice(pageStart, pageEnd);

                const lines = pageDiffs.map(d => {
                    const color = d.isDiff ? 'color:#ff6b6b' : '';
                    return `<div style="${color}">${formatHex16(d.offset)}: ${formatHex8(d.a)} vs ${formatHex8(d.b)}${d.isDiff ? ' ◄' : ''}</div>`;
                });
                return lines.join('');
            }
        }

        // Update pagination UI
        function updateComparePagination() {
            if (compareTotalPages > 1) {
                comparePagination.style.display = 'flex';
                compareDiffCountNoPage.style.display = 'none';
                comparePageInfo.textContent = `Page ${compareCurrentPage} / ${compareTotalPages}`;
                comparePrevPage.disabled = compareCurrentPage <= 1;
                compareNextPage.disabled = compareCurrentPage >= compareTotalPages;
                compareGoToPage.max = compareTotalPages;
                compareGoToPage.value = compareCurrentPage;
            } else {
                comparePagination.style.display = 'none';
                // Show diff count without pagination row
                compareDiffCountNoPage.style.display = 'block';
                compareDiffCountNoPage.textContent = compareDiffCount.textContent;
            }
        }

        // Pagination event handlers
        comparePrevPage.addEventListener('click', () => {
            if (compareCurrentPage > 1) {
                compareCurrentPage--;
                compareDataTable.innerHTML = renderComparePage(compareCurrentPage);
                updateComparePagination();
                compareDataTable.scrollTop = 0;
            }
        });

        compareNextPage.addEventListener('click', () => {
            if (compareCurrentPage < compareTotalPages) {
                compareCurrentPage++;
                compareDataTable.innerHTML = renderComparePage(compareCurrentPage);
                updateComparePagination();
                compareDataTable.scrollTop = 0;
            }
        });

        compareGoPage.addEventListener('click', () => {
            const page = parseInt(compareGoToPage.value) || 1;
            if (page >= 1 && page <= compareTotalPages && page !== compareCurrentPage) {
                compareCurrentPage = page;
                compareDataTable.innerHTML = renderComparePage(compareCurrentPage);
                updateComparePagination();
                compareDataTable.scrollTop = 0;
            }
        });

        compareGoToPage.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') compareGoPage.click();
        });

        // Keep old function as alias for backward compatibility
        function compareSnaFiles(dataA, dataB) {
            compareSnapshotFiles(dataA, dataB);
        }

        function compareBinaryFiles(dataA, dataB) {
            const showEqual = chkCompareShowEqual.checked;
            const showHexDump = chkCompareHexDump.checked;

            const result = compareBinaryData(dataA, dataB, 0, 0, null, showEqual, showHexDump);

            if (result.count === 0) {
                compareNoResults.style.display = 'block';
            } else {
                compareDataResults.style.display = 'block';
                compareDiffCount.textContent = `${result.count} bytes differ (sizes: ${dataA.byteLength} vs ${dataB.byteLength})`;
                compareDiffCountNoPage.style.display = 'block';
                compareDiffCountNoPage.textContent = compareDiffCount.textContent;
                compareDataTable.innerHTML = result.html;
            }
        }

        function compareSnapshotVsEmulator(snapData) {
            const showEqual = chkCompareShowEqual.checked;
            const showHexDump = chkCompareHexDump.checked;
            const excludeScreen = chkCompareExcludeScreen.checked;

            // Detect and parse snapshot file
            const snapType = detectSnapshotType(snapData);
            if (snapType === 'binary') {
                compareDataResults.style.display = 'block';
                compareDataTitle.textContent = 'Error';
                compareDiffCount.textContent = '';
                compareDataTable.innerHTML = '<div style="color:var(--red)">Not a valid snapshot file (.SNA or .Z80)</div>';
                return;
            }

            const snap = parseSnapshotFile(snapData);
            if (!snap) {
                compareDataResults.style.display = 'block';
                compareDataTitle.textContent = 'Error';
                compareDiffCount.textContent = '';
                compareDataTable.innerHTML = '<div style="color:var(--red)">Failed to parse snapshot file</div>';
                return;
            }

            // Get current emulator state as normalized format
            const cpu = spectrum.cpu;
            const paging = spectrum.memory.getPagingState();
            const emuMemory = spectrum.memory.getFullSnapshot();

            const emuSnap = {
                registers: {
                    'I': cpu.i,
                    "HL'": (cpu.h_ << 8) | cpu.l_,
                    "DE'": (cpu.d_ << 8) | cpu.e_,
                    "BC'": (cpu.b_ << 8) | cpu.c_,
                    "AF'": (cpu.a_ << 8) | cpu.f_,
                    'HL': (cpu.h << 8) | cpu.l,
                    'DE': (cpu.d << 8) | cpu.e,
                    'BC': (cpu.b << 8) | cpu.c,
                    'IY': cpu.iy,
                    'IX': cpu.ix,
                    'IFF1': cpu.iff1 ? 1 : 0,
                    'IFF2': cpu.iff2 ? 1 : 0,
                    'R': cpu.r,
                    'AF': (cpu.a << 8) | cpu.f,
                    'A': cpu.a,
                    'F': cpu.f,
                    'SP': cpu.sp,
                    'IM': cpu.im,
                    'PC': cpu.pc
                },
                memory: emuMemory,
                is128K: spectrum.machineType !== '48k',
                border: spectrum.ula.borderColor,
                port7FFD: (paging.ramBank & 0x07) |
                          (paging.screenBank === 7 ? 0x08 : 0x00) |
                          (paging.romBank ? 0x10 : 0x00) |
                          (paging.pagingDisabled ? 0x20 : 0x00)
            };

            // Compare registers
            const headerHtml = compareSnapshotRegisters(snap, emuSnap, showEqual, snapType, 'emulator');
            if (headerHtml) {
                compareHeaderResults.style.display = 'block';
                compareHeaderTable.innerHTML = headerHtml;
            }

            // Compare memory (0x4000-0xFFFF)
            const is128K = snap.is128K || emuSnap.is128K;
            const result = compareMemoryData(snap.memory, emuSnap.memory, 0x4000, 49152, showEqual, showHexDump, excludeScreen, is128K, 'Emulator');
            const diffCount = result.count;

            if (diffCount === 0 && !headerHtml) {
                compareNoResults.style.display = 'block';
                comparePagination.style.display = 'none';
            } else {
                compareDataResults.style.display = 'block';
                const blocksNote = result.totalBlocks ? `, ${result.totalBlocks} blocks` : '';
                compareDiffCount.textContent = `${diffCount} bytes differ${blocksNote}`;
                compareDataTable.innerHTML = result.html || '<div style="color:var(--green)">Memory is identical</div>';
                updateComparePagination();
            }
        }

        // Keep old function as alias
        function compareSnaVsEmulator(data) {
            compareSnapshotVsEmulator(data);
        }

        // Apply default full border mode
        spectrum.ula.setFullBorder(true);
        spectrum.updateDisplayDimensions();

        function showMessage(text, type = 'success') {
            const msg = document.createElement('div');
            msg.className = `message ${type}`;
            msg.textContent = text;
            document.body.appendChild(msg);
            setTimeout(() => msg.remove(), 3000);
        }
        
        function updateStatus() {
            fpsEl.textContent = spectrum.getFps();
            machineSelect.value = spectrum.machineType;
            btnRun.textContent = spectrum.isRunning() ? 'Pause' : 'Run';
            btnRun.disabled = !spectrum.romLoaded;
            
            // Update debugger if open (or in landscape mode where it's always visible)
            if (debuggerPanel.classList.contains('open') || window.innerWidth >= 1400) {
                updateDebugger();
            }

            // Update RZX status
            updateRZXStatus();
        }

        function updateRZXStatus() {
            if (spectrum.isRZXPlaying()) {
                rzxInfo.style.visibility = 'visible';
                const frame = spectrum.getRZXFrame();
                const total = spectrum.getRZXTotalFrames();
                const percent = Math.round((frame / total) * 100);
                rzxStatus.textContent = `${frame}/${total} (${percent}%)`;
            } else {
                rzxInfo.style.visibility = 'hidden';
            }
        }

        // RZX stop button handler
        btnRzxStop.addEventListener('click', () => {
            spectrum.rzxStop();
            updateRZXStatus();
            showMessage('RZX playback stopped');
        });

        // Port I/O logging controls
        const chkPortLog = document.getElementById('chkPortLog');
        const selPortLogFilter = document.getElementById('selPortLogFilter');
        const btnPortLogExport = document.getElementById('btnPortLogExport');
        const btnPortLogClear = document.getElementById('btnPortLogClear');
        const portLogStatus = document.getElementById('portLogStatus');

        function updatePortLogStatus() {
            const count = spectrum.getPortLogCount();
            portLogStatus.textContent = count > 0 ? `${count} entries` : '';
        }

        chkPortLog.addEventListener('change', () => {
            spectrum.setPortLogEnabled(chkPortLog.checked);
            updatePortLogStatus();
            if (chkPortLog.checked) {
                showMessage('Port I/O logging enabled');
            }
        });

        btnPortLogExport.addEventListener('click', () => {
            if (btnPortLogExport.dataset.exporting) return;
            btnPortLogExport.dataset.exporting = '1';
            try {
                const filter = selPortLogFilter.value; // 'both', 'in', or 'out'
                const result = spectrum.exportPortLog(filter);
                if (result.count === 0) {
                    showMessage('No port log entries to export');
                    return;
                }
                const blob = new Blob([result.text], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'port-io-log.txt';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showMessage(`Exported ${result.count} port log entries`);
            } finally {
                setTimeout(() => { delete btnPortLogExport.dataset.exporting; }, 500);
            }
        });

        btnPortLogClear.addEventListener('click', () => {
            spectrum.clearPortLog();
            updatePortLogStatus();
            showMessage('Port log cleared');
        });

        // Port trace filter controls
        const txtPortTraceFilter = document.getElementById('txtPortTraceFilter');
        const btnAddPortFilter = document.getElementById('btnAddPortFilter');
        const btnClearPortFilters = document.getElementById('btnClearPortFilters');
        const portFilterStatus = document.getElementById('portFilterStatus');
        const portFilterList = document.getElementById('portFilterList');

        function updatePortFilterList() {
            const filters = spectrum.getPortTraceFilters();
            if (filters.length === 0) {
                portFilterList.innerHTML = '<div class="no-breakpoints">All ports (no filter)</div>';
                portFilterStatus.textContent = '';
            } else {
                const hex = v => v.toString(16).toUpperCase().padStart(v > 0xFF ? 4 : 2, '0');
                portFilterList.innerHTML = filters.map((f, i) => {
                    const desc = hex(f.port) + '&' + hex(f.mask);
                    return `<div class="trigger-item" data-index="${i}">
                        <span class="trigger-icon port-filter" title="Port filter">P</span>
                        <span class="trigger-desc">${desc}</span>
                        <span class="trigger-remove" data-index="${i}" title="Remove">\u00d7</span>
                    </div>`;
                }).join('');
                portFilterStatus.textContent = `${filters.length} filter${filters.length !== 1 ? 's' : ''}`;
            }
        }

        function addPortFilterFromInput() {
            const val = txtPortTraceFilter.value.trim();
            if (!val) return;
            const result = spectrum.addPortTraceFilter(val);
            if (!result) {
                showMessage('Invalid port spec (use hex: FE, 7FFD, FE&FF)');
                return;
            }
            txtPortTraceFilter.value = '';
            updatePortFilterList();
        }

        btnAddPortFilter.addEventListener('click', addPortFilterFromInput);

        txtPortTraceFilter.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                addPortFilterFromInput();
            }
        });

        btnClearPortFilters.addEventListener('click', () => {
            spectrum.clearPortTraceFilters();
            updatePortFilterList();
            showMessage('Port filters cleared — tracing all ports');
        });

        portFilterList.addEventListener('click', (e) => {
            if (e.target.classList.contains('trigger-remove')) {
                const index = parseInt(e.target.dataset.index);
                spectrum.removePortTraceFilter(index);
                updatePortFilterList();
            }
        });

        // RZX end callback
        spectrum.onRZXEnd = () => {
            updateRZXStatus();
            showMessage('RZX playback finished');
        };

        // Debugger functionality
        const debuggerPanel = document.getElementById('debuggerPanel');
        const mainRegisters = document.getElementById('mainRegisters');
        const altRegisters = document.getElementById('altRegisters');
        const ixiyRegisters = document.getElementById('ixiyRegisters');
        const indexRegisters = document.getElementById('indexRegisters');
        const flagsDisplay = document.getElementById('flagsDisplay');
        const statusRegisters = document.getElementById('statusRegisters');
        const regRItem = document.getElementById('regRItem');
        const stackView = document.getElementById('stackView');
        const callStackView = document.getElementById('callStackView');
        const pagesGroup = document.getElementById('pagesGroup');
        const pagesInfo = document.getElementById('pagesInfo');
        const disassemblyView = document.getElementById('disassemblyView');

        // Register edit functionality
        let isEditingRegister = false;

        function startRegisterEdit(valueSpan) {
            if (!spectrum.cpu || isEditingRegister) return;

            isEditingRegister = true;
            const reg = valueSpan.dataset.reg;
            const bits = parseInt(valueSpan.dataset.bits) || 16;
            const originalValue = valueSpan.textContent;

            // Calculate max length based on register type
            // IFF is special: "1/1" format needs 3 chars
            // T-states: up to 5 digits (69888)
            // IM: 0-2 needs 1 char, I/R: 00-FF needs 2, 16-bit: 0000-FFFF needs 4
            const maxLen = reg === 'iff' ? 3 : reg === 'tstates' ? 5 : (bits <= 3 ? 1 : (bits <= 8 ? 2 : 4));

            // Lock width to prevent UI shift
            const originalWidth = valueSpan.offsetWidth;
            valueSpan.style.width = originalWidth + 'px';

            // Make span editable in place
            valueSpan.contentEditable = 'true';
            valueSpan.classList.add('editing');
            valueSpan.focus();

            // Select all text
            const range = document.createRange();
            range.selectNodeContents(valueSpan);
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);

            // Limit input length
            function limitInput() {
                const text = valueSpan.textContent;
                if (text.length > maxLen) {
                    valueSpan.textContent = text.slice(0, maxLen);
                    // Move cursor to end
                    const range = document.createRange();
                    range.selectNodeContents(valueSpan);
                    range.collapse(false);
                    const sel = window.getSelection();
                    sel.removeAllRanges();
                    sel.addRange(range);
                }
            }
            valueSpan.addEventListener('input', limitInput);

            function finishEdit(save) {
                if (!isEditingRegister) return;
                isEditingRegister = false;
                valueSpan.removeEventListener('input', limitInput);
                valueSpan.contentEditable = 'false';
                valueSpan.classList.remove('editing');
                valueSpan.style.width = '';
                if (save) {
                    applyRegisterValue(reg, valueSpan.textContent.trim(), bits);
                } else {
                    valueSpan.textContent = originalValue;
                }
                updateDebugger();
            }

            valueSpan.addEventListener('blur', () => finishEdit(true), { once: true });
            valueSpan.addEventListener('keydown', function handler(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    valueSpan.removeEventListener('keydown', handler);
                    finishEdit(true);
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    valueSpan.removeEventListener('keydown', handler);
                    finishEdit(false);
                }
            });
        }

        function applyRegisterValue(reg, valueStr, bits) {
            const cpu = spectrum.cpu;
            if (!cpu) return;

            // Parse value (hex or decimal)
            let value;
            valueStr = valueStr.trim().toUpperCase();

            // Handle special cases for IFF and IM
            if (reg === 'iff') {
                // Toggle IFF1/IFF2: parse as "1/1", "0/0", "1/0", "0/1" or single value
                if (valueStr.includes('/')) {
                    const parts = valueStr.split('/');
                    cpu.iff1 = parts[0] === '1';
                    cpu.iff2 = parts[1] === '1';
                } else {
                    const v = valueStr === '1' || valueStr === 'ON' || valueStr === 'TRUE';
                    cpu.iff1 = v;
                    cpu.iff2 = v;
                }
                return;
            } else if (reg === 'im') {
                value = parseInt(valueStr, 10);
                if (value >= 0 && value <= 2) {
                    cpu.im = value;
                }
                return;
            } else if (reg === 'rambank') {
                value = parseInt(valueStr, 10);
                if (value >= 0 && value <= 7) {
                    spectrum.memory.setRamBank(value);
                }
                return;
            } else if (reg === 'scrbank') {
                value = parseInt(valueStr, 10);
                if (value === 0 || value === 1) {
                    spectrum.memory.setScreenBank(value === 0 ? 5 : 7);
                }
                return;
            } else if (reg === 'rombank') {
                value = parseInt(valueStr, 10);
                if (value >= 0 && value <= 1) {
                    spectrum.memory.setRomBank(value);
                }
                return;
            } else if (reg === 'paginglock') {
                value = valueStr === '1' || valueStr === 'ON' || valueStr === 'TRUE';
                spectrum.memory.setPagingDisabled(value);
                return;
            } else if (reg === 'tstates') {
                value = parseInt(valueStr, 10);
                if (!isNaN(value) && value >= 0) {
                    cpu.tStates = value;
                }
                return;
            }

            // Parse hex (with or without suffix) or decimal
            if (valueStr.endsWith('H')) {
                value = parseInt(valueStr.slice(0, -1), 16);
            } else if (valueStr.startsWith('$') || valueStr.startsWith('0X')) {
                value = parseInt(valueStr.replace('$', '').replace('0X', ''), 16);
            } else if (/^[0-9A-F]+$/.test(valueStr) && valueStr.length > 2) {
                // Likely hex if all hex chars and longer than 2 chars
                value = parseInt(valueStr, 16);
            } else if (/^[0-9]+$/.test(valueStr)) {
                value = parseInt(valueStr, 10);
            } else {
                value = parseInt(valueStr, 16);
            }

            if (isNaN(value)) return;

            // Mask to appropriate bits
            const mask = bits === 8 ? 0xFF : 0xFFFF;
            value = value & mask;

            // Apply to registers
            switch (reg) {
                case 'af': cpu.a = (value >> 8) & 0xFF; cpu.f = value & 0xFF; break;
                case 'bc': cpu.b = (value >> 8) & 0xFF; cpu.c = value & 0xFF; break;
                case 'de': cpu.d = (value >> 8) & 0xFF; cpu.e = value & 0xFF; break;
                case 'hl': cpu.h = (value >> 8) & 0xFF; cpu.l = value & 0xFF; break;
                case 'af_': cpu.a_ = (value >> 8) & 0xFF; cpu.f_ = value & 0xFF; break;
                case 'bc_': cpu.b_ = (value >> 8) & 0xFF; cpu.c_ = value & 0xFF; break;
                case 'de_': cpu.d_ = (value >> 8) & 0xFF; cpu.e_ = value & 0xFF; break;
                case 'hl_': cpu.h_ = (value >> 8) & 0xFF; cpu.l_ = value & 0xFF; break;
                case 'ix': cpu.ix = value; break;
                case 'iy': cpu.iy = value; break;
                case 'sp': cpu.sp = value; break;
                case 'pc': cpu.pc = value; break;
                case 'i': cpu.i = value; break;
                case 'r': cpu.r = value & 0x7F; cpu.r7 = value & 0x80; break;
            }
        }

        // Event delegation for register editing
        function handleRegisterClick(e) {
            const target = e.target;
            if (target.classList.contains('editable') && target.classList.contains('register-value')) {
                startRegisterEdit(target);
            }
        }

        mainRegisters.addEventListener('click', handleRegisterClick);
        altRegisters.addEventListener('click', handleRegisterClick);
        ixiyRegisters.addEventListener('click', handleRegisterClick);
        indexRegisters.addEventListener('click', handleRegisterClick);
        statusRegisters.addEventListener('click', handleRegisterClick);
        regRItem.addEventListener('click', handleRegisterClick);
        pagesInfo.addEventListener('click', handleRegisterClick);

        // Flag click handler - toggle individual flags
        flagsDisplay.addEventListener('click', (e) => {
            const target = e.target;
            if (target.classList.contains('flag-item') && target.classList.contains('editable')) {
                const bit = parseInt(target.dataset.bit);
                if (!isNaN(bit) && spectrum.cpu) {
                    spectrum.cpu.f ^= bit;  // Toggle the flag bit
                    updateDebugger();
                }
            }
        });

        // EXA/EXX buttons - use event delegation since buttons are recreated
        ixiyRegisters.addEventListener('click', (e) => {
            if (!spectrum.cpu) return;
            const btn = e.target.closest('.reg-swap-btn');
            if (!btn) return;

            const cpu = spectrum.cpu;

            if (btn.id === 'btnEXA') {
                // EX AF,AF' - swap A/A' and F/F'
                let tmp = cpu.a; cpu.a = cpu.a_; cpu.a_ = tmp;
                tmp = cpu.f; cpu.f = cpu.f_; cpu.f_ = tmp;
                updateDebugger();
            } else if (btn.id === 'btnEXX') {
                // EXX - swap BC,DE,HL with BC',DE',HL'
                let tmp = cpu.b; cpu.b = cpu.b_; cpu.b_ = tmp;
                tmp = cpu.c; cpu.c = cpu.c_; cpu.c_ = tmp;
                tmp = cpu.d; cpu.d = cpu.d_; cpu.d_ = tmp;
                tmp = cpu.e; cpu.e = cpu.e_; cpu.e_ = tmp;
                tmp = cpu.h; cpu.h = cpu.h_; cpu.h_ = tmp;
                tmp = cpu.l; cpu.l = cpu.l_; cpu.l_ = tmp;
                updateDebugger();
            }
        });
        
        // Unified Trigger UI elements
        const triggerList = document.getElementById('triggerList');
        const triggerType = document.getElementById('triggerType');
        const triggerAddrInput = document.getElementById('triggerAddrInput');
        const triggerCondInput = document.getElementById('triggerCondInput');
        const btnAddTrigger = document.getElementById('btnAddTrigger');
        const btnClearTriggers = document.getElementById('btnClearTriggers');

        // Labels panel UI elements
        const labelsList = document.getElementById('labelsList');
        const labelFilterInput = document.getElementById('labelFilterInput');
        const btnAddLabel = document.getElementById('btnAddLabel');
        const btnExportLabels = document.getElementById('btnExportLabels');
        const btnImportLabels = document.getElementById('btnImportLabels');
        const btnClearLabels = document.getElementById('btnClearLabels');
        const labelFileInput = document.getElementById('labelFileInput');
        const chkShowRomLabels = document.getElementById('chkShowRomLabels');

        // Memory View UI elements
        const memoryView = document.getElementById('memoryView');
        const memoryAddressInput = document.getElementById('memoryAddress');
        const btnMemoryGo = document.getElementById('btnMemoryGo');
        const btnMemoryPC = document.getElementById('btnMemoryPC');
        const btnMemorySP = document.getElementById('btnMemorySP');
        const btnMemoryHL = document.getElementById('btnMemoryHL');
        const btnMemoryPgUp = document.getElementById('btnMemoryPgUp');
        const btnMemoryPgDn = document.getElementById('btnMemoryPgDn');
        const btnMemorySnap = document.getElementById('btnMemorySnap');
        const btnMemoryClearSnap = document.getElementById('btnMemoryClearSnap');
        const chkRomEdit = document.getElementById('chkRomEdit');

        // Memory snapshot for diff
        let memorySnapshot = null;

        // POKE search
        const btnPokeSnap = document.getElementById('btnPokeSnap');
        const pokeSearchMode = document.getElementById('pokeSearchMode');
        const pokeSearchValue = document.getElementById('pokeSearchValue');
        const btnPokeSearch = document.getElementById('btnPokeSearch');
        const btnPokeReset = document.getElementById('btnPokeReset');
        const pokeStatus = document.getElementById('pokeStatus');
        const pokeResults = document.getElementById('pokeResults');

        let pokeSnapshot = null;  // Last snapshot for comparison
        let pokeCandidates = null;  // Set of candidate addresses (null = all RAM)

        // Auto-map UI elements
        const chkAutoMap = document.getElementById('chkAutoMap');
        const btnAutoMapSnap = document.getElementById('btnAutoMapSnap');
        const btnAutoMapApply = document.getElementById('btnAutoMapApply');
        const btnAutoMapClear = document.getElementById('btnAutoMapClear');
        const autoMapStats = document.getElementById('autoMapStats');

        // Code-flow analysis UI elements
        const btnCfaRun = document.getElementById('btnCfaRun');
        const chkCfaSkipRom = document.getElementById('chkCfaSkipRom');
        const chkCfaISR = document.getElementById('chkCfaISR');
        const cfaExtraEntries = document.getElementById('cfaExtraEntries');
        const btnCfaClear = document.getElementById('btnCfaClear');
        const cfaStatus = document.getElementById('cfaStatus');

        // Snapshot state for export (captured via Snap button)
        let exportSnapshot = null;  // { cpu: {...}, memory: Uint8Array, border: number }

        // Memory search UI elements (right panel)
        const memSearchInput = document.getElementById('memSearchInput');
        const memSearchType = document.getElementById('memSearchType');
        const btnMemSearch = document.getElementById('btnMemSearch');
        const btnMemSearchNext = document.getElementById('btnMemSearchNext');
        const searchResults = document.getElementById('searchResults');
        const chkSearchCase = document.getElementById('chkSearchCase');
        const chkSearch7bit = document.getElementById('chkSearch7bit');

        // Left panel search elements
        const leftMemSearchInput = document.getElementById('leftMemSearchInput');
        const leftMemSearchType = document.getElementById('leftMemSearchType');
        const btnLeftMemSearch = document.getElementById('btnLeftMemSearch');
        const btnLeftMemSearchNext = document.getElementById('btnLeftMemSearchNext');
        const leftSearchResults = document.getElementById('leftSearchResults');
        const chkLeftSearchCase = document.getElementById('chkLeftSearchCase');
        const chkLeftSearch7bit = document.getElementById('chkLeftSearch7bit');

        // Right panel step buttons
        const btnRightStepInto = document.getElementById('btnRightStepInto');
        const btnRightStepOver = document.getElementById('btnRightStepOver');
        const btnRightRunTo = document.getElementById('btnRightRunTo');
        const btnRightRunToInt = document.getElementById('btnRightRunToInt');
        const btnRightRunToRet = document.getElementById('btnRightRunToRet');
        const btnRightRunTstates = document.getElementById('btnRightRunTstates');
        const rightTstatesInput = document.getElementById('rightTstatesInput');

        // Search state (shared between panels)
        let searchPattern = null;
        let searchResultAddrs = [];
        let searchResultIndex = -1;

        // Left panel search state
        let leftSearchPattern = null;
        let leftSearchResultAddrs = [];
        let leftSearchResultIndex = -1;
        
        // Disassembly navigation elements
        const disasmAddressInput = document.getElementById('disasmAddress');
        const btnDisasmGo = document.getElementById('btnDisasmGo');
        const btnDisasmPC = document.getElementById('btnDisasmPC');
        const btnDisasmPgUp = document.getElementById('btnDisasmPgUp');
        const btnDisasmPgDn = document.getElementById('btnDisasmPgDn');
        const btnDisasmExport = document.getElementById('btnDisasmExport');
        const btnDisasmExportRange = document.getElementById('btnDisasmExportRange');

        // Export dialog elements
        const exportDisasmDialog = document.getElementById('exportDisasmDialog');
        const exportStartAddr = document.getElementById('exportStartAddr');
        const exportEndAddr = document.getElementById('exportEndAddr');
        const exportWithOrg = document.getElementById('exportWithOrg');
        const exportWithAddr = document.getElementById('exportWithAddr');
        const exportWithBytes = document.getElementById('exportWithBytes');
        const exportWithTstates = document.getElementById('exportWithTstates');
        const btnExportCancel = document.getElementById('btnExportCancel');
        const btnExportSave = document.getElementById('btnExportSave');

        // Bookmarks - now store {addr, type} where type is 'disasm' or 'memdump'
        const disasmBookmarksBar = document.getElementById('disasmBookmarks');
        const memoryBookmarksBar = document.getElementById('memoryBookmarks');
        let leftBookmarks = [null, null, null, null, null];   // 5 bookmark slots for left panel
        let rightBookmarks = [null, null, null, null, null];  // 5 bookmark slots for right panel
        // Legacy aliases for compatibility
        let disasmBookmarks = leftBookmarks;
        let memoryBookmarks = rightBookmarks;

        // Panel type state
        let leftPanelType = 'disasm';   // 'disasm' or 'memdump'
        let rightPanelType = 'memdump'; // 'disasm' or 'memdump'
        const leftPanelTypeSelect = document.getElementById('leftPanelType');
        const rightPanelTypeSelect = document.getElementById('rightPanelType');
        const leftPanel = document.getElementById('leftPanel');
        const rightPanel = document.getElementById('rightPanel');

        // Left panel elements (for memdump mode)
        const leftMemAddressInput = document.getElementById('leftMemAddress');
        const leftMemoryView = document.getElementById('leftMemoryView');
        let leftMemoryViewAddress = 0;

        // Right panel elements (for disasm mode)
        const rightDisasmAddressInput = document.getElementById('rightDisasmAddress');
        const rightDisassemblyView = document.getElementById('rightDisassemblyView');
        let rightDisasmViewAddress = null;

        // Memory view state
        let memoryViewAddress = 0;
        let memoryEditingAddr = null;
        const MEMORY_LINES = 32;         // Right panel memory lines
        const LEFT_MEMORY_LINES = 42;    // Left panel memory lines (taller panel)
        const BYTES_PER_LINE = 16;
        
        // Disassembly view state
        let disasmViewAddress = null; // null = follow PC
        let disasmLastLineAddr = 0;
        let traceViewAddress = null; // Address being viewed in trace history (null = live)
        const DISASM_LINES = 48;
        const DISASM_PC_POSITION = 4; // Show PC at 5th line (0-indexed)
        const chkShowTstates = document.getElementById('chkShowTstates');
        const labelDisplayMode = document.getElementById('labelDisplayMode');

        // Format address with label based on display mode
        function formatAddrWithLabel(addr, mode) {
            const label = labelManager.get(addr);
            if (!label) return hex16(addr);

            switch (mode) {
                case 'addr': return hex16(addr);
                case 'label': return label.name;
                case 'both': return `${label.name}`;
                default: return hex16(addr);
            }
        }

        // Format address column (may include both address and label)
        // Returns { html, isLong, labelHtml } where isLong means label needs its own row
        const LABEL_MAX_CHARS = 12; // Max chars before wrapping to own row
        function formatAddrColumn(addr, mode) {
            const label = labelManager.get(addr);
            if (!label) return { html: hex16(addr), isLong: false, labelHtml: null };

            switch (mode) {
                case 'addr':
                    return { html: hex16(addr), isLong: false, labelHtml: null };
                case 'label': {
                    const isLong = label.name.length > LABEL_MAX_CHARS;
                    return {
                        html: isLong ? hex16(addr) : `<span class="label-name">${label.name}</span>`,
                        isLong,
                        labelHtml: isLong ? `<span class="label-name">${label.name}:</span>` : null
                    };
                }
                case 'both': {
                    const combined = `${hex16(addr)} ${label.name}`;
                    const isLong = combined.length > LABEL_MAX_CHARS + 5; // +5 for "XXXX "
                    return {
                        html: isLong ? hex16(addr) : `${hex16(addr)} <span class="label-name">${label.name}</span>`,
                        isLong,
                        labelHtml: isLong ? `<span class="label-name">${label.name}:</span>` : null
                    };
                }
                default:
                    return { html: hex16(addr), isLong: false, labelHtml: null };
            }
        }

        // Apply operand format to mnemonic based on instruction address
        function applyOperandFormat(mnemonic, instrAddr) {
            const format = operandFormatManager.get(instrAddr);
            if (format === OPERAND_FORMATS.HEX) {
                return mnemonic; // Default format, no change
            }

            // Replace 16-bit hex values first (4 digits), then 8-bit (2 digits)
            // Match 4-digit hex addresses (e.g., 1234h)
            let result = mnemonic.replace(/\b([0-9A-F]{4})h\b/gi, (match, hexVal) => {
                const val = parseInt(hexVal, 16);
                return operandFormatManager.formatValue(val, format, true);
            });

            // Match 2-digit hex values (e.g., FFh) but not in addresses we already converted
            result = result.replace(/\b([0-9A-F]{2})h\b/gi, (match, hexVal) => {
                const val = parseInt(hexVal, 16);
                return operandFormatManager.formatValue(val, format, false);
            });

            return result;
        }

        // Replace addresses in mnemonic with labels and make them clickable
        function replaceMnemonicAddresses(mnemonic, mode, instrAddr) {
            // First apply operand format if set
            let processed = applyOperandFormat(mnemonic, instrAddr);

            // Match 4-digit hex addresses (e.g., 1234h or 0010h)
            processed = processed.replace(/\b([0-9A-F]{4})h\b/gi, (match, hexAddr) => {
                const addr = parseInt(hexAddr, 16);
                const label = labelManager.get(addr);

                if (mode === 'addr' || !label) {
                    // No label mode or no label - show address as clickable
                    return `<span class="disasm-operand-addr" data-addr="${addr}">${match}</span>`;
                }

                // Label mode - show label as clickable
                return `<span class="disasm-label-operand disasm-operand-addr" data-addr="${addr}">${label.name}</span>`;
            });

            // Also make decimal addresses clickable (for dec format)
            // Match standalone numbers that could be addresses (4-5 digits, likely to be 256-65535)
            processed = processed.replace(/\b(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[0-9]{1,4})\b/g, (match, num) => {
                const addr = parseInt(num, 10);
                // Only make clickable if it's a reasonable address (not a small immediate)
                // and the format is decimal
                const format = operandFormatManager.get(instrAddr);
                if (format === OPERAND_FORMATS.DEC && addr >= 256) {
                    const label = labelManager.get(addr);
                    if (mode !== 'addr' && label) {
                        return `<span class="disasm-label-operand disasm-operand-addr" data-addr="${addr}">${label.name}</span>`;
                    }
                    return `<span class="disasm-operand-addr" data-addr="${addr}">${match}</span>`;
                }
                return match;
            });

            return processed;
        }

        // Debugger control buttons
        const btnStepInto = document.getElementById('btnStepInto');
        const btnStepOver = document.getElementById('btnStepOver');
        const btnRunTo = document.getElementById('btnRunTo');
        const btnRunToInt = document.getElementById('btnRunToInt');
        const btnRunToRet = document.getElementById('btnRunToRet');
        const btnRunTstates = document.getElementById('btnRunTstates');
        const tstatesInput = document.getElementById('tstatesInput');
        
        let disasm = null;
        let runToTarget = null; // For Run to Cursor
        
        // Check if in landscape mode (side-by-side layout)
        function isLandscapeMode() {
            return window.innerWidth >= 1400;
        }

        // Check if debugger panel is visible
        function isDebuggerVisible() {
            return debuggerPanel.classList.contains('open') || isLandscapeMode();
        }

        // Auto-expand tabs in landscape mode
        function checkLandscapeMode() {
            if (isLandscapeMode() && tabContainer.classList.contains('collapsed')) {
                tabContainer.classList.remove('collapsed');
            }
        }

        // Check on page load and resize
        checkLandscapeMode();
        window.addEventListener('resize', checkLandscapeMode);

        
        function hex8(val) {
            return (val & 0xff).toString(16).toUpperCase().padStart(2, '0');
        }
        
        function hex16(val) {
            return (val & 0xffff).toString(16).toUpperCase().padStart(4, '0');
        }

        // Check if instruction should have a blank line after it
        function isFlowBreak(mnemonic) {
            const mn = mnemonic.replace(/<[^>]+>/g, '').toUpperCase();
            return mn.startsWith('JP') || mn.startsWith('JR') ||
                   mn.startsWith('RET') || mn.startsWith('DJNZ') ||
                   mn.startsWith('RST') || mn.startsWith('CALL') ||
                   mn === 'HALT';
        }

        function createRegisterItem(name, value, editable = null, bits = 16) {
            const editClass = editable ? ' editable' : '';
            const dataAttr = editable ? ` data-reg="${editable}" data-bits="${bits}"` : '';
            return `<div class="register-item"><span class="register-name">${name}</span><br><span class="register-value${editClass}"${dataAttr}>${value}</span></div>`;
        }

        // Generate disassembly lines with region support
        // Returns array of {addr, bytes, mnemonic, isData}
        function disassembleWithRegions(startAddr, numLines) {
            if (!disasm || !spectrum.memory) return [];

            const lines = [];
            let addr = startAddr & 0xffff;

            while (lines.length < numLines && addr <= 0xffff) {
                const region = regionManager.get(addr);
                const lineAddr = addr;

                if (!region || region.type === REGION_TYPES.CODE || region.type === REGION_TYPES.SMC) {
                    // Normal disassembly
                    const instr = disasm.disassemble(addr);
                    lines.push({
                        addr: addr,
                        bytes: instr.bytes,
                        mnemonic: instr.mnemonic,
                        isData: false
                    });
                    addr = (addr + instr.bytes.length) & 0xffff;
                } else if (region.type === REGION_TYPES.TEXT) {
                    // Text region using helper
                    const result = parseTextRegion(spectrum.memory, addr, region.end);
                    if (result.singleByte) {
                        lines.push({
                            addr: lineAddr,
                            bytes: result.bytes,
                            mnemonic: `DB $${hex8(result.bytes[0])}`,
                            isData: true
                        });
                    } else if (result.text.length > 0) {
                        const suffix = result.bit7Terminated ? '+$80' : '';
                        lines.push({
                            addr: lineAddr,
                            bytes: result.bytes,
                            mnemonic: `DB "${result.text}"${suffix}`,
                            isData: true
                        });
                    }
                    addr = result.nextAddr & 0xffff;
                } else if (region.type === REGION_TYPES.DW) {
                    // Word data using helper
                    const result = parseWordRegion(spectrum.memory, addr, region.end);
                    if (result.wordStrs.length > 0) {
                        lines.push({
                            addr: lineAddr,
                            bytes: result.bytes,
                            mnemonic: `DW ${result.wordStrs.join(', ')}`,
                            isData: true
                        });
                    }
                    addr = result.nextAddr & 0xffff;
                } else if (region.type === REGION_TYPES.DB || region.type === REGION_TYPES.GRAPHICS) {
                    // Byte data using helper
                    const result = parseByteRegion(spectrum.memory, addr, region.end);
                    if (result.byteStrs.length > 0) {
                        lines.push({
                            addr: lineAddr,
                            bytes: result.bytes,
                            mnemonic: `DB ${result.byteStrs.join(', ')}`,
                            isData: true
                        });
                    }
                    addr = result.nextAddr & 0xffff;
                } else {
                    // Unknown region type - fallback to normal disassembly
                    const instr = disasm.disassemble(addr);
                    lines.push({
                        addr: addr,
                        bytes: instr.bytes,
                        mnemonic: instr.mnemonic,
                        isData: false
                    });
                    addr = (addr + instr.bytes.length) & 0xffff;
                }

                // Safety check for infinite loops
                if (lines.length > 1000) break;
            }

            return lines;
        }

        function updateDebugger() {
            if (!spectrum.cpu) return;
            if (isEditingRegister) return; // Don't update while editing
            const cpu = spectrum.cpu;

            // Check if viewing trace history
            const tracePos = traceManager.getCurrentPosition();
            const traceEntry = tracePos >= 0 ? traceManager.getEntry(tracePos) : null;

            // Use trace entry values if viewing history, otherwise use current CPU state
            const regAF = traceEntry ? traceEntry.af : cpu.af;
            const regBC = traceEntry ? traceEntry.bc : cpu.bc;
            const regDE = traceEntry ? traceEntry.de : cpu.de;
            const regHL = traceEntry ? traceEntry.hl : cpu.hl;
            const regIX = traceEntry ? traceEntry.ix : cpu.ix;
            const regIY = traceEntry ? traceEntry.iy : cpu.iy;
            const regSP = traceEntry ? traceEntry.sp : cpu.sp;
            const regPC = traceEntry ? traceEntry.pc : cpu.pc;
            const regI = traceEntry ? traceEntry.i : cpu.i;
            const regR = traceEntry ? traceEntry.r : cpu.rFull;
            const regIM = traceEntry ? traceEntry.im : cpu.im;
            const regIFF1 = traceEntry ? traceEntry.iff1 : cpu.iff1;
            const regIFF2 = traceEntry ? traceEntry.iff2 : cpu.iff2;
            const regTstates = traceEntry ? traceEntry.tStates : cpu.tStates;
            const regAF_ = traceEntry ? traceEntry.af_ : (cpu.a_ << 8) | cpu.f_;
            const regBC_ = traceEntry ? traceEntry.bc_ : (cpu.b_ << 8) | cpu.c_;
            const regDE_ = traceEntry ? traceEntry.de_ : (cpu.d_ << 8) | cpu.e_;
            const regHL_ = traceEntry ? traceEntry.hl_ : (cpu.h_ << 8) | cpu.l_;

            // Main registers (editable when not viewing trace history)
            const canEdit = !traceEntry;
            mainRegisters.innerHTML =
                createRegisterItem('AF', hex16(regAF), canEdit ? 'af' : null) +
                createRegisterItem('BC', hex16(regBC), canEdit ? 'bc' : null) +
                createRegisterItem('DE', hex16(regDE), canEdit ? 'de' : null) +
                createRegisterItem('HL', hex16(regHL), canEdit ? 'hl' : null);

            // Alternate registers
            altRegisters.innerHTML =
                createRegisterItem("AF'", hex16(regAF_), canEdit ? 'af_' : null) +
                createRegisterItem("BC'", hex16(regBC_), canEdit ? 'bc_' : null) +
                createRegisterItem("DE'", hex16(regDE_), canEdit ? 'de_' : null) +
                createRegisterItem("HL'", hex16(regHL_), canEdit ? 'hl_' : null);

            // IX, IY and swap buttons in same row
            ixiyRegisters.innerHTML =
                createRegisterItem('IX', hex16(regIX), canEdit ? 'ix' : null) +
                createRegisterItem('IY', hex16(regIY), canEdit ? 'iy' : null) +
                `<button class="reg-swap-btn" id="btnEXA" title="EX AF,AF'">exa</button>` +
                `<button class="reg-swap-btn" id="btnEXX" title="EXX">exx</button>`;

            // Index registers: SP, PC, I, IM, IFF
            indexRegisters.innerHTML =
                createRegisterItem('SP', hex16(regSP), canEdit ? 'sp' : null) +
                createRegisterItem('PC', hex16(regPC), canEdit ? 'pc' : null) +
                createRegisterItem('I', hex8(regI), canEdit ? 'i' : null, 8) +
                createRegisterItem('IM', regIM.toString(), canEdit ? 'im' : null, 2) +
                createRegisterItem('IFF', (regIFF1 ? '1' : '0') + '/' + (regIFF2 ? '1' : '0'), canEdit ? 'iff' : null, 2);

            // Timing registers: T-st, ΔT
            const bpT = spectrum.breakpointTStates;
            const bpTStr = bpT > 0 ? bpT.toLocaleString() : '0';
            statusRegisters.innerHTML =
                createRegisterItem('T-st', regTstates.toString(), canEdit ? 'tstates' : null, 17) +
                createRegisterItem('ΔT', bpTStr, null, 0);

            // R register (on flags row)
            const rEditClass = canEdit ? ' editable' : '';
            const rDataAttr = canEdit ? ' data-reg="r" data-bits="8"' : '';
            regRItem.innerHTML = `<span class="register-name">R</span><br><span class="register-value${rEditClass}"${rDataAttr}>${hex8(regR)}</span>`;

            // Flags (clickable to toggle when not viewing trace)
            const f = regAF & 0xFF;
            const flags = [
                { name: 'S', bit: 0x80, desc: 'Sign' },
                { name: 'Z', bit: 0x40, desc: 'Zero' },
                { name: 'y', bit: 0x20, desc: 'Undocumented (bit 5)' },
                { name: 'H', bit: 0x10, desc: 'Half Carry' },
                { name: 'x', bit: 0x08, desc: 'Undocumented (bit 3)' },
                { name: 'P/V', bit: 0x04, desc: 'Parity/Overflow' },
                { name: 'N', bit: 0x02, desc: 'Subtract' },
                { name: 'C', bit: 0x01, desc: 'Carry' }
            ];
            flagsDisplay.innerHTML = flags.map(flag =>
                `<div class="flag-item ${(f & flag.bit) ? 'set' : ''}${canEdit ? ' editable' : ''}" title="${flag.desc} (click to toggle)" data-bit="${flag.bit}">${flag.name}</div>`
            ).join('');

            // Paging info (128K/Pentagon only)
            if (spectrum.memory.machineType !== '48k') {
                pagesGroup.style.display = '';
                const paging = spectrum.memory.getPagingState();
                const screenNum = paging.screenBank === 5 ? '0' : '1';
                pagesInfo.innerHTML =
                    createRegisterItem('C000', paging.ramBank.toString(), canEdit ? 'rambank' : null, 3) +
                    createRegisterItem('Scr', screenNum, canEdit ? 'scrbank' : null, 1) +
                    createRegisterItem('ROM', paging.romBank.toString(), canEdit ? 'rombank' : null, 1) +
                    (paging.pagingDisabled ? createRegisterItem('Lock', '1', canEdit ? 'paginglock' : null, 1) : '');
            } else {
                pagesGroup.style.display = 'none';
            }

            // Disassembly view
            if (!disasm) {
                disasm = new Disassembler(spectrum.memory);
            }
            
            const pc = cpu.pc;

            // Auto-expand fold if PC is inside collapsed range
            const pcFold = foldManager.getCollapsedRangeContaining(pc);
            if (pcFold) foldManager.expand(pcFold.start);

            let viewAddr;
            const chkFollowPC = document.getElementById('chkFollowPC');

            if (chkFollowPC.checked) {
                // Follow PC - show PC at position from top
                viewAddr = disasm.findStartForPosition(pc, DISASM_PC_POSITION, DISASM_LINES);
                disasmViewAddress = null;
            } else if (disasmViewAddress !== null) {
                // Follow is off, use stored address
                viewAddr = disasmViewAddress;
            } else {
                // Follow is off but no address set - stay at current PC, store it
                viewAddr = disasm.findStartForPosition(pc, DISASM_PC_POSITION, DISASM_LINES);
                disasmViewAddress = viewAddr;
            }
            
            // Apply code folding with dynamic line fetching to fill the view
            // Keeps fetching more lines until we have DISASM_LINES visible after folding
            function disassembleWithFolding(startAddr, targetLines) {
                const result = [];
                let currentAddr = startAddr & 0xffff;
                const maxIterations = targetLines * 10; // Safety limit
                let iterations = 0;

                while (result.length < targetLines && currentAddr <= 0xffff && iterations < maxIterations) {
                    iterations++;

                    // Check if this address starts a collapsed subroutine
                    const sub = subroutineManager.get(currentAddr);
                    if (sub && sub.endAddress !== null && foldManager.isCollapsed(currentAddr)) {
                        // Calculate byte count directly from addresses (fast)
                        const byteCount = sub.endAddress - currentAddr + 1;
                        const subName = sub.name || labelManager.get(currentAddr)?.name || `sub_${hex16(currentAddr)}`;
                        result.push({
                            addr: currentAddr,
                            bytes: [],
                            mnemonic: '',
                            isData: false,
                            isFoldSummary: true,
                            foldType: 'subroutine',
                            foldName: subName,
                            foldEnd: sub.endAddress,
                            byteCount: byteCount,
                            instrCount: null  // Don't calculate - too expensive
                        });
                        currentAddr = (sub.endAddress + 1) & 0xffff;
                        continue;
                    }

                    // Check if this address starts a collapsed user fold
                    const userFold = foldManager.getUserFold(currentAddr);
                    if (userFold && foldManager.isCollapsed(currentAddr)) {
                        // Calculate byte count directly from addresses (fast)
                        const byteCount = userFold.endAddress - currentAddr + 1;
                        const foldName = userFold.name || `fold_${hex16(currentAddr)}`;
                        result.push({
                            addr: currentAddr,
                            bytes: [],
                            mnemonic: '',
                            isData: false,
                            isFoldSummary: true,
                            foldType: 'user',
                            foldName: foldName,
                            foldEnd: userFold.endAddress,
                            byteCount: byteCount,
                            instrCount: null  // Don't calculate - too expensive
                        });
                        currentAddr = (userFold.endAddress + 1) & 0xffff;
                        continue;
                    }

                    // Normal line - disassemble one instruction
                    const lineArr = disassembleWithRegions(currentAddr, 1);
                    if (lineArr.length === 0) break;
                    const line = lineArr[0];
                    result.push(line);
                    currentAddr = (currentAddr + line.bytes.length) & 0xffff;
                }

                return result;
            }

            const lines = disassembleWithFolding(viewAddr, DISASM_LINES);

            // Store last line address for page down
            if (lines.length > 0) {
                const lastLine = lines[lines.length - 1];
                disasmLastLineAddr = lastLine.isFoldSummary ? lastLine.foldEnd : lastLine.addr;
            }

            const showTstates = chkShowTstates.checked;
            const labelMode = labelDisplayMode.value;

            disassemblyView.innerHTML = lines.map((line, idx) => {
                // Handle fold summary lines
                if (line.isFoldSummary) {
                    const icon = '▸';
                    const typeClass = line.foldType === 'user' ? 'user-fold' : '';
                    return `<div class="disasm-fold-summary ${typeClass}" data-fold-addr="${line.addr}">
                        <span class="disasm-fold-toggle" data-fold-addr="${line.addr}">${icon}</span>
                        <span class="fold-name">${escapeHtml(line.foldName)}</span>
                        <span class="fold-stats">(${line.byteCount} bytes)</span>
                    </div>`;
                }

                const bytesStr = line.bytes.map(b => hex8(b)).join(' ');
                const isCurrent = line.addr === pc;
                const isTrace = traceViewAddress !== null && line.addr === traceViewAddress;
                const hasBp = spectrum.hasBreakpoint(line.addr);
                const classes = ['disasm-line'];
                if (isCurrent) classes.push('current');
                if (isTrace) classes.push('trace');
                if (hasBp) classes.push('breakpoint');
                if (line.isData) classes.push('data-line');

                // Add spacing after flow control instructions
                if (isFlowBreak(line.mnemonic)) {
                    classes.push('flow-break');
                }

                // Don't show T-states for data lines
                const timing = (showTstates && !line.isData) ? disasm.getTiming(line.bytes) : '';
                const timingHtml = timing ? `<span class="disasm-tstates">${timing}</span>` : '';

                // Apply label formatting to address and mnemonic (not for data lines)
                const addrInfo = formatAddrColumn(line.addr, labelMode);
                const mnemonicWithLabels = line.isData ? line.mnemonic : replaceMnemonicAddresses(line.mnemonic, labelMode, line.addr);

                // Region type indicator
                const region = regionManager.get(line.addr);
                let regionMarker = '';
                if (region && region.type !== REGION_TYPES.CODE) {
                    const markers = {
                        [REGION_TYPES.DB]: 'B',
                        [REGION_TYPES.DW]: 'W',
                        [REGION_TYPES.TEXT]: 'T',
                        [REGION_TYPES.GRAPHICS]: 'G',
                        [REGION_TYPES.SMC]: 'S'
                    };
                    const marker = markers[region.type] || '?';
                    regionMarker = `<span class="disasm-region region-type-${region.type}" title="${region.type.toUpperCase()}${region.comment ? ': ' + region.comment : ''}">${marker}</span>`;
                }

                // Get comments for this address
                const comment = commentManager.get(line.addr);
                let beforeHtml = '';
                let inlineHtml = '';
                let afterHtml = '';

                // Subroutine separator (IDA-style) with fold toggle
                const sub = subroutineManager.get(line.addr);
                if (sub) {
                    const subName = sub.name || labelManager.get(line.addr)?.name || `sub_${hex16(line.addr)}`;
                    const canFold = sub.endAddress !== null;
                    const foldIcon = canFold ? `<span class="disasm-fold-toggle" data-fold-addr="${line.addr}" title="Click to collapse">▾</span>` : '';
                    beforeHtml += `<span class="disasm-sub-separator">; ═══════════════════════════════════════════════════════════════</span>`;
                    beforeHtml += `<span class="disasm-sub-name">; ${foldIcon}${subName}</span>`;
                    if (sub.comment) {
                        beforeHtml += `<span class="disasm-sub-comment">; ${escapeHtml(sub.comment)}</span>`;
                    }
                    beforeHtml += `<span class="disasm-sub-separator">; ───────────────────────────────────────────────────────────────</span>`;
                }

                // User fold start marker
                const userFold = foldManager.getUserFold(line.addr);
                if (userFold) {
                    const foldName = userFold.name || `fold_${hex16(line.addr)}`;
                    const foldIcon = `<span class="disasm-fold-toggle" data-fold-addr="${line.addr}" title="Click to collapse">▾</span>`;
                    beforeHtml += `<span class="disasm-user-fold-start">; ┌─── ${foldIcon}${escapeHtml(foldName)} ───</span>`;
                }

                if (comment) {
                    // Separator line
                    if (comment.separator) {
                        beforeHtml += `<span class="disasm-separator">; ----------</span>`;
                    }
                    // Before comments (each line prefixed with ;)
                    if (comment.before) {
                        const beforeLines = comment.before.split('\n').map(l => `; ${l}`).join('\n');
                        beforeHtml += `<span class="disasm-comment-line">${escapeHtml(beforeLines)}</span>`;
                    }
                    // Inline comment
                    if (comment.inline) {
                        inlineHtml = `<span class="disasm-inline-comment">; ${escapeHtml(comment.inline)}</span>`;
                    }
                    // After comments
                    if (comment.after) {
                        const afterLines = comment.after.split('\n').map(l => `; ${l}`).join('\n');
                        afterHtml = `<span class="disasm-comment-line">${escapeHtml(afterLines)}</span>`;
                    }
                }

                // Subroutine end marker (after RET/JP that ends a subroutine)
                const endingSubs = subroutineManager.getAllEndingAt(line.addr);
                if (endingSubs.length > 0) {
                    for (const endingSub of endingSubs) {
                        const subName = endingSub.name || labelManager.get(endingSub.address)?.name || `sub_${hex16(endingSub.address)}`;
                        afterHtml += `<span class="disasm-sub-end">; end of ${subName}</span>`;
                    }
                    afterHtml += `<span class="disasm-sub-separator">; ═══════════════════════════════════════════════════════════════</span>`;
                }

                // User fold end marker
                for (const [foldAddr, foldData] of foldManager.userFolds) {
                    if (foldData.endAddress === line.addr) {
                        const foldName = foldData.name || `fold_${hex16(foldAddr)}`;
                        afterHtml += `<span class="disasm-user-fold-end">; └─── end of ${escapeHtml(foldName)} ───</span>`;
                    }
                }

                if (addrInfo.isLong) {
                    classes.push('has-long-label');
                    return `${beforeHtml}<div class="${classes.join(' ')}" data-addr="${line.addr}">
                        <div class="disasm-label-row">${addrInfo.labelHtml}</div>
                        <span class="disasm-bp ${hasBp ? 'active' : ''}" data-addr="${line.addr}" title="Toggle breakpoint">•</span>
                        ${regionMarker}
                        <span class="disasm-addr">${addrInfo.html}</span>
                        <span class="disasm-bytes">${bytesStr}</span>
                        ${timingHtml}
                        <span class="disasm-mnemonic">${formatMnemonic(mnemonicWithLabels)}</span>${inlineHtml}
                    </div>${afterHtml}`;
                }

                return `${beforeHtml}<div class="${classes.join(' ')}" data-addr="${line.addr}">
                    <span class="disasm-bp ${hasBp ? 'active' : ''}" data-addr="${line.addr}" title="Toggle breakpoint">•</span>
                    ${regionMarker}
                    <span class="disasm-addr">${addrInfo.html}</span>
                    <span class="disasm-bytes">${bytesStr}</span>
                    ${timingHtml}
                    <span class="disasm-mnemonic">${formatMnemonic(mnemonicWithLabels)}</span>${inlineHtml}
                </div>${afterHtml}`;
            }).join('');
            
            // Update breakpoint list
            updateBreakpointList();
            
            // Update watchpoint list
            updateWatchpointList();
            
            // Update port breakpoint list
            updatePortBreakpointList();

            // Update labels list
            updateLabelsList();

            // Update panels based on their types
            if (leftPanelType === 'memdump') {
                updateLeftMemoryView();
            }
            if (rightPanelType === 'memdump') {
                updateMemoryView();
            } else {
                updateRightDisassemblyView();
            }

            // Update stack view
            updateStackView();
            updateCallStack();

            // Update trace status (functions defined later, check existence)
            if (typeof window.updateTraceStatus === 'function') {
                window.updateTraceStatus();
                window.updateTraceList();
            }

            // Update watches (function defined later, check existence)
            if (typeof updateWatchValues === 'function') {
                updateWatchValues();
            }
        }
        
        // Stack view state
        let previousSP = null;
        let previousStackValues = {};
        
        function updateStackView() {
            if (!spectrum.cpu) {
                stackView.innerHTML = '<div class="stack-entry">No CPU</div>';
                return;
            }

            // Check if viewing trace history - use historical SP
            const tracePos = traceManager.getCurrentPosition();
            const traceEntry = tracePos >= 0 ? traceManager.getEntry(tracePos) : null;
            const sp = traceEntry ? traceEntry.sp : spectrum.cpu.sp;
            const spChanged = previousSP !== null && previousSP !== sp;
            
            let html = '';
            // Show 3 entries before SP, SP itself, and 3 entries after
            for (let offset = -6; offset <= 6; offset += 2) {
                const addr = (sp + offset) & 0xffff;
                const lo = spectrum.memory.read(addr);
                const hi = spectrum.memory.read((addr + 1) & 0xffff);
                const value = lo | (hi << 8);
                
                const isCurrent = offset === 0;
                const valueKey = addr.toString();
                const valueChanged = previousStackValues[valueKey] !== undefined && 
                                    previousStackValues[valueKey] !== value;
                
                let classes = 'stack-entry';
                if (isCurrent) classes += ' current';
                if (valueChanged && !spChanged) classes += ' changed';
                
                const pointer = isCurrent ? '<span class="stack-pointer">◄</span>' : '';
                
                html += `<div class="${classes}" data-addr="${addr}" data-value="${value}">` +
                        `<span class="stack-addr">${hex16(addr)}</span>` +
                        `<span class="stack-value">${hex16(value)}</span>` +
                        `${pointer}</div>`;
                
                previousStackValues[valueKey] = value;
            }
            
            stackView.innerHTML = html;
            previousSP = sp;
        }

        // Call stack analysis — reconstruct call chain from stack contents
        function updateCallStack() {
            if (!spectrum.cpu || !spectrum.romLoaded) {
                callStackView.innerHTML = '';
                return;
            }

            const stack = spectrum._debugCallStack;
            let html = '';

            // Show call stack from deepest (most recent) to shallowest
            // Most recent call at top
            for (let i = stack.length - 1; i >= 0; i--) {
                const entry = stack[i];
                const addr = entry.addr;
                const label = labelManager.get(addr);
                const labelStr = label ? ` <span class="call-label">${label.name}</span>` : '';
                const intMark = entry.isInt ? ' <span class="call-label">INT</span>' : '';
                const cls = i === stack.length - 1 ? 'stack-entry current' : 'stack-entry';
                html += `<div class="${cls}" data-value="${addr}">` +
                        `<span class="stack-value">${hex16(addr)}</span>${intMark}${labelStr}</div>`;
            }

            if (!html) {
                html = '<div class="stack-entry" style="opacity:0.4">—</div>';
            }

            callStackView.innerHTML = html;
        }

        // Smart navigation: prefer disasm panel, fall back to memory view
        function navigateToAddress(addr) {
            if (leftPanelType === 'disasm') {
                goToLeftDisasm(addr);
            } else if (rightPanelType === 'disasm') {
                goToRightDisasm(addr);
            } else if (leftPanelType === 'memdump') {
                goToLeftMemory(addr);
            } else if (rightPanelType === 'memdump') {
                goToRightMemory(addr);
            } else {
                // Both are calc or something else — force left disasm
                goToLeftDisasm(addr);
            }
        }

        // Call stack click — navigate to address
        callStackView.addEventListener('click', (e) => {
            const entry = e.target.closest('.stack-entry');
            if (!entry) return;
            const value = parseInt(entry.dataset.value, 10);
            if (!isNaN(value)) {
                navigateToAddress(value);
            }
        });

        // Call stack context menu
        callStackView.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            const entry = e.target.closest('.stack-entry');
            if (!entry) return;
            const value = parseInt(entry.dataset.value, 10);
            if (isNaN(value)) return;

            if (stackContextMenu) stackContextMenu.remove();
            stackContextMenu = document.createElement('div');
            stackContextMenu.className = 'stack-context-menu';
            stackContextMenu.innerHTML = `
                <div data-action="disasm-left">Disasm left → ${hex16(value)}</div>
                <div data-action="disasm-right">Disasm right → ${hex16(value)}</div>
                <div data-action="memory-left">Memory left → ${hex16(value)}</div>
                <div data-action="memory-right">Memory right → ${hex16(value)}</div>
            `;
            stackContextMenu.style.left = e.clientX + 'px';
            stackContextMenu.style.top = e.clientY + 'px';
            document.body.appendChild(stackContextMenu);

            stackContextMenu.addEventListener('click', (ev) => {
                const action = ev.target.dataset.action;
                if (action === 'disasm-left') {
                    disasmViewAddress = value;
                    updateDebugger();
                } else if (action === 'disasm-right') {
                    if (typeof rightDisasmViewAddress !== 'undefined') {
                        rightDisasmViewAddress = value;
                        updateRightDisassemblyView();
                    }
                } else if (action === 'memory-left') {
                    goToMemoryAddress(value);
                } else if (action === 'memory-right') {
                    if (typeof goToRightMemoryAddress === 'function') {
                        goToRightMemoryAddress(value);
                    }
                }
                stackContextMenu.remove();
                stackContextMenu = null;
            });
        });

        // Stack view click — navigate to the value stored at that stack address
        stackView.addEventListener('click', (e) => {
            const entry = e.target.closest('.stack-entry');
            if (!entry) return;
            const value = parseInt(entry.dataset.value, 10);
            if (!isNaN(value)) {
                navigateToAddress(value);
            }
        });

        // Stack view context menu
        let stackContextMenu = null;

        stackView.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            const entry = e.target.closest('.stack-entry');
            if (!entry) return;
            
            const addr = parseInt(entry.dataset.addr, 10);
            const value = parseInt(entry.dataset.value, 10);
            
            // Remove existing menu
            if (stackContextMenu) {
                stackContextMenu.remove();
            }
            
            stackContextMenu = document.createElement('div');
            stackContextMenu.className = 'stack-context-menu';
            stackContextMenu.innerHTML = `
                <div data-action="disasm-addr">Disassembly → ${hex16(addr)}</div>
                <div data-action="disasm-value">Disassembly → ${hex16(value)}</div>
                <div data-action="memory-addr">Memory → ${hex16(addr)}</div>
                <div data-action="memory-value">Memory → ${hex16(value)}</div>
            `;
            stackContextMenu.style.left = e.clientX + 'px';
            stackContextMenu.style.top = e.clientY + 'px';
            document.body.appendChild(stackContextMenu);
            
            stackContextMenu.addEventListener('click', (ev) => {
                const action = ev.target.dataset.action;
                if (action === 'disasm-addr') {
                    disasmViewAddress = addr;
                    updateDebugger();
                } else if (action === 'disasm-value') {
                    disasmViewAddress = value;
                    updateDebugger();
                } else if (action === 'memory-addr') {
                    goToMemoryAddress(addr);
                } else if (action === 'memory-value') {
                    goToMemoryAddress(value);
                }
                stackContextMenu.remove();
                stackContextMenu = null;
            });
        });
        
        // Close context menu on click elsewhere
        document.addEventListener('click', (e) => {
            if (stackContextMenu && !stackContextMenu.contains(e.target)) {
                stackContextMenu.remove();
                stackContextMenu = null;
            }
        });
        
        function updateTriggerList() {
            const triggers = spectrum.getTriggers();
            if (triggers.length === 0) {
                triggerList.innerHTML = '<div class="no-breakpoints">No breakpoints</div>';
            } else {
                triggerList.innerHTML = triggers.map(t => {
                    const icon = spectrum.getTriggerIcon(t.type);
                    const label = spectrum.getTriggerLabel(t.type);
                    const desc = spectrum.formatTrigger(t);
                    const disabledClass = t.enabled ? '' : ' disabled';
                    const iconClass = t.type.startsWith('port') ? 'port' : t.type;
                    const skipInfo = t.skipCount > 0 ? ` <span class="trigger-skip" title="Hit ${t.hitCount}/${t.skipCount + 1}">[${t.hitCount}/${t.skipCount + 1}]</span>` : '';
                    return `<div class="trigger-item${disabledClass}" data-index="${t.index}">
                        <span class="trigger-icon ${iconClass}" title="${label}">${icon}</span>
                        <span class="trigger-toggle" data-index="${t.index}" title="${t.enabled ? 'Disable' : 'Enable'}">⏻</span>
                        <span class="trigger-desc" data-index="${t.index}">${desc}${skipInfo}</span>
                        <span class="trigger-remove" data-index="${t.index}" title="Remove">×</span>
                    </div>`;
                }).join('');
            }
        }

        // Legacy function names for compatibility
        function updateBreakpointList() { updateTriggerList(); }
        function updateWatchpointList() { updateTriggerList(); }
        function updatePortBreakpointList() { updateTriggerList(); }

        function updateLabelsList() {
            const filter = labelFilterInput.value.toLowerCase().trim();

            // Get user labels
            const userLabels = labelManager.getAll().map(l => ({ ...l, isRom: false }));

            // Update label count display
            const labelCountEl = document.getElementById('labelCount');
            if (labelCountEl) labelCountEl.textContent = userLabels.length > 0 ? `labels: ${userLabels.length}` : '';

            // Get ROM labels if enabled
            let romLabels = [];
            if (labelManager.showRomLabels) {
                for (const label of labelManager.romLabels.values()) {
                    // Don't show ROM label if user has a label at same address
                    if (!labelManager.labels.has(labelManager._key(label.address, label.page))) {
                        romLabels.push({ ...label, isRom: true });
                    }
                }
            }

            // Combine and sort
            const allLabels = [...userLabels, ...romLabels].sort((a, b) => a.address - b.address);

            // Filter
            const labels = filter
                ? allLabels.filter(l => l.name.toLowerCase().includes(filter) ||
                                        (l.comment && l.comment.toLowerCase().includes(filter)))
                : allLabels;

            if (labels.length === 0) {
                labelsList.innerHTML = filter
                    ? '<div class="no-breakpoints">No matching labels</div>'
                    : '<div class="no-breakpoints">No labels</div>';
                return;
            }

            labelsList.innerHTML = labels.map(label => {
                const addrStr = label.page !== null ? `${label.page}:${hex16(label.address)}` : hex16(label.address);
                const commentHtml = label.comment ? `<span class="label-comment">${escapeHtml(label.comment)}</span>` : '';
                const itemClass = label.isRom ? 'label-item rom-label' : 'label-item';
                const actionsHtml = label.isRom ? '' : `
                    <div class="label-actions">
                        <button class="label-btn label-edit" data-addr="${label.address}" data-page="${label.page}" title="Edit">✎</button>
                        <button class="label-btn label-remove" data-addr="${label.address}" data-page="${label.page}" title="Remove">×</button>
                    </div>`;
                return `<div class="${itemClass}" data-addr="${label.address}" data-page="${label.page}">
                    <div class="label-info">
                        <span class="label-addr">${addrStr}</span>
                        <span class="label-item-name">${escapeHtml(label.name)}</span>
                        ${commentHtml}
                    </div>
                    ${actionsHtml}
                </div>`;
            }).join('');
        }

        function escapeHtml(str) {
            return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
        }

        function downloadFile(filename, content) {
            const blob = new Blob([content], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        function updateMemoryView() {
            if (!spectrum.memory || memoryEditingAddr !== null) return;

            let html = '';
            for (let line = 0; line < MEMORY_LINES; line++) {
                const lineAddr = (memoryViewAddress + line * BYTES_PER_LINE) & 0xffff;

                // Address
                html += `<div class="memory-line"><span class="memory-addr" data-addr="${lineAddr}">${hex16(lineAddr)}</span>`;

                // Hex bytes
                html += '<span class="memory-hex">';
                for (let i = 0; i < BYTES_PER_LINE; i++) {
                    const addr = (lineAddr + i) & 0xffff;
                    const byte = spectrum.memory.read(addr);
                    const changed = memorySnapshot && memorySnapshot[addr] !== byte;
                    let cls = changed ? 'memory-byte changed' : 'memory-byte';
                    // Check for breakpoints
                    if (spectrum.hasBreakpointAt(addr)) {
                        cls += ' has-bp';
                    }
                    // Check for watchpoints
                    const wps = spectrum.getWatchpoints();
                    for (const wp of wps) {
                        if (addr >= wp.start && addr <= wp.end) {
                            if (wp.read && wp.write) cls += ' has-wp';
                            else if (wp.read) cls += ' has-wp-r';
                            else if (wp.write) cls += ' has-wp-w';
                            break;
                        }
                    }
                    // Check for memory regions
                    const region = regionManager.get(addr);
                    if (region && region.type !== REGION_TYPES.CODE) {
                        cls += ` region-${region.type}`;
                    }
                    const lowByte = byte & 0x7F;
                    const isPrintableLow = lowByte >= 32 && lowByte < 127;
                    let asciiChar = '';
                    if (byte >= 32 && byte < 127) {
                        asciiChar = ` '${String.fromCharCode(byte)}'`;
                    } else if ((byte & 0x80) && isPrintableLow) {
                        asciiChar = ` '${String.fromCharCode(lowByte)}'+$80`;
                    }
                    let tip = `Addr: ${hex16(addr)} (${addr})\nValue: ${hex8(byte)} (${byte})${asciiChar}`;
                    if (region && region.type !== REGION_TYPES.CODE) {
                        tip += `\nRegion: ${region.type}${region.comment ? ' - ' + region.comment : ''}`;
                    }
                    // Add disassembly (if disassembler available)
                    if (disasm) {
                        const instr = disasm.disassemble(addr);
                        const bytes = instr.bytes.map(b => hex8(b)).join(' ');
                        tip += `\n${instr.mnemonic} [${bytes}]`;
                    }
                    html += `<span class="${cls}" data-addr="${addr}" title="${tip}">${hex8(byte)}</span>`;
                }
                html += '</span>';

                // ASCII representation
                html += '<span class="memory-ascii">';
                for (let i = 0; i < BYTES_PER_LINE; i++) {
                    const addr = (lineAddr + i) & 0xffff;
                    const byte = spectrum.memory.read(addr);
                    const isPrintable = byte >= 32 && byte < 127;
                    const char = isPrintable ? String.fromCharCode(byte) : '.';
                    const changed = memorySnapshot && memorySnapshot[addr] !== byte;
                    const asciiRegion = regionManager.get(addr);
                    let cls = isPrintable ? 'printable' : '';
                    if (changed) cls += ' changed';
                    if (asciiRegion && asciiRegion.type === REGION_TYPES.TEXT) {
                        cls += ' region-text';
                    }
                    html += `<span class="${cls.trim()}">${char}</span>`;
                }
                html += '</span></div>';
            }

            memoryView.innerHTML = html;

            // Reapply selection if active
            if (memSelectionStart !== null) {
                updateMemSelection();
            }
        }
        
        // Panel-specific navigation functions
        // panelSide: 'left' or 'right' - which panel the action originated from

        function goToLeftMemory(addr) {
            addr = addr & 0xffff;
            switchLeftPanelType('memdump');
            leftMemoryViewAddress = addr;
            leftMemAddressInput.value = hex16(addr);
            updateLeftMemoryView();
        }

        function goToRightMemory(addr) {
            addr = addr & 0xffff;
            switchRightPanelType('memdump');
            memoryViewAddress = addr;
            memoryAddressInput.value = hex16(addr);
            updateMemoryView();
        }

        function goToLeftDisasm(addr) {
            addr = addr & 0xffff;
            switchLeftPanelType('disasm');
            if (leftNavHistory.length === 0) {
                if (disasmViewAddress !== null) {
                    navPushHistory(disasmViewAddress, 'left');
                } else if (spectrum && spectrum.cpu) {
                    navPushHistory(spectrum.cpu.pc, 'left');
                }
            }
            navPushHistory(addr, 'left');
            if (disasm) {
                disasmViewAddress = disasm.findStartForPosition(addr, DISASM_PC_POSITION, DISASM_LINES);
            } else {
                disasmViewAddress = addr;
            }
            disasmAddressInput.value = hex16(addr);
            updateDisassemblyView();
        }

        function goToRightDisasm(addr) {
            addr = addr & 0xffff;
            switchRightPanelType('disasm');
            if (rightNavHistory.length === 0) {
                if (rightDisasmViewAddress !== null) {
                    navPushHistory(rightDisasmViewAddress, 'right');
                } else if (spectrum && spectrum.cpu) {
                    navPushHistory(spectrum.cpu.pc, 'right');
                }
            }
            navPushHistory(addr, 'right');
            rightDisasmViewAddress = addr;
            rightDisasmAddressInput.value = hex16(addr);
            updateRightDisassemblyView();
        }

        // "Here" = same panel, "Other" = other panel
        function goToMemoryHere(addr, panelSide) {
            if (panelSide === 'left') goToLeftMemory(addr);
            else goToRightMemory(addr);
        }

        function goToMemoryOther(addr, panelSide) {
            if (panelSide === 'left') goToRightMemory(addr);
            else goToLeftMemory(addr);
        }

        function goToDisasmHere(addr, panelSide) {
            if (panelSide === 'left') goToLeftDisasm(addr);
            else goToRightDisasm(addr);
        }

        function goToDisasmOther(addr, panelSide) {
            if (panelSide === 'left') goToRightDisasm(addr);
            else goToLeftDisasm(addr);
        }

        // Legacy functions for compatibility
        function goToMemoryAddress(addr) {
            // Default: prefer right memory panel
            if (rightPanelType === 'memdump') {
                goToRightMemory(addr);
            } else if (leftPanelType === 'memdump') {
                goToLeftMemory(addr);
            } else {
                goToRightMemory(addr);
            }
        }

        function goToAddressNoHistory(addr, panel = 'left') {
            // Navigate disasm without adding to history
            addr = addr & 0xffff;
            if (panel === 'right') {
                rightDisasmViewAddress = addr;
                rightDisasmAddressInput.value = hex16(addr);
                updateRightDisassemblyView();
            } else {
                if (disasm) {
                    disasmViewAddress = disasm.findStartForPosition(addr, DISASM_PC_POSITION, DISASM_LINES);
                } else {
                    disasmViewAddress = addr;
                }
                disasmAddressInput.value = hex16(addr);
                updateDisassemblyView();
            }
        }

        function goToAddress(addr) {
            // Default: prefer left disasm panel
            if (leftPanelType === 'disasm') {
                goToLeftDisasm(addr);
            } else if (rightPanelType === 'disasm') {
                goToRightDisasm(addr);
            } else {
                goToLeftDisasm(addr);
            }
        }

        let activeEditInput = null;
        
        function finishCurrentEdit(save = true) {
            if (activeEditInput && memoryEditingAddr !== null) {
                if (save) {
                    const newValue = parseInt(activeEditInput.value, 16);
                    if (!isNaN(newValue) && newValue >= 0 && newValue <= 255) {
                        spectrum.memory.writeDebug(memoryEditingAddr, newValue);
                    }
                }
                activeEditInput = null;
                memoryEditingAddr = null;
                updateDebugger(); // Refresh both memory and disassembly
            }
        }
        
        function startByteEdit(byteElement) {
            // Finish any current edit first
            finishCurrentEdit(true);
            
            const addr = parseInt(byteElement.dataset.addr);
            memoryEditingAddr = addr;
            const currentValue = spectrum.memory.read(addr);
            
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'memory-edit-input';
            input.value = hex8(currentValue);
            input.maxLength = 2;
            activeEditInput = input;
            
            byteElement.textContent = '';
            byteElement.appendChild(input);
            
            // Use setTimeout to ensure focus happens after DOM update
            setTimeout(() => {
                input.focus();
                input.select();
            }, 0);
            
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    finishCurrentEdit(true);
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    finishCurrentEdit(false);
                } else if (e.key === 'Tab') {
                    e.preventDefault();
                    const nextAddr = e.shiftKey ? (addr - 1) & 0xffff : (addr + 1) & 0xffff;
                    finishCurrentEdit(true);
                    setTimeout(() => {
                        const nextByte = memoryView.querySelector(`[data-addr="${nextAddr}"]`);
                        if (nextByte) startByteEdit(nextByte);
                    }, 0);
                }
            });
        }
        
        // Memory view event handlers - use mousedown for immediate response
        // Memory selection state
        let memSelectionStart = null;
        let memSelectionEnd = null;
        let memIsSelecting = false;

        function clearMemSelection() {
            memSelectionStart = null;
            memSelectionEnd = null;
            memIsSelecting = false;
            memoryView.querySelectorAll('.memory-byte.selected').forEach(el => {
                el.classList.remove('selected');
            });
        }

        function updateMemSelection() {
            if (memSelectionStart === null) return;

            const start = Math.min(memSelectionStart, memSelectionEnd ?? memSelectionStart);
            const end = Math.max(memSelectionStart, memSelectionEnd ?? memSelectionStart);

            memoryView.querySelectorAll('.memory-byte').forEach(el => {
                const addr = parseInt(el.dataset.addr, 10);
                if (addr >= start && addr <= end) {
                    el.classList.add('selected');
                } else {
                    el.classList.remove('selected');
                }
            });
        }

        memoryView.addEventListener('mousedown', (e) => {
            const byteEl = e.target.closest('.memory-byte');
            if (byteEl && !e.target.classList.contains('memory-edit-input')) {
                // Right-click: don't start selection, let context menu handle it
                if (e.button === 2) return;

                // Left-click: start selection or edit on double-click
                if (e.button === 0) {
                    e.preventDefault();
                    const addr = parseInt(byteEl.dataset.addr, 10);

                    // Start selection
                    memSelectionStart = addr;
                    memSelectionEnd = addr;
                    memIsSelecting = true;
                    updateMemSelection();
                }
            }
        });

        memoryView.addEventListener('mousemove', (e) => {
            if (!memIsSelecting) return;

            const byteEl = e.target.closest('.memory-byte');
            if (byteEl) {
                const addr = parseInt(byteEl.dataset.addr, 10);
                memSelectionEnd = addr;
                updateMemSelection();
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (memIsSelecting) {
                memIsSelecting = false;
                // If single click (no drag), treat as edit
                if (memSelectionStart === memSelectionEnd && e.button === 0) {
                    const byteEl = memoryView.querySelector(`[data-addr="${memSelectionStart}"]`);
                    if (byteEl && !e.target.classList.contains('memory-edit-input')) {
                        clearMemSelection();
                        startByteEdit(byteEl);
                    }
                }
            }
        });

        // Memory view context menu
        let memContextMenu = null;
        function closeMemContextMenu() {
            if (memContextMenu) {
                memContextMenu.remove();
                memContextMenu = null;
            }
        }

        memoryView.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            closeMemContextMenu();

            // Check for byte or address element
            const byteEl = e.target.closest('.memory-byte') || e.target.closest('.memory-addr');
            if (!byteEl || !byteEl.dataset.addr) return;

            const clickedAddr = parseInt(byteEl.dataset.addr, 10);

            // Determine selection range
            let hasSelection = memSelectionStart !== null && memSelectionEnd !== null &&
                               memSelectionStart !== memSelectionEnd;
            let selStart, selEnd;

            if (hasSelection) {
                selStart = Math.min(memSelectionStart, memSelectionEnd);
                selEnd = Math.max(memSelectionStart, memSelectionEnd);
                // Check if right-clicked inside selection
                if (clickedAddr < selStart || clickedAddr > selEnd) {
                    // Clicked outside selection, use single address
                    hasSelection = false;
                }
            }

            const addr = hasSelection ? selStart : clickedAddr;
            const endAddr = hasSelection ? selEnd : null;
            const existingLabel = labelManager.get(addr);
            const existingRegion = regionManager.get(addr);

            memContextMenu = document.createElement('div');
            memContextMenu.className = 'label-context-menu';

            let menuHtml = `<div class="menu-header">Address ${hex16(addr)}</div>`;
            menuHtml += `<div class="menu-separator"></div>`;
            menuHtml += `<div data-action="disasm-left">Disasm left</div>`;
            menuHtml += `<div data-action="disasm-right">Disasm right</div>`;
            menuHtml += `<div class="menu-separator"></div>`;
            menuHtml += `<div data-action="mem-left">Memory left</div>`;
            menuHtml += `<div data-action="mem-right">Memory right</div>`;
            menuHtml += `<div class="menu-separator"></div>`;
            if (existingLabel) {
                menuHtml += `<div data-action="edit-label">Edit label "${existingLabel.name}"</div>`;
                menuHtml += `<div data-action="delete-label" class="danger">Delete label</div>`;
            } else {
                menuHtml += `<div data-action="add-label">Add label</div>`;
            }
            menuHtml += `<div class="menu-separator"></div>`;

            // Show selection range or single address
            const rangeText = hasSelection ?
                `${hex16(selStart)}-${hex16(selEnd)} (${selEnd - selStart + 1} bytes)` :
                '';
            menuHtml += `<div class="menu-submenu">Mark as...${rangeText ? ' ' + rangeText : ''}
                <div class="menu-submenu-items">
                    <div data-action="mark-code">Code</div>
                    <div data-action="mark-db">DB (bytes)</div>
                    <div data-action="mark-dw">DW (words)</div>
                    <div data-action="mark-text">Text (ASCII)</div>
                    <div data-action="mark-gfx">Graphics</div>
                    <div data-action="mark-smc">SMC (self-mod)</div>
                </div>
            </div>`;
            if (existingRegion) {
                menuHtml += `<div data-action="remove-region" class="danger">Remove region mark</div>`;
            }
            memContextMenu.innerHTML = menuHtml;

            memContextMenu.style.left = e.clientX + 'px';
            memContextMenu.style.top = e.clientY + 'px';
            document.body.appendChild(memContextMenu);

            // Adjust submenu position if it would overflow viewport
            const submenu = memContextMenu.querySelector('.menu-submenu');
            if (submenu) {
                const menuRect = memContextMenu.getBoundingClientRect();
                const submenuItems = submenu.querySelector('.menu-submenu-items');
                if (submenuItems) {
                    // Temporarily show to measure
                    submenuItems.style.display = 'block';
                    const subRect = submenuItems.getBoundingClientRect();
                    submenuItems.style.display = '';

                    // Check horizontal overflow
                    if (menuRect.right + subRect.width > window.innerWidth) {
                        submenu.classList.add('submenu-left');
                    }
                    // Check vertical overflow
                    if (menuRect.top + subRect.height > window.innerHeight) {
                        submenu.classList.add('submenu-up');
                    }
                }
            }

            memContextMenu.addEventListener('click', (menuE) => {
                const action = menuE.target.dataset.action;
                if (action === 'disasm-left') {
                    goToLeftDisasm(addr);
                } else if (action === 'disasm-right') {
                    goToRightDisasm(addr);
                } else if (action === 'mem-left') {
                    goToLeftMemory(addr);
                } else if (action === 'mem-right') {
                    goToRightMemory(addr);
                } else if (action === 'add-label') {
                    showLabelDialog(addr);
                } else if (action === 'edit-label') {
                    showLabelDialog(addr, existingLabel);
                } else if (action === 'delete-label') {
                    const oldLabel = existingLabel;
                    labelManager.remove(addr);
                    undoManager.push({
                        type: 'label',
                        description: `Delete label "${oldLabel.name}"`,
                        undo: () => {
                            labelManager.add(oldLabel);
                            updateLabelsList();
                        },
                        redo: () => {
                            labelManager.remove(addr);
                            updateLabelsList();
                        }
                    });
                    showMessage(`Label "${existingLabel.name}" deleted`);
                    updateDebugger();
                } else if (action === 'mark-code') {
                    showRegionDialog(addr, REGION_TYPES.CODE, endAddr);
                } else if (action === 'mark-db') {
                    showRegionDialog(addr, REGION_TYPES.DB, endAddr);
                } else if (action === 'mark-dw') {
                    showRegionDialog(addr, REGION_TYPES.DW, endAddr);
                } else if (action === 'mark-text') {
                    showRegionDialog(addr, REGION_TYPES.TEXT, endAddr);
                } else if (action === 'mark-gfx') {
                    showRegionDialog(addr, REGION_TYPES.GRAPHICS, endAddr);
                } else if (action === 'mark-smc') {
                    showRegionDialog(addr, REGION_TYPES.SMC, endAddr);
                } else if (action === 'remove-region') {
                    const oldRegion = regionManager.get(addr);
                    if (oldRegion) {
                        regionManager.remove(addr);
                        undoManager.push({
                            type: 'region',
                            description: `Remove region ${hex16(oldRegion.start)}-${hex16(oldRegion.end)}`,
                            undo: () => {
                                regionManager.add(oldRegion, true);  // allowOverwrite for undo
                            },
                            redo: () => {
                                regionManager.remove(addr);
                            }
                        });
                        showMessage('Region mark removed');
                        updateDebugger();
                    }
                }
                clearMemSelection();
                closeMemContextMenu();
            });
        });

        // Left memory panel context menu
        let leftMemContextMenu = null;
        function closeLeftMemContextMenu() {
            if (leftMemContextMenu) {
                leftMemContextMenu.remove();
                leftMemContextMenu = null;
            }
        }

        leftMemoryView.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            closeLeftMemContextMenu();

            // Check for byte or address element
            const byteEl = e.target.closest('.memory-byte') || e.target.closest('.memory-addr');
            if (!byteEl || !byteEl.dataset.addr) return;

            const addr = parseInt(byteEl.dataset.addr, 10);
            const existingLabel = labelManager.get(addr);
            const existingRegion = regionManager.get(addr);

            leftMemContextMenu = document.createElement('div');
            leftMemContextMenu.className = 'label-context-menu';

            let menuHtml = `<div class="menu-header">Address ${hex16(addr)}</div>`;
            menuHtml += `<div class="menu-separator"></div>`;
            menuHtml += `<div data-action="disasm-left">Disasm left</div>`;
            menuHtml += `<div data-action="disasm-right">Disasm right</div>`;
            menuHtml += `<div class="menu-separator"></div>`;
            menuHtml += `<div data-action="mem-left">Memory left</div>`;
            menuHtml += `<div data-action="mem-right">Memory right</div>`;
            menuHtml += `<div class="menu-separator"></div>`;
            if (existingLabel) {
                menuHtml += `<div data-action="edit-label">Edit label "${existingLabel.name}"</div>`;
                menuHtml += `<div data-action="delete-label" class="danger">Delete label</div>`;
            } else {
                menuHtml += `<div data-action="add-label">Add label</div>`;
            }
            menuHtml += `<div class="menu-separator"></div>`;
            menuHtml += `<div class="menu-submenu">Mark as...
                <div class="menu-submenu-items">
                    <div data-action="mark-code">Code</div>
                    <div data-action="mark-db">DB (bytes)</div>
                    <div data-action="mark-dw">DW (words)</div>
                    <div data-action="mark-text">Text (ASCII)</div>
                    <div data-action="mark-gfx">Graphics</div>
                    <div data-action="mark-smc">SMC (self-mod)</div>
                </div>
            </div>`;
            if (existingRegion) {
                menuHtml += `<div data-action="remove-region" class="danger">Remove region mark</div>`;
            }
            leftMemContextMenu.innerHTML = menuHtml;

            leftMemContextMenu.style.left = e.clientX + 'px';
            leftMemContextMenu.style.top = e.clientY + 'px';
            document.body.appendChild(leftMemContextMenu);

            leftMemContextMenu.addEventListener('click', (menuE) => {
                const action = menuE.target.dataset.action;
                if (action === 'disasm-left') {
                    goToLeftDisasm(addr);
                } else if (action === 'disasm-right') {
                    goToRightDisasm(addr);
                } else if (action === 'mem-left') {
                    goToLeftMemory(addr);
                } else if (action === 'mem-right') {
                    goToRightMemory(addr);
                } else if (action === 'add-label') {
                    showLabelDialog(addr);
                } else if (action === 'edit-label') {
                    showLabelDialog(addr, existingLabel);
                } else if (action === 'delete-label') {
                    labelManager.remove(addr);
                    showMessage(`Label "${existingLabel.name}" deleted`);
                    updateDebugger();
                } else if (action === 'mark-code') {
                    showRegionDialog(addr, REGION_TYPES.CODE);
                } else if (action === 'mark-db') {
                    showRegionDialog(addr, REGION_TYPES.DB);
                } else if (action === 'mark-dw') {
                    showRegionDialog(addr, REGION_TYPES.DW);
                } else if (action === 'mark-text') {
                    showRegionDialog(addr, REGION_TYPES.TEXT);
                } else if (action === 'mark-gfx') {
                    showRegionDialog(addr, REGION_TYPES.GRAPHICS);
                } else if (action === 'mark-smc') {
                    showRegionDialog(addr, REGION_TYPES.SMC);
                } else if (action === 'remove-region') {
                    regionManager.remove(addr);
                    showMessage('Region mark removed');
                    updateDebugger();
                }
                closeLeftMemContextMenu();
            });
        });

        document.addEventListener('click', (e) => {
            if (leftMemContextMenu && !leftMemContextMenu.contains(e.target)) {
                closeLeftMemContextMenu();
            }
            if (memContextMenu && !memContextMenu.contains(e.target)) {
                closeMemContextMenu();
            }
            // Clear memory selection when clicking outside memory view
            if (memSelectionStart !== null && !memoryView.contains(e.target) &&
                (!memContextMenu || !memContextMenu.contains(e.target))) {
                clearMemSelection();
            }
        });

        // Finish edit when clicking outside memory view
        document.addEventListener('mousedown', (e) => {
            if (memoryEditingAddr !== null && !memoryView.contains(e.target)) {
                finishCurrentEdit(true);
            }
        });
        
        btnMemoryGo.addEventListener('click', () => {
            const addr = parseInt(memoryAddressInput.value, 16);
            if (!isNaN(addr)) goToMemoryAddress(addr);
        });
        
        memoryAddressInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const addr = parseInt(memoryAddressInput.value, 16);
                if (!isNaN(addr)) goToMemoryAddress(addr);
            }
        });
        
        btnMemoryPC.addEventListener('click', () => {
            if (spectrum.cpu) goToMemoryAddress(spectrum.cpu.pc);
        });
        
        btnMemorySP.addEventListener('click', () => {
            if (spectrum.cpu) goToMemoryAddress(spectrum.cpu.sp);
        });
        
        btnMemoryHL.addEventListener('click', () => {
            if (spectrum.cpu) goToMemoryAddress(spectrum.cpu.hl);
        });
        
        btnMemoryPgUp.addEventListener('click', () => {
            goToMemoryAddress(memoryViewAddress - MEMORY_LINES * BYTES_PER_LINE);
        });
        
        btnMemoryPgDn.addEventListener('click', () => {
            goToMemoryAddress(memoryViewAddress + MEMORY_LINES * BYTES_PER_LINE);
        });

        // Memory scroll wheel navigation
        memoryView.addEventListener('wheel', (e) => {
            e.preventDefault();
            // Scroll by 3 lines per wheel tick
            const scrollLines = e.deltaY > 0 ? 3 : -3;
            goToMemoryAddress(memoryViewAddress + scrollLines * BYTES_PER_LINE);
        }, { passive: false });

        // ========== Panel Type Switching ==========
        function switchLeftPanelType(type) {
            leftPanelType = type;
            leftPanelTypeSelect.value = type;

            const disasmControls = document.querySelector('.left-disasm-controls');
            const memdumpControls = document.querySelector('.left-memdump-controls');
            const disasmView = document.getElementById('disassemblyView');
            const leftStepControls = document.querySelector('.left-debugger-controls');
            const leftSearch = document.querySelector('.left-memory-search');

            if (type === 'disasm') {
                disasmControls.style.display = '';
                memdumpControls.style.display = 'none';
                disasmView.style.display = '';
                leftMemoryView.style.display = 'none';
                if (leftStepControls) leftStepControls.style.display = '';
                if (leftSearch) leftSearch.style.display = 'none';
            } else {
                disasmControls.style.display = 'none';
                memdumpControls.style.display = '';
                disasmView.style.display = 'none';
                leftMemoryView.style.display = '';
                if (leftStepControls) leftStepControls.style.display = 'none';
                if (leftSearch) leftSearch.style.display = '';
            }

            updateLeftPanel();
            updateBookmarkButtons(disasmBookmarksBar, leftBookmarks, 'left');
        }

        function switchRightPanelType(type) {
            rightPanelType = type;
            rightPanelTypeSelect.value = type;

            const memdumpControls = document.querySelector('.right-memdump-controls');
            const disasmControls = document.querySelector('.right-disasm-controls');
            const memView = document.getElementById('memoryView');
            const rightSearch = document.querySelector('.right-memory-search');
            const rightStepControls = document.querySelector('.right-debugger-controls');
            const calcView = document.getElementById('rightCalculatorView');
            const bookmarksBar = document.getElementById('memoryBookmarks');

            // Hide all views first
            memView.style.display = 'none';
            rightDisassemblyView.style.display = 'none';
            calcView.style.display = 'none';
            memdumpControls.style.display = 'none';
            disasmControls.style.display = 'none';
            if (rightSearch) rightSearch.style.display = 'none';
            if (rightStepControls) rightStepControls.style.display = 'none';

            if (type === 'memdump') {
                memdumpControls.style.display = '';
                memView.style.display = '';
                if (rightSearch) rightSearch.style.display = '';
                if (bookmarksBar) bookmarksBar.style.display = '';
            } else if (type === 'disasm') {
                disasmControls.style.display = '';
                rightDisassemblyView.style.display = '';
                if (rightStepControls) rightStepControls.style.display = '';
                if (bookmarksBar) bookmarksBar.style.display = '';
                // Initialize to current PC if not set
                if (rightDisasmViewAddress === null && spectrum.cpu) {
                    rightDisasmViewAddress = spectrum.cpu.pc;
                    rightDisasmAddressInput.value = hex16(rightDisasmViewAddress);
                }
            } else if (type === 'calc') {
                calcView.style.display = '';
                if (bookmarksBar) bookmarksBar.style.display = 'none';
            }

            updateRightPanel();
            if (type !== 'calc') {
                updateBookmarkButtons(memoryBookmarksBar, rightBookmarks, 'right');
            }
        }

        // Update left panel content based on type
        function updateLeftPanel() {
            if (leftPanelType === 'disasm') {
                // Handled by existing updateDisassemblyView
            } else {
                updateLeftMemoryView();
            }
        }

        // Update right panel content based on type
        function updateRightPanel() {
            if (rightPanelType === 'memdump') {
                updateMemoryView();
            } else {
                updateRightDisassemblyView();
            }
        }

        // Render memory view for left panel
        function updateLeftMemoryView() {
            if (!spectrum.memory) {
                leftMemoryView.innerHTML = '<div class="memory-line">No memory</div>';
                return;
            }

            let html = '';
            for (let line = 0; line < LEFT_MEMORY_LINES; line++) {
                const lineAddr = (leftMemoryViewAddress + line * BYTES_PER_LINE) & 0xffff;

                // Address
                html += `<div class="memory-line"><span class="memory-addr" data-addr="${lineAddr}">${hex16(lineAddr)}</span>`;

                // Hex bytes
                html += '<span class="memory-hex">';
                for (let i = 0; i < BYTES_PER_LINE; i++) {
                    const addr = (lineAddr + i) & 0xffff;
                    const val = spectrum.memory.read(addr);
                    let cls = 'memory-byte';
                    // Check for memory regions
                    const region = regionManager.get(addr);
                    if (region && region.type !== REGION_TYPES.CODE) {
                        cls += ` region-${region.type}`;
                    }
                    html += `<span class="${cls}" data-addr="${addr}">${hex8(val)}</span>`;
                }
                html += '</span>';

                // ASCII representation (styled like right panel)
                html += '<span class="memory-ascii">';
                for (let i = 0; i < BYTES_PER_LINE; i++) {
                    const addr = (lineAddr + i) & 0xffff;
                    const byte = spectrum.memory.read(addr);
                    const isPrintable = byte >= 32 && byte < 127;
                    const char = isPrintable ? String.fromCharCode(byte) : '.';
                    const asciiRegion = regionManager.get(addr);
                    let cls = isPrintable ? 'printable' : '';
                    if (asciiRegion && asciiRegion.type === REGION_TYPES.TEXT) {
                        cls += ' region-text';
                    }
                    html += `<span class="${cls.trim()}">${char}</span>`;
                }
                html += '</span></div>';
            }

            leftMemoryView.innerHTML = html;
        }

        // Render disassembly view for right panel (never auto-follows PC)
        function updateRightDisassemblyView() {
            if (!spectrum.memory || !disasm) {
                rightDisassemblyView.innerHTML = '<div class="disasm-line">No code</div>';
                return;
            }

            // Right panel doesn't auto-follow - use set address or 0
            let viewAddr = rightDisasmViewAddress !== null ? rightDisasmViewAddress : 0;

            const pc = spectrum.cpu ? spectrum.cpu.pc : 0;
            const showTstates = document.getElementById('chkRightShowTstates')?.checked || false;
            const labelMode = labelDisplayMode.value;

            // Apply code folding with dynamic line fetching (same as main panel)
            function disassembleWithFoldingRight(startAddr, targetLines) {
                const result = [];
                let currentAddr = startAddr & 0xffff;
                const maxIterations = targetLines * 10;
                let iterations = 0;

                while (result.length < targetLines && currentAddr <= 0xffff && iterations < maxIterations) {
                    iterations++;

                    const sub = subroutineManager.get(currentAddr);
                    if (sub && sub.endAddress !== null && foldManager.isCollapsed(currentAddr)) {
                        const foldLines = disassembleWithRegions(currentAddr, 500);
                        let byteCount = 0;
                        let instrCount = 0;
                        for (const fl of foldLines) {
                            if (fl.addr > sub.endAddress) break;
                            byteCount += fl.bytes.length;
                            instrCount++;
                        }
                        const subName = sub.name || labelManager.get(currentAddr)?.name || `sub_${hex16(currentAddr)}`;
                        result.push({
                            addr: currentAddr,
                            bytes: [],
                            mnemonic: '',
                            isData: false,
                            isFoldSummary: true,
                            foldType: 'subroutine',
                            foldName: subName,
                            foldEnd: sub.endAddress,
                            byteCount: byteCount,
                            instrCount: instrCount
                        });
                        currentAddr = (sub.endAddress + 1) & 0xffff;
                        continue;
                    }

                    const userFold = foldManager.getUserFold(currentAddr);
                    if (userFold && foldManager.isCollapsed(currentAddr)) {
                        const foldLines = disassembleWithRegions(currentAddr, 500);
                        let byteCount = 0;
                        let instrCount = 0;
                        for (const fl of foldLines) {
                            if (fl.addr > userFold.endAddress) break;
                            byteCount += fl.bytes.length;
                            instrCount++;
                        }
                        const foldName = userFold.name || `fold_${hex16(currentAddr)}`;
                        result.push({
                            addr: currentAddr,
                            bytes: [],
                            mnemonic: '',
                            isData: false,
                            isFoldSummary: true,
                            foldType: 'user',
                            foldName: foldName,
                            foldEnd: userFold.endAddress,
                            byteCount: byteCount,
                            instrCount: instrCount
                        });
                        currentAddr = (userFold.endAddress + 1) & 0xffff;
                        continue;
                    }

                    const lineArr = disassembleWithRegions(currentAddr, 1);
                    if (lineArr.length === 0) break;
                    const line = lineArr[0];
                    result.push(line);
                    currentAddr = (currentAddr + line.bytes.length) & 0xffff;
                }

                return result;
            }

            const lines = disassembleWithFoldingRight(viewAddr, DISASM_LINES);

            rightDisassemblyView.innerHTML = lines.map((line, idx) => {
                // Handle fold summary lines
                if (line.isFoldSummary) {
                    const icon = '▸';
                    const typeClass = line.foldType === 'user' ? 'user-fold' : '';
                    return `<div class="disasm-fold-summary ${typeClass}" data-fold-addr="${line.addr}">
                        <span class="disasm-fold-toggle" data-fold-addr="${line.addr}">${icon}</span>
                        <span class="fold-name">${escapeHtml(line.foldName)}</span>
                        <span class="fold-stats">(${line.byteCount} bytes)</span>
                    </div>`;
                }

                const bytesStr = line.bytes.map(b => hex8(b)).join(' ');
                const isCurrent = line.addr === pc;
                const hasBp = spectrum.hasBreakpoint(line.addr);
                const classes = ['disasm-line'];
                if (isCurrent) classes.push('current');
                if (hasBp) classes.push('breakpoint');
                if (line.isData) classes.push('data-line');
                if (isFlowBreak(line.mnemonic)) classes.push('flow-break');

                const timing = (showTstates && !line.isData) ? disasm.getTiming(line.bytes) : '';
                const timingHtml = timing ? `<span class="disasm-tstates">${timing}</span>` : '';
                const addrInfo = formatAddrColumn(line.addr, labelMode);
                const mnemonicWithLabels = line.isData ? line.mnemonic : replaceMnemonicAddresses(line.mnemonic, labelMode, line.addr);

                return `<div class="${classes.join(' ')}" data-addr="${line.addr}">
                    <span class="disasm-bp ${hasBp ? 'active' : ''}" data-addr="${line.addr}">•</span>
                    <span class="disasm-addr">${addrInfo.html}</span>
                    <span class="disasm-bytes">${bytesStr}</span>
                    ${timingHtml}
                    <span class="disasm-mnemonic">${formatMnemonic(mnemonicWithLabels)}</span>
                </div>`;
            }).join('');
        }

        // Go to address in left memory view
        function goToLeftMemoryAddress(addr) {
            leftMemoryViewAddress = addr & 0xffff;
            leftMemAddressInput.value = hex16(leftMemoryViewAddress);
            updateLeftMemoryView();
        }

        // Go to address in right disasm view
        function goToRightDisasmAddress(addr) {
            rightDisasmViewAddress = addr & 0xffff;
            rightDisasmAddressInput.value = hex16(rightDisasmViewAddress);
            updateRightDisassemblyView();
        }

        // Panel type select event handlers
        leftPanelTypeSelect.addEventListener('change', (e) => {
            switchLeftPanelType(e.target.value);
        });

        rightPanelTypeSelect.addEventListener('change', (e) => {
            switchRightPanelType(e.target.value);
        });

        // Left panel memory controls
        document.getElementById('btnLeftMemGo')?.addEventListener('click', () => {
            const addr = parseInt(leftMemAddressInput.value, 16);
            if (!isNaN(addr)) goToLeftMemoryAddress(addr);
        });
        leftMemAddressInput?.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const addr = parseInt(leftMemAddressInput.value, 16);
                if (!isNaN(addr)) goToLeftMemoryAddress(addr);
            }
        });
        document.getElementById('btnLeftMemPC')?.addEventListener('click', () => {
            if (spectrum.cpu) goToLeftMemoryAddress(spectrum.cpu.pc);
        });
        document.getElementById('btnLeftMemSP')?.addEventListener('click', () => {
            if (spectrum.cpu) goToLeftMemoryAddress(spectrum.cpu.sp);
        });
        document.getElementById('btnLeftMemHL')?.addEventListener('click', () => {
            if (spectrum.cpu) goToLeftMemoryAddress(spectrum.cpu.hl);
        });
        document.getElementById('btnLeftMemPgUp')?.addEventListener('click', () => {
            goToLeftMemoryAddress(leftMemoryViewAddress - LEFT_MEMORY_LINES * BYTES_PER_LINE);
        });
        document.getElementById('btnLeftMemPgDn')?.addEventListener('click', () => {
            goToLeftMemoryAddress(leftMemoryViewAddress + LEFT_MEMORY_LINES * BYTES_PER_LINE);
        });

        // Right panel disasm controls
        document.getElementById('btnRightDisasmGo')?.addEventListener('click', () => {
            const addr = parseInt(rightDisasmAddressInput.value, 16);
            if (!isNaN(addr)) goToRightDisasmAddress(addr);
        });
        rightDisasmAddressInput?.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const addr = parseInt(rightDisasmAddressInput.value, 16);
                if (!isNaN(addr)) goToRightDisasmAddress(addr);
            }
        });
        document.getElementById('btnRightDisasmPC')?.addEventListener('click', () => {
            if (spectrum.cpu) goToRightDisasmAddress(spectrum.cpu.pc);
        });
        document.getElementById('btnRightDisasmPgUp')?.addEventListener('click', () => {
            navBack('right');
        });
        document.getElementById('btnRightDisasmPgDn')?.addEventListener('click', () => {
            navForward('right');
        });

        // Scroll wheel for left memory view
        leftMemoryView.addEventListener('wheel', (e) => {
            if (leftPanelType !== 'memdump') return;
            e.preventDefault();
            const scrollLines = e.deltaY > 0 ? 3 : -3;
            goToLeftMemoryAddress(leftMemoryViewAddress + scrollLines * BYTES_PER_LINE);
        }, { passive: false });

        // Scroll wheel for right disasm view
        rightDisassemblyView.addEventListener('wheel', (e) => {
            if (rightPanelType !== 'disasm') return;
            e.preventDefault();
            const scrollLines = e.deltaY > 0 ? 3 : -3;
            if (rightDisasmViewAddress !== null) {
                goToRightDisasmAddress(rightDisasmViewAddress + scrollLines * 3);
            }
        }, { passive: false });

        // Click handler for right disasm view - navigate on operand address click
        rightDisassemblyView.addEventListener('click', (e) => {
            if (rightPanelType !== 'disasm') return;

            // Check if clicking on fold toggle or fold summary
            const foldToggle = e.target.closest('.disasm-fold-toggle, .disasm-fold-summary');
            if (foldToggle) {
                const addr = parseInt(foldToggle.dataset.foldAddr, 10);
                if (!isNaN(addr)) {
                    foldManager.toggle(addr);
                    updateDebugger();
                }
                return;
            }

            // Check if clicking on operand address (e.g., JP 4000h)
            // Click = go to disasm in right panel, Ctrl+Click = go to memory
            const operandAddr = e.target.closest('.disasm-operand-addr');
            if (operandAddr) {
                const addr = parseInt(operandAddr.dataset.addr, 10);
                if (e.ctrlKey) {
                    goToRightMemory(addr);
                    showMessage(`Memory: ${hex16(addr)}`);
                } else {
                    goToRightDisasm(addr);
                    showMessage(`Disasm: ${hex16(addr)}`);
                }
                return;
            }
        });

        // XRef tooltip handlers for right disasm view
        rightDisassemblyView.addEventListener('mouseover', (e) => {
            if (rightPanelType !== 'disasm') return;
            const operandAddr = e.target.closest('.disasm-operand-addr');
            if (!operandAddr) return;

            const addr = parseInt(operandAddr.dataset.addr, 10);
            if (isNaN(addr)) return;

            const refs = xrefManager.get(addr);
            if (refs.length === 0) return;

            if (xrefTooltipTimeout) clearTimeout(xrefTooltipTimeout);
            xrefTooltipTimeout = setTimeout(() => {
                showXRefTooltip(addr, refs, e.clientX, e.clientY);
            }, 300);
        });

        rightDisassemblyView.addEventListener('mouseout', (e) => {
            if (rightPanelType !== 'disasm') return;
            const operandAddr = e.target.closest('.disasm-operand-addr');
            if (operandAddr) {
                hideXRefTooltip();
            }
        });

        // Bookmarks handling - updated to store type info with emoji indicators
        function updateBookmarkButtons(bar, bookmarks, panelSide) {
            const buttons = bar.querySelectorAll('.bookmark-btn');
            const currentType = panelSide === 'left' ? leftPanelType : rightPanelType;
            // Emoji indicators: 🔍 for disasm (code inspection), 📦 for memory (raw data)
            const typeEmoji = { disasm: '🔍', memdump: '📦' };
            buttons.forEach((btn, i) => {
                const bm = bookmarks[i];
                if (bm !== null && typeof bm === 'object') {
                    // New format: {addr, type}
                    const emoji = typeEmoji[bm.type] || '';
                    btn.textContent = `${emoji}${hex16(bm.addr)}`;
                    btn.classList.add('set');
                    btn.classList.toggle('type-mismatch', bm.type !== currentType);
                    btn.title = `${bm.type}: ${hex16(bm.addr)} (Click: go, Right-click: set)`;
                } else if (bm !== null) {
                    // Legacy format: just address (assume current panel type)
                    btn.textContent = hex16(bm);
                    btn.classList.add('set');
                    btn.classList.remove('type-mismatch');
                } else {
                    btn.textContent = '-';
                    btn.classList.remove('set');
                    btn.classList.remove('type-mismatch');
                }
            });
        }

        function setupBookmarkHandlers(bar, bookmarks, panelSide) {
            const buttons = bar.querySelectorAll('.bookmark-btn');
            buttons.forEach((btn) => {
                const idx = parseInt(btn.dataset.index);

                // Left click: navigate to bookmark (switch panel type if needed)
                btn.addEventListener('click', () => {
                    const bm = bookmarks[idx];
                    if (bm !== null) {
                        const addr = typeof bm === 'object' ? bm.addr : bm;
                        const type = typeof bm === 'object' ? bm.type : (panelSide === 'left' ? 'disasm' : 'memdump');

                        if (panelSide === 'left') {
                            if (type !== leftPanelType) {
                                switchLeftPanelType(type);
                            }
                            if (leftPanelType === 'disasm') {
                                goToAddress(addr);
                            } else {
                                goToLeftMemoryAddress(addr);
                            }
                        } else {
                            if (type !== rightPanelType) {
                                switchRightPanelType(type);
                            }
                            if (rightPanelType === 'memdump') {
                                goToMemoryAddress(addr);
                            } else {
                                goToRightDisasmAddress(addr);
                            }
                        }
                    }
                });

                // Right click: set bookmark to current address and type
                btn.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    let addr, type;

                    if (panelSide === 'left') {
                        type = leftPanelType;
                        if (type === 'disasm') {
                            addr = disasmViewAddress !== null ? disasmViewAddress : (spectrum.cpu ? spectrum.cpu.pc : null);
                        } else {
                            addr = leftMemoryViewAddress;
                        }
                    } else {
                        type = rightPanelType;
                        if (type === 'memdump') {
                            addr = memoryViewAddress;
                        } else {
                            addr = rightDisasmViewAddress !== null ? rightDisasmViewAddress : (spectrum.cpu ? spectrum.cpu.pc : null);
                        }
                    }

                    if (addr !== null) {
                        const oldBm = bookmarks[idx];
                        bookmarks[idx] = { addr, type };
                        updateBookmarkButtons(bar, bookmarks, panelSide);

                        undoManager.push({
                            type: 'bookmark',
                            description: oldBm !== null
                                ? `Update ${panelSide} bookmark ${idx + 1}`
                                : `Set ${panelSide} bookmark ${idx + 1}`,
                            undo: () => {
                                bookmarks[idx] = oldBm;
                                updateBookmarkButtons(bar, bookmarks, panelSide);
                            },
                            redo: () => {
                                bookmarks[idx] = { addr, type };
                                updateBookmarkButtons(bar, bookmarks, panelSide);
                            }
                        });
                    }
                });
            });
        }

        // Setup left panel bookmarks
        setupBookmarkHandlers(disasmBookmarksBar, leftBookmarks, 'left');

        // Setup right panel bookmarks
        setupBookmarkHandlers(memoryBookmarksBar, rightBookmarks, 'right');

        // Memory snapshot for diff
        btnMemorySnap.addEventListener('click', () => {
            if (!spectrum.memory) return;
            memorySnapshot = new Uint8Array(0x10000);
            for (let addr = 0; addr < 0x10000; addr++) {
                memorySnapshot[addr] = spectrum.memory.read(addr);
            }
            btnMemorySnap.style.display = 'none';
            btnMemoryClearSnap.style.display = '';
            showMessage('Memory snapshot taken');
            updateMemoryView();
        });

        btnMemoryClearSnap.addEventListener('click', () => {
            memorySnapshot = null;
            btnMemorySnap.style.display = '';
            btnMemoryClearSnap.style.display = 'none';
            showMessage('Snapshot cleared');
            updateMemoryView();
        });

        // ROM edit checkbox
        chkRomEdit.addEventListener('change', () => {
            if (spectrum.memory) {
                spectrum.memory.allowRomEdit = chkRomEdit.checked;
            }
        });
        
        // Memory search functions
        // Returns {pattern: number[], mask: number[]} where mask[i]=0xFF for exact, 0x00 for wildcard
        function parseSearchPattern(input, type) {
            if (type === 'hex') {
                // Parse hex bytes like "CD 21 00" with wildcards ?? or **
                const tokens = input.trim().split(/\s+/).filter(s => s.length > 0);
                if (tokens.length === 0) return null;

                const pattern = [];
                const mask = [];

                for (const token of tokens) {
                    if (token === '?' || token === '??' || token === '*' || token === '**') {
                        // Wildcard - match any byte
                        pattern.push(0);
                        mask.push(0x00);
                    } else if (/^[0-9A-Fa-f]{2}$/.test(token)) {
                        // Single hex byte
                        pattern.push(parseInt(token, 16));
                        mask.push(0xFF);
                    } else if (/^[0-9A-Fa-f]+$/.test(token) && token.length % 2 === 0) {
                        // Concatenated hex bytes like "CD21" - split them
                        for (let i = 0; i < token.length; i += 2) {
                            pattern.push(parseInt(token.substr(i, 2), 16));
                            mask.push(0xFF);
                        }
                    } else {
                        return null; // Invalid token
                    }
                }
                return pattern.length > 0 ? { pattern, mask } : null;
            } else if (type === 'dec') {
                // Parse decimal bytes like "205 33 0" or "205,33,0"
                const parts = input.split(/[\s,]+/).filter(s => s.length > 0);
                if (parts.length === 0) return null;
                const pattern = [];
                const mask = [];
                for (const part of parts) {
                    const val = parseInt(part, 10);
                    if (isNaN(val) || val < 0 || val > 255) return null;
                    pattern.push(val);
                    mask.push(0xFF);
                }
                return pattern.length > 0 ? { pattern, mask } : null;
            } else {
                // Text search - convert to bytes
                if (input.length === 0) return null;
                const pattern = Array.from(input).map(c => c.charCodeAt(0) & 0xff);
                const mask = pattern.map(() => 0xFF);
                return { pattern, mask };
            }
        }
        
        function searchMemory(searchData, startAddr = 0, options = {}) {
            if (!spectrum.memory || !searchData) return [];

            // Support both old format (array) and new format ({pattern, mask})
            const pattern = Array.isArray(searchData) ? searchData : searchData.pattern;
            const mask = Array.isArray(searchData) ? null : searchData.mask;

            if (!pattern || pattern.length === 0) return [];

            const { caseInsensitive = false, lastChar7bit = false } = options;
            const results = [];
            const maxResults = 100;
            const memSize = 0x10000;
            const patternLen = pattern.length;

            // Prepare pattern for matching
            const matchPattern = caseInsensitive
                ? pattern.map(b => (b >= 0x41 && b <= 0x5a) ? b | 0x20 : (b >= 0x61 && b <= 0x7a) ? b : b)
                : pattern;

            for (let addr = startAddr; addr < memSize && results.length < maxResults; addr++) {
                let match = true;
                for (let i = 0; i < patternLen && match; i++) {
                    // Skip wildcards (mask = 0x00)
                    if (mask && mask[i] === 0x00) continue;

                    let memByte = spectrum.memory.read((addr + i) & 0xffff);
                    let patByte = matchPattern[i];

                    // Last character with 7-bit set: match both normal and +128 versions
                    if (lastChar7bit && i === patternLen - 1) {
                        const memByteLow = memByte & 0x7f;
                        if (caseInsensitive) {
                            const memLower = (memByteLow >= 0x41 && memByteLow <= 0x5a) ? memByteLow | 0x20 : memByteLow;
                            const patLower = (patByte >= 0x41 && patByte <= 0x5a) ? patByte | 0x20 : patByte;
                            if (memLower !== patLower) match = false;
                        } else {
                            if (memByteLow !== patByte) match = false;
                        }
                    } else if (caseInsensitive) {
                        // Case-insensitive: convert both to lowercase for comparison
                        const memLower = (memByte >= 0x41 && memByte <= 0x5a) ? memByte | 0x20 : memByte;
                        const patLower = (patByte >= 0x41 && patByte <= 0x5a) ? patByte | 0x20 : patByte;
                        if (memLower !== patLower) match = false;
                    } else {
                        if (memByte !== patByte) match = false;
                    }
                }
                if (match) {
                    results.push(addr);
                }
            }
            return results;
        }
        
        function displaySearchResults(results, searchData) {
            if (results.length === 0) {
                searchResults.innerHTML = '<div class="search-info">No results found</div>';
                return;
            }

            const patternLen = searchData.pattern ? searchData.pattern.length : searchData.length;
            searchResults.innerHTML = results.slice(0, 20).map((addr, idx) => {
                // Show preview of bytes at this address
                let preview = '';
                for (let i = 0; i < Math.min(8, patternLen + 4); i++) {
                    preview += hex8(spectrum.memory.read((addr + i) & 0xffff)) + ' ';
                }
                return `<div class="search-result" data-addr="${addr}" data-idx="${idx}">
                    <span class="addr">${hex16(addr)}</span>
                    <span class="preview">${preview.trim()}</span>
                </div>`;
            }).join('') + (results.length > 20 ? `<div class="search-info">...and ${results.length - 20} more</div>` : '');
        }

        function doSearch() {
            const input = memSearchInput.value.trim();
            if (!input) {
                searchResults.innerHTML = '';
                return;
            }

            searchPattern = parseSearchPattern(input, memSearchType.value);
            if (!searchPattern) {
                searchResults.innerHTML = '<div class="search-info">Invalid pattern (hex: use ? for wildcard)</div>';
                return;
            }

            const searchOptions = {
                caseInsensitive: chkSearchCase.checked,
                lastChar7bit: chkSearch7bit.checked
            };
            
            searchResultAddrs = searchMemory(searchPattern, 0, searchOptions);
            searchResultIndex = searchResultAddrs.length > 0 ? 0 : -1;
            
            displaySearchResults(searchResultAddrs, searchPattern);
            
            if (searchResultAddrs.length > 0) {
                goToMemoryAddress(searchResultAddrs[0]);
                showMessage(`Found ${searchResultAddrs.length} result(s)`);
            } else {
                showMessage('No results found', 'error');
            }
        }
        
        function doSearchNext() {
            if (searchResultAddrs.length === 0) {
                doSearch();
                return;
            }
            
            searchResultIndex = (searchResultIndex + 1) % searchResultAddrs.length;
            goToMemoryAddress(searchResultAddrs[searchResultIndex]);
            showMessage(`Result ${searchResultIndex + 1} of ${searchResultAddrs.length}`);
        }
        
        btnMemSearch.addEventListener('click', doSearch);
        
        btnMemSearchNext.addEventListener('click', doSearchNext);
        
        memSearchInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                if (e.shiftKey) {
                    doSearchNext();
                } else {
                    doSearch();
                }
            }
        });
        
        // Show/hide text search options and update placeholder based on search type
        const searchOptionsDiv = document.querySelector('.right-memory-search .search-options');
        function updateSearchOptions() {
            const mode = memSearchType.value;
            if (searchOptionsDiv) searchOptionsDiv.style.display = mode === 'text' ? 'flex' : 'none';

            // Update placeholder and tooltip based on mode
            if (mode === 'hex') {
                memSearchInput.placeholder = 'CD ? 00...';
                memSearchInput.title = 'Hex bytes, use ? for wildcard';
            } else if (mode === 'dec') {
                memSearchInput.placeholder = '205 33 0...';
                memSearchInput.title = 'Decimal bytes (0-255)';
            } else {
                memSearchInput.placeholder = 'text...';
                memSearchInput.title = 'Text string to search';
            }
        }
        memSearchType.addEventListener('change', updateSearchOptions);
        updateSearchOptions(); // Initial state
        
        searchResults.addEventListener('click', (e) => {
            const resultEl = e.target.closest('.search-result');
            if (resultEl) {
                const addr = parseInt(resultEl.dataset.addr);
                const idx = parseInt(resultEl.dataset.idx);
                searchResultIndex = idx;
                goToMemoryAddress(addr);
            }
        });

        // Left panel search functions
        function displayLeftSearchResults(results, pattern) {
            if (results.length === 0) {
                leftSearchResults.innerHTML = '<div class="search-info">No results</div>';
                return;
            }
            const patternLen = pattern.length;
            leftSearchResults.innerHTML = results.slice(0, 20).map((addr, idx) => {
                let preview = '';
                for (let i = 0; i < Math.min(8, patternLen + 4); i++) {
                    preview += hex8(spectrum.memory.read((addr + i) & 0xffff)) + ' ';
                }
                return `<div class="search-result" data-addr="${addr}" data-idx="${idx}">
                    <span class="addr">${hex16(addr)}</span>
                    <span class="preview">${preview.trim()}</span>
                </div>`;
            }).join('') + (results.length > 20 ? `<div class="search-info">...and ${results.length - 20} more</div>` : '');
        }

        function doLeftSearch() {
            const input = leftMemSearchInput.value.trim();
            if (!input) {
                leftSearchResults.innerHTML = '';
                return;
            }

            leftSearchPattern = parseSearchPattern(input, leftMemSearchType.value);
            if (!leftSearchPattern) {
                leftSearchResults.innerHTML = '<div class="search-info">Invalid pattern (hex: use ? for wildcard)</div>';
                return;
            }

            const searchOptions = {
                caseInsensitive: chkLeftSearchCase.checked,
                lastChar7bit: chkLeftSearch7bit.checked
            };

            leftSearchResultAddrs = searchMemory(leftSearchPattern, 0, searchOptions);
            leftSearchResultIndex = leftSearchResultAddrs.length > 0 ? 0 : -1;

            displayLeftSearchResults(leftSearchResultAddrs, leftSearchPattern);

            if (leftSearchResultAddrs.length > 0) {
                goToLeftMemoryAddress(leftSearchResultAddrs[0]);
                showMessage(`Found ${leftSearchResultAddrs.length} result(s)`);
            } else {
                showMessage('No results found', 'error');
            }
        }

        function doLeftSearchNext() {
            if (leftSearchResultAddrs.length === 0) {
                doLeftSearch();
                return;
            }

            leftSearchResultIndex = (leftSearchResultIndex + 1) % leftSearchResultAddrs.length;
            goToLeftMemoryAddress(leftSearchResultAddrs[leftSearchResultIndex]);
            showMessage(`Result ${leftSearchResultIndex + 1} of ${leftSearchResultAddrs.length}`);
        }

        btnLeftMemSearch.addEventListener('click', doLeftSearch);
        btnLeftMemSearchNext.addEventListener('click', doLeftSearchNext);

        leftMemSearchInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                if (e.shiftKey) {
                    doLeftSearchNext();
                } else {
                    doLeftSearch();
                }
            }
        });

        // Left panel search options update
        const leftSearchOptionsDiv = document.querySelector('.left-memory-search .search-options');
        function updateLeftSearchOptions() {
            const mode = leftMemSearchType.value;
            if (leftSearchOptionsDiv) leftSearchOptionsDiv.style.display = mode === 'text' ? 'flex' : 'none';

            if (mode === 'hex') {
                leftMemSearchInput.placeholder = 'CD ? 00...';
                leftMemSearchInput.title = 'Hex bytes, use ? for wildcard';
            } else if (mode === 'dec') {
                leftMemSearchInput.placeholder = '205 33 0...';
                leftMemSearchInput.title = 'Decimal bytes (0-255)';
            } else {
                leftMemSearchInput.placeholder = 'text...';
                leftMemSearchInput.title = 'Text string to search';
            }
        }
        leftMemSearchType.addEventListener('change', updateLeftSearchOptions);
        updateLeftSearchOptions();

        leftSearchResults.addEventListener('click', (e) => {
            const resultEl = e.target.closest('.search-result');
            if (resultEl) {
                const addr = parseInt(resultEl.dataset.addr);
                const idx = parseInt(resultEl.dataset.idx);
                leftSearchResultIndex = idx;
                goToLeftMemoryAddress(addr);
            }
        });

        // POKE search handlers
        pokeSearchMode.addEventListener('change', () => {
            pokeSearchValue.style.display = pokeSearchMode.value === 'equals' ? '' : 'none';
        });

        function updatePokeStatus() {
            if (pokeCandidates === null) {
                pokeStatus.textContent = pokeSnapshot ? '(snap taken)' : '';
            } else {
                pokeStatus.textContent = `(${pokeCandidates.size} candidates)`;
            }
        }

        function updatePokeResults() {
            if (pokeCandidates === null || pokeCandidates.size === 0) {
                pokeResults.innerHTML = '';
                return;
            }
            // Show first 100 candidates
            const addrs = [...pokeCandidates].slice(0, 100);
            pokeResults.innerHTML = addrs.map(addr => {
                const val = spectrum.memory.read(addr);
                return `<span class="poke-result" data-addr="${addr}"><span class="addr">${hex16(addr)}</span><span class="val">${hex8(val)}</span></span>`;
            }).join('');
            if (pokeCandidates.size > 100) {
                pokeResults.innerHTML += `<span class="poke-status">...and ${pokeCandidates.size - 100} more</span>`;
            }
        }

        btnPokeSnap.addEventListener('click', () => {
            if (!spectrum.memory) return;
            pokeSnapshot = new Uint8Array(0x10000);
            for (let addr = 0; addr < 0x10000; addr++) {
                pokeSnapshot[addr] = spectrum.memory.read(addr);
            }
            showMessage('POKE snapshot taken');
            updatePokeStatus();
        });

        btnPokeSearch.addEventListener('click', () => {
            if (!spectrum.memory || !pokeSnapshot) {
                showMessage('Take a snapshot first', 'error');
                return;
            }

            const mode = pokeSearchMode.value;
            let targetValue = 0;
            if (mode === 'equals') {
                const valStr = pokeSearchValue.value.trim();
                if (!/^[0-9A-Fa-f]{1,2}$/.test(valStr)) {
                    showMessage('Enter hex value (00-FF)', 'error');
                    return;
                }
                targetValue = parseInt(valStr, 16);
            }

            // Start with all RAM addresses or existing candidates
            const searchSet = pokeCandidates !== null ? pokeCandidates : new Set();
            if (pokeCandidates === null) {
                // First search: all RAM (0x4000-0xFFFF)
                for (let addr = 0x4000; addr < 0x10000; addr++) {
                    searchSet.add(addr);
                }
            }

            const newCandidates = new Set();
            for (const addr of searchSet) {
                const oldVal = pokeSnapshot[addr];
                const newVal = spectrum.memory.read(addr);
                let match = false;

                switch (mode) {
                    case 'dec1': match = newVal === ((oldVal - 1) & 0xff); break;
                    case 'inc1': match = newVal === ((oldVal + 1) & 0xff); break;
                    case 'decreased': match = newVal < oldVal; break;
                    case 'increased': match = newVal > oldVal; break;
                    case 'changed': match = newVal !== oldVal; break;
                    case 'unchanged': match = newVal === oldVal; break;
                    case 'equals': match = newVal === targetValue; break;
                }

                if (match) {
                    newCandidates.add(addr);
                }
            }

            pokeCandidates = newCandidates;

            // Update snapshot to current state for next comparison
            for (let addr = 0; addr < 0x10000; addr++) {
                pokeSnapshot[addr] = spectrum.memory.read(addr);
            }

            showMessage(`${pokeCandidates.size} candidate(s) found`);
            updatePokeStatus();
            updatePokeResults();
        });

        btnPokeReset.addEventListener('click', () => {
            pokeSnapshot = null;
            pokeCandidates = null;
            pokeResults.innerHTML = '';
            updatePokeStatus();
            showMessage('POKE search reset');
        });

        pokeResults.addEventListener('click', (e) => {
            const resultEl = e.target.closest('.poke-result');
            if (resultEl) {
                const addr = parseInt(resultEl.dataset.addr);
                goToMemoryAddress(addr);
            }
        });

        // ========== Explorer Tab ==========
        const explorerFileInput = document.getElementById('explorerFileInput');
        const btnExplorerLoad = document.getElementById('btnExplorerLoad');
        const explorerFileName = document.getElementById('explorerFileName');
        const explorerFileSize = document.getElementById('explorerFileSize');
        const explorerInfoOutput = document.getElementById('explorerInfoOutput');
        const explorerBasicOutput = document.getElementById('explorerBasicOutput');
        const explorerBasicSource = document.getElementById('explorerBasicSource');
        const explorerDisasmOutput = document.getElementById('explorerDisasmOutput');
        const explorerDisasmAddr = document.getElementById('explorerDisasmAddr');
        const explorerDisasmLen = document.getElementById('explorerDisasmLen');
        const explorerDisasmSource = document.getElementById('explorerDisasmSource');
        const btnExplorerDisasm = document.getElementById('btnExplorerDisasm');
        const explorerHexOutput = document.getElementById('explorerHexOutput');
        const explorerHexAddr = document.getElementById('explorerHexAddr');
        const explorerHexLen = document.getElementById('explorerHexLen');
        const explorerHexSource = document.getElementById('explorerHexSource');
        const btnExplorerHex = document.getElementById('btnExplorerHex');

        // Explorer state
        let explorerData = null;         // Raw file data
        let explorerParsed = null;       // Parsed file structure
        let explorerFileType = null;     // 'tap', 'sna', 'z80', 'trd', 'scl', 'zip'
        let explorerBlocks = [];         // Parsed blocks/files
        let explorerZipFiles = [];       // Files from ZIP archive
        let explorerZipParentName = null; // Store parent ZIP name for drill-down

        // Preview canvas elements
        const explorerPreviewContainer = document.getElementById('explorerPreviewContainer');
        const explorerPreviewCanvas = document.getElementById('explorerPreviewCanvas');
        const explorerPreviewLabel = document.getElementById('explorerPreviewLabel');
        const explorerPreviewCtx = explorerPreviewCanvas.getContext('2d');

        // Get current palette from ULA (falls back to default if not available)
        function getExplorerPalette() {
            if (spectrum && spectrum.ula && spectrum.ula.palette) {
                // ULA palette is 16 colors: 0-7 regular, 8-15 bright
                return {
                    regular: spectrum.ula.palette.slice(0, 8).map(c => [c[0], c[1], c[2]]),
                    bright: spectrum.ula.palette.slice(8, 16).map(c => [c[0], c[1], c[2]])
                };
            }
            // Default palette if ULA not available
            return {
                regular: [[0,0,0], [0,0,215], [215,0,0], [215,0,215], [0,215,0], [0,215,215], [215,215,0], [215,215,215]],
                bright: [[0,0,0], [0,0,255], [255,0,0], [255,0,255], [0,255,0], [0,255,255], [255,255,0], [255,255,255]]
            };
        }

        // Preview rendering functions
        function explorerUpdatePreview(data, blockData = null) {
            if (!data) {
                explorerPreviewContainer.style.display = 'none';
                return;
            }

            const len = data.length;
            let previewType = null;
            let label = '';

            // Detect preview type by size
            if (len === 6912) {
                previewType = 'scr';
                label = 'Screen (6912 bytes)';
            } else if (len === 6144) {
                previewType = 'mono_full';
                label = 'Bitmap (6144 bytes)';
            } else if (len === 4096) {
                previewType = 'mono_2_3';
                label = 'Bitmap 2/3 (4096 bytes)';
            } else if (len === 2048) {
                previewType = 'mono_1_3';
                label = 'Bitmap 1/3 (2048 bytes)';
            } else if (len === 768) {
                previewType = 'font';
                label = 'Font / Attributes (768 bytes)';
            } else if (len === 9216) {
                previewType = 'ifl';
                label = 'IFL 8×2 Multicolor (9216 bytes)';
            } else if (len === 12288) {
                previewType = 'mlt';
                label = 'MLT 8×1 Multicolor (12288 bytes)';
            } else if (len === 18432) {
                previewType = 'rgb3';
                label = 'RGB3 Tricolor (18432 bytes)';
            }

            if (!previewType) {
                explorerPreviewContainer.style.display = 'none';
                return;
            }

            // Show preview
            explorerPreviewContainer.style.display = 'flex';
            explorerPreviewLabel.textContent = label;

            // Render based on type
            switch (previewType) {
                case 'scr':
                    explorerRenderSCR(data);
                    break;
                case 'mono_full':
                    explorerRenderMono(data, 3);
                    break;
                case 'mono_2_3':
                    explorerRenderMono(data, 2);
                    break;
                case 'mono_1_3':
                    explorerRenderMono(data, 1);
                    break;
                case 'font':
                    explorerRenderFont(data);
                    break;
                case 'ifl':
                    explorerRenderIFL(data);
                    break;
                case 'mlt':
                    explorerRenderMLT(data);
                    break;
                case 'rgb3':
                    explorerRenderRGB3(data);
                    break;
            }
        }

        function explorerRenderSCR(data) {
            explorerPreviewCanvas.width = 256;
            explorerPreviewCanvas.height = 192;
            const imageData = explorerPreviewCtx.createImageData(256, 192);
            const pixels = imageData.data;

            // Process all three screen thirds
            const sections = [
                { bitmapAddr: 0, attrAddr: 6144, yOffset: 0 },
                { bitmapAddr: 2048, attrAddr: 6400, yOffset: 64 },
                { bitmapAddr: 4096, attrAddr: 6656, yOffset: 128 }
            ];

            for (const section of sections) {
                const { bitmapAddr, attrAddr, yOffset } = section;
                for (let line = 0; line < 8; line++) {
                    for (let row = 0; row < 8; row++) {
                        for (let col = 0; col < 32; col++) {
                            const bitmapOffset = bitmapAddr + col + row * 32 + line * 256;
                            const byte = data[bitmapOffset];
                            const attrOffset = attrAddr + col + row * 32;
                            const attr = data[attrOffset];

                            const isBright = (attr & 0x40) !== 0;
                            const ink = attr & 0x07;
                            const paper = (attr >> 3) & 0x07;
                            const pal = getExplorerPalette();
                            const palette = isBright ? pal.bright : pal.regular;
                            const inkRgb = palette[ink];
                            const paperRgb = palette[paper];

                            const x = col * 8;
                            const y = yOffset + row * 8 + line;

                            for (let bit = 0; bit < 8; bit++) {
                                const isSet = (byte & (0x80 >> bit)) !== 0;
                                const rgb = isSet ? inkRgb : paperRgb;
                                const idx = ((y * 256) + x + bit) * 4;
                                pixels[idx] = rgb[0];
                                pixels[idx + 1] = rgb[1];
                                pixels[idx + 2] = rgb[2];
                                pixels[idx + 3] = 255;
                            }
                        }
                    }
                }
            }

            explorerPreviewCtx.putImageData(imageData, 0, 0);
        }

        function explorerRenderMono(data, thirds) {
            explorerPreviewCanvas.width = 256;
            explorerPreviewCanvas.height = 192;
            const imageData = explorerPreviewCtx.createImageData(256, 192);
            const pixels = imageData.data;

            // Fill with black
            for (let i = 0; i < pixels.length; i += 4) {
                pixels[i] = 0; pixels[i + 1] = 0; pixels[i + 2] = 0; pixels[i + 3] = 255;
            }

            const ink = [215, 215, 215];
            const paper = [0, 0, 0];

            for (let third = 0; third < thirds; third++) {
                const bitmapBase = third * 2048;
                for (let y = 0; y < 64; y++) {
                    const charRow = Math.floor(y / 8);
                    const pixelLine = y % 8;
                    const bitmapOffset = bitmapBase + charRow * 32 + pixelLine * 256;

                    for (let col = 0; col < 32; col++) {
                        const byte = data[bitmapOffset + col];
                        const screenY = third * 64 + y;
                        const x = col * 8;

                        for (let bit = 0; bit < 8; bit++) {
                            const isSet = (byte & (0x80 >> bit)) !== 0;
                            const rgb = isSet ? ink : paper;
                            const idx = ((screenY * 256) + x + bit) * 4;
                            pixels[idx] = rgb[0];
                            pixels[idx + 1] = rgb[1];
                            pixels[idx + 2] = rgb[2];
                            pixels[idx + 3] = 255;
                        }
                    }
                }
            }

            explorerPreviewCtx.putImageData(imageData, 0, 0);
        }

        function explorerRenderFont(data) {
            // 96 chars, 8 bytes each = 768 bytes
            // Render as 16x6 grid (96 chars)
            explorerPreviewCanvas.width = 128;
            explorerPreviewCanvas.height = 48;
            const imageData = explorerPreviewCtx.createImageData(128, 48);
            const pixels = imageData.data;

            // Fill with black
            for (let i = 0; i < pixels.length; i += 4) {
                pixels[i] = 0; pixels[i + 1] = 0; pixels[i + 2] = 0; pixels[i + 3] = 255;
            }

            const ink = [215, 215, 215];

            for (let charIdx = 0; charIdx < 96; charIdx++) {
                const gridX = charIdx % 16;
                const gridY = Math.floor(charIdx / 16);
                const charOffset = charIdx * 8;

                for (let line = 0; line < 8; line++) {
                    const byte = data[charOffset + line];
                    const y = gridY * 8 + line;
                    const x = gridX * 8;

                    for (let bit = 0; bit < 8; bit++) {
                        if ((byte & (0x80 >> bit)) !== 0) {
                            const idx = ((y * 128) + x + bit) * 4;
                            pixels[idx] = ink[0];
                            pixels[idx + 1] = ink[1];
                            pixels[idx + 2] = ink[2];
                        }
                    }
                }
            }

            explorerPreviewCtx.putImageData(imageData, 0, 0);
        }

        function explorerRenderIFL(data) {
            // IFL: 8×2 multicolor - 6144 bitmap + 3072 attributes (1 attr per 2 pixel lines)
            explorerPreviewCanvas.width = 256;
            explorerPreviewCanvas.height = 192;
            const imageData = explorerPreviewCtx.createImageData(256, 192);
            const pixels = imageData.data;

            const sections = [
                { bitmapAddr: 0, yOffset: 0 },
                { bitmapAddr: 2048, yOffset: 64 },
                { bitmapAddr: 4096, yOffset: 128 }
            ];

            for (const section of sections) {
                const { bitmapAddr, yOffset } = section;
                for (let line = 0; line < 8; line++) {
                    for (let row = 0; row < 8; row++) {
                        for (let col = 0; col < 32; col++) {
                            const bitmapOffset = bitmapAddr + col + row * 32 + line * 256;
                            const byte = data[bitmapOffset];

                            const screenY = yOffset + row * 8 + line;
                            // IFL: 96 attribute rows (192/2), one per 2 pixel lines
                            const attrRow = Math.floor(screenY / 2);
                            const attrOffset = 6144 + attrRow * 32 + col;
                            const attr = data[attrOffset];

                            const isBright = (attr & 0x40) !== 0;
                            const ink = attr & 0x07;
                            const paper = (attr >> 3) & 0x07;
                            const pal = getExplorerPalette();
                            const palette = isBright ? pal.bright : pal.regular;
                            const inkRgb = palette[ink];
                            const paperRgb = palette[paper];

                            const x = col * 8;
                            for (let bit = 0; bit < 8; bit++) {
                                const isSet = (byte & (0x80 >> bit)) !== 0;
                                const rgb = isSet ? inkRgb : paperRgb;
                                const idx = ((screenY * 256) + x + bit) * 4;
                                pixels[idx] = rgb[0];
                                pixels[idx + 1] = rgb[1];
                                pixels[idx + 2] = rgb[2];
                                pixels[idx + 3] = 255;
                            }
                        }
                    }
                }
            }
            explorerPreviewCtx.putImageData(imageData, 0, 0);
        }

        function explorerRenderMLT(data) {
            // MLT: 8×1 multicolor - 6144 bitmap + 6144 attributes (1 attr per pixel line)
            explorerPreviewCanvas.width = 256;
            explorerPreviewCanvas.height = 192;
            const imageData = explorerPreviewCtx.createImageData(256, 192);
            const pixels = imageData.data;

            const sections = [
                { bitmapAddr: 0, yOffset: 0 },
                { bitmapAddr: 2048, yOffset: 64 },
                { bitmapAddr: 4096, yOffset: 128 }
            ];

            for (const section of sections) {
                const { bitmapAddr, yOffset } = section;
                for (let line = 0; line < 8; line++) {
                    for (let row = 0; row < 8; row++) {
                        for (let col = 0; col < 32; col++) {
                            const bitmapOffset = bitmapAddr + col + row * 32 + line * 256;
                            const byte = data[bitmapOffset];

                            const screenY = yOffset + row * 8 + line;
                            // MLT: 192 attribute rows, one per pixel line
                            const attrOffset = 6144 + screenY * 32 + col;
                            const attr = data[attrOffset];

                            const isBright = (attr & 0x40) !== 0;
                            const ink = attr & 0x07;
                            const paper = (attr >> 3) & 0x07;
                            const pal = getExplorerPalette();
                            const palette = isBright ? pal.bright : pal.regular;
                            const inkRgb = palette[ink];
                            const paperRgb = palette[paper];

                            const x = col * 8;
                            for (let bit = 0; bit < 8; bit++) {
                                const isSet = (byte & (0x80 >> bit)) !== 0;
                                const rgb = isSet ? inkRgb : paperRgb;
                                const idx = ((screenY * 256) + x + bit) * 4;
                                pixels[idx] = rgb[0];
                                pixels[idx + 1] = rgb[1];
                                pixels[idx + 2] = rgb[2];
                                pixels[idx + 3] = 255;
                            }
                        }
                    }
                }
            }
            explorerPreviewCtx.putImageData(imageData, 0, 0);
        }

        function explorerRenderRGB3(data) {
            // RGB3: Tricolor - 3 × 6144 bitmaps (Red, Green, Blue)
            explorerPreviewCanvas.width = 256;
            explorerPreviewCanvas.height = 192;
            const imageData = explorerPreviewCtx.createImageData(256, 192);
            const pixels = imageData.data;

            // Fill with black
            for (let i = 0; i < pixels.length; i += 4) {
                pixels[i] = 0; pixels[i + 1] = 0; pixels[i + 2] = 0; pixels[i + 3] = 255;
            }

            const sections = [
                { bitmapAddr: 0, yOffset: 0 },
                { bitmapAddr: 2048, yOffset: 64 },
                { bitmapAddr: 4096, yOffset: 128 }
            ];

            // Process each color plane
            for (const section of sections) {
                const { bitmapAddr, yOffset } = section;
                for (let line = 0; line < 8; line++) {
                    for (let row = 0; row < 8; row++) {
                        for (let col = 0; col < 32; col++) {
                            const baseOffset = bitmapAddr + col + row * 32 + line * 256;
                            const redByte = data[baseOffset];           // Red plane
                            const greenByte = data[baseOffset + 6144];  // Green plane
                            const blueByte = data[baseOffset + 12288];  // Blue plane

                            const screenY = yOffset + row * 8 + line;
                            const x = col * 8;

                            for (let bit = 0; bit < 8; bit++) {
                                const mask = 0x80 >> bit;
                                const r = (redByte & mask) ? 255 : 0;
                                const g = (greenByte & mask) ? 255 : 0;
                                const b = (blueByte & mask) ? 255 : 0;

                                const idx = ((screenY * 256) + x + bit) * 4;
                                pixels[idx] = r;
                                pixels[idx + 1] = g;
                                pixels[idx + 2] = b;
                                pixels[idx + 3] = 255;
                            }
                        }
                    }
                }
            }
            explorerPreviewCtx.putImageData(imageData, 0, 0);
        }

        function explorerRenderDualScreen(screen5, screen7, activeScreen) {
            // Render two screens side by side for 128K
            explorerPreviewCanvas.width = 520;  // 256 + 8 gap + 256
            explorerPreviewCanvas.height = 192;
            explorerPreviewContainer.style.display = 'flex';
            explorerPreviewLabel.textContent = `128K Screens (Bank 5 / Bank 7) - Active: ${activeScreen}`;

            const imageData = explorerPreviewCtx.createImageData(520, 192);
            const pixels = imageData.data;

            // Fill with dark background
            for (let i = 0; i < pixels.length; i += 4) {
                pixels[i] = 32; pixels[i + 1] = 32; pixels[i + 2] = 48; pixels[i + 3] = 255;
            }

            // Render screen 5 (left)
            if (screen5) {
                explorerRenderSCRToImageData(pixels, 520, screen5, 0);
            }

            // Render screen 7 (right, offset by 264 pixels)
            if (screen7) {
                explorerRenderSCRToImageData(pixels, 520, screen7, 264);
            }

            explorerPreviewCtx.putImageData(imageData, 0, 0);

            // Draw border around active screen
            explorerPreviewCtx.strokeStyle = '#0f0';
            explorerPreviewCtx.lineWidth = 2;
            if (activeScreen === 5) {
                explorerPreviewCtx.strokeRect(1, 1, 254, 190);
            } else {
                explorerPreviewCtx.strokeRect(265, 1, 254, 190);
            }
        }

        function explorerRenderSCRToImageData(pixels, canvasWidth, data, xOffset) {
            const sections = [
                { bitmapAddr: 0, attrAddr: 6144, yOffset: 0 },
                { bitmapAddr: 2048, attrAddr: 6400, yOffset: 64 },
                { bitmapAddr: 4096, attrAddr: 6656, yOffset: 128 }
            ];

            for (const section of sections) {
                const { bitmapAddr, attrAddr, yOffset } = section;
                for (let line = 0; line < 8; line++) {
                    for (let row = 0; row < 8; row++) {
                        for (let col = 0; col < 32; col++) {
                            const bitmapOffset = bitmapAddr + col + row * 32 + line * 256;
                            const byte = data[bitmapOffset];
                            const attrOffset = attrAddr + col + row * 32;
                            const attr = data[attrOffset];

                            const isBright = (attr & 0x40) !== 0;
                            const ink = attr & 0x07;
                            const paper = (attr >> 3) & 0x07;
                            const pal = getExplorerPalette();
                            const palette = isBright ? pal.bright : pal.regular;
                            const inkRgb = palette[ink];
                            const paperRgb = palette[paper];

                            const x = col * 8 + xOffset;
                            const y = yOffset + row * 8 + line;

                            for (let bit = 0; bit < 8; bit++) {
                                const isSet = (byte & (0x80 >> bit)) !== 0;
                                const rgb = isSet ? inkRgb : paperRgb;
                                const idx = ((y * canvasWidth) + x + bit) * 4;
                                pixels[idx] = rgb[0];
                                pixels[idx + 1] = rgb[1];
                                pixels[idx + 2] = rgb[2];
                                pixels[idx + 3] = 255;
                            }
                        }
                    }
                }
            }
        }

        // Sub-tab switching
        document.querySelectorAll('.explorer-subtab').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.explorer-subtab').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.explorer-subtab-content').forEach(c => {
                    c.classList.remove('active');
                    c.style.display = 'none';
                });
                btn.classList.add('active');
                const contentId = 'explorer-' + btn.dataset.subtab;
                const content = document.getElementById(contentId);
                if (content) {
                    content.classList.add('active');
                    content.style.display = '';
                }
            });
        });

        // File load button
        btnExplorerLoad.addEventListener('click', () => explorerFileInput.click());

        explorerFileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            try {
                const data = await file.arrayBuffer();
                explorerData = new Uint8Array(data);
                explorerFileName.textContent = file.name;
                explorerFileSize.textContent = `(${explorerData.length.toLocaleString()} bytes)`;

                // Detect file type
                const ext = file.name.split('.').pop().toLowerCase();
                explorerFileType = ext;

                // Parse file
                await explorerParseFile(file.name, ext);

                // Clear all sub-tab outputs (prevent stale content from previous file)
                explorerBasicOutput.innerHTML = '<div class="explorer-empty">Select a BASIC program source</div>';
                explorerDisasmOutput.innerHTML = '<div class="explorer-empty">Select a source to disassemble</div>';
                explorerHexOutput.innerHTML = '';

                // Render File Info
                explorerRenderFileInfo();

                // Switch to File Info tab
                document.querySelector('.explorer-subtab[data-subtab="info"]').click();

            } catch (err) {
                explorerFileName.textContent = 'Error loading file';
                explorerFileSize.textContent = '';
                console.error('Explorer load error:', err);
            }

            e.target.value = '';
        });

        // Parse file based on type
        async function explorerParseFile(filename, ext) {
            explorerBlocks = [];
            explorerZipFiles = [];
            explorerParsed = null;

            switch (ext) {
                case 'tap':
                    explorerParsed = explorerParseTAP(explorerData);
                    break;
                case 'tzx':
                    explorerParsed = explorerParseTZX(explorerData);
                    break;
                case 'sna':
                    explorerParsed = explorerParseSNA(explorerData);
                    break;
                case 'z80':
                    explorerParsed = explorerParseZ80(explorerData);
                    break;
                case 'trd':
                    explorerParsed = explorerParseTRD(explorerData);
                    break;
                case 'scl':
                    explorerParsed = explorerParseSCL(explorerData);
                    break;
                case 'dsk':
                    explorerParsed = explorerParseDSK(explorerData);
                    break;
                case 'zip':
                    explorerParsed = await explorerParseZIP(explorerData);
                    break;
                case 'scr':
                case 'bsc':
                case 'fnt':
                case 'chr':
                    explorerParsed = explorerParseRawGraphics(explorerData, ext);
                    break;
                case 'szx':
                    explorerParsed = explorerParseSZX(explorerData);
                    break;
                case 'rzx':
                    explorerParsed = await explorerParseRZX(explorerData);
                    break;
                default:
                    // Check if raw data matches known graphics sizes
                    explorerParsed = explorerParseRawGraphics(explorerData, ext);
            }
        }

        // Raw graphics file parser (SCR, BSC, fonts, etc.)
        function explorerParseRawGraphics(data, ext) {
            const len = data.length;
            let graphicsType = null;
            let description = '';

            // Detect by size
            if (len === 6912) {
                graphicsType = 'scr';
                description = 'ZX Spectrum Screen (bitmap + attributes)';
            } else if (len === 6144) {
                graphicsType = 'bitmap';
                description = 'Monochrome Bitmap (full screen)';
            } else if (len === 4096) {
                graphicsType = 'bitmap_2_3';
                description = 'Monochrome Bitmap (2/3 screen)';
            } else if (len === 2048) {
                graphicsType = 'bitmap_1_3';
                description = 'Monochrome Bitmap (1/3 screen)';
            } else if (len === 768) {
                if (ext === 'fnt' || ext === 'chr') {
                    graphicsType = 'font';
                    description = 'ZX Spectrum Font (96 characters)';
                } else {
                    graphicsType = 'attr';
                    description = 'Attribute data (768 bytes)';
                }
            } else if (len === 9216) {
                graphicsType = 'ifl';
                description = 'IFL 8×2 Multicolor (6144 + 3072 attributes)';
            } else if (len === 11136) {
                graphicsType = 'bsc';
                description = 'BSC Screen (6912 + 4224 border)';
            } else if (len === 12288) {
                graphicsType = 'mlt';
                description = 'MLT 8×1 Multicolor (6144 + 6144 attributes)';
            } else if (len === 18432) {
                graphicsType = 'rgb3';
                description = 'RGB3 Tricolor (3 × 6144 bitmaps)';
            }

            if (graphicsType) {
                return {
                    type: 'graphics',
                    graphicsType: graphicsType,
                    description: description,
                    size: len,
                    data: data
                };
            }

            return { type: 'unknown', size: len };
        }

        // TAP file parser
        function explorerParseTAP(data) {
            const blocks = [];
            let offset = 0;

            while (offset < data.length - 1) {
                const blockLen = data[offset] | (data[offset + 1] << 8);
                if (blockLen === 0 || offset + 2 + blockLen > data.length) break;

                const blockData = data.slice(offset + 2, offset + 2 + blockLen);
                const flag = blockData[0];

                let blockInfo = {
                    offset: offset,
                    length: blockLen,
                    flag: flag,
                    data: blockData
                };

                if (flag === 0 && blockLen === 19) {
                    // Header block
                    const type = blockData[1];
                    const name = String.fromCharCode(...blockData.slice(2, 12)).trim();
                    const dataLen = blockData[12] | (blockData[13] << 8);
                    const param1 = blockData[14] | (blockData[15] << 8);
                    const param2 = blockData[16] | (blockData[17] << 8);

                    const typeNames = ['Program', 'Number array', 'Character array', 'Bytes'];
                    blockInfo.blockType = 'header';
                    blockInfo.headerType = type;
                    blockInfo.typeName = typeNames[type] || 'Unknown';
                    blockInfo.name = name;
                    blockInfo.dataLength = dataLen;
                    blockInfo.param1 = param1;
                    blockInfo.param2 = param2;

                    if (type === 0) {
                        // Program: param1 = autostart, param2 = vars offset
                        blockInfo.autostart = param1 < 32768 ? param1 : null;
                        blockInfo.varsOffset = param2;
                    } else if (type === 3) {
                        // Bytes: param1 = start address
                        blockInfo.startAddress = param1;
                    }
                } else {
                    // Data block
                    blockInfo.blockType = 'data';
                }

                blocks.push(blockInfo);
                offset += 2 + blockLen;
            }

            explorerBlocks = blocks;
            return { type: 'tap', blocks: blocks, size: data.length };
        }

        // TZX file parser
        function explorerParseTZX(data) {
            // Check TZX header: "ZXTape!" + 0x1A
            const header = String.fromCharCode(...data.slice(0, 7));
            if (header !== 'ZXTape!' || data[7] !== 0x1A) {
                return { type: 'unknown', size: data.length, error: 'Invalid TZX header' };
            }

            const versionMajor = data[8];
            const versionMinor = data[9];
            const blocks = [];
            let offset = 10;

            const blockNames = {
                0x10: 'Standard Speed Data',
                0x11: 'Turbo Speed Data',
                0x12: 'Pure Tone',
                0x13: 'Pulse Sequence',
                0x14: 'Pure Data',
                0x15: 'Direct Recording',
                0x18: 'CSW Recording',
                0x19: 'Generalized Data',
                0x20: 'Pause/Stop',
                0x21: 'Group Start',
                0x22: 'Group End',
                0x23: 'Jump to Block',
                0x24: 'Loop Start',
                0x25: 'Loop End',
                0x26: 'Call Sequence',
                0x27: 'Return from Sequence',
                0x28: 'Select Block',
                0x2A: 'Stop if 48K',
                0x2B: 'Set Signal Level',
                0x30: 'Text Description',
                0x31: 'Message',
                0x32: 'Archive Info',
                0x33: 'Hardware Type',
                0x35: 'Custom Info',
                0x5A: 'Glue Block'
            };

            while (offset < data.length) {
                const blockId = data[offset];
                const blockName = blockNames[blockId] || `Unknown (0x${blockId.toString(16).toUpperCase().padStart(2, '0')})`;
                let blockLen = 0;
                let blockInfo = {
                    offset: offset,
                    id: blockId,
                    name: blockName
                };

                offset++;

                switch (blockId) {
                    case 0x10: // Standard speed data block
                        {
                            const pause = data[offset] | (data[offset + 1] << 8);
                            const dataLen = data[offset + 2] | (data[offset + 3] << 8);
                            blockLen = 4 + dataLen;
                            blockInfo.pause = pause;
                            blockInfo.dataLength = dataLen;

                            // Parse header if it's a standard header block
                            const blockData = data.slice(offset + 4, offset + 4 + dataLen);
                            if (dataLen === 19 && blockData[0] === 0) {
                                const type = blockData[1];
                                const name = String.fromCharCode(...blockData.slice(2, 12)).replace(/\x00/g, ' ').trim();
                                const len = blockData[12] | (blockData[13] << 8);
                                const param1 = blockData[14] | (blockData[15] << 8);
                                const typeNames = ['Program', 'Number array', 'Character array', 'Bytes'];
                                blockInfo.headerType = typeNames[type] || 'Unknown';
                                blockInfo.fileName = name;
                                blockInfo.fileLength = len;
                                if (type === 0) blockInfo.autostart = param1 < 32768 ? param1 : null;
                                if (type === 3) blockInfo.startAddress = param1;
                            } else if (blockData[0] === 0xFF) {
                                blockInfo.dataBlock = true;
                            }
                        }
                        break;

                    case 0x11: // Turbo speed data block
                        {
                            blockLen = 18 + (data[offset + 15] | (data[offset + 16] << 8) | (data[offset + 17] << 16));
                            blockInfo.dataLength = blockLen - 18;
                        }
                        break;

                    case 0x12: // Pure tone
                        blockLen = 4;
                        blockInfo.pulseLength = data[offset] | (data[offset + 1] << 8);
                        blockInfo.pulseCount = data[offset + 2] | (data[offset + 3] << 8);
                        break;

                    case 0x13: // Pulse sequence
                        {
                            const pulseCount = data[offset];
                            blockLen = 1 + pulseCount * 2;
                        }
                        break;

                    case 0x14: // Pure data block
                        blockLen = 10 + (data[offset + 7] | (data[offset + 8] << 8) | (data[offset + 9] << 16));
                        blockInfo.dataLength = blockLen - 10;
                        break;

                    case 0x15: // Direct recording
                        blockLen = 8 + (data[offset + 5] | (data[offset + 6] << 8) | (data[offset + 7] << 16));
                        break;

                    case 0x18: // CSW recording
                        blockLen = 4 + (data[offset] | (data[offset + 1] << 8) | (data[offset + 2] << 16) | (data[offset + 3] << 24));
                        break;

                    case 0x19: // Generalized data block
                        blockLen = 4 + (data[offset] | (data[offset + 1] << 8) | (data[offset + 2] << 16) | (data[offset + 3] << 24));
                        break;

                    case 0x20: // Pause/stop
                        blockLen = 2;
                        blockInfo.pause = data[offset] | (data[offset + 1] << 8);
                        if (blockInfo.pause === 0) blockInfo.stopTape = true;
                        break;

                    case 0x21: // Group start
                        {
                            const nameLen = data[offset];
                            blockLen = 1 + nameLen;
                            blockInfo.groupName = String.fromCharCode(...data.slice(offset + 1, offset + 1 + nameLen));
                        }
                        break;

                    case 0x22: // Group end
                        blockLen = 0;
                        break;

                    case 0x23: // Jump to block
                        blockLen = 2;
                        blockInfo.jump = data[offset] | (data[offset + 1] << 8);
                        break;

                    case 0x24: // Loop start
                        blockLen = 2;
                        blockInfo.repetitions = data[offset] | (data[offset + 1] << 8);
                        break;

                    case 0x25: // Loop end
                        blockLen = 0;
                        break;

                    case 0x26: // Call sequence
                        {
                            const callCount = data[offset] | (data[offset + 1] << 8);
                            blockLen = 2 + callCount * 2;
                        }
                        break;

                    case 0x27: // Return from sequence
                        blockLen = 0;
                        break;

                    case 0x28: // Select block
                        blockLen = 2 + (data[offset] | (data[offset + 1] << 8));
                        break;

                    case 0x2A: // Stop tape if in 48K mode
                        blockLen = 4;
                        break;

                    case 0x2B: // Set signal level
                        blockLen = 5;
                        break;

                    case 0x30: // Text description
                        {
                            const textLen = data[offset];
                            blockLen = 1 + textLen;
                            blockInfo.text = String.fromCharCode(...data.slice(offset + 1, offset + 1 + textLen));
                        }
                        break;

                    case 0x31: // Message block
                        {
                            const msgLen = data[offset + 1];
                            blockLen = 2 + msgLen;
                            blockInfo.displayTime = data[offset];
                            blockInfo.message = String.fromCharCode(...data.slice(offset + 2, offset + 2 + msgLen));
                        }
                        break;

                    case 0x32: // Archive info
                        {
                            const archiveLen = data[offset] | (data[offset + 1] << 8);
                            blockLen = 2 + archiveLen;
                            // Parse archive info strings
                            const infoTypes = ['Title', 'Publisher', 'Author', 'Year', 'Language', 'Type', 'Price', 'Loader', 'Origin', 'Comment'];
                            const stringCount = data[offset + 2];
                            let infoOffset = offset + 3;
                            blockInfo.archiveInfo = [];
                            for (let i = 0; i < stringCount && infoOffset < offset + 2 + archiveLen; i++) {
                                const typeId = data[infoOffset];
                                const strLen = data[infoOffset + 1];
                                const str = String.fromCharCode(...data.slice(infoOffset + 2, infoOffset + 2 + strLen));
                                blockInfo.archiveInfo.push({
                                    type: infoTypes[typeId] || `Info ${typeId}`,
                                    value: str
                                });
                                infoOffset += 2 + strLen;
                            }
                        }
                        break;

                    case 0x33: // Hardware type
                        {
                            const hwCount = data[offset];
                            blockLen = 1 + hwCount * 3;
                        }
                        break;

                    case 0x35: // Custom info block
                        blockLen = 20 + (data[offset + 16] | (data[offset + 17] << 8) | (data[offset + 18] << 16) | (data[offset + 19] << 24));
                        blockInfo.customId = String.fromCharCode(...data.slice(offset, offset + 16)).replace(/\x00/g, '').trim();
                        break;

                    case 0x5A: // Glue block
                        blockLen = 9;
                        break;

                    default:
                        // Unknown block - try to skip based on common patterns
                        // Many unknown blocks have length at offset 0-3
                        if (offset + 4 <= data.length) {
                            blockLen = data[offset] | (data[offset + 1] << 8) | (data[offset + 2] << 16) | (data[offset + 3] << 24);
                            if (blockLen > data.length - offset) {
                                // Invalid length, stop parsing
                                blockInfo.error = 'Unknown block type, cannot determine length';
                                blocks.push(blockInfo);
                                offset = data.length;
                                continue;
                            }
                        } else {
                            offset = data.length;
                            continue;
                        }
                }

                blockInfo.length = blockLen;
                blocks.push(blockInfo);
                offset += blockLen;
            }

            explorerBlocks = blocks;
            return {
                type: 'tzx',
                version: `${versionMajor}.${versionMinor}`,
                blocks: blocks,
                size: data.length
            };
        }

        // SNA file parser
        function explorerParseSNA(data) {
            const is128 = data.length === 131103 || data.length === 147487;

            const regs = {
                I: data[0],
                HLa: data[1] | (data[2] << 8),
                DEa: data[3] | (data[4] << 8),
                BCa: data[5] | (data[6] << 8),
                AFa: data[7] | (data[8] << 8),
                HL: data[9] | (data[10] << 8),
                DE: data[11] | (data[12] << 8),
                BC: data[13] | (data[14] << 8),
                IY: data[15] | (data[16] << 8),
                IX: data[17] | (data[18] << 8),
                IFF2: (data[19] & 0x04) ? 1 : 0,
                R: data[20],
                AF: data[21] | (data[22] << 8),
                SP: data[23] | (data[24] << 8),
                IM: data[25],
                border: data[26]
            };

            // For 48K SNA, PC is on stack
            if (!is128) {
                const spOffset = regs.SP - 0x4000 + 27;
                if (spOffset >= 0 && spOffset < data.length - 1) {
                    regs.PC = data[spOffset] | (data[spOffset + 1] << 8);
                }
            } else {
                // 128K SNA has PC after memory
                regs.PC = data[49179] | (data[49180] << 8);
                regs.port7FFD = data[49181];
                regs.trdosROM = data[49182];
            }

            return {
                type: 'sna',
                is128: is128,
                registers: regs,
                memoryOffset: 27,
                size: data.length
            };
        }

        // Z80 file parser
        function explorerParseZ80(data) {
            const regs = {
                A: data[0],
                F: data[1],
                BC: data[2] | (data[3] << 8),
                HL: data[4] | (data[5] << 8),
                PC: data[6] | (data[7] << 8),
                SP: data[8] | (data[9] << 8),
                I: data[10],
                R: (data[11] & 0x7f) | ((data[12] & 0x01) << 7),
                border: (data[12] >> 1) & 0x07,
                DE: data[13] | (data[14] << 8),
                BCa: data[15] | (data[16] << 8),
                DEa: data[17] | (data[18] << 8),
                HLa: data[19] | (data[20] << 8),
                Aa: data[21],
                Fa: data[22],
                IY: data[23] | (data[24] << 8),
                IX: data[25] | (data[26] << 8),
                IFF1: data[27] ? 1 : 0,
                IFF2: data[28] ? 1 : 0,
                IM: data[29] & 0x03
            };

            let version = 1;
            let is128 = false;
            let compressed = (data[12] & 0x20) !== 0;
            let hwMode = 0;
            let port7FFD = 0;
            let pages = [];

            if (regs.PC === 0) {
                // V2 or V3
                const extLen = data[30] | (data[31] << 8);
                version = extLen === 23 ? 2 : 3;
                regs.PC = data[32] | (data[33] << 8);
                hwMode = data[34];
                port7FFD = data[35];

                if (version === 2) {
                    // V2: hwMode 3=128K, 4=128K+IF1, 9=Pentagon (non-standard but used by some savers)
                    is128 = hwMode === 3 || hwMode === 4 || hwMode === 9;
                } else {
                    // V3: 4-6=128K variants, 7=+3, 9=Pentagon, 12=+2, 13=+2A
                    is128 = hwMode >= 4 && hwMode <= 6 || hwMode === 7 || hwMode === 9 || hwMode === 12 || hwMode === 13;
                }

                // Parse pages
                const headerLen = 30 + 2 + extLen;
                let offset = headerLen;
                while (offset < data.length - 3) {
                    const compLen = data[offset] | (data[offset + 1] << 8);
                    const pageNum = data[offset + 2];
                    const isCompressed = compLen !== 0xffff;
                    const dataLen = isCompressed ? compLen : 16384;

                    // Determine page description
                    let pageDesc = '';
                    if (is128 || hwMode === 9) {
                        // 128K/Pentagon page mapping
                        if (pageNum === 0) pageDesc = 'ROM 48K (modified)';
                        else if (pageNum === 1) pageDesc = 'IF1 ROM';
                        else if (pageNum === 2) pageDesc = 'ROM 128K (modified)';
                        else if (pageNum >= 3 && pageNum <= 10) pageDesc = `RAM bank ${pageNum - 3}`;
                        else if (pageNum === 11) pageDesc = 'Multiface ROM';
                        else pageDesc = `Unknown`;
                    } else {
                        // 48K page mapping
                        if (pageNum === 4) pageDesc = '0x8000-0xBFFF';
                        else if (pageNum === 5) pageDesc = '0xC000-0xFFFF';
                        else if (pageNum === 8) pageDesc = '0x4000-0x7FFF';
                        else pageDesc = `Unknown`;
                    }

                    pages.push({
                        num: pageNum,
                        offset: offset,
                        compLen: isCompressed ? compLen : 16384,
                        compressed: isCompressed,
                        desc: pageDesc
                    });

                    offset += 3 + dataLen;
                }
            }

            regs.AF = (regs.A << 8) | regs.F;
            regs.AFa = (regs.Aa << 8) | regs.Fa;

            return {
                type: 'z80',
                version: version,
                is128: is128,
                hwMode: hwMode,
                port7FFD: port7FFD,
                compressed: compressed,
                registers: regs,
                pages: pages,
                size: data.length
            };
        }

        // SZX file parser
        function explorerParseSZX(data) {
            if (!SZXLoader.isSZX(data)) {
                return { type: 'szx', error: 'Invalid SZX file', size: data.length };
            }

            const info = SZXLoader.parse(data);
            const bytes = new Uint8Array(data);

            // Extract registers from Z80R chunk
            const regs = {};
            for (const chunk of info.chunks) {
                if (chunk.id === 'Z80R') {
                    const r = bytes.slice(chunk.offset, chunk.offset + chunk.size);
                    regs.F = r[0]; regs.A = r[1];
                    regs.C = r[2]; regs.B = r[3];
                    regs.E = r[4]; regs.D = r[5];
                    regs.L = r[6]; regs.H = r[7];
                    regs.Fa = r[8]; regs.Aa = r[9];
                    regs.Ca = r[10]; regs.Ba = r[11];
                    regs.Ea = r[12]; regs.Da = r[13];
                    regs.La = r[14]; regs.Ha = r[15];
                    regs.IXL = r[16]; regs.IXH = r[17];
                    regs.IYL = r[18]; regs.IYH = r[19];
                    regs.SP = r[20] | (r[21] << 8);
                    regs.PC = r[22] | (r[23] << 8);
                    regs.I = r[24];
                    regs.R = r[25];
                    regs.IFF1 = r[26] & 1;
                    regs.IFF2 = r[27] & 1;
                    regs.IM = r[28];
                    // Combine register pairs
                    regs.AF = (regs.A << 8) | regs.F;
                    regs.BC = (regs.B << 8) | regs.C;
                    regs.DE = (regs.D << 8) | regs.E;
                    regs.HL = (regs.H << 8) | regs.L;
                    regs.AFa = (regs.Aa << 8) | regs.Fa;
                    regs.BCa = (regs.Ba << 8) | regs.Ca;
                    regs.DEa = (regs.Da << 8) | regs.Ea;
                    regs.HLa = (regs.Ha << 8) | regs.La;
                    regs.IX = (regs.IXH << 8) | regs.IXL;
                    regs.IY = (regs.IYH << 8) | regs.IYL;
                    break;
                }
            }

            // Extract border from SPCR chunk
            let border = 0;
            let port7FFD = 0;
            for (const chunk of info.chunks) {
                if (chunk.id === 'SPCR') {
                    border = bytes[chunk.offset];
                    port7FFD = bytes[chunk.offset + 1];
                    break;
                }
            }
            regs.border = border;
            regs.port7FFD = port7FFD;

            return {
                type: 'szx',
                version: `${info.majorVersion}.${info.minorVersion}`,
                machineId: info.machineId,
                machineType: info.machineType,
                is128: info.is128,
                chunks: info.chunks,
                registers: regs,
                size: data.length
            };
        }

        // RZX file parser
        async function explorerParseRZX(data) {
            if (!RZXLoader.isRZX(data)) {
                return { type: 'rzx', error: 'Invalid RZX file', size: data.length };
            }

            const rzxLoader = new RZXLoader();
            try {
                await rzxLoader.parse(data.buffer || data);

                const result = {
                    type: 'rzx',
                    totalFrames: rzxLoader.getFrameCount(),
                    creatorInfo: rzxLoader.creatorInfo,
                    snapshotType: rzxLoader.getSnapshotType(),
                    snapshot: rzxLoader.getSnapshot(),
                    allSnapshots: rzxLoader.allSnapshots || [],
                    size: data.length,
                    stats: rzxLoader.getStats(),
                    frames: rzxLoader.getFrames()
                };

                // Parse embedded snapshot for registers
                if (result.snapshot && result.snapshotType) {
                    if (result.snapshotType === 'sna') {
                        result.embeddedParsed = explorerParseSNA(result.snapshot);
                    } else if (result.snapshotType === 'z80') {
                        result.embeddedParsed = explorerParseZ80(result.snapshot);
                    }
                }

                return result;
            } catch (e) {
                return { type: 'rzx', error: e.message, size: data.length };
            }
        }

        // TRD file parser
        function explorerParseTRD(data) {
            const files = [];

            // Read directory (first 8 sectors = 2048 bytes)
            for (let i = 0; i < 128; i++) {
                const entryOffset = i * 16;
                if (data[entryOffset] === 0) break;
                if (data[entryOffset] === 1) continue; // Deleted

                const name = String.fromCharCode(...data.slice(entryOffset, entryOffset + 8)).replace(/\s+$/, '');
                const ext = String.fromCharCode(data[entryOffset + 8]);
                const startAddr = data[entryOffset + 9] | (data[entryOffset + 10] << 8);
                const length = data[entryOffset + 11] | (data[entryOffset + 12] << 8);
                const sectors = data[entryOffset + 13];
                const startSector = data[entryOffset + 14];
                const startTrack = data[entryOffset + 15];

                files.push({
                    name: name,
                    ext: ext,
                    startAddress: startAddr,
                    length: length,
                    sectors: sectors,
                    startSector: startSector,
                    startTrack: startTrack,
                    offset: (startTrack * 16 + startSector) * 256
                });
            }

            // Read disk info from sector 8 (track 0, sector 8)
            const infoOffset = 8 * 256;
            const diskTitle = String.fromCharCode(...data.slice(infoOffset + 0xF5, infoOffset + 0xFD)).trim();
            const freeSpace = data[infoOffset + 0xE5];

            explorerBlocks = files;
            return {
                type: 'trd',
                files: files,
                diskTitle: diskTitle,
                freeSectors: freeSpace,
                size: data.length
            };
        }

        // SCL file parser
        function explorerParseSCL(data) {
            const files = [];

            // Check signature
            const sig = String.fromCharCode(...data.slice(0, 8));
            if (sig !== 'SINCLAIR') {
                return { type: 'scl', error: 'Invalid SCL signature', size: data.length };
            }

            const fileCount = data[8];
            let offset = 9;

            for (let i = 0; i < fileCount; i++) {
                const name = String.fromCharCode(...data.slice(offset, offset + 8)).replace(/\s+$/, '');
                const ext = String.fromCharCode(data[offset + 8]);
                const startAddr = data[offset + 9] | (data[offset + 10] << 8);
                const length = data[offset + 11] | (data[offset + 12] << 8);
                const sectors = data[offset + 13];

                files.push({
                    name: name,
                    ext: ext,
                    startAddress: startAddr,
                    length: length,
                    sectors: sectors
                });

                offset += 14;
            }

            // Calculate data offsets
            let dataOffset = 9 + fileCount * 14;
            for (const file of files) {
                file.offset = dataOffset;
                dataOffset += file.sectors * 256;
            }

            explorerBlocks = files;
            return {
                type: 'scl',
                files: files,
                size: data.length
            };
        }

        // DSK file parser
        function explorerParseDSK(data) {
            try {
                const dskImage = DSKLoader.parse(data);
                const diskSpec = DSKLoader.getDiskSpec(dskImage);
                let files = [];
                try {
                    files = DSKLoader.listFiles(dskImage);
                } catch (e) {
                    // Non-CP/M disk or corrupt directory — show geometry without files
                }

                // Store DSKImage for later file data extraction
                explorerBlocks = files;
                return {
                    type: 'dsk',
                    dskImage: dskImage,
                    diskSpec: diskSpec,
                    files: files,
                    isExtended: dskImage.isExtended,
                    numTracks: dskImage.numTracks,
                    numSides: dskImage.numSides,
                    size: data.length
                };
            } catch (err) {
                return { type: 'dsk', error: err.message, size: data.length };
            }
        }

        // ZIP file parser
        async function explorerParseZIP(data) {
            try {
                const files = await ZipLoader.extract(data.buffer);
                explorerZipFiles = files;

                // Auto-drill into ZIP if it contains exactly one supported file
                const supportedExts = ['tap', 'tzx', 'sna', 'z80', 'trd', 'scl', 'dsk'];
                const supportedFiles = files.filter(f => {
                    const ext = f.name.split('.').pop().toLowerCase();
                    return supportedExts.includes(ext);
                });

                if (supportedFiles.length === 1) {
                    // Auto-extract and parse the single file
                    const zipFile = supportedFiles[0];
                    const ext = zipFile.name.split('.').pop().toLowerCase();

                    explorerZipParentName = explorerFileName.textContent;
                    explorerData = new Uint8Array(zipFile.data);
                    explorerFileName.textContent = `${explorerZipParentName} > ${zipFile.name}`;
                    explorerFileSize.textContent = `(${explorerData.length.toLocaleString()} bytes)`;
                    explorerFileType = ext;

                    // Parse based on type
                    switch (ext) {
                        case 'tap':
                            return explorerParseTAP(explorerData);
                        case 'tzx':
                            return explorerParseTZX(explorerData);
                        case 'sna':
                            return explorerParseSNA(explorerData);
                        case 'z80':
                            return explorerParseZ80(explorerData);
                        case 'trd':
                            return explorerParseTRD(explorerData);
                        case 'scl':
                            return explorerParseSCL(explorerData);
                    }
                }

                return {
                    type: 'zip',
                    files: files.map(f => ({
                        name: f.name,
                        size: f.data.length
                    })),
                    size: data.length
                };
            } catch (err) {
                return { type: 'zip', error: err.message, size: data.length };
            }
        }

        // Helper to render register table
        function explorerRenderRegsTable(r) {
            return `<table class="explorer-info-table">
                <tr><th>PC</th><td>${hex16(r.PC)}</td><th>SP</th><td>${hex16(r.SP)}</td></tr>
                <tr><th>AF</th><td>${hex16(r.AF)}</td><th>AF'</th><td>${hex16(r.AFa)}</td></tr>
                <tr><th>BC</th><td>${hex16(r.BC)}</td><th>BC'</th><td>${hex16(r.BCa)}</td></tr>
                <tr><th>DE</th><td>${hex16(r.DE)}</td><th>DE'</th><td>${hex16(r.DEa)}</td></tr>
                <tr><th>HL</th><td>${hex16(r.HL)}</td><th>HL'</th><td>${hex16(r.HLa)}</td></tr>
                <tr><th>IX</th><td>${hex16(r.IX)}</td><th>IY</th><td>${hex16(r.IY)}</td></tr>
                <tr><th>I</th><td>${hex8(r.I)}</td><th>R</th><td>${hex8(r.R)}</td></tr>
                <tr><th>IM</th><td>${r.IM}</td><th>IFF2</th><td>${r.IFF2}</td></tr>
                <tr><th>Border</th><td>${r.border}</td><th></th><td></td></tr>
            </table>`;
        }

        // Render File Info
        function explorerRenderFileInfo() {
            if (!explorerParsed) {
                explorerInfoOutput.innerHTML = '<div class="explorer-empty">No file loaded</div>';
                return;
            }

            let html = '';

            switch (explorerParsed.type) {
                case 'tap':
                    html = explorerRenderTAPInfo();
                    break;
                case 'tzx':
                    html = explorerRenderTZXInfo();
                    break;
                case 'sna':
                    html = explorerRenderSNAInfo();
                    break;
                case 'z80':
                    html = explorerRenderZ80Info();
                    break;
                case 'szx':
                    html = explorerRenderSZXInfo();
                    break;
                case 'rzx':
                    html = explorerRenderRZXInfo();
                    break;
                case 'trd':
                    html = explorerRenderTRDInfo();
                    break;
                case 'scl':
                    html = explorerRenderSCLInfo();
                    break;
                case 'dsk':
                    html = explorerRenderDSKInfo();
                    break;
                case 'zip':
                    html = explorerRenderZIPInfo();
                    break;
                case 'graphics':
                    html = explorerRenderGraphicsInfo();
                    break;
                default:
                    html = `<div class="explorer-info-section"><div class="explorer-info-header">File Info</div><table class="explorer-info-table"><tr><th>Type</th><td>Unknown</td></tr><tr><th>Size</th><td>${explorerParsed.size.toLocaleString()} bytes</td></tr></table></div>`;
            }

            explorerInfoOutput.innerHTML = html;

            // Update source selectors
            explorerUpdateSourceSelectors();

            // Update preview - check for previewable content
            explorerUpdatePreviewForFile();
        }

        function explorerRenderGraphicsInfo() {
            const p = explorerParsed;
            return `<div class="explorer-info-section"><div class="explorer-info-header">${p.description}</div><table class="explorer-info-table"><tr><th>Type</th><td>${p.graphicsType.toUpperCase()}</td></tr><tr><th>Size</th><td>${p.size.toLocaleString()} bytes</td></tr></table></div>`;
        }

        function explorerUpdatePreviewForFile() {
            // For graphics files, preview directly
            if (explorerParsed && explorerParsed.type === 'graphics') {
                // For BSC, extract the SCR portion (first 6912 bytes)
                if (explorerParsed.graphicsType === 'bsc') {
                    explorerUpdatePreview(explorerData.slice(0, 6912));
                } else {
                    explorerUpdatePreview(explorerData);
                }
                return;
            }

            // For raw files loaded directly, check the file size
            if (explorerData && !explorerParsed) {
                explorerUpdatePreview(explorerData);
                return;
            }

            // For TAP files, check each data block for screen data
            if (explorerParsed && explorerParsed.type === 'tap') {
                for (const block of explorerBlocks) {
                    if (block.blockType === 'data') {
                        // Data block - check if it's a screen (minus flag and checksum bytes)
                        const contentLen = block.data.length - 2; // subtract flag byte and checksum
                        if (contentLen === 6912 || contentLen === 6144 || contentLen === 4096 ||
                            contentLen === 2048 || contentLen === 768) {
                            // Extract content (skip flag byte, exclude checksum)
                            const content = block.data.slice(1, block.data.length - 1);
                            explorerUpdatePreview(content);
                            return;
                        }
                    }
                }
            }

            // For TZX files, check data blocks for screen data
            if (explorerParsed && explorerParsed.type === 'tzx') {
                for (const block of explorerBlocks) {
                    // Check standard speed data blocks (0x10)
                    if (block.id === 0x10 && block.dataLength) {
                        // Data starts at offset + 1 (block ID) + 4 (pause + length)
                        const dataStart = block.offset + 1 + 4;
                        const blockData = explorerData.slice(dataStart, dataStart + block.dataLength);
                        // Check for data block with screen-sized content
                        if (blockData.length > 0 && blockData[0] === 0xFF) {
                            const contentLen = blockData.length - 2; // subtract flag and checksum
                            if (contentLen === 6912 || contentLen === 6144 || contentLen === 4096 ||
                                contentLen === 2048 || contentLen === 768) {
                                const content = blockData.slice(1, blockData.length - 1);
                                explorerUpdatePreview(content);
                                return;
                            }
                        }
                    }
                }
            }

            // For SNA, extract screen from memory
            if (explorerParsed && explorerParsed.type === 'sna') {
                // SNA memory layout: 27-byte header, then RAM starting at $4000
                // Bank 5 (screen at $4000) is always first 16KB after header
                const memOffset = 27;

                if (explorerParsed.is128) {
                    // 128K SNA: show both screens (bank 5 and bank 7)
                    const port7FFD = explorerParsed.registers.port7FFD || 0;
                    const activeScreen = (port7FFD & 0x08) ? 7 : 5;
                    const pagedBank = port7FFD & 0x07;

                    // Bank 5 is always at offset 27 (first 16KB after header)
                    const screen5 = explorerData.slice(memOffset, memOffset + 6912);

                    // Bank 7 location depends on which bank is paged at $C000
                    let screen7 = null;
                    if (pagedBank === 7) {
                        // Bank 7 is paged in at $C000, so it's in the first 48KB
                        // Offset: 27 (header) + 32768 ($C000 - $4000) = 32795
                        const bank7Offset = 27 + 32768;
                        screen7 = explorerData.slice(bank7Offset, bank7Offset + 6912);
                    } else {
                        // Bank 7 is in the remaining banks after offset 49183
                        // Remaining banks are stored in order, excluding banks 2, 5, and pagedBank
                        // Order: 0,1,3,4,6,7 minus pagedBank (if not 2,5,7)
                        const remainingBanks = [0, 1, 3, 4, 6, 7].filter(b => b !== pagedBank);
                        const bank7Index = remainingBanks.indexOf(7);
                        if (bank7Index >= 0) {
                            const bank7Offset = 49183 + bank7Index * 16384;
                            if (explorerData.length >= bank7Offset + 6912) {
                                screen7 = explorerData.slice(bank7Offset, bank7Offset + 6912);
                            }
                        }
                    }

                    // Render both screens side by side
                    explorerRenderDualScreen(screen5, screen7, activeScreen);
                    return;
                } else {
                    // 48K SNA: screen is at offset 27
                    if (explorerData.length >= memOffset + 6912) {
                        const screen = explorerData.slice(memOffset, memOffset + 6912);
                        // Show preview with custom label for SNA
                        explorerPreviewContainer.style.display = 'flex';
                        explorerPreviewLabel.textContent = '48K Screen';
                        explorerRenderSCR(screen);
                        return;
                    }
                }
            }

            // For Z80 files, extract and decompress screen
            if (explorerParsed && explorerParsed.type === 'z80') {
                const screen = explorerExtractZ80Screen(explorerData, explorerParsed);
                if (screen) {
                    explorerPreviewContainer.style.display = 'flex';
                    explorerPreviewLabel.textContent = `Z80 v${explorerParsed.version} Screen`;
                    explorerRenderSCR(screen);
                    return;
                }
            }

            // For SZX files, extract screen from RAMP chunk
            if (explorerParsed && explorerParsed.type === 'szx') {
                try {
                    const screen = SZXLoader.extractScreen(explorerData);
                    if (screen) {
                        explorerPreviewContainer.style.display = 'flex';
                        explorerPreviewLabel.textContent = `SZX v${explorerParsed.version} Screen`;
                        explorerRenderSCR(screen);
                        return;
                    }
                } catch (e) {
                    console.error('SZX screen extraction error:', e);
                }
            }

            // For RZX files, extract screen from embedded snapshot
            if (explorerParsed && explorerParsed.type === 'rzx' && explorerParsed.snapshot) {
                try {
                    let screen = null;
                    if (explorerParsed.snapshotType === 'sna') {
                        // SNA: screen is at offset 27
                        if (explorerParsed.snapshot.length >= 27 + 6912) {
                            screen = explorerParsed.snapshot.slice(27, 27 + 6912);
                        }
                    } else if (explorerParsed.snapshotType === 'z80' && explorerParsed.embeddedParsed) {
                        // Use Z80 extraction
                        screen = explorerExtractZ80Screen(explorerParsed.snapshot, explorerParsed.embeddedParsed);
                    }

                    if (screen) {
                        explorerPreviewContainer.style.display = 'flex';
                        explorerPreviewLabel.textContent = `RZX Embedded ${explorerParsed.snapshotType.toUpperCase()} Screen`;
                        explorerRenderSCR(screen);
                        return;
                    }
                } catch (e) {
                    console.error('RZX screen extraction error:', e);
                }
            }

            // For TRD/SCL, look for previewable files (screens, fonts)
            if (explorerParsed && (explorerParsed.type === 'trd' || explorerParsed.type === 'scl')) {
                const previewSizes = [6912, 6144, 4096, 2048, 768, 9216, 11136, 12288, 18432];
                for (const file of explorerParsed.files) {
                    if (previewSizes.includes(file.length)) {
                        const fileData = explorerData.slice(file.offset, file.offset + file.length);
                        explorerUpdatePreview(fileData);
                        return;
                    }
                }
            }

            // For DSK, look for previewable files (check data size after +3DOS header)
            if (explorerParsed && explorerParsed.type === 'dsk') {
                const previewSizes = [6912, 6144, 4096, 2048, 768, 9216, 11136, 12288, 18432];
                for (const file of explorerParsed.files) {
                    if (previewSizes.includes(file.size)) {
                        const fileData = DSKLoader.readFileData(
                            explorerParsed.dskImage, file.name, file.ext, file.user, file.rawSize || file.size
                        );
                        if (fileData) {
                            // Skip +3DOS header for preview
                            const content = file.hasPlus3Header ? fileData.slice(128) : fileData;
                            explorerUpdatePreview(content);
                            return;
                        }
                    }
                }
            }

            // No previewable content
            explorerUpdatePreview(null);
        }

        // Z80 decompression (RLE: ED ED count value -> repeat value count times)
        function explorerDecompressZ80(data, start, end) {
            const output = [];
            let i = start;

            while (i < end) {
                if (data[i] === 0xED && i + 1 < end && data[i + 1] === 0xED) {
                    // Compressed sequence: ED ED count value
                    if (i + 3 < end) {
                        const count = data[i + 2];
                        const value = data[i + 3];
                        for (let j = 0; j < count; j++) {
                            output.push(value);
                        }
                        i += 4;
                    } else {
                        break;
                    }
                } else {
                    output.push(data[i]);
                    i++;
                }
            }

            return new Uint8Array(output);
        }

        // Extract screen from Z80 file (supports v1, v2, v3, compressed and uncompressed)
        function explorerExtractZ80Screen(data, parsed) {
            try {
                if (parsed.version === 1) {
                    // V1: 30-byte header, then memory (possibly compressed)
                    if (parsed.compressed) {
                        // Find end marker (00 ED ED 00) and decompress
                        let endMarker = data.length;
                        for (let i = 30; i < data.length - 3; i++) {
                            if (data[i] === 0x00 && data[i + 1] === 0xED &&
                                data[i + 2] === 0xED && data[i + 3] === 0x00) {
                                endMarker = i;
                                break;
                            }
                        }
                        const memory = explorerDecompressZ80(data, 30, endMarker);
                        if (memory.length >= 6912) {
                            return memory.slice(0, 6912);
                        }
                    } else {
                        // Uncompressed v1
                        if (data.length >= 30 + 6912) {
                            return data.slice(30, 30 + 6912);
                        }
                    }
                } else {
                    // V2/V3: extended header + compressed pages
                    const extLen = data[30] | (data[31] << 8);
                    const headerEnd = 32 + extLen;
                    const hwMode = data[34];

                    // Determine which page contains the screen
                    // Page 8 always contains the screen ($4000-$7FFF)
                    // For 48K: page 8 = $4000-$7FFF
                    // For 128K: pages 3-10 = RAM banks 0-7, so page 8 = bank 5 (screen)
                    const screenPage = 8;

                    // Parse pages
                    let offset = headerEnd;
                    while (offset < data.length - 3) {
                        const pageLen = data[offset] | (data[offset + 1] << 8);
                        const pageNum = data[offset + 2];
                        offset += 3;

                        if (pageNum === screenPage) {
                            let pageData;
                            if (pageLen === 0xFFFF) {
                                // Uncompressed page
                                pageData = data.slice(offset, offset + 16384);
                            } else {
                                // Compressed page
                                pageData = explorerDecompressZ80(data, offset, offset + pageLen);
                            }

                            if (pageData.length >= 6912) {
                                return pageData.slice(0, 6912);
                            }
                        }

                        // Move to next page
                        if (pageLen === 0xFFFF) {
                            offset += 16384;
                        } else {
                            offset += pageLen;
                        }
                    }
                }
            } catch (e) {
                console.error('Z80 screen extraction error:', e);
            }
            return null;
        }

        function explorerRenderTAPInfo() {
            let html = `<div class="explorer-info-section"><div class="explorer-info-header">TAP File · ${explorerBlocks.length} blocks · ${explorerData.length.toLocaleString()} bytes</div><div class="explorer-block-list">`;

            for (let i = 0; i < explorerBlocks.length; i++) {
                const block = explorerBlocks[i];
                const data = block.data;

                // Calculate checksum (XOR of all bytes except the last one, which is the stored checksum)
                let calcChecksum = 0;
                for (let j = 0; j < data.length - 1; j++) {
                    calcChecksum ^= data[j];
                }
                const storedChecksum = data[data.length - 1];
                const checksumOk = calcChecksum === storedChecksum;
                const checksumClass = checksumOk ? 'checksum-ok' : 'checksum-bad';
                const checksumMark = checksumOk ? '✓' : '✗';

                if (block.blockType === 'header') {
                    // Header block - different colors for different types
                    let blockClass = 'explorer-block';
                    if (block.headerType === 0) blockClass += ' basic-block';
                    else if (block.headerType === 3) blockClass += ' code-block';
                    else if (block.headerType === 1 || block.headerType === 2) blockClass += ' array-block';

                    html += `<div class="${blockClass}" data-block-index="${i}">`;
                    html += `<div class="explorer-block-header">${i + 1}: ${block.typeName}</div>`;
                    html += `<div class="explorer-block-meta">Offset: ${block.offset} | Flag: ${block.flag} ($${hex8(block.flag)}) | Length: ${block.length} bytes | Checksum: ${hex8(storedChecksum)} <span class="${checksumClass}">${checksumMark}</span></div>`;
                    html += `<div class="explorer-block-details">`;
                    html += `<span class="label">Filename:</span> <span class="filename">"${block.name}"</span><br>`;
                    html += `<span class="label">Data length:</span> ${block.dataLength} bytes`;

                    if (block.headerType === 0) {
                        // Program
                        html += `<br><span class="label">Autostart:</span> ${block.autostart !== null ? block.autostart : 'None'}`;
                    } else if (block.headerType === 3) {
                        // Bytes/CODE
                        html += `<br><span class="label">Start address:</span> <span class="value">$${hex16(block.startAddress)}</span>`;
                    } else if (block.headerType === 1 || block.headerType === 2) {
                        // Number/Character array
                        html += `<br><span class="label">Variable name:</span> ${String.fromCharCode((block.param1 & 0x3F) + 0x40)}`;
                    }

                    html += `</div></div>`;
                } else {
                    // Data block
                    html += `<div class="explorer-block data-block" data-block-index="${i}">`;
                    html += `<div class="explorer-block-header">${i + 1}: Data</div>`;
                    html += `<div class="explorer-block-meta">Offset: ${block.offset} | Flag: ${block.flag} ($${hex8(block.flag)}) | Length: ${block.length} bytes | Checksum: ${hex8(storedChecksum)} <span class="${checksumClass}">${checksumMark}</span></div>`;
                    html += `</div>`;
                }
            }

            html += '</div></div>';
            return html;
        }

        function explorerRenderTZXInfo() {
            const p = explorerParsed;
            let html = `<div class="explorer-info-section"><div class="explorer-info-header">TZX File v${p.version} · ${explorerBlocks.length} blocks · ${explorerData.length.toLocaleString()} bytes</div><div class="explorer-block-list">`;

            for (let i = 0; i < explorerBlocks.length; i++) {
                const block = explorerBlocks[i];
                let blockClass = 'explorer-block';

                // Color code different block types
                if (block.id === 0x10 || block.id === 0x11 || block.id === 0x14) {
                    if (block.headerType) blockClass += ' code-block';
                    else if (block.dataBlock) blockClass += ' data-block';
                    else blockClass += ' data-block';
                } else if (block.id === 0x30 || block.id === 0x31 || block.id === 0x32) {
                    blockClass += ' basic-block'; // Text/info blocks
                } else if (block.id === 0x20 || block.id === 0x21 || block.id === 0x22 || block.id === 0x24 || block.id === 0x25) {
                    blockClass += ' array-block'; // Control blocks
                }

                html += `<div class="${blockClass}" data-block-index="${i}">`;
                html += `<div class="explorer-block-header">${i + 1}: ${block.name}</div>`;
                html += `<div class="explorer-block-meta">Offset: ${block.offset} | ID: $${hex8(block.id)} | Length: ${block.length} bytes</div>`;

                // Block-specific details
                let details = '';
                switch (block.id) {
                    case 0x10: // Standard speed data
                        if (block.headerType) {
                            details = `<span class="label">Type:</span> ${block.headerType}<br>`;
                            details += `<span class="label">Filename:</span> <span class="filename">"${block.fileName}"</span><br>`;
                            details += `<span class="label">Data length:</span> ${block.fileLength} bytes`;
                            if (block.autostart !== undefined && block.autostart !== null) {
                                details += `<br><span class="label">Autostart:</span> ${block.autostart}`;
                            }
                            if (block.startAddress !== undefined) {
                                details += `<br><span class="label">Start address:</span> <span class="value">$${hex16(block.startAddress)}</span>`;
                            }
                        } else if (block.dataBlock) {
                            details = `<span class="label">Data length:</span> ${block.dataLength} bytes`;
                        } else {
                            details = `<span class="label">Data length:</span> ${block.dataLength} bytes`;
                        }
                        if (block.pause) details += `<br><span class="label">Pause:</span> ${block.pause} ms`;
                        break;

                    case 0x11: // Turbo speed data
                        details = `<span class="label">Data length:</span> ${block.dataLength} bytes`;
                        break;

                    case 0x12: // Pure tone
                        details = `<span class="label">Pulse length:</span> ${block.pulseLength} T-states<br>`;
                        details += `<span class="label">Pulse count:</span> ${block.pulseCount}`;
                        break;

                    case 0x14: // Pure data
                        details = `<span class="label">Data length:</span> ${block.dataLength} bytes`;
                        break;

                    case 0x20: // Pause/stop
                        if (block.stopTape) {
                            details = `<span class="label">Action:</span> Stop the tape`;
                        } else {
                            details = `<span class="label">Pause:</span> ${block.pause} ms`;
                        }
                        break;

                    case 0x21: // Group start
                        details = `<span class="label">Group:</span> "${block.groupName}"`;
                        break;

                    case 0x23: // Jump
                        details = `<span class="label">Jump:</span> ${block.jump} blocks`;
                        break;

                    case 0x24: // Loop start
                        details = `<span class="label">Repetitions:</span> ${block.repetitions}`;
                        break;

                    case 0x30: // Text description
                        details = `<span class="label">Text:</span> "${block.text}"`;
                        break;

                    case 0x31: // Message
                        details = `<span class="label">Display time:</span> ${block.displayTime}s<br>`;
                        details += `<span class="label">Message:</span> "${block.message}"`;
                        break;

                    case 0x32: // Archive info
                        if (block.archiveInfo && block.archiveInfo.length > 0) {
                            for (const info of block.archiveInfo) {
                                details += `<span class="label">${info.type}:</span> "${info.value}"<br>`;
                            }
                            details = details.slice(0, -4); // Remove trailing <br>
                        }
                        break;

                    case 0x35: // Custom info
                        details = `<span class="label">Custom ID:</span> "${block.customId}"`;
                        break;
                }

                if (details) {
                    html += `<div class="explorer-block-details">${details}</div>`;
                }

                if (block.error) {
                    html += `<div class="explorer-block-details" style="color: var(--error);">${block.error}</div>`;
                }

                html += '</div>';
            }

            html += '</div></div>';
            return html;
        }

        function explorerRenderSNAInfo() {
            const r = explorerParsed.registers;
            let html = `<div class="explorer-info-section">
                <div class="explorer-info-header">SNA Snapshot (${explorerParsed.is128 ? '128K' : '48K'})</div>
                <table class="explorer-info-table">
                    <tr><th>Size</th><td>${explorerData.length.toLocaleString()} bytes</td></tr>
                    <tr><th>Machine</th><td>${explorerParsed.is128 ? 'ZX Spectrum 128K' : 'ZX Spectrum 48K'}</td></tr>
                </table>
            </div>`;

            html += `<div class="explorer-info-section">
                <div class="explorer-info-header">Registers</div>
                ${explorerRenderRegsTable(r)}
            </div>`;

            return html;
        }

        function explorerRenderZ80Info() {
            const r = explorerParsed.registers;

            // Determine machine type name from hwMode
            let machineType = explorerParsed.is128 ? 'ZX Spectrum 128K' : 'ZX Spectrum 48K';
            if (explorerParsed.version >= 2) {
                const hwMode = explorerParsed.hwMode;
                if (explorerParsed.version === 2) {
                    if (hwMode === 0) machineType = '48K';
                    else if (hwMode === 1) machineType = '48K + IF1';
                    else if (hwMode === 2) machineType = 'SamRam';
                    else if (hwMode === 3) machineType = '128K';
                    else if (hwMode === 4) machineType = '128K + IF1';
                } else {
                    if (hwMode === 0) machineType = '48K';
                    else if (hwMode === 1) machineType = '48K + IF1';
                    else if (hwMode === 2) machineType = 'SamRam';
                    else if (hwMode === 3) machineType = '48K + MGT';
                    else if (hwMode === 4) machineType = '128K';
                    else if (hwMode === 5) machineType = '128K + IF1';
                    else if (hwMode === 6) machineType = '128K + MGT';
                    else if (hwMode === 7) machineType = '+3';
                    else if (hwMode === 9) machineType = 'Pentagon';
                    else if (hwMode === 12) machineType = '+2';
                    else if (hwMode === 13) machineType = '+2A';
                }
            }

            let html = `<div class="explorer-info-section">
                <div class="explorer-info-header">Z80 Snapshot (v${explorerParsed.version})</div>
                <table class="explorer-info-table">
                    <tr><th>Size</th><td>${explorerData.length.toLocaleString()} bytes</td></tr>
                    <tr><th>Version</th><td>${explorerParsed.version}</td></tr>
                    <tr><th>Machine</th><td>${machineType} (hwMode=${explorerParsed.hwMode})</td></tr>
                    <tr><th>Compressed</th><td>${explorerParsed.compressed ? 'Yes' : 'No'}</td></tr>
                    ${explorerParsed.is128 ? `<tr><th>Port 7FFD</th><td>${hex8(explorerParsed.port7FFD)}</td></tr>` : ''}
                </table>
            </div>`;

            html += `<div class="explorer-info-section">
                <div class="explorer-info-header">Registers</div>
                <table class="explorer-info-table">
                    <tr><th>PC</th><td>${hex16(r.PC)}</td><th>SP</th><td>${hex16(r.SP)}</td></tr>
                    <tr><th>AF</th><td>${hex16(r.AF)}</td><th>AF'</th><td>${hex16(r.AFa)}</td></tr>
                    <tr><th>BC</th><td>${hex16(r.BC)}</td><th>BC'</th><td>${hex16(r.BCa)}</td></tr>
                    <tr><th>DE</th><td>${hex16(r.DE)}</td><th>DE'</th><td>${hex16(r.DEa)}</td></tr>
                    <tr><th>HL</th><td>${hex16(r.HL)}</td><th>HL'</th><td>${hex16(r.HLa)}</td></tr>
                    <tr><th>IX</th><td>${hex16(r.IX)}</td><th>IY</th><td>${hex16(r.IY)}</td></tr>
                    <tr><th>I</th><td>${hex8(r.I)}</td><th>R</th><td>${hex8(r.R)}</td></tr>
                    <tr><th>IM</th><td>${r.IM}</td><th>IFF1</th><td>${r.IFF1}</td></tr>
                    <tr><th>Border</th><td>${r.border}</td><th>IFF2</th><td>${r.IFF2}</td></tr>
                </table>
            </div>`;

            // Show pages
            if (explorerParsed.pages && explorerParsed.pages.length > 0) {
                html += `<div class="explorer-info-section">
                    <div class="explorer-info-header">Pages (${explorerParsed.pages.length})</div>
                    <div class="explorer-block-list">`;

                for (const page of explorerParsed.pages) {
                    const romClass = (page.num === 0 || page.num === 2) ? ' style="color: var(--cyan);"' : '';
                    html += `<div class="explorer-block"${romClass}>
                        <span class="explorer-block-type">Page ${page.num}</span>
                        <span class="explorer-block-size">${page.desc} (${page.compLen} bytes${page.compressed ? ', compressed' : ''})</span>
                    </div>`;
                }

                html += '</div></div>';
            }

            return html;
        }

        function explorerRenderSZXInfo() {
            if (explorerParsed.error) {
                return `<div class="explorer-info-section"><div class="explorer-info-header">SZX File</div><table class="explorer-info-table"><tr><th>Error</th><td>${explorerParsed.error}</td></tr></table></div>`;
            }

            const r = explorerParsed.registers;
            let html = `<div class="explorer-info-section">
                <div class="explorer-info-header">SZX Snapshot (v${explorerParsed.version}, ${explorerParsed.is128 ? '128K' : '48K'})</div>
                <table class="explorer-info-table">
                    <tr><th>Size</th><td>${explorerData.length.toLocaleString()} bytes</td></tr>
                    <tr><th>Version</th><td>${explorerParsed.version}</td></tr>
                    <tr><th>Machine</th><td>${explorerParsed.machineType} (ID: ${explorerParsed.machineId})</td></tr>
                    <tr><th>Chunks</th><td>${explorerParsed.chunks.length}</td></tr>
                </table>
            </div>`;

            if (r && r.PC !== undefined) {
                html += `<div class="explorer-info-section">
                    <div class="explorer-info-header">Registers</div>
                    <table class="explorer-info-table">
                        <tr><th>PC</th><td>${hex16(r.PC)}</td><th>SP</th><td>${hex16(r.SP)}</td></tr>
                        <tr><th>AF</th><td>${hex16(r.AF)}</td><th>AF'</th><td>${hex16(r.AFa)}</td></tr>
                        <tr><th>BC</th><td>${hex16(r.BC)}</td><th>BC'</th><td>${hex16(r.BCa)}</td></tr>
                        <tr><th>DE</th><td>${hex16(r.DE)}</td><th>DE'</th><td>${hex16(r.DEa)}</td></tr>
                        <tr><th>HL</th><td>${hex16(r.HL)}</td><th>HL'</th><td>${hex16(r.HLa)}</td></tr>
                        <tr><th>IX</th><td>${hex16(r.IX)}</td><th>IY</th><td>${hex16(r.IY)}</td></tr>
                        <tr><th>I</th><td>${hex8(r.I)}</td><th>R</th><td>${hex8(r.R)}</td></tr>
                        <tr><th>IM</th><td>${r.IM}</td><th>IFF1</th><td>${r.IFF1}</td></tr>
                        <tr><th>Border</th><td>${r.border}</td><th>IFF2</th><td>${r.IFF2}</td></tr>
                    </table>
                </div>`;
            }

            // Show chunk list
            html += `<div class="explorer-info-section">
                <div class="explorer-info-header">Chunks</div>
                <div class="explorer-block-list">`;

            for (const chunk of explorerParsed.chunks) {
                html += `<div class="explorer-block">
                    <span class="explorer-block-type">${chunk.id}</span>
                    <span class="explorer-block-size">${chunk.size} bytes @ ${hex16(chunk.offset)}</span>
                </div>`;
            }

            html += '</div></div>';
            return html;
        }

        function explorerRenderRZXInfo() {
            if (explorerParsed.error) {
                return `<div class="explorer-info-section"><div class="explorer-info-header">RZX File</div><table class="explorer-info-table"><tr><th>Error</th><td>${explorerParsed.error}</td></tr></table></div>`;
            }

            const stats = explorerParsed.stats;
            const creatorStr = explorerParsed.creatorInfo ?
                `${explorerParsed.creatorInfo.name} v${explorerParsed.creatorInfo.majorVersion}.${explorerParsed.creatorInfo.minorVersion}` :
                'Unknown';

            let html = `<div class="explorer-info-section">
                <div class="explorer-info-header">RZX Input Recording</div>
                <table class="explorer-info-table">
                    <tr><th>Size</th><td>${explorerData.length.toLocaleString()} bytes</td></tr>
                    <tr><th>Frames</th><td>${explorerParsed.totalFrames.toLocaleString()}</td></tr>
                    <tr><th>Duration</th><td>${stats ? stats.durationSeconds + 's' : '?'} (@ 50fps)</td></tr>
                    <tr><th>Snapshots</th><td>${explorerParsed.allSnapshots && explorerParsed.allSnapshots.length > 0
                        ? explorerParsed.allSnapshots.map((s, i) =>
                            `${s.ext.toUpperCase()}${i === 0 ? ' (start)' : i === explorerParsed.allSnapshots.length - 1 ? ' (end)' : ''} <button onclick="explorerExtractRZXSnapshot(${i})" class="small-btn">Extract</button>`
                          ).join('<br>')
                        : 'None'}</td></tr>
                    <tr><th>Creator</th><td>${creatorStr}</td></tr>
                </table>
            </div>`;

            // Show frame statistics
            if (stats) {
                html += `<div class="explorer-info-section">
                    <div class="explorer-info-header">Frame Statistics</div>
                    <table class="explorer-info-table">
                        <tr><th>Total Inputs</th><td>${stats.totalInputs.toLocaleString()}</td></tr>
                        <tr><th>Total M1 Cycles</th><td>${stats.totalFetchCount.toLocaleString()}</td></tr>
                        <tr><th>Avg M1/Frame</th><td>${stats.avgFetchCount.toLocaleString()}</td></tr>
                        <tr><th>Avg Inputs/Frame</th><td>${stats.avgInputsPerFrame}</td></tr>
                        <tr><th>M1 Range</th><td>${stats.fetchRange.min} - ${stats.fetchRange.max}</td></tr>
                        <tr><th>Inputs Range</th><td>${stats.inputsRange.min} - ${stats.inputsRange.max}</td></tr>
                    </table>
                </div>`;
            }

            // Show embedded snapshot registers if available
            if (explorerParsed.embeddedParsed && explorerParsed.embeddedParsed.registers) {
                const r = explorerParsed.embeddedParsed.registers;
                const snapType = explorerParsed.snapshotType.toUpperCase();
                const is128 = explorerParsed.embeddedParsed.is128;

                html += `<div class="explorer-info-section">
                    <div class="explorer-info-header">Embedded ${snapType} Snapshot (${is128 ? '128K' : '48K'})</div>
                    <table class="explorer-info-table">
                        <tr><th>PC</th><td>${hex16(r.PC)}</td><th>SP</th><td>${hex16(r.SP)}</td></tr>
                        <tr><th>AF</th><td>${hex16(r.AF)}</td><th>AF'</th><td>${hex16(r.AFa)}</td></tr>
                        <tr><th>BC</th><td>${hex16(r.BC)}</td><th>BC'</th><td>${hex16(r.BCa)}</td></tr>
                        <tr><th>DE</th><td>${hex16(r.DE)}</td><th>DE'</th><td>${hex16(r.DEa)}</td></tr>
                        <tr><th>HL</th><td>${hex16(r.HL)}</td><th>HL'</th><td>${hex16(r.HLa)}</td></tr>
                        <tr><th>IX</th><td>${hex16(r.IX)}</td><th>IY</th><td>${hex16(r.IY)}</td></tr>
                        <tr><th>I</th><td>${hex8(r.I)}</td><th>R</th><td>${hex8(r.R)}</td></tr>
                        <tr><th>IM</th><td>${r.IM}</td><th>Border</th><td>${r.border}</td></tr>
                    </table>
                </div>`;

                // Show embedded snapshot pages
                const embPages = explorerParsed.embeddedParsed.pages;
                if (embPages && embPages.length > 0) {
                    html += `<div class="explorer-info-section">
                        <div class="explorer-info-header">Snapshot Pages (${embPages.length})</div>
                        <div class="explorer-block-list">`;

                    for (const page of embPages) {
                        const romClass = (page.num === 0 || page.num === 2) ? ' style="color: var(--cyan);"' : '';
                        html += `<div class="explorer-block"${romClass}>
                            <span class="explorer-block-type">Page ${page.num}</span>
                            <span class="explorer-block-size">${page.desc} (${page.compLen} bytes${page.compressed ? ', compressed' : ''})</span>
                        </div>`;
                    }

                    html += '</div></div>';
                }
            }

            // Show keypress timeline (human-readable)
            if (explorerParsed.frames && explorerParsed.frames.length > 0) {
                html += explorerRenderRZXKeyTimeline();
            }

            return html;
        }

        // Extract embedded snapshot from RZX and download it
        // index: which snapshot to extract (0 = first/start, default; higher = later/end)
        function explorerExtractRZXSnapshot(index = 0) {
            if (!explorerParsed || explorerParsed.type !== 'rzx') {
                alert('No RZX file loaded');
                return;
            }

            const allSnapshots = explorerParsed.allSnapshots;
            if (!allSnapshots || allSnapshots.length === 0) {
                alert('No embedded snapshots to extract');
                return;
            }

            if (index < 0 || index >= allSnapshots.length) {
                alert(`Invalid snapshot index: ${index}`);
                return;
            }

            const snapInfo = allSnapshots[index];
            const snapshot = snapInfo.data;
            const ext = snapInfo.ext || 'bin';
            const baseName = (explorerFileName.textContent || 'rzx_snapshot').replace(/\.rzx$/i, '');
            const suffix = allSnapshots.length > 1 ? `_snap${index + 1}` : '_embedded';
            const filename = baseName + suffix + '.' + ext;

            // Create download blob
            const blob = new Blob([snapshot], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

        }

        // Decode RZX input value to human-readable format
        // NOTE: RZX only stores VALUES, not ports - so for keyboard we show all possible keys per bit
        function rzxDecodeInput(value) {
            // Kempston joystick: active HIGH, values 0x01-0x1F
            // Bits: 0=Right, 1=Left, 2=Down, 3=Up, 4=Fire
            if (value > 0 && value <= 0x1F) {
                const dirs = [];
                if (value & 0x01) dirs.push('Right');
                if (value & 0x02) dirs.push('Left');
                if (value & 0x04) dirs.push('Down');
                if (value & 0x08) dirs.push('Up');
                if (value & 0x10) dirs.push('Fire');
                return 'Kemp: ' + dirs.join('+');
            }

            // Keyboard: active LOW (0=pressed in bits 0-4)
            // All 8 possible keys for each bit (one per row):
            const keysPerBit = [
                'CS/A/Q/1/0/P/Ent/Spc',   // bit 0
                'Z/S/W/2/9/O/L/SS',        // bit 1
                'X/D/E/3/8/I/K/M',         // bit 2
                'C/F/R/4/7/U/J/N',         // bit 3
                'V/G/T/5/6/Y/H/B'          // bit 4
            ];

            const pressed = [];
            for (let bit = 0; bit < 5; bit++) {
                if ((value & (1 << bit)) === 0) {
                    pressed.push(keysPerBit[bit]);
                }
            }

            if (pressed.length === 0) return '(none)';
            return pressed.join(' + ');
        }

        // Current RZX decode mode (for explorer)
        let rzxDecodeMode = 'all';

        // Decode pressed bits (already normalized: 1=pressed) to key names
        function rzxDecodeBits(bits, originalValue, mode = null) {
            mode = mode || rzxDecodeMode;

            // Check if Kempston (original value was low with bits SET)
            if (originalValue > 0 && originalValue <= 0x1F) {
                const dirs = [];
                if (bits & 0x01) dirs.push('Right');
                if (bits & 0x02) dirs.push('Left');
                if (bits & 0x04) dirs.push('Down');
                if (bits & 0x08) dirs.push('Up');
                if (bits & 0x10) dirs.push('Fire');
                return dirs.length > 0 ? dirs.join('+') : '(none)';
            }

            // Keyboard decode based on mode
            // Interface I / IF2 Port 2: 6=Left, 7=Down, 8=Up, 9=Right, 0=Fire (row 0xEFFE: 0,9,8,7,6)
            // Interface II Port 1: 1=Left, 2=Right, 3=Down, 4=Up, 5=Fire (row 0xF7FE: 1,2,3,4,5)
            // Cursor keys: 5=Left, 6=Down, 7=Up, 8=Right, 0=Fire

            const decodeModes = {
                'all': [
                    'CS/A/Q/1/0/P/Ent/Spc',   // bit 0
                    'Z/S/W/2/9/O/L/SS',        // bit 1
                    'X/D/E/3/8/I/K/M',         // bit 2
                    'C/F/R/4/7/U/J/N',         // bit 3
                    'V/G/T/5/6/Y/H/B'          // bit 4
                ],
                'if2p1': [  // Interface II Port 1 (1-5): 1=Left, 2=Right, 3=Down, 4=Up, 5=Fire
                    'Left',   // bit 0 = 1
                    'Right',  // bit 1 = 2
                    'Down',   // bit 2 = 3
                    'Up',     // bit 3 = 4
                    'Fire'    // bit 4 = 5
                ],
                'if2p2': [  // Interface II Port 2 (6-0): 6=Left, 7=Right, 8=Down, 9=Up, 0=Fire
                    'Fire',   // bit 0 = 0
                    'Up',     // bit 1 = 9
                    'Down',   // bit 2 = 8
                    'Right',  // bit 3 = 7
                    'Left'    // bit 4 = 6
                ],
                'cursors': [  // Cursor keys: 5=Left, 6=Down, 7=Up, 8=Right, 0=Fire
                    'Fire',   // bit 0 = 0
                    '?',      // bit 1 = 9
                    'Right',  // bit 2 = 8
                    'Up',     // bit 3 = 7
                    'Left/Down' // bit 4 = 5 or 6
                ],
                'qaop': [  // QAOP + Space: Q=Up, A=Down, O=Left, P=Right, Space=Fire
                    'Up/Fire',   // bit 0 = Q or Space
                    'Down/Left', // bit 1 = A or O
                    '?',         // bit 2
                    '?',         // bit 3
                    'Right'      // bit 4 = P (row 0xDF)
                ],
                'kempston': [
                    'Right',  // bit 0
                    'Left',   // bit 1
                    'Down',   // bit 2
                    'Up',     // bit 3
                    'Fire'    // bit 4
                ]
            };

            const keysPerBit = decodeModes[mode] || decodeModes['all'];

            const pressed = [];
            for (let bit = 0; bit < 5; bit++) {
                if (bits & (1 << bit)) {
                    pressed.push(keysPerBit[bit]);
                }
            }

            return pressed.length > 0 ? pressed.join('+') : '(none)';
        }

        // Check if a value indicates "no input" (all key bits = 1)
        function rzxIsNoInput(value) {
            // Keyboard: bits 0-4 all set = no keys pressed
            // Also check for Kempston no-press (0x00)
            return (value & 0x1F) === 0x1F || value === 0;
        }

        // Extract pressed key bits (0-4) from a value, ignoring upper bits
        function rzxGetPressedBits(value) {
            // For Kempston (active high): bits that are 1
            if (value > 0 && value <= 0x1F) {
                return value & 0x1F;
            }
            // For keyboard (active low): invert so pressed = 1
            return (~value) & 0x1F;
        }

        function explorerRenderRZXKeyTimeline() {
            if (!explorerParsed.frames || explorerParsed.frames.length === 0) return '';

            // Analyze frames to find keypress events
            // Track by PRESSED BITS, not raw values (upper bits can vary)
            // Use gap tolerance: if same key reappears within GAP_TOLERANCE frames, treat as held
            const GAP_TOLERANCE = 5;  // frames

            const events = [];
            let currentBits = 0;  // 0 = no keys, otherwise bitmask of pressed keys
            let currentValue = 0xFF;
            let keyStartFrame = 0;
            let lastActiveFrame = 0;  // Last frame where key was detected

            for (let i = 0; i < explorerParsed.frames.length; i++) {
                const frame = explorerParsed.frames[i];

                // Find pressed bits across all inputs in this frame
                let frameBits = 0;
                let frameValue = 0xFF;

                for (const input of frame.inputs) {
                    if (!rzxIsNoInput(input)) {
                        const bits = rzxGetPressedBits(input);
                        frameBits |= bits;  // Combine all pressed bits
                        frameValue = input; // Keep last non-empty value for display
                    }
                }

                if (frameBits !== 0 && currentBits === 0) {
                    // Key press started
                    currentBits = frameBits;
                    currentValue = frameValue;
                    keyStartFrame = i;
                    lastActiveFrame = i;
                } else if (frameBits === 0 && currentBits !== 0) {
                    // No keys in this frame - but check gap tolerance before ending
                    if (i - lastActiveFrame > GAP_TOLERANCE) {
                        // Gap too large, key was released
                        events.push({
                            type: 'press',
                            startFrame: keyStartFrame,
                            endFrame: lastActiveFrame,
                            duration: lastActiveFrame - keyStartFrame + 1,
                            value: currentValue,
                            bits: currentBits
                        });
                        currentBits = 0;
                    }
                    // else: within tolerance, keep waiting
                } else if (frameBits !== 0 && currentBits !== 0) {
                    if (frameBits === currentBits) {
                        // Same key still held
                        lastActiveFrame = i;
                    } else {
                        // Key combination changed
                        events.push({
                            type: 'press',
                            startFrame: keyStartFrame,
                            endFrame: lastActiveFrame,
                            duration: lastActiveFrame - keyStartFrame + 1,
                            value: currentValue,
                            bits: currentBits
                        });
                        currentBits = frameBits;
                        currentValue = frameValue;
                        keyStartFrame = i;
                        lastActiveFrame = i;
                    }
                }
            }

            // Close any remaining keypress
            if (currentBits !== 0) {
                events.push({
                    type: 'press',
                    startFrame: keyStartFrame,
                    endFrame: explorerParsed.frames.length - 1,
                    duration: explorerParsed.frames.length - keyStartFrame,
                    value: currentValue,
                    bits: currentBits
                });
            }

            let html = `<div class="explorer-info-section">
                <div class="explorer-info-header">Keypress Timeline (${events.length} keypresses)
                    <select id="rzxDecodeMode" style="margin-left: 10px; font-size: 11px;">
                        <option value="all">All keys</option>
                        <option value="if2p1">Interface II Port 1 (1-5)</option>
                        <option value="if2p2">Interface II Port 2 (6-0)</option>
                        <option value="cursors">Cursor keys (5-8)</option>
                        <option value="qaop">QAOP + Space</option>
                        <option value="kempston">Kempston</option>
                    </select>
                </div>
                <div class="explorer-file-list" style="max-height: 350px; font-size: 11px;">`;

            if (events.length === 0) {
                html += '<div style="color: var(--text-secondary); padding: 8px;">No keypresses detected</div>';
            } else {
                // Show header
                html += `<div class="explorer-file-entry" style="padding: 2px 4px; color: var(--text-secondary); border-bottom: 1px solid var(--border-color);">
                    <span style="width: 55px; display: inline-block;">Start</span>
                    <span style="width: 70px; display: inline-block;">Duration</span>
                    <span>Keys (possible)</span>
                </div>`;

                const maxToShow = 200;
                for (let i = 0; i < Math.min(maxToShow, events.length); i++) {
                    const e = events[i];
                    const startMs = Math.round(e.startFrame * 20);
                    const durMs = Math.round(e.duration * 20);
                    const durStr = durMs >= 1000 ? `${(durMs/1000).toFixed(1)}s` : `${durMs}ms`;

                    // Decode pressed bits to human-readable keys
                    const keysStr = rzxDecodeBits(e.bits, e.value);

                    // Show bit numbers for debugging
                    const bitNums = [];
                    for (let b = 0; b < 5; b++) {
                        if (e.bits & (1 << b)) bitNums.push(b);
                    }
                    const bitStr = bitNums.length > 0 ? `[b${bitNums.join(',')}]` : '';

                    html += `<div class="explorer-file-entry" style="padding: 2px 4px;">
                        <span style="color: var(--cyan); width: 55px; display: inline-block;">F${e.startFrame}</span>
                        <span style="color: var(--text-secondary); width: 70px; display: inline-block;">${durStr}</span>
                        <span style="color: var(--text-primary);">${keysStr}</span>
                        <span style="color: var(--text-secondary); margin-left: 8px;">${bitStr}</span>
                    </div>`;
                }

                if (events.length > maxToShow) {
                    html += `<div style="color: var(--text-secondary); padding: 4px;">... and ${events.length - maxToShow} more keypresses</div>`;
                }
            }

            html += '</div></div>';

            // Also show frame-by-frame view for first N frames with input
            html += explorerRenderRZXFrameDetails();

            return html;
        }

        function explorerRenderRZXFrameDetails() {
            // Show first 30 frames that have actual input
            const framesWithInput = [];
            for (let i = 0; i < explorerParsed.frames.length && framesWithInput.length < 30; i++) {
                const frame = explorerParsed.frames[i];
                const hasInput = frame.inputs.some(v => !rzxIsNoInput(v));
                if (hasInput) {
                    framesWithInput.push({ index: i, frame });
                }
            }

            if (framesWithInput.length === 0) return '';

            let html = `<div class="explorer-info-section">
                <div class="explorer-info-header">Frames with Input (first ${framesWithInput.length})</div>
                <div class="explorer-file-list" style="max-height: 250px; font-size: 11px;">`;

            for (const { index, frame } of framesWithInput) {
                const timeMs = Math.round(index * 20);

                // Get unique non-empty inputs and decode them
                const activeInputs = [...new Set(frame.inputs.filter(v => !rzxIsNoInput(v)))];
                const inputStr = activeInputs.map(v => rzxDecodeInput(v)).join('; ');

                html += `<div class="explorer-file-entry" style="padding: 2px 4px;">
                    <span style="color: var(--cyan); width: 50px; display: inline-block;">F${index}</span>
                    <span style="color: var(--text-secondary); width: 60px; display: inline-block;">${timeMs}ms</span>
                    <span style="color: var(--text-secondary); width: 70px; display: inline-block;">M1:${frame.fetchCount}</span>
                    <span style="color: #f80;">${inputStr}</span>
                </div>`;
            }

            html += '</div></div>';
            return html;
        }

        function explorerRenderTRDInfo() {
            let html = `<div class="explorer-info-section">
                <div class="explorer-info-header">TRD Disk Image</div>
                <table class="explorer-info-table">
                    <tr><th>Size</th><td>${explorerData.length.toLocaleString()} bytes</td></tr>
                    <tr><th>Label</th><td>${explorerParsed.diskTitle || '(none)'}</td></tr>
                    <tr><th>Files</th><td>${explorerParsed.files.length}</td></tr>
                    <tr><th>Free</th><td>${explorerParsed.freeSectors} sectors</td></tr>
                </table>
            </div>`;

            html += `<div class="explorer-info-section">
                <div class="explorer-info-header">File List</div>
                <div class="explorer-file-list">`;

            for (let i = 0; i < explorerParsed.files.length; i++) {
                const file = explorerParsed.files[i];
                const len = file.length;
                // Check if previewable (screen or font sizes)
                const previewable = len === 6912 || len === 6144 || len === 4096 ||
                    len === 2048 || len === 768 || len === 9216 ||
                    len === 11136 || len === 12288 || len === 18432;
                const previewIcon = previewable ? '⬚' : '';
                html += `<div class="explorer-file-entry" data-index="${i}">
                    <span class="explorer-file-num">${i + 1}</span>
                    <span class="explorer-file-type">${file.ext}</span>
                    <span class="explorer-file-name">${file.name}</span>
                    <span class="explorer-file-size">${file.length}</span>
                    <span class="explorer-file-addr">$${hex16(file.startAddress)}</span>
                    <span class="explorer-file-preview">${previewIcon}</span>
                </div>`;
            }

            html += '</div></div>';
            return html;
        }

        function explorerRenderSCLInfo() {
            if (explorerParsed.error) {
                return `<div class="explorer-info-section">
                    <div class="explorer-info-header">SCL File</div>
                    <div style="color:#e74c3c">Error: ${explorerParsed.error}</div>
                </div>`;
            }

            let html = `<div class="explorer-info-section">
                <div class="explorer-info-header">SCL Archive</div>
                <table class="explorer-info-table">
                    <tr><th>Size</th><td>${explorerData.length.toLocaleString()} bytes</td></tr>
                    <tr><th>Files</th><td>${explorerParsed.files.length}</td></tr>
                </table>
            </div>`;

            html += `<div class="explorer-info-section">
                <div class="explorer-info-header">File List</div>
                <div class="explorer-file-list">`;

            for (let i = 0; i < explorerParsed.files.length; i++) {
                const file = explorerParsed.files[i];
                const len = file.length;
                // Check if previewable (screen or font sizes)
                const previewable = len === 6912 || len === 6144 || len === 4096 ||
                    len === 2048 || len === 768 || len === 9216 ||
                    len === 11136 || len === 12288 || len === 18432;
                const previewIcon = previewable ? '⬚' : '';
                html += `<div class="explorer-file-entry" data-index="${i}">
                    <span class="explorer-file-num">${i + 1}</span>
                    <span class="explorer-file-type">${file.ext}</span>
                    <span class="explorer-file-name">${file.name}</span>
                    <span class="explorer-file-size">${file.length}</span>
                    <span class="explorer-file-addr">$${hex16(file.startAddress)}</span>
                    <span class="explorer-file-preview">${previewIcon}</span>
                </div>`;
            }

            html += '</div></div>';
            return html;
        }

        function explorerRenderDSKInfo() {
            if (explorerParsed.error) {
                return `<div class="explorer-info-section">
                    <div class="explorer-info-header">DSK Disk Image</div>
                    <div style="color:#e74c3c">Error: ${explorerParsed.error}</div>
                </div>`;
            }

            const formatType = explorerParsed.isExtended ? 'Extended CPC DSK' : 'Standard CPC DSK';
            const geometry = `${explorerParsed.numTracks} tracks, ${explorerParsed.numSides} side${explorerParsed.numSides > 1 ? 's' : ''}`;
            const spec = explorerParsed.diskSpec;

            // Get sector info from first track
            let sectorInfo = '';
            if (explorerParsed.dskImage) {
                const t0 = explorerParsed.dskImage.getTrack(0, 0);
                if (t0 && t0.sectors.length > 0) {
                    const sectorSize = t0.sectors[0].data.length;
                    sectorInfo = `${t0.sectors.length} sectors/track, ${sectorSize} bytes/sector`;
                }
            }

            let specRows = '';
            if (spec) {
                specRows += `<tr><th>Block size</th><td>${spec.blockSize} bytes</td></tr>`;
                specRows += `<tr><th>Reserved</th><td>${spec.reservedTracks} track${spec.reservedTracks !== 1 ? 's' : ''}</td></tr>`;
            }

            let html = `<div class="explorer-info-section">
                <div class="explorer-info-header">DSK Disk Image</div>
                <table class="explorer-info-table">
                    <tr><th>Size</th><td>${explorerData.length.toLocaleString()} bytes</td></tr>
                    <tr><th>Format</th><td>${formatType}</td></tr>
                    <tr><th>Geometry</th><td>${geometry}</td></tr>
                    ${sectorInfo ? `<tr><th>Sectors</th><td>${sectorInfo}</td></tr>` : ''}
                    ${specRows}
                    <tr><th>Files</th><td>${explorerParsed.files.length}</td></tr>
                </table>
            </div>`;

            if (explorerParsed.files.length > 0) {
                html += `<div class="explorer-info-section">
                    <div class="explorer-info-header">File List (+3DOS / CP/M)</div>
                    <div class="explorer-file-list">`;

                for (let i = 0; i < explorerParsed.files.length; i++) {
                    const file = explorerParsed.files[i];
                    const sizeStr = file.size.toLocaleString();

                    // Full filename with CP/M extension
                    const fullName = file.name + (file.ext ? '.' + file.ext : '');

                    // +3DOS file type label
                    let typeStr = '-';
                    if (file.hasPlus3Header) {
                        const typeNames = { 0: 'BASIC', 1: 'NUM', 2: 'CHR', 3: 'CODE' };
                        typeStr = typeNames[file.plus3Type] || '-';
                    }

                    // Address info: load address for CODE, autostart for BASIC
                    let addrStr = '';
                    if (file.plus3Type === 3 && file.loadAddress !== undefined) {
                        addrStr = '$' + file.loadAddress.toString(16).toUpperCase().padStart(4, '0');
                    } else if (file.plus3Type === 0 && file.autostart !== undefined && file.autostart < 32768) {
                        addrStr = 'LINE ' + file.autostart;
                    }

                    // Previewable check
                    const len = file.size;
                    const previewable = len === 6912 || len === 6144 || len === 4096 ||
                        len === 2048 || len === 768 || len === 9216 ||
                        len === 11136 || len === 12288 || len === 18432;
                    const previewIcon = previewable ? '\u2B1A' : '';

                    html += `<div class="explorer-file-entry" data-index="${i}">
                        <span class="explorer-file-num">${i + 1}</span>
                        <span class="explorer-file-type">${typeStr}</span>
                        <span class="explorer-file-name">${fullName}</span>
                        <span class="explorer-file-size">${sizeStr}</span>
                        <span class="explorer-file-addr">${addrStr}</span>
                        <span class="explorer-file-preview">${previewIcon}</span>
                    </div>`;
                }

                html += '</div></div>';
            }

            return html;
        }

        function explorerRenderZIPInfo() {
            if (explorerParsed.error) {
                return `<div class="explorer-info-section">
                    <div class="explorer-info-header">ZIP Archive</div>
                    <div style="color:#e74c3c">Error: ${explorerParsed.error}</div>
                </div>`;
            }

            let html = `<div class="explorer-info-section">
                <div class="explorer-info-header">ZIP Archive</div>
                <table class="explorer-info-table">
                    <tr><th>Size</th><td>${explorerData.length.toLocaleString()} bytes</td></tr>
                    <tr><th>Files</th><td>${explorerParsed.files.length}</td></tr>
                </table>
            </div>`;

            html += `<div class="explorer-info-section">
                <div class="explorer-info-header">File List <span style="font-size:10px;color:var(--text-secondary)">(click to open)</span></div>
                <div class="explorer-block-list">`;

            for (let i = 0; i < explorerParsed.files.length; i++) {
                const file = explorerParsed.files[i];
                const ext = file.name.split('.').pop().toLowerCase();
                const supported = ['tap', 'tzx', 'sna', 'z80', 'trd', 'scl', 'dsk', 'rzx'].includes(ext);

                // For RZX files, try to get quick info
                let extraInfo = '';
                if (ext === 'rzx' && file.data && file.data.length > 10) {
                    extraInfo = ' <span style="color:var(--cyan)">[RZX]</span>';
                }

                html += `<div class="explorer-block${supported ? ' explorer-zip-file' : ''}" data-zip-index="${i}" style="${supported ? 'cursor:pointer' : 'opacity:0.5'}">
                    <span class="explorer-block-num">${i + 1}</span>
                    <span class="explorer-block-type">${ext.toUpperCase()}</span>
                    <span class="explorer-block-name">${file.name}${extraInfo}</span>
                    <span class="explorer-block-size">${file.size.toLocaleString()} bytes</span>
                </div>`;
            }

            html += '</div></div>';
            return html;
        }

        // Handle RZX decode mode change
        explorerInfoOutput.addEventListener('change', (e) => {
            if (e.target.id === 'rzxDecodeMode') {
                rzxDecodeMode = e.target.value;
                // Re-render RZX info with new decode mode
                if (explorerParsed && explorerParsed.type === 'rzx') {
                    explorerInfoOutput.innerHTML = explorerRenderRZXInfo();
                    // Restore dropdown selection after re-render
                    const dropdown = document.getElementById('rzxDecodeMode');
                    if (dropdown) dropdown.value = rzxDecodeMode;
                }
            }
        });

        // Handle clicking on ZIP file entries and TAP blocks
        explorerInfoOutput.addEventListener('click', async (e) => {
            // Check for ZIP file entry click
            const zipEntry = e.target.closest('.explorer-zip-file');
            if (zipEntry) {
                const idx = parseInt(zipEntry.dataset.zipIndex);
                if (isNaN(idx) || !explorerZipFiles[idx]) return;

                const zipFile = explorerZipFiles[idx];
                const ext = zipFile.name.split('.').pop().toLowerCase();

                if (!['tap', 'tzx', 'sna', 'z80', 'trd', 'scl', 'dsk', 'rzx'].includes(ext)) return;

                // Store parent ZIP name and load inner file
                explorerZipParentName = explorerFileName.textContent;
                explorerData = new Uint8Array(zipFile.data);
                explorerFileName.textContent = `${explorerZipParentName} > ${zipFile.name}`;
                explorerFileSize.textContent = `(${explorerData.length.toLocaleString()} bytes)`;
                explorerFileType = ext;

                // Parse the extracted file
                await explorerParseFile(zipFile.name, ext);

                // Clear all sub-tab outputs (prevent stale content from previous file)
                explorerBasicOutput.innerHTML = '<div class="explorer-empty">Select a BASIC program source</div>';
                explorerDisasmOutput.innerHTML = '<div class="explorer-empty">Select a source to disassemble</div>';
                explorerHexOutput.innerHTML = '';

                // Render File Info
                explorerRenderFileInfo();
                return;
            }

            // Check for TAP block click - update preview or open in hex dump
            const blockEntry = e.target.closest('.explorer-block[data-block-index]');
            if (blockEntry && explorerParsed && explorerParsed.type === 'tap') {
                const idx = parseInt(blockEntry.dataset.blockIndex);
                if (isNaN(idx) || !explorerBlocks[idx]) return;

                const block = explorerBlocks[idx];

                // Check if this block is previewable (screen or font)
                if (block.blockType === 'data' && block.data.length > 2) {
                    const content = block.data.slice(1, block.data.length - 1);
                    const contentLen = content.length;

                    // If size matches screen or font, just update preview (don't switch to hex)
                    if (contentLen === 6912 || contentLen === 6144 || contentLen === 4096 ||
                        contentLen === 2048 || contentLen === 768 || contentLen === 9216 ||
                        contentLen === 11136 || contentLen === 12288 || contentLen === 18432) {
                        explorerUpdatePreview(content);
                        return;
                    }
                }

                // Not previewable - switch to Hex Dump tab
                document.querySelector('.explorer-subtab[data-subtab="hexdump"]').click();

                // Select the block in hex source (data blocks use data:N format)
                if (block.blockType === 'data') {
                    explorerHexSource.value = idx.toString();
                } else {
                    // For header blocks, show the next data block if it exists
                    if (idx + 1 < explorerBlocks.length && explorerBlocks[idx + 1].blockType === 'data') {
                        explorerHexSource.value = (idx + 1).toString();
                    }
                }

                // Set length to block length (capped at 65536)
                const dataLen = block.length;
                explorerHexLen.value = Math.min(dataLen, 65536);
                explorerHexAddr.value = '0000';

                // Render hex dump
                explorerRenderHexDump();
            }

            // Check for TRD/SCL file entry click
            const trdEntry = e.target.closest('.explorer-file-entry[data-index]');
            if (trdEntry && explorerParsed && (explorerParsed.type === 'trd' || explorerParsed.type === 'scl')) {
                const idx = parseInt(trdEntry.dataset.index);
                if (isNaN(idx) || !explorerParsed.files[idx]) return;

                const file = explorerParsed.files[idx];

                // Get file data from explorerData using offset
                const fileData = explorerData.slice(file.offset, file.offset + file.length);

                // Check if this file is previewable (screen or font by size)
                const contentLen = fileData.length;
                if (contentLen === 6912 || contentLen === 6144 || contentLen === 4096 ||
                    contentLen === 2048 || contentLen === 768 || contentLen === 9216 ||
                    contentLen === 11136 || contentLen === 12288 || contentLen === 18432) {
                    explorerUpdatePreview(fileData);
                    return;
                }

                // BASIC files - switch to BASIC tab
                if (file.ext === 'B') {
                    document.querySelector('.explorer-subtab[data-subtab="basic"]').click();
                    explorerBasicSource.value = idx.toString();
                    explorerDecodeBASIC();
                    return;
                }

                // CODE files - switch to Disasm tab
                if (file.ext === 'C') {
                    document.querySelector('.explorer-subtab[data-subtab="disasm"]').click();
                    explorerDisasmSource.value = idx.toString();
                    explorerDisasmAddr.value = hex16(file.startAddress);
                    explorerDisasmLen.value = Math.min(file.length, 4096);
                    explorerRenderDisasm();
                    return;
                }

                // Not previewable - switch to Hex Dump tab
                document.querySelector('.explorer-subtab[data-subtab="hexdump"]').click();

                // Select the file in hex source (use plain index, like TAP blocks)
                explorerHexSource.value = idx.toString();

                // Set length to file length (capped at 65536)
                explorerHexLen.value = Math.min(file.length, 65536);
                explorerHexAddr.value = '0000';

                // Render hex dump
                explorerRenderHexDump();
            }

            // Check for DSK file entry click
            const dskEntry = e.target.closest('.explorer-file-entry[data-index]');
            if (dskEntry && explorerParsed && explorerParsed.type === 'dsk') {
                const idx = parseInt(dskEntry.dataset.index);
                if (isNaN(idx) || !explorerParsed.files[idx]) return;

                const file = explorerParsed.files[idx];

                // Extract file data from DSK image (use rawSize for full CP/M data incl. header)
                const fileData = DSKLoader.readFileData(
                    explorerParsed.dskImage, file.name, file.ext, file.user, file.rawSize || file.size
                );
                if (!fileData || fileData.length === 0) return;

                // Skip +3DOS header (128 bytes) for content checks
                const hasHeader = file.hasPlus3Header;
                const contentData = hasHeader ? fileData.slice(128) : fileData;
                const contentLen = contentData.length;

                // Check if previewable (screen or font by size)
                if (contentLen === 6912 || contentLen === 6144 || contentLen === 4096 ||
                    contentLen === 2048 || contentLen === 768 || contentLen === 9216 ||
                    contentLen === 11136 || contentLen === 12288 || contentLen === 18432) {
                    explorerUpdatePreview(contentData);
                    return;
                }

                // BASIC files - switch to BASIC tab
                if (file.plus3Type === 0) {
                    document.querySelector('.explorer-subtab[data-subtab="basic"]').click();
                    explorerBasicSource.value = idx.toString();
                    explorerRenderBASIC();
                    return;
                }

                // CODE files - switch to Disasm tab
                if (file.plus3Type === 3 && file.loadAddress !== undefined) {
                    document.querySelector('.explorer-subtab[data-subtab="disasm"]').click();
                    explorerDisasmSource.value = idx.toString();
                    explorerDisasmAddr.value = file.loadAddress.toString(16).toUpperCase().padStart(4, '0');
                    explorerDisasmLen.value = Math.min(file.size, 4096);
                    explorerRenderDisasm();
                    return;
                }

                // Switch to Hex Dump tab
                document.querySelector('.explorer-subtab[data-subtab="hexdump"]').click();
                explorerHexSource.value = idx.toString();
                explorerHexLen.value = Math.min(file.rawSize || file.size, 65536);
                explorerHexAddr.value = '0000';
                explorerRenderHexDump();
            }
        });

        // Update source selectors based on file type
        function explorerUpdateSourceSelectors() {
            // Update BASIC source selector
            explorerBasicSource.innerHTML = '<option value="">Select source...</option>';

            // Update Disasm source selector
            explorerDisasmSource.innerHTML = '<option value="">Select source...</option>';

            // Update Hex source selector
            explorerHexSource.innerHTML = '<option value="">Whole file</option>';

            // Track BASIC sources for auto-selection
            let basicSources = [];

            if (explorerParsed.type === 'tap') {
                // Add BASIC programs to BASIC selector
                for (let i = 0; i < explorerBlocks.length; i++) {
                    const block = explorerBlocks[i];
                    if (block.blockType === 'header' && block.headerType === 0) {
                        explorerBasicSource.innerHTML += `<option value="${i}">Block ${i + 1}: ${block.name}</option>`;
                        basicSources.push(i.toString());
                    }
                }

                // Add CODE blocks to Disasm selector (with address info)
                for (let i = 0; i < explorerBlocks.length; i++) {
                    const block = explorerBlocks[i];
                    if (block.blockType === 'header' && block.headerType === 3) {
                        explorerDisasmSource.innerHTML += `<option value="${i}">Block ${i + 1}: ${block.name} @ ${hex16(block.startAddress)}</option>`;
                    }
                }

                // Also add all data blocks to Disasm selector (for embedded code in BASIC, etc.)
                for (let i = 0; i < explorerBlocks.length; i++) {
                    const block = explorerBlocks[i];
                    if (block.blockType === 'data') {
                        const prevBlock = i > 0 ? explorerBlocks[i - 1] : null;
                        const name = prevBlock && prevBlock.blockType === 'header' ? prevBlock.name : `Block ${i + 1}`;
                        const addr = prevBlock && prevBlock.startAddress !== undefined ? ` @ ${hex16(prevBlock.startAddress)}` : '';
                        // Don't duplicate if already added as CODE block
                        if (!prevBlock || prevBlock.headerType !== 3) {
                            explorerDisasmSource.innerHTML += `<option value="data:${i}">${name} data${addr} (${block.length} bytes)</option>`;
                        }
                    }
                }

                // Add all data blocks to Hex selector
                for (let i = 0; i < explorerBlocks.length; i++) {
                    const block = explorerBlocks[i];
                    if (block.blockType === 'data') {
                        const prevBlock = i > 0 ? explorerBlocks[i - 1] : null;
                        const name = prevBlock && prevBlock.blockType === 'header' ? prevBlock.name : `Block ${i + 1}`;
                        explorerHexSource.innerHTML += `<option value="${i}">${name} (${block.length} bytes)</option>`;
                    }
                }
            } else if (explorerParsed.type === 'trd' || explorerParsed.type === 'scl') {
                // Add files to selectors
                const files = explorerParsed.files;
                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    if (file.ext === 'B') {
                        explorerBasicSource.innerHTML += `<option value="${i}">${file.name}.${file.ext}</option>`;
                        basicSources.push(i.toString());
                        // Also add BASIC to disasm (for embedded code, uni-loaders)
                        // TR-DOS BASIC loads at PROG (23755), startAddress is autostart line
                        explorerDisasmSource.innerHTML += `<option value="basic:${i}">${file.name}.${file.ext} (BASIC @ 5CCB)</option>`;
                    } else if (file.ext === 'C') {
                        explorerDisasmSource.innerHTML += `<option value="${i}">${file.name}.${file.ext} @ ${hex16(file.startAddress)}</option>`;
                    } else if (file.ext === 'D') {
                        // Data files - also may contain code
                        explorerDisasmSource.innerHTML += `<option value="${i}">${file.name}.${file.ext} @ ${hex16(file.startAddress)}</option>`;
                    }
                    explorerHexSource.innerHTML += `<option value="${i}">${file.name}.${file.ext} (${file.length} bytes)</option>`;
                }
            } else if (explorerParsed.type === 'dsk') {
                // Add boot sector to Disasm and Hex selectors
                // +3 ROM loads boot sector to $FE00, code starts at offset 16 ($FE10)
                explorerDisasmSource.innerHTML += '<option value="boot">Boot sector @ $FE10</option>';
                explorerHexSource.innerHTML += '<option value="boot">Boot sector (512 bytes)</option>';

                // Add DSK files to selectors
                const files = explorerParsed.files;
                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    const displayName = file.name + (file.ext ? '.' + file.ext : '');
                    const addrStr = file.loadAddress !== undefined ? ` @ ${hex16(file.loadAddress)}` : '';
                    if (file.plus3Type === 0) {
                        // BASIC program
                        explorerBasicSource.innerHTML += `<option value="${i}">${displayName}</option>`;
                        basicSources.push(i.toString());
                    }
                    if (file.plus3Type === 3 || file.plus3Type === undefined) {
                        explorerDisasmSource.innerHTML += `<option value="${i}">${displayName}${addrStr} (${file.size} bytes)</option>`;
                    }
                    explorerHexSource.innerHTML += `<option value="${i}">${displayName} (${file.size} bytes)</option>`;
                }
            } else if (explorerParsed.type === 'sna' || explorerParsed.type === 'z80') {
                // For snapshots, offer memory as source
                explorerDisasmSource.innerHTML += '<option value="memory">Full memory</option>';
                explorerHexSource.innerHTML += '<option value="memory">Full memory</option>';
            }

            // Auto-select and decode if only one BASIC source
            if (basicSources.length === 1) {
                explorerBasicSource.value = basicSources[0];
                explorerRenderBASIC();
                // Switch to BASIC sub-tab to show the decoded listing
                document.querySelector('.explorer-subtab[data-subtab="basic"]').click();
            }

            // Auto-select first Disasm source if available and set address
            if (explorerDisasmSource.options.length > 1) {
                explorerDisasmSource.selectedIndex = 1; // Select first actual source (index 0 is "Select source...")
                // Trigger change event to set address
                explorerDisasmSource.dispatchEvent(new Event('change'));
            }

            // Set default disasm length based on data size (use full length if <= 4KB)
            const dataLen = explorerData ? explorerData.length : 0;
            if (dataLen > 0 && dataLen <= 4096) {
                explorerDisasmLen.value = dataLen;
            } else {
                explorerDisasmLen.value = 256;
            }

            // Set default hex length based on data size (use full length if <= 64KB)
            if (dataLen > 0 && dataLen <= 65536) {
                explorerHexLen.value = dataLen;
            } else {
                explorerHexLen.value = 256;
            }

            // Auto-select first Hex source if available (after "Whole file")
            if (explorerHexSource.options.length > 1) {
                explorerHexSource.selectedIndex = 1;
            }
        }

        // Disassembly button handler
        btnExplorerDisasm.addEventListener('click', () => {
            explorerRenderDisasm();
        });

        // Auto-set address and render when Disasm source changes
        explorerDisasmSource.addEventListener('change', () => {
            const source = explorerDisasmSource.value;
            if (!source) return;

            // Set address based on selected source
            if (explorerParsed.type === 'tap') {
                if (source.startsWith('data:')) {
                    const blockIdx = parseInt(source.slice(5));
                    const prevBlock = blockIdx > 0 ? explorerBlocks[blockIdx - 1] : null;
                    if (prevBlock && prevBlock.blockType === 'header' && prevBlock.startAddress !== undefined) {
                        explorerDisasmAddr.value = hex16(prevBlock.startAddress);
                    }
                } else {
                    const blockIdx = parseInt(source);
                    const headerBlock = explorerBlocks[blockIdx];
                    if (headerBlock && headerBlock.startAddress !== undefined) {
                        explorerDisasmAddr.value = hex16(headerBlock.startAddress);
                    }
                }
            } else if (explorerParsed.type === 'trd' || explorerParsed.type === 'scl') {
                if (source.startsWith('basic:')) {
                    explorerDisasmAddr.value = '5CCB'; // PROG address
                } else {
                    const fileIdx = parseInt(source);
                    const file = explorerParsed.files[fileIdx];
                    if (file && file.startAddress !== undefined) {
                        explorerDisasmAddr.value = hex16(file.startAddress);
                    }
                }
            } else if (explorerParsed.type === 'dsk') {
                if (source === 'boot') {
                    explorerDisasmAddr.value = 'FE10';
                } else {
                    const fileIdx = parseInt(source);
                    const file = explorerParsed.files[fileIdx];
                    if (file && file.loadAddress !== undefined) {
                        explorerDisasmAddr.value = hex16(file.loadAddress);
                    } else {
                        explorerDisasmAddr.value = '0000';
                    }
                }
            } else if (source === 'memory') {
                explorerDisasmAddr.value = '4000'; // RAM start
            }

            // Auto-render
            explorerRenderDisasm();
        });

        function explorerRenderDisasm() {
            const addr = parseInt(explorerDisasmAddr.value, 16) || 0;
            const len = parseInt(explorerDisasmLen.value, 10) || 256;
            const source = explorerDisasmSource.value;

            let data = null;
            let baseAddr = addr;

            if (source === 'memory' && (explorerParsed.type === 'sna' || explorerParsed.type === 'z80')) {
                // Get memory from snapshot
                data = explorerData.slice(explorerParsed.memoryOffset || 27);
                baseAddr = 0x4000; // RAM starts at 0x4000
            } else if (source && explorerParsed.type === 'tap') {
                // Check if it's a data block reference (data:N)
                if (source.startsWith('data:')) {
                    const blockIdx = parseInt(source.slice(5));
                    const dataBlock = explorerBlocks[blockIdx];
                    if (dataBlock && dataBlock.blockType === 'data') {
                        data = dataBlock.data.slice(1, -1); // Remove flag and checksum
                        // Try to get base address from preceding header
                        const prevBlock = blockIdx > 0 ? explorerBlocks[blockIdx - 1] : null;
                        if (prevBlock && prevBlock.blockType === 'header' && prevBlock.startAddress !== undefined) {
                            baseAddr = prevBlock.startAddress;
                        } else {
                            baseAddr = 0; // No address info, use 0
                        }
                    }
                } else {
                    // Header block reference - get following data block
                    const blockIdx = parseInt(source);
                    const headerBlock = explorerBlocks[blockIdx];
                    if (headerBlock && headerBlock.blockType === 'header' && blockIdx + 1 < explorerBlocks.length) {
                        const dataBlock = explorerBlocks[blockIdx + 1];
                        data = dataBlock.data.slice(1, -1); // Remove flag and checksum
                        baseAddr = headerBlock.startAddress || 0;
                        explorerDisasmAddr.value = hex16(baseAddr);
                    }
                }
            } else if (source && (explorerParsed.type === 'trd' || explorerParsed.type === 'scl')) {
                // Check if it's a BASIC file reference (basic:N)
                if (source.startsWith('basic:')) {
                    const fileIdx = parseInt(source.slice(6));
                    const file = explorerParsed.files[fileIdx];
                    if (file) {
                        // Use full sector size - machine code in BASIC variables is beyond 'length'
                        const fullSize = file.sectors * 256;
                        data = explorerData.slice(file.offset, file.offset + fullSize);
                        // TR-DOS BASIC loads at shifted PROG address (not 0x5CCB like 48K)
                        // Standard TR-DOS PROG = 0x5D3B (23867)
                        baseAddr = 0x5D3B;
                    }
                } else {
                    const fileIdx = parseInt(source);
                    const file = explorerParsed.files[fileIdx];
                    if (file) {
                        // Use full sector size for disasm
                        const fullSize = file.sectors * 256;
                        data = explorerData.slice(file.offset, file.offset + fullSize);
                        baseAddr = file.startAddress;
                        explorerDisasmAddr.value = hex16(baseAddr);
                    }
                }
            } else if (source && explorerParsed.type === 'dsk') {
                if (source === 'boot') {
                    // Boot sector: +3 ROM loads track 0 sector 1 to $FE00
                    // Disk spec at $FE00-$FE0F (16 bytes), code starts at $FE10
                    const bootSector = explorerParsed.dskImage.readSector(0, 0,
                        explorerParsed.diskSpec && explorerParsed.diskSpec.firstSectorId !== undefined
                            ? explorerParsed.diskSpec.firstSectorId : 1);
                    if (bootSector && bootSector.length > 16) {
                        data = bootSector.slice(16);  // Skip disk spec
                        baseAddr = 0xFE10;
                        explorerDisasmAddr.value = 'FE10';
                    }
                } else {
                    const fileIdx = parseInt(source);
                    const file = explorerParsed.files[fileIdx];
                    if (file) {
                        const rawData = DSKLoader.readFileData(
                            explorerParsed.dskImage, file.name, file.ext, file.user, file.rawSize || file.size
                        );
                        // Skip +3DOS header for disassembly
                        if (rawData && file.hasPlus3Header && rawData.length > 128) {
                            data = rawData.slice(128);
                        } else {
                            data = rawData;
                        }
                        baseAddr = (file.loadAddress !== undefined) ? file.loadAddress : 0;
                        explorerDisasmAddr.value = baseAddr.toString(16).toUpperCase().padStart(4, '0');
                    }
                }
            } else if (!source && explorerData) {
                // Use whole file
                data = explorerData;
            }

            if (!data || data.length === 0) {
                explorerDisasmOutput.innerHTML = '<div class="explorer-empty">No data to disassemble</div>';
                return;
            }

            // Create a fake memory object for the disassembler
            const fakeMemory = {
                read: (a) => {
                    const offset = a - baseAddr;
                    if (offset >= 0 && offset < data.length) {
                        return data[offset];
                    }
                    return 0;
                }
            };

            // Create disassembler with fake memory
            const disasm = new Disassembler(fakeMemory);

            let html = '';
            let offset = addr - baseAddr;
            const endOffset = Math.min(offset + len, data.length);

            // Get ROM labels from labelManager
            const romLabels = labelManager.romLabels || {};

            while (offset < endOffset && offset >= 0) {
                const currentAddr = baseAddr + offset;

                // Disassemble instruction
                const result = disasm.disassemble(currentAddr);
                const instrLen = result.length || 1;
                const bytesHex = result.bytes.map(b => hex8(b)).join(' ');

                // Check for ROM labels in mnemonic (addresses end with 'h')
                let mnemonic = result.mnemonic || '???';
                const addrMatch = mnemonic.match(/([0-9A-F]{4})h/i);
                if (addrMatch) {
                    const targetAddr = parseInt(addrMatch[1], 16);
                    const label = romLabels[targetAddr];
                    if (label) {
                        mnemonic = mnemonic.replace(addrMatch[0], `<span class="dl">${label}</span>`);
                    }
                }

                html += `<span class="da">${hex16(currentAddr)}</span>  <span class="dm">${mnemonic.padEnd(20)}</span> <span class="db">; ${bytesHex}</span>\n`;

                // Add blank line after jumps/calls/returns/halt
                if (isFlowBreak(mnemonic)) {
                    html += '\n';
                }

                offset += instrLen;
            }

            explorerDisasmOutput.innerHTML = html || '<div class="explorer-empty">No instructions</div>';
        }

        // Hex dump button handler
        btnExplorerHex.addEventListener('click', () => {
            explorerRenderHexDump();
        });

        function explorerRenderHexDump() {
            const addr = parseInt(explorerHexAddr.value, 16) || 0;
            const len = parseInt(explorerHexLen.value, 10) || 256;
            const source = explorerHexSource.value;

            let data = null;
            let baseAddr = addr;

            if (source === 'memory' && (explorerParsed.type === 'sna' || explorerParsed.type === 'z80')) {
                data = explorerData.slice(explorerParsed.memoryOffset || 27);
                baseAddr = 0x4000;
            } else if (source && explorerParsed.type === 'tap') {
                const blockIdx = parseInt(source);
                const block = explorerBlocks[blockIdx];
                if (block && block.blockType === 'data') {
                    data = block.data;
                    baseAddr = 0;
                }
            } else if (source && (explorerParsed.type === 'trd' || explorerParsed.type === 'scl')) {
                const fileIdx = parseInt(source);
                const file = explorerParsed.files[fileIdx];
                if (file) {
                    data = explorerData.slice(file.offset, file.offset + file.length);
                    baseAddr = 0;
                }
            } else if (source && explorerParsed.type === 'dsk') {
                if (source === 'boot') {
                    // Full boot sector from track 0
                    const bootSector = explorerParsed.dskImage.readSector(0, 0,
                        explorerParsed.diskSpec && explorerParsed.diskSpec.firstSectorId !== undefined
                            ? explorerParsed.diskSpec.firstSectorId : 1);
                    if (bootSector) {
                        data = bootSector;
                        baseAddr = 0xFE00;
                    }
                } else {
                    const fileIdx = parseInt(source);
                    const file = explorerParsed.files[fileIdx];
                    if (file) {
                        data = DSKLoader.readFileData(
                            explorerParsed.dskImage, file.name, file.ext, file.user, file.rawSize || file.size
                        );
                        baseAddr = 0;
                    }
                }
            } else if (explorerData) {
                data = explorerData;
            }

            if (!data || data.length === 0) {
                explorerHexOutput.innerHTML = '<div class="explorer-empty">No data</div>';
                return;
            }

            let html = '';
            const startOffset = Math.max(0, addr - baseAddr);
            const endOffset = Math.min(startOffset + len, data.length);

            for (let offset = startOffset; offset < endOffset; offset += 16) {
                const lineAddr = baseAddr + offset;
                let bytesHex = '';
                let ascii = '';

                for (let i = 0; i < 16; i++) {
                    if (offset + i < data.length) {
                        const b = data[offset + i];
                        bytesHex += hex8(b) + ' ';
                        ascii += (b >= 32 && b < 127) ? String.fromCharCode(b) : '.';
                    } else {
                        bytesHex += '   ';
                        ascii += ' ';
                    }
                    if (i === 7) bytesHex += ' ';
                }

                html += `<span class="ha">${hex16(lineAddr)}</span>  <span class="hb">${bytesHex}</span>  <span class="hc">${ascii}</span>\n`;
            }

            explorerHexOutput.innerHTML = html || '<div class="explorer-empty">No data</div>';
        }

        // BASIC Decoder for Explorer
        const ExplorerBasicDecoder = (() => {
            // ZX Spectrum BASIC tokens (0xA3-0xFF)
            const TOKENS = {
                0xA3: ['SPECTRUM', true, true], 0xA4: ['PLAY', true, true],
                0xA5: ['RND', true, false], 0xA6: ['INKEY$', true, false],
                0xA7: ['PI', true, false], 0xA8: ['FN', true, false],
                0xA9: ['POINT', true, false], 0xAA: ['SCREEN$', true, false],
                0xAB: ['ATTR', true, false], 0xAC: ['AT', true, true],
                0xAD: ['TAB', true, true], 0xAE: ['VAL$', true, false],
                0xAF: ['CODE', true, true], 0xB0: ['VAL', true, true],
                0xB1: ['LEN', true, false], 0xB2: ['SIN', true, false],
                0xB3: ['COS', true, false], 0xB4: ['TAN', true, false],
                0xB5: ['ASN', true, false], 0xB6: ['ACS', true, false],
                0xB7: ['ATN', true, false], 0xB8: ['LN', true, false],
                0xB9: ['EXP', true, false], 0xBA: ['INT', true, false],
                0xBB: ['SQR', true, false], 0xBC: ['SGN', true, false],
                0xBD: ['ABS', true, false], 0xBE: ['PEEK', true, false],
                0xBF: ['IN', true, true], 0xC0: ['USR', true, true],
                0xC1: ['STR$', true, false], 0xC2: ['CHR$', true, false],
                0xC3: ['NOT', true, true], 0xC4: ['BIN', true, true],
                0xC5: ['OR', true, true], 0xC6: ['AND', true, true],
                0xC7: ['<=', false, false], 0xC8: ['>=', false, false],
                0xC9: ['<>', false, false], 0xCA: ['LINE', true, true],
                0xCB: ['THEN', true, true], 0xCC: ['TO', true, true],
                0xCD: ['STEP', true, true], 0xCE: ['DEF FN', true, true],
                0xCF: ['CAT', true, true], 0xD0: ['FORMAT', true, true],
                0xD1: ['MOVE', true, true], 0xD2: ['ERASE', true, true],
                0xD3: ['OPEN #', true, false], 0xD4: ['CLOSE #', true, false],
                0xD5: ['MERGE', true, true], 0xD6: ['VERIFY', true, true],
                0xD7: ['BEEP', true, true], 0xD8: ['CIRCLE', true, true],
                0xD9: ['INK', true, true], 0xDA: ['PAPER', true, true],
                0xDB: ['FLASH', true, true], 0xDC: ['BRIGHT', true, true],
                0xDD: ['INVERSE', true, true], 0xDE: ['OVER', true, true],
                0xDF: ['OUT', true, true], 0xE0: ['LPRINT', true, true],
                0xE1: ['LLIST', true, true], 0xE2: ['STOP', true, false],
                0xE3: ['READ', true, true], 0xE4: ['DATA', true, true],
                0xE5: ['RESTORE', true, true], 0xE6: ['NEW', true, false],
                0xE7: ['BORDER', true, true], 0xE8: ['CONTINUE', true, false],
                0xE9: ['DIM', true, true], 0xEA: ['REM', true, true],
                0xEB: ['FOR', true, true], 0xEC: ['GO TO', true, true],
                0xED: ['GO SUB', true, true], 0xEE: ['INPUT', true, true],
                0xEF: ['LOAD', true, true], 0xF0: ['LIST', true, true],
                0xF1: ['LET', true, true], 0xF2: ['PAUSE', true, true],
                0xF3: ['NEXT', true, true], 0xF4: ['POKE', true, true],
                0xF5: ['PRINT', true, true], 0xF6: ['PLOT', true, true],
                0xF7: ['RUN', true, true], 0xF8: ['SAVE', true, true],
                0xF9: ['RANDOMIZE', true, true], 0xFA: ['IF', true, true],
                0xFB: ['CLS', true, false], 0xFC: ['DRAW', true, true],
                0xFD: ['CLEAR', true, true], 0xFE: ['RETURN', true, false],
                0xFF: ['COPY', true, false]
            };

            const CONTROL_CODES = {
                0x10: 'INK', 0x11: 'PAPER', 0x12: 'FLASH',
                0x13: 'BRIGHT', 0x14: 'INVERSE', 0x15: 'OVER',
                0x16: 'AT', 0x17: 'TAB'
            };

            function parseFloat5(bytes) {
                if (bytes.length < 5) return null;
                const exp = bytes[0];
                if (exp === 0) {
                    if (bytes[1] === 0x00 && bytes[4] === 0x00) {
                        return bytes[2] | (bytes[3] << 8);
                    }
                    if (bytes[1] === 0xFF && bytes[4] === 0x00) {
                        const val = bytes[2] | (bytes[3] << 8);
                        return val > 32767 ? val - 65536 : -val;
                    }
                    return 0;
                }
                const sign = (bytes[1] & 0x80) ? -1 : 1;
                const mantissa = (((bytes[1] | 0x80) << 24) | (bytes[2] << 16) | (bytes[3] << 8) | bytes[4]) >>> 0;
                return sign * (mantissa / 0x100000000) * Math.pow(2, exp - 128);
            }

            function formatNumber(n) {
                if (n === null || n === undefined) return '?';
                if (Number.isInteger(n)) return n.toString();
                return parseFloat(n.toPrecision(10)).toString();
            }

            function decode(data) {
                const lines = [];
                let offset = 0;

                while (offset < data.length - 4) {
                    const lineNum = (data[offset] << 8) | data[offset + 1];
                    let lineLen = data[offset + 2] | (data[offset + 3] << 8);

                    // Allow line numbers > 9999 (used for obfuscation/protection)
                    // But stop if lineLen is 0 or line number looks completely invalid
                    if (lineLen === 0) {
                        break;
                    }

                    // Cap lineLen to available data (handles obfuscated programs with huge lengths)
                    const availableLen = data.length - offset - 4;
                    if (lineLen > availableLen) {
                        lineLen = availableLen;
                    }

                    if (lineLen === 0) {
                        break;
                    }

                    const lineData = data.slice(offset + 4, offset + 4 + lineLen);
                    const decoded = decodeLine(lineData);

                    lines.push({
                        number: lineNum,
                        offset: offset,
                        text: decoded.text,
                        obfuscations: decoded.obfuscations
                    });

                    offset += 4 + lineLen;
                }
                return lines;
            }

            function decodeLine(data) {
                let text = '';
                let obfuscations = [];
                let i = 0;
                let inString = false;
                let inREM = false;
                let lastWasSpace = false;
                let asciiBeforeFP = '';
                let asciiStartPos = -1;

                function addText(str, spaceBefore = false, spaceAfter = false) {
                    if (spaceBefore && text.length > 0 && !lastWasSpace && !text.endsWith(' ') && !text.endsWith(':')) {
                        text += ' ';
                    }
                    text += str;
                    lastWasSpace = str.endsWith(' ') || spaceAfter;
                    if (spaceAfter && !str.endsWith(' ')) {
                        text += ' ';
                        lastWasSpace = true;
                    }
                }

                while (i < data.length) {
                    const byte = data[i];

                    if (byte === 0x0D) break;

                    if (inREM) {
                        if (byte >= 0x20 && byte < 0x80) {
                            text += String.fromCharCode(byte);
                        } else if (byte === 0x0E) {
                            i += 5;
                        } else if (TOKENS[byte]) {
                            const [keyword, spaceBefore, spaceAfter] = TOKENS[byte];
                            if (spaceBefore && text.length > 0 && !text.endsWith(' ')) text += ' ';
                            text += keyword;
                            if (spaceAfter) text += ' ';
                        } else {
                            text += `[${byte.toString(16).padStart(2, '0').toUpperCase()}]`;
                        }
                        i++;
                        continue;
                    }

                    if (byte === 0x0E && !inString) {
                        const fpBytes = [];
                        for (let j = 0; j < 5 && i + 1 + j < data.length; j++) {
                            fpBytes.push(data[i + 1 + j]);
                        }
                        const fpValue = parseFloat5(fpBytes);
                        const fpFormatted = formatNumber(fpValue);
                        let isObfuscated = false;
                        let asciiDisplay = asciiBeforeFP.trim();

                        if (asciiDisplay !== '') {
                            let asciiNum = parseFloat(asciiDisplay);
                            if (asciiDisplay.startsWith('.')) asciiNum = parseFloat('0' + asciiDisplay);
                            if (isNaN(asciiNum)) {
                                isObfuscated = true;
                            } else {
                                const valuesMatch = Math.abs(Math.abs(asciiNum) - Math.abs(fpValue)) < 0.0001 ||
                                                   Math.abs(asciiNum - fpValue) < 0.0001;
                                if (!valuesMatch) isObfuscated = true;
                            }
                        } else {
                            isObfuscated = true;
                            asciiDisplay = '(hidden)';
                        }

                        if (isObfuscated) {
                            obfuscations.push({ ascii: asciiDisplay, actual: fpValue });
                            if (asciiStartPos >= 0 && asciiStartPos < text.length) {
                                text = text.substring(0, asciiStartPos);
                            }
                            text += `{{${fpFormatted}}}`;
                        }
                        asciiBeforeFP = '';
                        asciiStartPos = -1;
                        i += 6;
                        continue;
                    }

                    const isNumberChar = (byte >= 0x30 && byte <= 0x39) || byte === 0x2E ||
                                         byte === 0x2B || byte === 0x2D || byte === 0x45 || byte === 0x65;
                    if (!inString && isNumberChar) {
                        if (asciiStartPos < 0) asciiStartPos = text.length;
                        asciiBeforeFP += String.fromCharCode(byte);
                    } else if (!inString && byte !== 0x0E) {
                        if (byte !== 0x20 || asciiBeforeFP === '') {
                            asciiBeforeFP = '';
                            asciiStartPos = -1;
                        } else if (byte === 0x20 && asciiBeforeFP !== '') {
                            asciiBeforeFP += ' ';
                        }
                    }

                    if (byte === 0x22) {
                        inString = !inString;
                        text += '"';
                        lastWasSpace = false;
                        asciiBeforeFP = '';
                        asciiStartPos = -1;
                        i++;
                        continue;
                    }

                    if (inString) {
                        if (byte >= 0x20 && byte < 0x7F) {
                            text += String.fromCharCode(byte);
                        } else {
                            text += `[${byte.toString(16).padStart(2, '0').toUpperCase()}]`;
                        }
                        i++;
                        continue;
                    }

                    if (CONTROL_CODES[byte]) {
                        addText('{' + CONTROL_CODES[byte] + ' ', true, false);
                        asciiBeforeFP = '';
                        asciiStartPos = -1;
                        if (byte >= 0x16) {
                            i++;
                            if (i < data.length) text += data[i];
                            i++;
                            if (i < data.length) text += ',' + data[i];
                        } else {
                            i++;
                            if (i < data.length) text += data[i];
                        }
                        text += '}';
                        i++;
                        continue;
                    }

                    if (TOKENS[byte]) {
                        const [keyword, spaceBefore, spaceAfter] = TOKENS[byte];
                        addText(keyword, spaceBefore, spaceAfter);
                        if (byte === 0xEA) inREM = true;
                        asciiBeforeFP = '';
                        asciiStartPos = -1;
                        i++;
                        continue;
                    }

                    if (byte === 0x3A) {
                        text += ':';
                        lastWasSpace = false;
                        asciiBeforeFP = '';
                        asciiStartPos = -1;
                        i++;
                        continue;
                    }

                    if (byte >= 0x20 && byte < 0x80) {
                        text += String.fromCharCode(byte);
                        lastWasSpace = (byte === 0x20);
                    } else if (byte >= 0x90 && byte <= 0xA2) {
                        text += `[UDG-${String.fromCharCode(65 + byte - 0x90)}]`;
                        lastWasSpace = false;
                        asciiBeforeFP = '';
                        asciiStartPos = -1;
                    } else if (byte >= 0x80 && byte <= 0x8F) {
                        text += `[BLK]`;
                        lastWasSpace = false;
                        asciiBeforeFP = '';
                        asciiStartPos = -1;
                    } else if (byte < 0x20 && byte !== 0x0E) {
                        if (byte === 0x06) text += ',';
                        asciiBeforeFP = '';
                        asciiStartPos = -1;
                    }
                    i++;
                }
                return { text: text.trim(), obfuscations };
            }

            return { decode, parseFloat5, TOKENS };
        })();

        // BASIC view button handler
        const btnExplorerBasic = document.getElementById('btnExplorerBasic');
        if (btnExplorerBasic) {
            btnExplorerBasic.addEventListener('click', () => {
                explorerRenderBASIC();
            });
        }

        function explorerRenderBASIC() {
            const source = explorerBasicSource.value;
            if (!source) {
                explorerBasicOutput.innerHTML = '<div class="explorer-empty">Select a BASIC program source</div>';
                return;
            }

            let data = null;

            if (explorerParsed.type === 'tap') {
                const blockIdx = parseInt(source);
                const headerBlock = explorerBlocks[blockIdx];
                if (headerBlock && headerBlock.blockType === 'header' && headerBlock.headerType === 0 && blockIdx + 1 < explorerBlocks.length) {
                    const dataBlock = explorerBlocks[blockIdx + 1];
                    data = dataBlock.data.slice(1, -1); // Remove flag and checksum
                }
            } else if (explorerParsed.type === 'trd' || explorerParsed.type === 'scl') {
                const fileIdx = parseInt(source);
                const file = explorerParsed.files[fileIdx];
                if (file) {
                    // TR-DOS BASIC files - raw BASIC data, no header
                    data = explorerData.slice(file.offset, file.offset + file.length);
                }
            } else if (explorerParsed.type === 'dsk') {
                const fileIdx = parseInt(source);
                const file = explorerParsed.files[fileIdx];
                if (file && explorerParsed.dskImage) {
                    const rawData = DSKLoader.readFileData(
                        explorerParsed.dskImage, file.name, file.ext, file.user, file.rawSize || file.size
                    );
                    if (rawData) {
                        // Skip 128-byte +3DOS header to get raw BASIC data
                        if (file.hasPlus3Header && rawData.length > 128) {
                            data = rawData.slice(128);
                        } else {
                            data = rawData;
                        }
                    }
                }
            }

            if (!data || data.length === 0) {
                explorerBasicOutput.innerHTML = '<div class="explorer-empty">No BASIC data found</div>';
                return;
            }

            try {
                const lines = ExplorerBasicDecoder.decode(data);

                if (lines.length === 0) {
                    // Debug: show first bytes to help diagnose
                    const hexBytes = Array.from(data.slice(0, 16)).map(b => b.toString(16).padStart(2, '0')).join(' ');
                    explorerBasicOutput.innerHTML = `<div class="explorer-empty">No BASIC lines found<br><span style="font-size:10px;color:var(--text-secondary)">First 16 bytes: ${hexBytes}</span></div>`;
                    return;
                }

                let html = '';
                for (const line of lines) {
                    // Syntax highlight the line
                    let highlighted = highlightBasicLine(line.text);

                    html += `<div class="explorer-basic-line">`;
                    html += `<span class="explorer-basic-linenum">${line.number}</span>`;
                    html += `<span>${highlighted}</span>`;
                    html += `</div>`;

                    // Show obfuscation warnings
                    if (line.obfuscations && line.obfuscations.length > 0) {
                        for (const obf of line.obfuscations) {
                            html += `<div style="color:#e67e22;font-size:10px;margin-left:60px;">`;
                            // Make address clickable if it's in memory range
                            const actualNum = typeof obf.actual === 'number' ? obf.actual : parseFloat(obf.actual);
                            if (Number.isInteger(actualNum) && actualNum >= 16384 && actualNum <= 65535) {
                                html += `⚠ Obfuscated: "${obf.ascii}" → <span class="explorer-basic-addr" data-addr="${actualNum}" style="cursor:pointer;text-decoration:underline;color:var(--cyan)" title="Click to disassemble">${obf.actual}</span>`;
                            } else {
                                html += `⚠ Obfuscated: "${obf.ascii}" → ${obf.actual}`;
                            }
                            html += `</div>`;
                        }
                    }
                }

                explorerBasicOutput.innerHTML = html;

            } catch (err) {
                explorerBasicOutput.innerHTML = `<div class="explorer-empty">Error decoding BASIC: ${err.message}</div>`;
            }
        }

        function highlightBasicLine(text) {
            // Escape HTML first
            let html = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

            // Highlight strings (must be done first)
            html = html.replace(/"([^"]*)"/g, '<span class="explorer-basic-string">"$1"</span>');

            // Highlight keywords
            const keywords = Object.values(ExplorerBasicDecoder.TOKENS).map(t => t[0]).sort((a, b) => b.length - a.length);
            for (const kw of keywords) {
                const escaped = kw.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const regex = new RegExp('\\b(' + escaped + ')\\b', 'g');
                html = html.replace(regex, '<span class="explorer-basic-keyword">$1</span>');
            }

            // Make addresses after USR, PEEK, POKE clickable (numbers 16384-65535)
            html = html.replace(/(USR|PEEK|POKE|RANDOMIZE\s+USR)(\s*<[^>]+>)?\s*(\d{4,5})/gi, (match, keyword, span, addr) => {
                const addrNum = parseInt(addr);
                if (addrNum >= 16384 && addrNum <= 65535) {
                    return `${keyword}${span || ''} <span class="explorer-basic-addr" data-addr="${addrNum}" style="cursor:pointer;text-decoration:underline;color:var(--cyan)" title="Click to disassemble">${addr}</span>`;
                }
                return match;
            });

            // Handle USR/PEEK/POKE VAL "number" pattern (common technique to hide addresses)
            // Supports: VAL "24064", VAL "2.4064E4", VAL "24064.0", etc.
            html = html.replace(/(USR|PEEK|POKE)(<\/span>)?\s*(<span[^>]*>)?VAL(<\/span>)?\s*"([\d.]+(?:[Ee][+\-]?\d+)?)"/gi, (match, keyword, kwClose, valOpen, valClose, numStr) => {
                const addrNum = Math.round(parseFloat(numStr));
                if (addrNum >= 16384 && addrNum <= 65535) {
                    return `${keyword}${kwClose || ''} ${valOpen || ''}VAL${valClose || ''} "<span class="explorer-basic-addr" data-addr="${addrNum}" style="cursor:pointer;text-decoration:underline;color:var(--cyan)" title="Click to disassemble at ${addrNum}">${numStr}</span>"`;
                }
                return match;
            });

            // Highlight remaining numbers (not in strings, not already wrapped)
            html = html.replace(/\b(\d+(?:\.\d+)?)\b(?![^<]*>)/g, '<span class="explorer-basic-number">$1</span>');

            // Highlight obfuscation markers
            html = html.replace(/\{\{([^}]+)\}\}/g, '<span style="color:#e67e22;font-weight:bold">{{$1}}</span>');

            return html;
        }

        // Handle clicking on addresses in BASIC listing
        explorerBasicOutput.addEventListener('click', (e) => {
            const addrSpan = e.target.closest('.explorer-basic-addr');
            if (!addrSpan) return;

            const addr = parseInt(addrSpan.dataset.addr);
            if (isNaN(addr)) return;

            // Switch to Disasm sub-tab
            document.querySelector('.explorer-subtab[data-subtab="disasm"]').click();

            // Try to find a CODE block that contains this address
            let foundSource = '';

            if (explorerParsed.type === 'tap') {
                // First, try to find CODE block (headerType === 3) that contains the address
                for (let i = 0; i < explorerBlocks.length; i++) {
                    const block = explorerBlocks[i];
                    if (block.blockType === 'header' && block.headerType === 3) {
                        const startAddr = block.startAddress;
                        const dataBlock = explorerBlocks[i + 1];
                        if (dataBlock && dataBlock.blockType === 'data') {
                            const endAddr = startAddr + dataBlock.length - 2; // -2 for flag and checksum
                            if (addr >= startAddr && addr < endAddr) {
                                foundSource = i.toString();
                                break;
                            }
                        }
                    }
                }

                // If no CODE block found, try any data block with a header that has an address
                if (!foundSource) {
                    for (let i = 0; i < explorerBlocks.length; i++) {
                        const block = explorerBlocks[i];
                        if (block.blockType === 'data' && i > 0) {
                            const prevBlock = explorerBlocks[i - 1];
                            if (prevBlock.blockType === 'header' && prevBlock.startAddress !== undefined) {
                                const startAddr = prevBlock.startAddress;
                                const endAddr = startAddr + block.length - 2;
                                if (addr >= startAddr && addr < endAddr) {
                                    foundSource = 'data:' + i.toString();
                                    break;
                                }
                            }
                        }
                    }
                }

                // If still not found, just use the first data block
                if (!foundSource) {
                    for (let i = 0; i < explorerBlocks.length; i++) {
                        if (explorerBlocks[i].blockType === 'data') {
                            foundSource = 'data:' + i.toString();
                            break;
                        }
                    }
                }
            } else if (explorerParsed.type === 'trd' || explorerParsed.type === 'scl') {
                // First, find CODE file that contains the address
                for (let i = 0; i < explorerParsed.files.length; i++) {
                    const file = explorerParsed.files[i];
                    if (file.ext === 'C' || file.ext === 'D') {
                        const endAddr = file.startAddress + file.length;
                        if (addr >= file.startAddress && addr < endAddr) {
                            foundSource = i.toString();
                            break;
                        }
                    }
                }

                // If not found in CODE, check BASIC files (for embedded code in variables)
                // TR-DOS BASIC loads at PROG = 0x5D3B (23867), not 0x5CCB
                if (!foundSource) {
                    for (let i = 0; i < explorerParsed.files.length; i++) {
                        const file = explorerParsed.files[i];
                        if (file.ext === 'B') {
                            const basicBase = 0x5D3B; // TR-DOS PROG
                            const fullSize = file.sectors * 256;
                            const endAddr = basicBase + fullSize;
                            if (addr >= basicBase && addr < endAddr) {
                                foundSource = 'basic:' + i.toString();
                                // Keep addr as memory address - disasm uses baseAddr=0x5D3B
                                break;
                            }
                        }
                    }
                }

                // If still not found, the USR address might be for code loaded from a CODE file
                // Try to find any CODE file that contains this address
                if (!foundSource) {
                    for (let i = 0; i < explorerParsed.files.length; i++) {
                        const file = explorerParsed.files[i];
                        if (file.ext === 'C') {
                            const endAddr = file.startAddress + file.length;
                            if (addr >= file.startAddress && addr < endAddr) {
                                foundSource = i.toString();
                                break;
                            }
                        }
                    }
                }

                // Last resort: if address looks like it could be in any file's range, use first CODE file
                if (!foundSource) {
                    for (let i = 0; i < explorerParsed.files.length; i++) {
                        const file = explorerParsed.files[i];
                        if (file.ext === 'C') {
                            foundSource = i.toString();
                            // Adjust addr to be within this file if needed
                            if (addr < file.startAddress || addr >= file.startAddress + file.length) {
                                // Use the file's start address instead
                                addr = file.startAddress;
                            }
                            break;
                        }
                    }
                }
            } else if (explorerParsed.type === 'sna' || explorerParsed.type === 'z80') {
                // Use full memory for snapshots
                foundSource = 'memory';
            }

            // Set source if found
            if (foundSource) {
                explorerDisasmSource.value = foundSource;
            }

            // Set address and trigger disassembly
            explorerDisasmAddr.value = addr.toString(16).toUpperCase().padStart(4, '0');
            explorerDisasmLen.value = 256;

            // Trigger disassembly
            explorerRenderDisasm();
        });

        // ========== Text Scanner ==========
        const btnTextScan = document.getElementById('btnTextScan');
        const textScanMode = document.getElementById('textScanMode');
        const textScanCustom = document.getElementById('textScanCustom');
        const textScanMinLen = document.getElementById('textScanMinLen');
        const textScanROM = document.getElementById('textScanROM');
        const textScanAllBanks = document.getElementById('textScanAllBanks');
        const textScanMax = document.getElementById('textScanMax');
        const textScanStatus = document.getElementById('textScanStatus');
        const textScanResults = document.getElementById('textScanResults');
        const textScanPagination = document.getElementById('textScanPagination');
        const textScanPrev = document.getElementById('textScanPrev');
        const textScanNext = document.getElementById('textScanNext');
        const textScanPage = document.getElementById('textScanPage');

        let textScanAllResults = [];  // Store all results for pagination
        let textScanCurrentPage = 0;

        // Dictionary of common ZX Spectrum game/computer words
        const TEXT_DICTIONARY = [
            // Game terms
            'SCORE', 'LIVES', 'LEVEL', 'LIFE', 'TIME', 'BONUS', 'POINTS', 'ENERGY',
            'GAME', 'OVER', 'PLAYER', 'PRESS', 'START', 'PLAY', 'PAUSE', 'CONTINUE',
            'HIGH', 'ENTER', 'NAME', 'TABLE', 'BEST', 'TOP', 'NEW', 'RECORD',
            // Controls
            'FIRE', 'JUMP', 'LEFT', 'RIGHT', 'UP', 'DOWN', 'SPACE', 'ENTER',
            'KEYBOARD', 'JOYSTICK', 'KEMPSTON', 'SINCLAIR', 'CURSOR', 'KEYS',
            'CONTROL', 'SELECT', 'OPTION', 'MENU', 'QUIT', 'EXIT', 'ABORT',
            // Messages
            'LOADING', 'SAVING', 'LOAD', 'SAVE', 'BYTES', 'READY', 'ERROR',
            'PRESS ANY KEY', 'WAIT', 'PLEASE', 'INSERT', 'TAPE', 'DISK',
            'CONGRATULATIONS', 'WELL DONE', 'TRY AGAIN', 'GET READY',
            // Credits
            'COPYRIGHT', 'WRITTEN', 'PROGRAMMED', 'GRAPHICS', 'MUSIC', 'SOUND',
            'PRESENTS', 'PRODUCTIONS', 'SOFTWARE', 'GAMES', 'CODE',
            // Status
            'SHIELD', 'AMMO', 'FUEL', 'POWER', 'HEALTH', 'MAGIC', 'GOLD', 'COINS',
            'WEAPON', 'ARMOR', 'ITEM', 'INVENTORY', 'MAP', 'STAGE', 'ROUND', 'WAVE',
            // Common words
            'THE', 'AND', 'YOU', 'ARE', 'FOR', 'NOT', 'ALL', 'CAN', 'HAS', 'HER',
            'WAS', 'ONE', 'OUR', 'OUT', 'DAY', 'HAD', 'HOT', 'HIS', 'HOW', 'ITS',
            'MAY', 'OLD', 'SEE', 'NOW', 'WAY', 'WHO', 'DID', 'GET', 'HIM', 'HIS',
            'LET', 'PUT', 'SAY', 'SHE', 'TOO', 'USE', 'YES', 'FROM', 'HAVE', 'INTO',
            'KILL', 'DEAD', 'DIED', 'HELP', 'FIND', 'OPEN', 'DOOR', 'ROOM', 'LOCK',
            'TAKE', 'DROP', 'GIVE', 'LOOK', 'WALK', 'MOVE', 'STOP', 'TURN', 'BACK',
            'NORTH', 'SOUTH', 'EAST', 'WEST', 'EXAMINE', 'ATTACK', 'DEFEND',
            // ZX Spectrum specific
            'SPECTRUM', 'SINCLAIR', 'BASIC', 'RETURN', 'BREAK', 'STOP',
            'PRINT', 'INPUT', 'GOTO', 'GOSUB', 'THEN', 'ELSE', 'NEXT', 'DATA',
            'POKE', 'PEEK', 'BEEP', 'BORDER', 'PAPER', 'INK', 'FLASH', 'BRIGHT'
        ];

        // Convert dictionary to lowercase Set for fast lookup
        const dictSet = new Set(TEXT_DICTIONARY.map(w => w.toLowerCase()));

        textScanMode.addEventListener('change', () => {
            textScanCustom.style.display = textScanMode.value === 'custom' ? '' : 'none';
        });

        function renderTextScanPage() {
            const perPage = parseInt(textScanMax.value) || 0;  // 0 = all
            const total = textScanAllResults.length;

            if (total === 0) {
                textScanResults.innerHTML = '<div style="color:var(--text-secondary);padding:5px;">No strings found</div>';
                textScanPagination.style.display = 'none';
                return;
            }

            let startIdx, endIdx, totalPages;
            if (perPage === 0) {
                // Show all
                startIdx = 0;
                endIdx = total;
                totalPages = 1;
                textScanCurrentPage = 0;
                textScanPagination.style.display = 'none';
            } else {
                totalPages = Math.ceil(total / perPage);
                if (textScanCurrentPage >= totalPages) textScanCurrentPage = totalPages - 1;
                if (textScanCurrentPage < 0) textScanCurrentPage = 0;
                startIdx = textScanCurrentPage * perPage;
                endIdx = Math.min(startIdx + perPage, total);
                textScanPagination.style.display = totalPages > 1 ? '' : 'none';
                textScanPage.textContent = `${textScanCurrentPage + 1}/${totalPages}`;
                textScanPrev.disabled = textScanCurrentPage === 0;
                textScanNext.disabled = textScanCurrentPage >= totalPages - 1;
            }

            let html = '';
            for (let i = startIdx; i < endIdx; i++) {
                const r = textScanAllResults[i];
                let textHtml = escapeHtml(r.text);
                // Highlight dictionary matches
                if (r.dictMatches.length > 0) {
                    for (const word of r.dictMatches) {
                        const re = new RegExp('(' + word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + ')', 'gi');
                        textHtml = textHtml.replace(re, '<span class="dict-match">$1</span>');
                    }
                }
                const termIcon = r.termType === 'bit7' ? '⁷' : r.termType === 'null' ? '∅' : '';
                const bankLabel = r.bank ? `<span class="bank">${r.bank}</span>` : '';
                html += `<div class="text-scan-result" data-addr="${r.addr}" data-bank="${r.bank || ''}" title="${r.termType}-terminated${r.bank ? ' (' + r.bank + ')' : ''}">
                    <span class="addr">${hex16(r.addr)}</span>${bankLabel}
                    <span class="len">${r.len}${termIcon}</span>
                    <span class="text">${textHtml}</span>
                </div>`;
            }
            textScanResults.innerHTML = html;
        }

        textScanPrev.addEventListener('click', () => {
            if (textScanCurrentPage > 0) {
                textScanCurrentPage--;
                renderTextScanPage();
            }
        });

        textScanNext.addEventListener('click', () => {
            const perPage = parseInt(textScanMax.value) || 0;
            const totalPages = perPage > 0 ? Math.ceil(textScanAllResults.length / perPage) : 1;
            if (textScanCurrentPage < totalPages - 1) {
                textScanCurrentPage++;
                renderTextScanPage();
            }
        });

        textScanMax.addEventListener('change', () => {
            textScanCurrentPage = 0;
            renderTextScanPage();
        });

        // Extract string from raw buffer at offset
        function extractStringFromBuffer(buffer, startOffset, minLen) {
            let text = '';
            let offset = startOffset;
            let termType = null;

            while (offset < buffer.length) {
                const byte = buffer[offset];

                if (byte === 0) {
                    if (text.length >= minLen) {
                        termType = 'null';
                        return { text, len: offset - startOffset + 1, termType };
                    }
                    return null;
                }

                const char = byte & 0x7F;
                const bit7set = (byte & 0x80) !== 0;

                const isLetter = (char >= 65 && char <= 90) || (char >= 97 && char <= 122);
                const isPunct = char === 32 || char === 33 || char === 44 || char === 45 ||
                                char === 58 || char === 59 || char === 63;
                if (isLetter || isPunct) {
                    text += String.fromCharCode(char);
                    offset++;

                    if (bit7set) {
                        if (text.length >= minLen) {
                            termType = 'bit7';
                            return { text, len: offset - startOffset, termType };
                        }
                        return null;
                    }

                } else {
                    if (text.length >= minLen) {
                        termType = 'nonprint';
                        return { text, len: offset - startOffset, termType };
                    }
                    return null;
                }
            }

            if (text.length >= minLen) {
                termType = 'eof';
                return { text, len: offset - startOffset, termType };
            }
            return null;
        }

        // Scan a buffer for strings and add to results
        function scanBufferForStrings(buffer, baseAddr, bankLabel, mode, minLen, customSearch) {
            let offset = 0;
            while (offset < buffer.length) {
                const str = extractStringFromBuffer(buffer, offset, minLen);
                if (str) {
                    let include = false;
                    let dictMatches = [];

                    if (mode === 'all') {
                        include = true;
                        dictMatches = findDictWords(str.text);
                    } else if (mode === 'dict') {
                        dictMatches = findDictWords(str.text);
                        include = dictMatches.length > 0;
                    } else if (mode === 'custom') {
                        include = str.text.toLowerCase().includes(customSearch);
                    }

                    if (include) {
                        textScanAllResults.push({
                            addr: baseAddr + offset,
                            text: str.text,
                            len: str.len,
                            termType: str.termType,
                            dictMatches: dictMatches,
                            bank: bankLabel
                        });
                    }
                    offset += str.len;
                } else {
                    offset++;
                }
            }
        }

        btnTextScan.addEventListener('click', () => {
            if (!spectrum.memory) {
                showMessage('No memory available');
                return;
            }

            const mode = textScanMode.value;
            const minLen = parseInt(textScanMinLen.value) || 4;
            const customSearch = textScanCustom.value.toLowerCase();
            const includeROM = textScanROM.checked;
            const scanAllBanks = textScanAllBanks.checked && spectrum.memory.machineType !== '48k';
            textScanAllResults = [];

            if (scanAllBanks) {
                // Scan all 8 RAM banks directly (128K mode)
                for (let bank = 0; bank < 8; bank++) {
                    const buffer = spectrum.memory.getRamBank(bank);
                    scanBufferForStrings(buffer, 0xC000, `bank${bank}`, mode, minLen, customSearch);
                }
                // Optionally scan ROM
                if (includeROM) {
                    const rom0 = spectrum.memory.rom[0];
                    if (rom0) scanBufferForStrings(rom0, 0x0000, 'ROM0', mode, minLen, customSearch);
                    const rom1 = spectrum.memory.rom[1];
                    if (rom1) scanBufferForStrings(rom1, 0x0000, 'ROM1', mode, minLen, customSearch);
                }
            } else {
                // Scan mapped memory only
                let addr = includeROM ? 0x0000 : 0x4000;
                while (addr < 0x10000) {
                    const str = extractString(addr, minLen);
                    if (str) {
                        let include = false;
                        let dictMatches = [];

                        if (mode === 'all') {
                            include = true;
                            dictMatches = findDictWords(str.text);
                        } else if (mode === 'dict') {
                            dictMatches = findDictWords(str.text);
                            include = dictMatches.length > 0;
                        } else if (mode === 'custom') {
                            include = str.text.toLowerCase().includes(customSearch);
                        }

                        if (include) {
                            textScanAllResults.push({
                                addr: addr,
                                text: str.text,
                                len: str.len,
                                termType: str.termType,
                                dictMatches: dictMatches,
                                bank: null
                            });
                        }
                        addr += str.len;
                    } else {
                        addr++;
                    }
                }
            }

            // Display results
            textScanStatus.textContent = `(${textScanAllResults.length} strings)`;
            textScanCurrentPage = 0;
            renderTextScanPage();

            showMessage(`Found ${textScanAllResults.length} text strings`);
        });

        textScanResults.addEventListener('click', (e) => {
            const resultEl = e.target.closest('.text-scan-result');
            if (resultEl) {
                const addr = parseInt(resultEl.dataset.addr);
                goToMemoryAddress(addr);
            }
        });

        // Extract a string from memory address
        // Returns {text, len, termType} or null if not a valid string
        function extractString(startAddr, minLen) {
            let text = '';
            let addr = startAddr;
            let termType = null;

            while (addr < 0x10000) {
                const byte = spectrum.memory.read(addr);

                // Check for null terminator
                if (byte === 0) {
                    if (text.length >= minLen) {
                        termType = 'null';
                        return { text, len: addr - startAddr + 1, termType };
                    }
                    return null;
                }

                // Check for bit 7 set (last char marker)
                const char = byte & 0x7F;
                const bit7set = (byte & 0x80) !== 0;

                // Check if letter or limited punctuation
                const isLetter = (char >= 65 && char <= 90) || (char >= 97 && char <= 122);
                // Only: space(32), !(33), ,(44), -(45), :(58), ;(59), ?(63)
                const isPunct = char === 32 || char === 33 || char === 44 || char === 45 ||
                                char === 58 || char === 59 || char === 63;
                if (isLetter || isPunct) {
                    text += String.fromCharCode(char);
                    addr++;

                    if (bit7set) {
                        // Bit 7 terminator
                        if (text.length >= minLen) {
                            termType = 'bit7';
                            return { text, len: addr - startAddr, termType };
                        }
                        return null;
                    }

                } else {
                    // Non-printable character
                    if (text.length >= minLen) {
                        termType = 'nonprint';
                        return { text, len: addr - startAddr, termType };
                    }
                    return null;
                }
            }

            // End of memory
            if (text.length >= minLen) {
                termType = 'eof';
                return { text, len: addr - startAddr, termType };
            }
            return null;
        }

        // Find dictionary words in a string
        function findDictWords(text) {
            const found = [];
            const textLower = text.toLowerCase();
            const words = textLower.split(/[^a-z]+/);

            for (const word of words) {
                if (word.length >= 3 && dictSet.has(word)) {
                    found.push(word);
                }
            }

            // Also check for multi-word matches without spaces
            for (const dictWord of TEXT_DICTIONARY) {
                const lower = dictWord.toLowerCase();
                if (lower.length >= 4 && textLower.includes(lower) && !found.includes(lower)) {
                    found.push(lower);
                }
            }

            return found;
        }

        // ========== Watches ==========
        const watchesList = document.getElementById('watchesList');
        const watchAddrInput = document.getElementById('watchAddrInput');
        const watchNameInput = document.getElementById('watchNameInput');
        const btnWatchAdd = document.getElementById('btnWatchAdd');
        const btnWatchClear = document.getElementById('btnWatchClear');
        let watches = []; // Array of {addr: number, name: string, prevBytes: Uint8Array}
        const MAX_WATCHES = 10;
        const WATCH_BYTES = 8;

        function loadWatches() {
            const saved = localStorage.getItem('zx_watches');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    // Support old format (number), intermediate (addr only), and new format (addr+name+page)
                    watches = data.map(item => {
                        if (typeof item === 'number') {
                            return { addr: item, name: '', page: null, prevBytes: new Uint8Array(WATCH_BYTES) };
                        }
                        return {
                            addr: item.addr,
                            name: item.name || '',
                            page: item.page !== undefined ? item.page : null,
                            prevBytes: new Uint8Array(WATCH_BYTES)
                        };
                    });
                } catch (e) {
                    watches = [];
                }
            }
        }

        function saveWatches() {
            const data = watches.map(w => ({ addr: w.addr, name: w.name, page: w.page }));
            localStorage.setItem('zx_watches', JSON.stringify(data));
        }

        function readWatchByte(watch, offset) {
            const addr = (watch.addr + offset) & 0xFFFF;
            // If page specified and address is in C000-FFFF range, read from specific bank
            if (watch.page !== null && addr >= 0xC000 && spectrum.memory.machineType !== '48k') {
                const bank = spectrum.memory.getRamBank(watch.page);
                if (bank) {
                    return bank[addr - 0xC000] & 0xFF;
                }
            }
            return spectrum.memory.read(addr) & 0xFF;
        }

        function getWatchDisplayName(watch) {
            // Check if address matches a label
            const label = labelManager.get(watch.addr);
            if (label) {
                return { text: label.name, isLabel: true };
            }
            return { text: watch.name || '', isLabel: false };
        }

        function sortWatches() {
            watches.sort((a, b) => a.addr - b.addr);
        }

        function renderWatches() {
            watchesList.innerHTML = '';
            if (watches.length === 0) {
                watchesList.innerHTML = '<div class="no-breakpoints">No watches</div>';
                return;
            }
            sortWatches();
            watches.forEach((watch, index) => {
                const entry = document.createElement('div');
                entry.className = 'watch-entry';

                // Address display (with page if specified)
                const addrSpan = document.createElement('span');
                addrSpan.className = 'watch-addr';
                const pagePrefix = watch.page !== null ? `${watch.page}:` : '';
                addrSpan.textContent = pagePrefix + watch.addr.toString(16).toUpperCase().padStart(4, '0');

                // Name/label display
                const nameSpan = document.createElement('span');
                nameSpan.dataset.index = index;
                const displayName = getWatchDisplayName(watch);
                nameSpan.className = 'watch-name' + (displayName.isLabel ? ' label' : '');
                nameSpan.textContent = displayName.text;
                nameSpan.title = displayName.isLabel ? 'Label: ' + displayName.text : (watch.name || 'No name');

                const bytesSpan = document.createElement('span');
                bytesSpan.className = 'watch-bytes';
                bytesSpan.dataset.index = index;
                bytesSpan.textContent = '-- -- -- -- -- -- -- --';

                const asciiSpan = document.createElement('span');
                asciiSpan.className = 'watch-ascii';
                asciiSpan.dataset.index = index;
                asciiSpan.textContent = '........';

                const removeBtn = document.createElement('button');
                removeBtn.className = 'watch-remove';
                removeBtn.textContent = '×';
                removeBtn.title = 'Remove watch';
                removeBtn.addEventListener('click', () => {
                    watches.splice(index, 1);
                    saveWatches();
                    renderWatches();
                });

                entry.appendChild(removeBtn);
                entry.appendChild(addrSpan);
                entry.appendChild(nameSpan);
                entry.appendChild(bytesSpan);
                entry.appendChild(asciiSpan);
                watchesList.appendChild(entry);
            });
            updateWatchValues();
        }

        function updateWatchValues() {
            if (!spectrum || !spectrum.memory) return;
            watches.forEach((watch, index) => {
                const bytesSpan = watchesList.querySelector(`.watch-bytes[data-index="${index}"]`);
                const asciiSpan = watchesList.querySelector(`.watch-ascii[data-index="${index}"]`);
                const nameSpan = watchesList.querySelector(`.watch-name[data-index="${index}"]`);
                if (!bytesSpan || !asciiSpan) return;

                // Update name/label (may change after labels load)
                if (nameSpan) {
                    const displayName = getWatchDisplayName(watch);
                    nameSpan.className = 'watch-name' + (displayName.isLabel ? ' label' : '');
                    nameSpan.textContent = displayName.text;
                    nameSpan.title = displayName.isLabel ? 'Label: ' + displayName.text : (watch.name || 'No name');
                }

                let bytesHtml = '';
                let asciiStr = '';
                const currentBytes = new Uint8Array(WATCH_BYTES);

                for (let i = 0; i < WATCH_BYTES; i++) {
                    const byte = readWatchByte(watch, i);
                    currentBytes[i] = byte;
                    const changed = watch.prevBytes[i] !== byte;
                    const hex = byte.toString(16).toUpperCase().padStart(2, '0');
                    if (changed) {
                        bytesHtml += `<span class="changed">${hex}</span> `;
                    } else {
                        bytesHtml += hex + ' ';
                    }
                    asciiStr += (byte >= 32 && byte < 127) ? String.fromCharCode(byte) : '.';
                }

                bytesSpan.innerHTML = bytesHtml;
                asciiSpan.textContent = asciiStr;
                watch.prevBytes = currentBytes;
            });
        }

        if (btnWatchAdd) {
            btnWatchAdd.addEventListener('click', () => {
                if (watches.length >= MAX_WATCHES) {
                    showMessage(`Maximum ${MAX_WATCHES} watches allowed`);
                    return;
                }
                // Parse address from input (supports P:ADDR format)
                const addrStr = watchAddrInput.value.trim();
                if (!addrStr) {
                    showMessage('Enter address', 'error');
                    watchAddrInput.focus();
                    return;
                }

                let addr, page = null;
                const parsed = spectrum.parseAddressSpec(addrStr);
                if (parsed) {
                    addr = parsed.start;
                    page = parsed.page;
                } else {
                    // Fallback: try simple hex parse
                    addr = parseInt(addrStr, 16);
                    if (isNaN(addr) || addr < 0 || addr > 0xFFFF) {
                        showMessage('Invalid address', 'error');
                        watchAddrInput.focus();
                        return;
                    }
                }

                const name = watchNameInput.value.trim();
                watches.push({
                    addr: addr,
                    name: name,
                    page: page,
                    prevBytes: new Uint8Array(WATCH_BYTES)
                });
                saveWatches();
                renderWatches();
                // Clear inputs
                watchAddrInput.value = '';
                watchNameInput.value = '';
                const pageStr = page !== null ? `${page}:` : '';
                showMessage(`Watch added: ${pageStr}${addr.toString(16).toUpperCase().padStart(4, '0')}${name ? ' (' + name + ')' : ''}`);
            });
        } else {
            console.error('btnWatchAdd not found');
        }

        if (btnWatchClear) {
            btnWatchClear.addEventListener('click', () => {
                if (watches.length === 0) return;
                watches = [];
                saveWatches();
                renderWatches();
                showMessage('All watches cleared');
            });
        } else {
            console.error('btnWatchClear not found');
        }

        // Load watches on startup
        loadWatches();
        renderWatches();

        // ========== Assembler ==========
        const asmEditor = document.getElementById('asmEditor');
        const asmHighlight = document.getElementById('asmHighlight');
        const asmLineNumbers = document.getElementById('asmLineNumbers');
        const asmOutput = document.getElementById('asmOutput');
        // asmStatus removed - status shown in output log
        const btnAsmAssemble = document.getElementById('btnAsmAssemble');
        const btnAsmClear = document.getElementById('btnAsmClear');
        const btnAsmNew = document.getElementById('btnAsmNew');
        const btnAsmLoad = document.getElementById('btnAsmLoad');
        const asmFileInput = document.getElementById('asmFileInput');
        const btnAsmInject = document.getElementById('btnAsmInject');
        const btnAsmDebug = document.getElementById('btnAsmDebug');
        const btnAsmDownload = document.getElementById('btnAsmDownload');
        const chkAsmUnusedLabels = document.getElementById('chkAsmUnusedLabels');
        const chkAsmShowCompiled = document.getElementById('chkAsmShowCompiled');
        const asmDefinesInput = document.getElementById('asmDefines');
        const asmDetectedDefines = document.getElementById('asmDetectedDefines');
        const btnAsmExport = document.getElementById('btnAsmExport');
        const asmFileTabs = document.getElementById('asmFileTabs');
        const asmMainFileLabel = document.getElementById('asmMainFileLabel');
        const asmFilesDropdown = document.querySelector('.asm-files-dropdown');
        const btnAsmFiles = document.getElementById('btnAsmFiles');
        const asmFilesList = document.getElementById('asmFilesList');
        const fileSelectorDialog = document.getElementById('fileSelectorDialog');
        const fileSelectorBody = document.getElementById('fileSelectorBody');
        const fileSelectorTitle = document.getElementById('fileSelectorTitle');
        const btnFileSelectorClose = document.getElementById('btnFileSelectorClose');

        // Current project state
        let currentProjectMainFile = null;  // Main file for compilation
        let currentOpenFile = null;         // Currently displayed file in editor
        let openTabs = [];                  // List of open tab paths
        let fileModified = {};              // Track modified state per file

        // Show/hide buttons based on project state
        function updateProjectButtons() {
            const fileCount = Object.keys(VFS.files).length;
            const hasFiles = fileCount > 0;
            const hasMultipleFiles = fileCount > 1;
            const hasContent = asmEditor && asmEditor.value.trim().length > 0;

            if (btnAsmExport) {
                btnAsmExport.style.display = hasFiles ? 'inline-block' : 'none';
            }
            // Files button: always visible, disabled when 0 or 1 file
            if (btnAsmFiles) {
                btnAsmFiles.disabled = !hasMultipleFiles;
            }
            if (asmMainFileLabel) {
                if (currentProjectMainFile && hasFiles) {
                    asmMainFileLabel.style.display = 'inline';
                    asmMainFileLabel.textContent = currentProjectMainFile.split('/').pop();
                } else {
                    asmMainFileLabel.style.display = 'none';
                }
            }
            // Enable Assemble if there's content in editor or files in VFS
            if (btnAsmAssemble) {
                btnAsmAssemble.disabled = !(hasContent || hasFiles);
            }
        }

        // Update files dropdown list
        function updateFilesList() {
            if (!asmFilesList) return;
            asmFilesList.innerHTML = '';

            const files = VFS.listFiles();

            // Sort by directory then filename
            files.sort((a, b) => {
                const dirA = a.includes('/') ? a.substring(0, a.lastIndexOf('/')) : '';
                const dirB = b.includes('/') ? b.substring(0, b.lastIndexOf('/')) : '';
                const nameA = a.split('/').pop().toLowerCase();
                const nameB = b.split('/').pop().toLowerCase();

                // First compare directories
                if (dirA !== dirB) {
                    // Root files (no directory) come first
                    if (!dirA) return -1;
                    if (!dirB) return 1;
                    return dirA.localeCompare(dirB);
                }
                // Then compare filenames
                return nameA.localeCompare(nameB);
            });

            for (const path of files) {
                const file = VFS.files[path];
                const name = path.split('/').pop();
                const dir = path.includes('/') ? path.substring(0, path.lastIndexOf('/') + 1) : '';
                const isBinary = file.binary;
                const isMain = path === currentProjectMainFile;
                const isOpen = openTabs.includes(path);
                const size = isBinary ? file.content.length : file.content.length;

                const item = document.createElement('div');
                item.className = 'asm-files-list-item';
                if (isMain) item.classList.add('main');
                if (isBinary) item.classList.add('binary');
                if (isOpen) item.classList.add('open');

                const icon = isBinary ? '📦' : (isMain ? '▶' : '📄');
                const sizeStr = size < 1024 ? `${size}b` : `${(size/1024).toFixed(1)}K`;
                const dirHtml = dir ? `<span class="file-dir">${dir}</span>` : '';

                item.innerHTML = `
                    <span class="file-icon">${icon}</span>
                    <span class="file-name" title="${path}">${dirHtml}${name}</span>
                    <span class="file-size">${sizeStr}</span>
                `;

                item.addEventListener('click', () => {
                    openFileTab(path);
                    asmFilesList.classList.remove('show');
                });

                asmFilesList.appendChild(item);
            }
        }

        // Open a file in a tab
        function openFileTab(path) {
            const file = VFS.files[path];
            if (!file) {
                console.warn('openFileTab: file not found:', path);
                return;
            }

            // Save current editor content to previous file (only if it's a text file)
            if (currentOpenFile && VFS.files[currentOpenFile] && !VFS.files[currentOpenFile].binary) {
                VFS.files[currentOpenFile].content = asmEditor.value;
            }

            // Add to open tabs if not already open
            if (!openTabs.includes(path)) {
                openTabs.push(path);
            }

            // Load file content into editor
            if (file.binary) {
                asmEditor.value = `; Binary file: ${path}\n; Size: ${file.content.length} bytes\n; Cannot edit binary files`;
                asmEditor.disabled = true;
            } else {
                asmEditor.value = file.content || '';
                asmEditor.disabled = false;
            }

            currentOpenFile = path;
            updateLineNumbers();
            updateHighlight();
            updateFileTabs();

            // Update defines dropdown when opening main file
            if (path === currentProjectMainFile || !currentProjectMainFile) {
                updateDefinesDropdown();
            }
        }

        // Close a file tab
        function closeFileTab(path) {
            const idx = openTabs.indexOf(path);
            if (idx === -1) return;

            openTabs.splice(idx, 1);
            delete fileModified[path];

            // If closing current file, switch to another
            if (currentOpenFile === path) {
                if (openTabs.length > 0) {
                    openFileTab(openTabs[Math.min(idx, openTabs.length - 1)]);
                } else {
                    currentOpenFile = null;
                    asmEditor.value = '';
                    asmEditor.disabled = false;
                    updateLineNumbers();
                    updateHighlight();
                }
            }

            updateFileTabs();
        }

        // Update file tabs display
        function updateFileTabs() {
            if (!asmFileTabs) return;
            asmFileTabs.innerHTML = '';

            for (const path of openTabs) {
                const file = VFS.files[path];
                if (!file) continue;

                const tab = document.createElement('div');
                tab.className = 'asm-file-tab';
                if (path === currentOpenFile) tab.classList.add('active');
                if (path === currentProjectMainFile) tab.classList.add('main');
                if (file.binary) tab.classList.add('binary');
                if (fileModified[path]) tab.classList.add('modified');

                const name = path.split('/').pop();
                tab.innerHTML = `<span class="tab-name" title="${path}">${name}</span><span class="tab-close">×</span>`;

                // Click on tab (anywhere except close button) to switch
                tab.addEventListener('click', (e) => {
                    if (!e.target.classList.contains('tab-close')) {
                        openFileTab(path);
                    }
                });

                // Close button
                tab.querySelector('.tab-close').addEventListener('click', (e) => {
                    e.stopPropagation();
                    closeFileTab(path);
                });

                // Right-click to set as main file
                tab.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    if (!file.binary) {
                        currentProjectMainFile = path;
                        updateFileTabs();
                        updateProjectButtons();
                        showMessage(`Main file set to: ${name}`);
                    }
                });

                asmFileTabs.appendChild(tab);
            }
        }

        // Show main file selection dialog (returns a Promise)
        function showMainFileDialog(files, title = 'Select Main File') {
            return new Promise((resolve) => {
                const asmFiles = files.filter(f => {
                    const ext = '.' + f.split('.').pop().toLowerCase();
                    return ['.asm', '.z80', '.s', '.a80'].includes(ext);
                });

                if (asmFiles.length === 0) {
                    showMessage('No assembly files found');
                    resolve(null);
                    return;
                }

                if (asmFiles.length === 1) {
                    resolve(asmFiles[0]);
                    return;
                }

                // Auto-detect main file
                const detected = VFS.findMainFile();

                // Sort files: detected main file first, then alphabetically
                asmFiles.sort((a, b) => a.localeCompare(b));
                if (detected) {
                    // Find detected file (exact match or case-insensitive)
                    let idx = asmFiles.indexOf(detected);
                    if (idx === -1) {
                        const detectedLower = detected.toLowerCase();
                        idx = asmFiles.findIndex(f => f.toLowerCase() === detectedLower);
                    }
                    if (idx > 0) {
                        const mainFile = asmFiles.splice(idx, 1)[0];
                        asmFiles.unshift(mainFile);
                    }
                }

                // Build dialog content
                fileSelectorTitle.textContent = title;
                fileSelectorBody.innerHTML = '';

                for (const path of asmFiles) {
                    const name = path.split('/').pop();
                    const isDetected = path === detected;

                    const item = document.createElement('div');
                    item.className = 'file-selector-item';
                    if (isDetected) item.classList.add('detected');

                    item.innerHTML = `
                        <span class="item-icon">📄</span>
                        <span class="item-name">${path}</span>
                        ${isDetected ? '<span class="item-hint">detected</span>' : ''}
                    `;

                    item.addEventListener('click', () => {
                        fileSelectorDialog.classList.add('hidden');
                        resolve(path);
                    });

                    fileSelectorBody.appendChild(item);
                }

                // Show dialog
                fileSelectorDialog.classList.remove('hidden');

                // Handle close button - use detected or first file
                const closeHandler = () => {
                    fileSelectorDialog.classList.add('hidden');
                    resolve(detected || asmFiles[0]);
                };
                btnFileSelectorClose.onclick = closeHandler;

                // Click outside to close
                fileSelectorDialog.onclick = (e) => {
                    if (e.target === fileSelectorDialog) {
                        closeHandler();
                    }
                };
            });
        }

        // Z80 instructions set for highlighting
        const Z80_INSTRUCTIONS = new Set([
            'ADC', 'ADD', 'AND', 'BIT', 'CALL', 'CCF', 'CP', 'CPD', 'CPDR', 'CPI', 'CPIR',
            'CPL', 'DAA', 'DEC', 'DI', 'DJNZ', 'EI', 'EX', 'EXX', 'HALT', 'IM', 'IN',
            'INC', 'IND', 'INDR', 'INI', 'INIR', 'JP', 'JR', 'LD', 'LDD', 'LDDR', 'LDI',
            'LDIR', 'NEG', 'NOP', 'OR', 'OTDR', 'OTIR', 'OUT', 'OUTD', 'OUTI', 'POP',
            'PUSH', 'RES', 'RET', 'RETI', 'RETN', 'RL', 'RLA', 'RLC', 'RLCA', 'RLD',
            'RR', 'RRA', 'RRC', 'RRCA', 'RRD', 'RST', 'SBC', 'SCF', 'SET', 'SLA', 'SLL',
            'SRA', 'SRL', 'SUB', 'XOR', 'DEFB', 'DEFW', 'DEFS', 'DB', 'DW', 'DS', 'DEFM',
            'DM', 'BYTE', 'WORD', 'BLOCK'
        ]);

        const Z80_DIRECTIVES = new Set([
            'ORG', 'EQU', 'INCLUDE', 'INCBIN', 'MACRO', 'ENDM', 'REPT', 'ENDR',
            'IF', 'ELSE', 'ENDIF', 'IFDEF', 'IFNDEF', 'ALIGN', 'PHASE', 'DEPHASE',
            'END', 'ASSERT', 'DEVICE', 'SLOT', 'PAGE', 'MODULE', 'ENDMODULE',
            'STRUCT', 'ENDS', 'SECTION', 'ENDSECTION', 'OUTPUT', 'LABELSLIST',
            'DISPLAY', 'SHELLEXEC', 'DEFINE', 'UNDEFINE', 'DUP', 'EDUP', 'PROC', 'ENDP'
        ]);

        const Z80_REGISTERS = new Set([
            'A', 'B', 'C', 'D', 'E', 'H', 'L', 'F', 'I', 'R',
            'AF', 'BC', 'DE', 'HL', 'IX', 'IY', 'SP', 'PC',
            'IXH', 'IXL', 'IYH', 'IYL', "AF'"
        ]);

        const Z80_CONDITIONS = new Set(['Z', 'NZ', 'C', 'NC', 'PE', 'PO', 'P', 'M']);

        // Simple tokenizer for syntax highlighting
        function tokenizeAsmLine(line) {
            const tokens = [];
            let pos = 0;

            while (pos < line.length) {
                const ch = line[pos];

                // Whitespace
                if (ch === ' ' || ch === '\t') {
                    let start = pos;
                    while (pos < line.length && (line[pos] === ' ' || line[pos] === '\t')) {
                        pos++;
                    }
                    tokens.push({ type: 'whitespace', value: line.slice(start, pos) });
                    continue;
                }

                // Comment (;)
                if (ch === ';') {
                    tokens.push({ type: 'comment', value: line.slice(pos) });
                    break;
                }

                // String
                if (ch === '"' || ch === "'") {
                    const quote = ch;
                    let start = pos;
                    pos++;
                    while (pos < line.length && line[pos] !== quote) {
                        if (line[pos] === '\\' && pos + 1 < line.length) pos++;
                        pos++;
                    }
                    if (pos < line.length) pos++; // closing quote
                    tokens.push({ type: 'string', value: line.slice(start, pos) });
                    continue;
                }

                // Number: $hex, #hex, 0x, %, binary, decimal, or suffix-based
                if (/[0-9$#%]/.test(ch)) {
                    let start = pos;
                    if (ch === '$' || ch === '#') {
                        pos++;
                        while (pos < line.length && /[0-9a-fA-F_]/.test(line[pos])) pos++;
                    } else if (ch === '%') {
                        pos++;
                        while (pos < line.length && /[01_]/.test(line[pos])) pos++;
                    } else if (ch === '0' && pos + 1 < line.length && (line[pos + 1] === 'x' || line[pos + 1] === 'X')) {
                        pos += 2;
                        while (pos < line.length && /[0-9a-fA-F_]/.test(line[pos])) pos++;
                    } else {
                        while (pos < line.length && /[0-9a-fA-F_]/.test(line[pos])) pos++;
                        if (pos < line.length && /[hHbBoOdDqQ]/.test(line[pos])) pos++;
                    }
                    tokens.push({ type: 'number', value: line.slice(start, pos) });
                    continue;
                }

                // Identifier (label, instruction, register)
                if (/[a-zA-Z_.]/.test(ch) || ch === '@') {
                    let start = pos;
                    pos++;
                    while (pos < line.length && /[a-zA-Z0-9_]/.test(line[pos])) pos++;
                    if (pos < line.length && line[pos] === "'") pos++; // AF'
                    const value = line.slice(start, pos);
                    const upper = value.toUpperCase();

                    // Check for colon after (label definition)
                    let isLabel = false;
                    let colonPos = pos;
                    while (colonPos < line.length && (line[colonPos] === ' ' || line[colonPos] === '\t')) colonPos++;
                    if (colonPos < line.length && line[colonPos] === ':') {
                        isLabel = true;
                    }
                    // Also check if starts with . (local label)
                    if (value.startsWith('.')) isLabel = true;

                    if (Z80_INSTRUCTIONS.has(upper)) {
                        tokens.push({ type: 'instruction', value });
                    } else if (Z80_DIRECTIVES.has(upper)) {
                        tokens.push({ type: 'directive', value });
                    } else if (Z80_REGISTERS.has(upper) || Z80_CONDITIONS.has(upper)) {
                        tokens.push({ type: 'register', value });
                    } else if (isLabel || start === 0) {
                        tokens.push({ type: 'label', value });
                    } else {
                        tokens.push({ type: 'identifier', value });
                    }
                    continue;
                }

                // Operators and punctuation
                if (ch === '(' || ch === ')' || ch === '[' || ch === ']') {
                    tokens.push({ type: 'paren', value: ch });
                    pos++;
                    continue;
                }

                if (ch === ':') {
                    tokens.push({ type: 'colon', value: ch });
                    pos++;
                    continue;
                }

                if (ch === ',') {
                    tokens.push({ type: 'comma', value: ch });
                    pos++;
                    continue;
                }

                if (/[+\-*\/%&|^~<>=!]/.test(ch)) {
                    let start = pos;
                    pos++;
                    // Handle two-char operators
                    if (pos < line.length && /[<>=&|]/.test(line[pos])) pos++;
                    tokens.push({ type: 'operator', value: line.slice(start, pos) });
                    continue;
                }

                // Unknown char
                tokens.push({ type: 'text', value: ch });
                pos++;
            }

            return tokens;
        }

        function escapeHtml(text) {
            return text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;');
        }

        function highlightAsmCode(code) {
            const lines = code.split('\n');
            return lines.map(line => {
                const tokens = tokenizeAsmLine(line);
                return tokens.map(token => {
                    const escaped = escapeHtml(token.value);
                    switch (token.type) {
                        case 'instruction':
                            return `<span class="asm-hl-instruction">${escaped}</span>`;
                        case 'directive':
                            return `<span class="asm-hl-directive">${escaped}</span>`;
                        case 'register':
                            return `<span class="asm-hl-register">${escaped}</span>`;
                        case 'number':
                            return `<span class="asm-hl-number">${escaped}</span>`;
                        case 'string':
                            return `<span class="asm-hl-string">${escaped}</span>`;
                        case 'label':
                            return `<span class="asm-hl-label">${escaped}</span>`;
                        case 'comment':
                            return `<span class="asm-hl-comment">${escaped}</span>`;
                        case 'paren':
                            return `<span class="asm-hl-paren">${escaped}</span>`;
                        case 'operator':
                            return `<span class="asm-hl-operator">${escaped}</span>`;
                        default:
                            return escaped;
                    }
                }).join('');
            }).join('\n');
        }

        function updateLineNumbers() {
            const lines = asmEditor.value.split('\n');
            const lineCount = lines.length;
            // Build line numbers without trailing newline to match textarea height
            const numbers = [];
            for (let i = 1; i <= lineCount; i++) {
                numbers.push(i);
            }
            asmLineNumbers.textContent = numbers.join('\n');
        }

        function updateHighlight() {
            try {
                // Use exact same content as textarea - no extra newline
                // Add a zero-width space at end to prevent collapse if needed
                const code = asmEditor.value;
                asmHighlight.innerHTML = highlightAsmCode(code) + '\u200B';
                asmEditor.classList.add('highlighting');
            } catch (e) {
                console.error('Highlight error:', e);
                asmEditor.classList.remove('highlighting');
            }
        }

        function syncScroll() {
            asmHighlight.scrollTop = asmEditor.scrollTop;
            asmHighlight.scrollLeft = asmEditor.scrollLeft;
            asmLineNumbers.scrollTop = asmEditor.scrollTop;
        }

        // Sync editor to VFS when in project mode
        function syncEditorToVFS() {
            if (currentOpenFile && VFS.files[currentOpenFile] && !VFS.files[currentOpenFile].binary) {
                VFS.files[currentOpenFile].content = asmEditor.value;
            }
        }

        // Editor event listeners
        if (asmEditor) {
            // Debounce timer for defines detection
            let definesUpdateTimer = null;

            asmEditor.addEventListener('input', () => {
                updateLineNumbers();
                updateHighlight();
                syncEditorToVFS();
                updateProjectButtons();

                // Debounced update of defines dropdown (only when editing main file)
                if (!currentOpenFile || currentOpenFile === currentProjectMainFile) {
                    clearTimeout(definesUpdateTimer);
                    definesUpdateTimer = setTimeout(updateDefinesDropdown, 500);
                }
            });

            asmEditor.addEventListener('scroll', syncScroll);

            // Sync on click and cursor movement (browser may auto-scroll)
            asmEditor.addEventListener('click', () => {
                requestAnimationFrame(syncScroll);
            });
            asmEditor.addEventListener('keyup', (e) => {
                // Arrow keys, Home, End, Page Up/Down may cause auto-scroll
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight',
                     'Home', 'End', 'PageUp', 'PageDown'].includes(e.key)) {
                    requestAnimationFrame(syncScroll);
                }
            });
            asmEditor.addEventListener('focus', syncScroll);

            // Handle paste - need delay for content to be inserted
            asmEditor.addEventListener('paste', () => {
                setTimeout(() => {
                    updateLineNumbers();
                    updateHighlight();
                    syncScroll();
                    syncEditorToVFS();
                    updateProjectButtons();
                }, 0);
            });

            asmEditor.addEventListener('keydown', (e) => {
                // Tab inserts actual tab
                if (e.key === 'Tab') {
                    e.preventDefault();
                    const start = asmEditor.selectionStart;
                    const end = asmEditor.selectionEnd;
                    asmEditor.value = asmEditor.value.substring(0, start) + '\t' + asmEditor.value.substring(end);
                    asmEditor.selectionStart = asmEditor.selectionEnd = start + 1;
                    updateLineNumbers();
                    updateHighlight();
                }
                // Ctrl+F - Find
                if (e.ctrlKey && e.key === 'f') {
                    e.preventDefault();
                    openSearchBar(false);
                }
                // Ctrl+H or Ctrl+R - Replace
                if (e.ctrlKey && (e.key === 'h' || e.key === 'r')) {
                    e.preventDefault();
                    openSearchBar(true);
                }
                // F3 - Find Next
                if (e.key === 'F3' && !e.shiftKey) {
                    e.preventDefault();
                    findNext();
                }
                // Shift+F3 - Find Previous
                if (e.key === 'F3' && e.shiftKey) {
                    e.preventDefault();
                    findPrev();
                }
                // Escape - Close search
                if (e.key === 'Escape' && asmSearchBar.style.display !== 'none') {
                    closeSearchBar();
                }
            });

            // Drag & drop file loading
            const asmEditorContainer = asmEditor.parentElement;

            asmEditorContainer.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                asmEditorContainer.classList.add('drag-over');
            });

            asmEditorContainer.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                asmEditorContainer.classList.remove('drag-over');
            });

            asmEditorContainer.addEventListener('drop', async (e) => {
                e.preventDefault();
                e.stopPropagation();
                asmEditorContainer.classList.remove('drag-over');

                const files = e.dataTransfer.files;
                if (files && files.length > 0) {
                    await loadAsmFiles(files);
                }
            });

            // Initial update
            updateLineNumbers();
            updateHighlight();
        }

        // Find existing files in VFS with the same basename
        function findFilesByBasename(basename) {
            const matches = [];
            const basenameLower = basename.toLowerCase();
            for (const path of VFS.listFiles()) {
                const pathBasename = path.split('/').pop().toLowerCase();
                if (pathBasename === basenameLower) {
                    matches.push(path);
                }
            }
            return matches;
        }

        // Show dialog to choose where to put a file
        async function showFileReplaceDialog(filename, existingPaths) {
            return new Promise((resolve) => {
                const overlay = document.createElement('div');
                overlay.className = 'modal-overlay';
                overlay.innerHTML = `
                    <div class="modal" style="max-width: 400px;">
                        <h3 style="margin-top:0;">File already exists</h3>
                        <p>A file named "<b>${filename}</b>" already exists in the project.</p>
                        <p>Where should the new file be placed?</p>
                        <div id="fileReplaceOptions" style="margin: 15px 0;"></div>
                        <div style="text-align: right;">
                            <button id="fileReplaceCancel" style="margin-right: 10px;">Cancel</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(overlay);

                const optionsDiv = overlay.querySelector('#fileReplaceOptions');

                // Add option to replace each existing file
                for (const path of existingPaths) {
                    const btn = document.createElement('button');
                    btn.style.cssText = 'display: block; width: 100%; margin: 5px 0; text-align: left; padding: 8px;';
                    btn.textContent = `Replace: ${path}`;
                    btn.onclick = () => {
                        document.body.removeChild(overlay);
                        resolve({ action: 'replace', path: path });
                    };
                    optionsDiv.appendChild(btn);
                }

                // Add option to create new file at root
                const rootPath = filename.toLowerCase();
                if (!existingPaths.includes(rootPath)) {
                    const btn = document.createElement('button');
                    btn.style.cssText = 'display: block; width: 100%; margin: 5px 0; text-align: left; padding: 8px;';
                    btn.textContent = `Add as new: ${filename}`;
                    btn.onclick = () => {
                        document.body.removeChild(overlay);
                        resolve({ action: 'new', path: filename });
                    };
                    optionsDiv.appendChild(btn);
                }

                overlay.querySelector('#fileReplaceCancel').onclick = () => {
                    document.body.removeChild(overlay);
                    resolve({ action: 'cancel' });
                };
            });
        }

        // Reusable file loading function (for Load button and drag & drop)
        async function loadAsmFiles(files) {
            const textExtensions = ['.asm', '.z80', '.s', '.a80', '.inc', '.txt', '.def', '.h'];
            let totalAdded = 0;
            let lastAddedFile = null;
            let needsMainFile = !currentProjectMainFile;

            try {
                for (const file of files) {
                    const arrayBuffer = await file.arrayBuffer();

                    // Check if it's a ZIP file
                    if (file.name.toLowerCase().endsWith('.zip') && ZipLoader.isZip(arrayBuffer)) {
                        const zipFiles = await ZipLoader.extract(arrayBuffer);

                        // Track which files from ZIP will update open tabs
                        const updatedPaths = [];

                        for (const f of zipFiles) {
                            if (f.name.endsWith('/') || f.name.startsWith('.') || f.name.includes('/.')) continue;

                            const ext = '.' + f.name.split('.').pop().toLowerCase();
                            const isText = textExtensions.includes(ext);
                            const normalizedPath = VFS.normalizePath(f.name);

                            // Check if this file is already open in a tab
                            if (openTabs.includes(normalizedPath)) {
                                updatedPaths.push(normalizedPath);
                            }

                            if (isText) {
                                const decoder = new TextDecoder('utf-8');
                                VFS.addFile(f.name, decoder.decode(f.data));
                                if (['.asm', '.z80', '.s', '.a80'].includes(ext)) {
                                    lastAddedFile = normalizedPath;
                                }
                            } else {
                                VFS.addBinaryFile(f.name, f.data);
                            }
                            totalAdded++;
                        }

                        // Remove updated files from open tabs so they get refreshed
                        for (const path of updatedPaths) {
                            const idx = openTabs.indexOf(path);
                            if (idx !== -1) {
                                openTabs.splice(idx, 1);
                            }
                        }

                        // If current file was updated, clear it to prevent old content being saved back
                        if (currentOpenFile && updatedPaths.includes(currentOpenFile)) {
                            currentOpenFile = null;
                        }

                        // Prefer opening the main file if it exists in the ZIP
                        if (currentProjectMainFile && updatedPaths.includes(currentProjectMainFile)) {
                            lastAddedFile = currentProjectMainFile;
                        }
                    } else {
                        // Single file - check for duplicates
                        const ext = '.' + file.name.split('.').pop().toLowerCase();
                        const isText = textExtensions.includes(ext);
                        const basename = file.name.split('/').pop();
                        const existingFiles = findFilesByBasename(basename);

                        let targetPath = file.name;

                        if (existingFiles.length > 0) {
                            // Check if exact path match exists
                            const normalizedInput = VFS.normalizePath(file.name);
                            const exactMatch = existingFiles.find(p => p === normalizedInput);

                            if (exactMatch) {
                                // Exact match - just replace
                                targetPath = exactMatch;
                                // If this file is currently open, clear currentOpenFile
                                // to prevent openFileTab from saving old content back
                                if (currentOpenFile === exactMatch) {
                                    currentOpenFile = null;
                                }
                                // Remove from open tabs (will reopen with new content)
                                const oldTabIdx = openTabs.indexOf(exactMatch);
                                if (oldTabIdx !== -1) {
                                    openTabs.splice(oldTabIdx, 1);
                                }
                            } else {
                                // Same basename but different path - ask user
                                const result = await showFileReplaceDialog(basename, existingFiles);
                                if (result.action === 'cancel') {
                                    continue; // Skip this file
                                } else if (result.action === 'replace') {
                                    targetPath = result.path;
                                    // If this file is currently open, clear currentOpenFile
                                    // to prevent openFileTab from saving old content back
                                    if (currentOpenFile === result.path) {
                                        currentOpenFile = null;
                                    }
                                    // Close old tab if open (will reopen with new content)
                                    const oldTabIdx = openTabs.indexOf(result.path);
                                    if (oldTabIdx !== -1) {
                                        openTabs.splice(oldTabIdx, 1);
                                    }
                                } else {
                                    targetPath = result.path;
                                }
                            }
                        }

                        if (isText) {
                            const decoder = new TextDecoder('utf-8');
                            VFS.addFile(targetPath, decoder.decode(new Uint8Array(arrayBuffer)));
                            if (['.asm', '.z80', '.s', '.a80'].includes(ext)) {
                                lastAddedFile = VFS.normalizePath(targetPath);
                            }
                        } else {
                            VFS.addBinaryFile(targetPath, new Uint8Array(arrayBuffer));
                        }
                        totalAdded++;
                    }
                }

                // If no main file set and we added source files, ask to select
                if (needsMainFile && lastAddedFile) {
                    const allFiles = VFS.listFiles();
                    const mainFile = await showMainFileDialog(allFiles);
                    if (mainFile) {
                        currentProjectMainFile = mainFile;
                        openFileTab(mainFile);
                    }
                } else if (lastAddedFile) {
                    // Open the last added source file
                    openFileTab(lastAddedFile);
                }

                updateProjectButtons();
                updateDefinesDropdown();
                updateFileTabs();
                showMessage(totalAdded > 0 ? `Added/updated ${totalAdded} file(s)` : 'No files added');

            } catch (err) {
                console.error('Load error:', err);
                showMessage('Error loading: ' + err.message);
            }
        }

        // Search/Replace functionality
        const asmSearchBar = document.getElementById('asmSearchBar');
        const asmSearchInput = document.getElementById('asmSearchInput');
        const asmReplaceInput = document.getElementById('asmReplaceInput');
        const asmReplaceRow = document.getElementById('asmReplaceRow');
        const asmSearchCount = document.getElementById('asmSearchCount');
        const chkAsmSearchCase = document.getElementById('chkAsmSearchCase');
        const btnAsmFindNext = document.getElementById('btnAsmFindNext');
        const btnAsmFindPrev = document.getElementById('btnAsmFindPrev');
        const btnAsmReplace = document.getElementById('btnAsmReplace');
        const btnAsmReplaceAll = document.getElementById('btnAsmReplaceAll');
        const btnAsmSearchAll = document.getElementById('btnAsmSearchAll');
        const btnAsmSearchClose = document.getElementById('btnAsmSearchClose');
        const asmSearchResults = document.getElementById('asmSearchResults');

        let searchMatches = [];
        let currentMatchIndex = -1;

        function openSearchBar(showReplace) {
            asmSearchBar.style.display = 'flex';
            asmReplaceRow.style.display = showReplace ? 'flex' : 'none';
            asmSearchResults.style.display = 'none';
            asmSearchInput.focus();
            // Pre-fill with selected text
            const selected = asmEditor.value.substring(asmEditor.selectionStart, asmEditor.selectionEnd);
            if (selected && !selected.includes('\n')) {
                asmSearchInput.value = selected;
            }
            asmSearchInput.select();
            updateSearchMatches();
        }

        function closeSearchBar() {
            asmSearchBar.style.display = 'none';
            asmSearchResults.style.display = 'none';
            asmEditor.focus();
        }

        function searchAllFiles() {
            const query = asmSearchInput.value;
            if (!query) {
                asmSearchResults.style.display = 'none';
                return;
            }

            const caseSensitive = chkAsmSearchCase.checked;
            const results = [];

            // Get all files from VFS
            const files = VFS.listFiles();
            if (files.length === 0) {
                // Just search current editor
                const currentResults = searchInText(asmEditor.value, query, caseSensitive, currentOpenFile || 'untitled');
                results.push(...currentResults);
            } else {
                // Save current editor to VFS first
                if (currentOpenFile && VFS.files[currentOpenFile] && !VFS.files[currentOpenFile].binary) {
                    VFS.files[currentOpenFile].content = asmEditor.value;
                }
                // Search all files (skip binary files)
                for (const filename of files) {
                    const file = VFS.files[filename];
                    if (file && !file.binary) {
                        const fileResults = searchInText(file.content, query, caseSensitive, filename);
                        results.push(...fileResults);
                    }
                }
            }

            // Display results
            if (results.length === 0) {
                asmSearchResults.innerHTML = '<div class="asm-search-results-header">No results found</div>';
            } else {
                let html = `<div class="asm-search-results-header">Found ${results.length} result${results.length !== 1 ? 's' : ''} in ${new Set(results.map(r => r.file)).size} file${new Set(results.map(r => r.file)).size !== 1 ? 's' : ''}</div>`;
                for (const r of results) {
                    const escapedText = escapeHtml(r.lineText);
                    const highlightedText = highlightMatch(escapedText, query, caseSensitive);
                    html += `<div class="asm-search-result-item" data-file="${escapeHtml(r.file)}" data-line="${r.lineNum}" data-col="${r.col}">`;
                    html += `<span class="asm-search-result-file">${escapeHtml(r.file)}</span>`;
                    html += `<span class="asm-search-result-line">${r.lineNum}</span>`;
                    html += `<span class="asm-search-result-text">${highlightedText}</span>`;
                    html += `</div>`;
                }
                asmSearchResults.innerHTML = html;

                // Add click handlers
                asmSearchResults.querySelectorAll('.asm-search-result-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const file = item.dataset.file;
                        const line = parseInt(item.dataset.line);
                        const col = parseInt(item.dataset.col);
                        goToSearchResult(file, line, col, query.length);
                    });
                });
            }
            asmSearchResults.style.display = 'block';
        }

        function searchInText(text, query, caseSensitive, filename) {
            const results = [];
            const lines = text.split('\n');
            const searchQuery = caseSensitive ? query : query.toLowerCase();

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const searchLine = caseSensitive ? line : line.toLowerCase();
                let col = 0;
                while ((col = searchLine.indexOf(searchQuery, col)) !== -1) {
                    results.push({
                        file: filename,
                        lineNum: i + 1,
                        col: col,
                        lineText: line.trim()
                    });
                    col += searchQuery.length;
                }
            }
            return results;
        }

        function highlightMatch(text, query, caseSensitive) {
            const flags = caseSensitive ? 'g' : 'gi';
            const regex = new RegExp(query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), flags);
            return text.replace(regex, match => `<span class="asm-search-result-match">${match}</span>`);
        }

        function goToSearchResult(file, lineNum, col, matchLen) {
            // If different file, switch to it
            if (file !== currentOpenFile && VFS.listFiles().length > 0) {
                // Save current file first
                if (currentOpenFile && VFS.files[currentOpenFile] && !VFS.files[currentOpenFile].binary) {
                    VFS.files[currentOpenFile].content = asmEditor.value;
                }
                // Open target file
                const targetFile = VFS.files[file];
                if (targetFile && !targetFile.binary) {
                    if (!openTabs.includes(file)) {
                        openTabs.push(file);
                    }
                    currentOpenFile = file;
                    asmEditor.value = targetFile.content;
                    updateFileTabs();
                    updateLineNumbers();
                    updateHighlight();
                }
            }

            // Go to line and select match
            const lines = asmEditor.value.split('\n');
            let pos = 0;
            for (let i = 0; i < lineNum - 1 && i < lines.length; i++) {
                pos += lines[i].length + 1;
            }
            pos += col;
            asmEditor.focus();
            asmEditor.setSelectionRange(pos, pos + matchLen);
            // Scroll into view
            const lineHeight = 18;
            const scrollTop = (lineNum - 5) * lineHeight;
            asmEditor.scrollTop = Math.max(0, scrollTop);
        }

        function updateSearchMatches() {
            const query = asmSearchInput.value;
            searchMatches = [];
            currentMatchIndex = -1;

            if (!query) {
                asmSearchCount.textContent = '';
                return;
            }

            const text = asmEditor.value;
            const caseSensitive = chkAsmSearchCase.checked;
            const searchText = caseSensitive ? text : text.toLowerCase();
            const searchQuery = caseSensitive ? query : query.toLowerCase();

            let pos = 0;
            while ((pos = searchText.indexOf(searchQuery, pos)) !== -1) {
                searchMatches.push(pos);
                pos += searchQuery.length;
            }

            if (searchMatches.length > 0) {
                // Find closest match to cursor
                const cursor = asmEditor.selectionStart;
                currentMatchIndex = 0;
                for (let i = 0; i < searchMatches.length; i++) {
                    if (searchMatches[i] >= cursor) {
                        currentMatchIndex = i;
                        break;
                    }
                }
                asmSearchCount.textContent = `${currentMatchIndex + 1} of ${searchMatches.length}`;
            } else {
                asmSearchCount.textContent = 'No results';
            }
        }

        function findNext() {
            if (searchMatches.length === 0) {
                updateSearchMatches();
                if (searchMatches.length === 0) return;
            }

            currentMatchIndex = (currentMatchIndex + 1) % searchMatches.length;
            selectMatch();
        }

        function findPrev() {
            if (searchMatches.length === 0) {
                updateSearchMatches();
                if (searchMatches.length === 0) return;
            }

            currentMatchIndex = (currentMatchIndex - 1 + searchMatches.length) % searchMatches.length;
            selectMatch();
        }

        function selectMatch() {
            if (currentMatchIndex < 0 || currentMatchIndex >= searchMatches.length) return;

            const pos = searchMatches[currentMatchIndex];
            const len = asmSearchInput.value.length;
            asmEditor.focus();
            asmEditor.setSelectionRange(pos, pos + len);

            // Scroll to selection
            const lineHeight = 16;
            const lines = asmEditor.value.substring(0, pos).split('\n').length - 1;
            asmEditor.scrollTop = Math.max(0, lines * lineHeight - asmEditor.clientHeight / 2);

            asmSearchCount.textContent = `${currentMatchIndex + 1} of ${searchMatches.length}`;
        }

        function replaceOne() {
            if (searchMatches.length === 0 || currentMatchIndex < 0) return;

            const pos = searchMatches[currentMatchIndex];
            const len = asmSearchInput.value.length;
            const replacement = asmReplaceInput.value;

            const before = asmEditor.value.substring(0, pos);
            const after = asmEditor.value.substring(pos + len);
            asmEditor.value = before + replacement + after;

            updateLineNumbers();
            updateHighlight();
            syncEditorToVFS();

            // Update matches and find next
            updateSearchMatches();
            if (searchMatches.length > 0) {
                if (currentMatchIndex >= searchMatches.length) {
                    currentMatchIndex = 0;
                }
                selectMatch();
            }
        }

        function replaceAll() {
            const query = asmSearchInput.value;
            if (!query) return;

            const replacement = asmReplaceInput.value;
            const caseSensitive = chkAsmSearchCase.checked;

            let text = asmEditor.value;
            let count = 0;

            if (caseSensitive) {
                while (text.includes(query)) {
                    text = text.replace(query, replacement);
                    count++;
                }
            } else {
                const regex = new RegExp(query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
                const matches = text.match(regex);
                count = matches ? matches.length : 0;
                text = text.replace(regex, replacement);
            }

            asmEditor.value = text;
            updateLineNumbers();
            updateHighlight();
            syncEditorToVFS();
            updateSearchMatches();

            asmSearchCount.textContent = `Replaced ${count}`;
        }

        // Search bar event listeners
        if (asmSearchInput) {
            asmSearchInput.addEventListener('input', updateSearchMatches);
            asmSearchInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    if (e.shiftKey) findPrev();
                    else findNext();
                }
                if (e.key === 'Escape') closeSearchBar();
            });
        }
        if (asmReplaceInput) {
            asmReplaceInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    replaceOne();
                }
                if (e.key === 'Escape') closeSearchBar();
            });
        }
        if (chkAsmSearchCase) {
            chkAsmSearchCase.addEventListener('change', updateSearchMatches);
        }
        if (btnAsmFindNext) btnAsmFindNext.addEventListener('click', findNext);
        if (btnAsmFindPrev) btnAsmFindPrev.addEventListener('click', findPrev);
        if (btnAsmReplace) btnAsmReplace.addEventListener('click', replaceOne);
        if (btnAsmReplaceAll) btnAsmReplaceAll.addEventListener('click', replaceAll);
        if (btnAsmSearchClose) btnAsmSearchClose.addEventListener('click', closeSearchBar);
        if (btnAsmSearchAll) btnAsmSearchAll.addEventListener('click', searchAllFiles);

        updateProjectButtons();

        // Font size controls for assembler editor
        const asmFontSizeSelect = document.getElementById('asmFontSize');

        let asmFontSize = parseInt(localStorage.getItem('asmFontSize')) || 12;

        function updateAsmFontSize(newSize) {
            // Clamp between 8 and 24
            asmFontSize = Math.max(8, Math.min(24, newSize));
            // Line height is roughly 1.4x font size, rounded to avoid fractional pixels
            const lineHeight = Math.round(asmFontSize * 1.4);

            document.documentElement.style.setProperty('--asm-font-size', asmFontSize + 'px');
            document.documentElement.style.setProperty('--asm-line-height', lineHeight + 'px');

            // Update dropdown to match
            if (asmFontSizeSelect) {
                asmFontSizeSelect.value = asmFontSize;
            }

            localStorage.setItem('asmFontSize', asmFontSize);

            // Update line numbers to match new height
            updateLineNumbers();
        }

        // Initialize font size from saved preference
        updateAsmFontSize(asmFontSize);

        if (asmFontSizeSelect) {
            asmFontSizeSelect.addEventListener('change', () => {
                updateAsmFontSize(parseInt(asmFontSizeSelect.value));
            });
        }

        // Keyboard shortcuts for font size (Ctrl+Plus, Ctrl+Minus)
        if (asmEditor) {
            asmEditor.addEventListener('keydown', (e) => {
                if (e.ctrlKey && (e.key === '+' || e.key === '=' || e.key === 'NumpadAdd')) {
                    e.preventDefault();
                    updateAsmFontSize(asmFontSize + 1);
                } else if (e.ctrlKey && (e.key === '-' || e.key === '_' || e.key === 'NumpadSubtract')) {
                    e.preventDefault();
                    updateAsmFontSize(asmFontSize - 1);
                }
            });
        }

        // Button handlers
        if (btnAsmClear) {
            btnAsmClear.addEventListener('click', () => {
                asmEditor.value = '';
                asmOutput.innerHTML = '<span class="asm-hint">Press Assemble to compile</span>';
                updateLineNumbers();
                updateHighlight();
                // Close any open project and reset tabs
                VFS.reset();
                currentProjectMainFile = null;
                currentOpenFile = null;
                openTabs = [];
                fileModified = {};
                updateFileTabs();
                updateProjectButtons();
                updateDefinesDropdown();
                // Disable inject since nothing is assembled
                assembledBytes = null;
                btnAsmInject.disabled = true;
                btnAsmDebug.disabled = true;
                btnAsmDownload.disabled = true;
            });
        }

        if (btnAsmNew) {
            btnAsmNew.addEventListener('click', () => {
                // Prompt for filename
                const defaultName = `file${Object.keys(VFS.files).length + 1}.asm`;
                const filename = prompt('Enter filename:', defaultName);
                if (!filename) return;

                // Ensure it has an extension
                let finalName = filename.trim();
                if (!finalName.includes('.')) {
                    finalName += '.asm';
                }

                // Check if file already exists
                const normalized = finalName.replace(/\\/g, '/').toLowerCase();
                for (const path in VFS.files) {
                    if (path.toLowerCase() === normalized) {
                        showMessage(`File already exists: ${finalName}`);
                        return;
                    }
                }

                // Create empty file in VFS
                const template = `; ${finalName}\n; Created: ${new Date().toLocaleDateString()}\n; @entry start\n\n        ORG $8000\n\nstart:\n        ret\n`;
                VFS.addFile(finalName, template);

                // Set as main file if no main file yet
                if (!currentProjectMainFile) {
                    currentProjectMainFile = finalName;
                }

                // Open in tab
                openFileTab(finalName);
                updateProjectButtons();
                showMessage(`Created: ${finalName}`);
            });
        }

        if (btnAsmLoad) {
            btnAsmLoad.addEventListener('click', () => {
                asmFileInput.click();
            });
        }

        // Files dropdown handler
        if (btnAsmFiles) {
            btnAsmFiles.addEventListener('click', (e) => {
                e.stopPropagation();
                updateFilesList();
                asmFilesList.classList.toggle('show');
            });

            // Close dropdown when clicking outside
            document.addEventListener('click', (e) => {
                if (asmFilesList && !asmFilesDropdown.contains(e.target)) {
                    asmFilesList.classList.remove('show');
                }
            });
        }

        // Click handler for main file label - allows changing main file
        if (asmMainFileLabel) {
            asmMainFileLabel.addEventListener('click', async () => {
                const allFiles = VFS.listFiles();
                const newMain = await showMainFileDialog(allFiles, 'Change Main File');
                if (newMain) {
                    currentProjectMainFile = newMain;
                    updateFileTabs();
                    updateProjectButtons();
                    showMessage(`Main file set to: ${newMain.split('/').pop()}`);
                }
            });
        }

        // File loader - always adds/merges files (never resets VFS)
        if (asmFileInput) {
            asmFileInput.addEventListener('change', async (e) => {
                const files = e.target.files;
                if (!files || files.length === 0) return;
                await loadAsmFiles(files);
                asmFileInput.value = '';
            });
        }

        // Export source files as ZIP
        if (btnAsmExport) {
            btnAsmExport.addEventListener('click', () => {
                // Sync current editor to VFS first
                syncEditorToVFS();

                // Collect source files only (skip binary)
                const sourceFiles = [];
                const textExtensions = ['.asm', '.z80', '.s', '.a80', '.inc', '.txt', '.def', '.h'];

                for (const path in VFS.files) {
                    const file = VFS.files[path];
                    if (!file.binary) {
                        const ext = '.' + path.split('.').pop().toLowerCase();
                        if (textExtensions.includes(ext) || !path.includes('.')) {
                            sourceFiles.push({ name: path, content: file.content });
                        }
                    }
                }

                if (sourceFiles.length === 0) {
                    showMessage('No source files to export');
                    return;
                }

                // Create simple uncompressed ZIP
                const zipParts = [];
                const centralDir = [];
                let offset = 0;

                for (const file of sourceFiles) {
                    const nameBytes = new TextEncoder().encode(file.name);
                    const contentBytes = new TextEncoder().encode(file.content);

                    // CRC-32 calculation
                    let crc = 0xFFFFFFFF;
                    for (const byte of contentBytes) {
                        crc ^= byte;
                        for (let i = 0; i < 8; i++) {
                            crc = (crc >>> 1) ^ (crc & 1 ? 0xEDB88320 : 0);
                        }
                    }
                    crc ^= 0xFFFFFFFF;

                    // Local file header
                    const localHeader = new Uint8Array(30 + nameBytes.length);
                    const lhView = new DataView(localHeader.buffer);
                    lhView.setUint32(0, 0x04034b50, true);  // Signature
                    lhView.setUint16(4, 20, true);          // Version needed
                    lhView.setUint16(6, 0, true);           // Flags
                    lhView.setUint16(8, 0, true);           // Compression (0=store)
                    lhView.setUint16(10, 0, true);          // Mod time
                    lhView.setUint16(12, 0, true);          // Mod date
                    lhView.setUint32(14, crc >>> 0, true);  // CRC-32
                    lhView.setUint32(18, contentBytes.length, true);  // Compressed size
                    lhView.setUint32(22, contentBytes.length, true);  // Uncompressed size
                    lhView.setUint16(26, nameBytes.length, true);     // Name length
                    lhView.setUint16(28, 0, true);          // Extra length
                    localHeader.set(nameBytes, 30);

                    // Central directory entry
                    const cdEntry = new Uint8Array(46 + nameBytes.length);
                    const cdView = new DataView(cdEntry.buffer);
                    cdView.setUint32(0, 0x02014b50, true);  // Signature
                    cdView.setUint16(4, 20, true);          // Version made by
                    cdView.setUint16(6, 20, true);          // Version needed
                    cdView.setUint16(8, 0, true);           // Flags
                    cdView.setUint16(10, 0, true);          // Compression
                    cdView.setUint16(12, 0, true);          // Mod time
                    cdView.setUint16(14, 0, true);          // Mod date
                    cdView.setUint32(16, crc >>> 0, true);  // CRC-32
                    cdView.setUint32(20, contentBytes.length, true);  // Compressed
                    cdView.setUint32(24, contentBytes.length, true);  // Uncompressed
                    cdView.setUint16(28, nameBytes.length, true);     // Name length
                    cdView.setUint16(30, 0, true);          // Extra length
                    cdView.setUint16(32, 0, true);          // Comment length
                    cdView.setUint16(34, 0, true);          // Disk start
                    cdView.setUint16(36, 0, true);          // Internal attrs
                    cdView.setUint32(38, 0, true);          // External attrs
                    cdView.setUint32(42, offset, true);     // Local header offset
                    cdEntry.set(nameBytes, 46);

                    zipParts.push(localHeader);
                    zipParts.push(contentBytes);
                    centralDir.push(cdEntry);
                    offset += localHeader.length + contentBytes.length;
                }

                // Central directory
                const cdOffset = offset;
                let cdSize = 0;
                for (const entry of centralDir) {
                    zipParts.push(entry);
                    cdSize += entry.length;
                }

                // End of central directory
                const eocd = new Uint8Array(22);
                const eocdView = new DataView(eocd.buffer);
                eocdView.setUint32(0, 0x06054b50, true);    // Signature
                eocdView.setUint16(4, 0, true);             // Disk number
                eocdView.setUint16(6, 0, true);             // CD disk
                eocdView.setUint16(8, sourceFiles.length, true);   // Entries on disk
                eocdView.setUint16(10, sourceFiles.length, true);  // Total entries
                eocdView.setUint32(12, cdSize, true);       // CD size
                eocdView.setUint32(16, cdOffset, true);     // CD offset
                eocdView.setUint16(20, 0, true);            // Comment length
                zipParts.push(eocd);

                // Combine all parts
                const totalSize = zipParts.reduce((sum, p) => sum + p.length, 0);
                const zipData = new Uint8Array(totalSize);
                let pos = 0;
                for (const part of zipParts) {
                    zipData.set(part, pos);
                    pos += part.length;
                }

                // Download
                const blob = new Blob([zipData], { type: 'application/zip' });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = 'project_source.zip';
                a.click();
                URL.revokeObjectURL(a.href);

                showMessage(`Exported ${sourceFiles.length} source file(s)`);
            });
        }

        // Simple assembler - enough for basic code
        if (btnAsmAssemble) {
            btnAsmAssemble.addEventListener('click', assembleCode);
        }

        // Assembled bytes storage
        let assembledBytes = null;
        let assembledOrg = 0;
        let assembledOrgAddresses = [];  // All ORG addresses from assembly
        let assembledSaveCommands = [];  // SAVESNA/SAVETAP commands from assembly
        let assembledEntryPoint = null;  // Entry point from ; @entry marker
        let assembledSymbols = [];       // Symbols from last assembly {name, value, type}

        // Navigate to file:line in editor
        function goToFileLine(file, line) {
            // Normalize file path
            const normalizedFile = file ? file.replace(/\\/g, '/').toLowerCase() : null;

            // Find the file in VFS
            let targetPath = null;
            if (normalizedFile) {
                for (const path in VFS.files) {
                    if (path.toLowerCase() === normalizedFile ||
                        path.toLowerCase().endsWith('/' + normalizedFile) ||
                        normalizedFile.endsWith('/' + path.toLowerCase())) {
                        targetPath = path;
                        break;
                    }
                }
            }

            // If file found and it's different from current, open it
            if (targetPath && targetPath !== currentOpenFile) {
                openFileTab(targetPath);
            }

            // Go to line in editor
            if (line && asmEditor) {
                const lines = asmEditor.value.split('\n');
                const lineIndex = Math.max(0, Math.min(line - 1, lines.length - 1));
                let charPos = 0;
                for (let i = 0; i < lineIndex; i++) {
                    charPos += lines[i].length + 1;
                }
                asmEditor.focus();
                asmEditor.setSelectionRange(charPos, charPos + lines[lineIndex].length);
                // Scroll to make the line visible
                const lineHeight = parseInt(getComputedStyle(asmEditor).lineHeight) || 18;
                asmEditor.scrollTop = Math.max(0, (lineIndex - 5) * lineHeight);
            }
        }

        // Format error/warning location as clickable HTML
        function formatErrorLocation(file, line, message, isError) {
            const cssClass = isError ? 'asm-error' : 'asm-warning';
            const prefix = isError ? 'Error' : 'Warning';
            let location = '';

            if (file) {
                const shortFile = file.split('/').pop();
                location = `${shortFile}:${line || '?'}`;
            } else if (line) {
                location = `Line ${line}`;
            }

            const escapedMsg = escapeHtml(message);
            const dataFile = file ? `data-file="${escapeHtml(file)}"` : '';
            const dataLine = line ? `data-line="${line}"` : '';

            return `<div class="${cssClass} asm-clickable" ${dataFile} ${dataLine} style="cursor:pointer" title="Click to go to location">${prefix}: ${location}: ${escapedMsg}</div>`;
        }

        // Scan source file header for @define markers (first 50 lines)
        // Format: ; @define NAME or ; @define NAME=VALUE
        function detectDefinesFromSource() {
            const defines = [];

            // Get content from main file in project mode, or current editor
            let content = '';
            const mainFile = currentProjectMainFile || currentOpenFile;
            if (mainFile && VFS.files[mainFile] && !VFS.files[mainFile].binary) {
                content = VFS.files[mainFile].content;
            } else if (asmEditor) {
                content = asmEditor.value;
            }

            if (!content) return defines;

            // Only check first 50 lines for @define markers
            const lines = content.split('\n').slice(0, 50);
            for (const line of lines) {
                const match = line.match(/^\s*;\s*@define\s+(\w+)(?:\s*=\s*(.+))?/i);
                if (match) {
                    defines.push({
                        name: match[1],
                        value: match[2] !== undefined ? match[2].trim() : '1'
                    });
                }
            }

            return defines;
        }

        // Update defines dropdown based on @define markers in source
        function updateDefinesDropdown() {
            if (!asmDetectedDefines) return;

            const defines = detectDefinesFromSource();

            if (defines.length === 0) {
                asmDetectedDefines.style.display = 'none';
                return;
            }

            // Build options
            asmDetectedDefines.innerHTML = defines.map(d =>
                `<option value="${d.name}" data-value="${d.value}">${d.name}${d.value !== '1' ? '=' + d.value : ''}</option>`
            ).join('');

            // Adjust size based on count
            asmDetectedDefines.size = Math.min(defines.length, 4);
            asmDetectedDefines.style.display = 'inline-block';
            asmDetectedDefines.title = `Available defines from @define markers (${defines.length})\nCtrl+click to select multiple`;
        }

        // Get selected defines from dropdown
        function getSelectedDefinesFromDropdown() {
            if (!asmDetectedDefines) return [];

            const selected = [];
            for (const opt of asmDetectedDefines.selectedOptions) {
                const valueStr = opt.dataset.value;
                // Parse value
                let value = 1;
                if (valueStr && valueStr !== '1') {
                    if (/^-?\d+$/.test(valueStr)) {
                        value = parseInt(valueStr, 10);
                    } else if (/^[\$0x]/i.test(valueStr)) {
                        value = parseInt(valueStr.replace(/^[\$0x]/i, ''), 16);
                    } else {
                        value = valueStr; // Keep as string
                    }
                }
                selected.push({ name: opt.value, value });
            }
            return selected;
        }

        function assembleCode() {
            // Pause emulator before assembly
            if (spectrum.isRunning()) {
                spectrum.stop();
                updateStatus();
            }
            // Run assembly directly (no setTimeout to avoid race with Debug button)
            doAssemble();
        }

        function doAssemble() {
            // Use the project main file name if available, otherwise default to current file or 'editor.asm'
            const filename = currentProjectMainFile || currentOpenFile || 'editor.asm';
            // VFS normalizes paths to lowercase
            const normalizedFilename = filename.replace(/\\/g, '/').toLowerCase();

            // Determine if this is a single-file assembly (no project loaded)
            const isSingleFile = !currentProjectMainFile && !currentOpenFile;

            // For single-file mode, always use fresh VFS to avoid stale content
            if (isSingleFile) {
                VFS.reset();
            }

            // Sync current editor to VFS before assembly
            const normalizedOpenFile = currentOpenFile ? currentOpenFile.replace(/\\/g, '/').toLowerCase() : null;
            if (normalizedOpenFile && VFS.files[normalizedOpenFile] && !VFS.files[normalizedOpenFile].binary) {
                // Update existing file in VFS
                VFS.files[normalizedOpenFile].content = asmEditor.value;
            }

            // Always add/update the file being assembled with current editor content
            if (asmEditor.value.trim()) {
                VFS.addFile(filename, asmEditor.value);
            }

            // Check if we have a multi-file project
            const hasProject = !isSingleFile && Object.keys(VFS.files).length > 1;

            // Parse command-line defines from input (format: "NAME,NAME=value,...")
            const cmdDefines = [];
            if (asmDefinesInput && asmDefinesInput.value.trim()) {
                const defParts = asmDefinesInput.value.split(',').map(s => s.trim()).filter(s => s);
                for (const part of defParts) {
                    const eqIdx = part.indexOf('=');
                    if (eqIdx > 0) {
                        const name = part.substring(0, eqIdx).trim();
                        const valueStr = part.substring(eqIdx + 1).trim();
                        // Parse value as number if possible, otherwise use 1
                        const value = /^-?\d+$/.test(valueStr) ? parseInt(valueStr, 10) :
                                      /^[\$0x]/i.test(valueStr) ? parseInt(valueStr.replace(/^[\$0x]/i, ''), 16) : 1;
                        cmdDefines.push({ name, value });
                    } else {
                        cmdDefines.push({ name: part, value: 1 });
                    }
                }
            }

            // Add selected defines from @define markers dropdown
            const dropdownDefines = getSelectedDefinesFromDropdown();
            for (const def of dropdownDefines) {
                // Only add if not already in cmdDefines (manual input takes priority)
                if (!cmdDefines.some(d => d.name === def.name)) {
                    cmdDefines.push(def);
                }
            }

            // Use sjasmplus-js assembler
            try {
                let result;
                if (hasProject && VFS.files[normalizedFilename]) {
                    // Multi-file project - use assembleProject to preserve VFS
                    result = Assembler.assembleProject(normalizedFilename, cmdDefines);
                } else {
                    // Single file mode - use assemble
                    const code = asmEditor.value;
                    result = Assembler.assemble(code, filename, cmdDefines);
                }

                assembledBytes = result.output;
                assembledOrg = result.outputStart;
                assembledOrgAddresses = result.orgAddresses || [result.outputStart];
                assembledSaveCommands = result.saveCommands || [];
                assembledSymbols = result.symbols || [];

                // Parse ; @entry marker from source
                assembledEntryPoint = null;
                const sourceCode = hasProject && VFS.files[normalizedFilename] ? VFS.files[normalizedFilename].content : asmEditor.value;
                const entryMatch = sourceCode.match(/^\s*;\s*@entry\s+(\S+)/im);
                if (entryMatch) {
                    const entryValue = entryMatch[1];
                    // result.symbols is an array of {name, value, ...}
                    // Try to resolve as label first (case-insensitive)
                    const symbolEntry = result.symbols && result.symbols.find(s =>
                        s.name === entryValue || s.name.toLowerCase() === entryValue.toLowerCase()
                    );
                    if (symbolEntry) {
                        assembledEntryPoint = symbolEntry.value;
                    } else {
                        // Try parsing as number ($hex, 0xhex, or decimal)
                        const numMatch = entryValue.match(/^(?:\$|0x)([0-9a-f]+)$/i);
                        if (numMatch) {
                            assembledEntryPoint = parseInt(numMatch[1], 16);
                        } else if (/^\d+$/.test(entryValue)) {
                            assembledEntryPoint = parseInt(entryValue, 10);
                        }
                    }
                }

                // Check for errors
                const errors = ErrorCollector.errors || [];
                const warnings = result.warnings || [];

                let html = '';

                if (errors.length > 0) {
                    const statusMsg = `${errors.length} error(s)`;
                    html += `<div class="asm-status-line error">${statusMsg}</div>`;
                    errors.forEach(e => {
                        html += formatErrorLocation(e.file, e.line, e.message, true);
                    });
                    assembledBytes = null;
                    btnAsmInject.disabled = true;
                    btnAsmDebug.disabled = true;
                    btnAsmDownload.disabled = true;
                } else {
                    // Show assembled output with addresses and bytes (if enabled)
                    const output = result.output;
                    const startAddr = result.outputStart;
                    const statusMsg = `OK: ${output.length} bytes at ${startAddr.toString(16).toUpperCase()}h (${result.passes} pass${result.passes > 1 ? 'es' : ''})`;
                    html += `<div class="asm-status-line success">${statusMsg}</div>`;

                    // Show warnings (filter unused labels based on checkbox)
                    const showUnused = chkAsmUnusedLabels && chkAsmUnusedLabels.checked;
                    const realWarnings = warnings.filter(w =>
                        showUnused || !w.message.startsWith('Unused label:')
                    );
                    realWarnings.forEach(w => {
                        html += formatErrorLocation(w.file, w.line, w.message, false);
                    });

                    const showCompiled = chkAsmShowCompiled && chkAsmShowCompiled.checked;

                    if (showCompiled && output.length > 0) {
                        // Show hex dump grouped by 8 bytes per line
                        for (let i = 0; i < output.length; i += 8) {
                            const addr = startAddr + i;
                            const chunk = output.slice(i, Math.min(i + 8, output.length));
                            const bytesHex = chunk.map(b => b.toString(16).toUpperCase().padStart(2, '0')).join(' ');
                            html += `<div class="asm-line">`;
                            html += `<span class="asm-addr">${addr.toString(16).toUpperCase().padStart(4, '0')}</span>`;
                            html += `<span class="asm-bytes">${bytesHex}</span>`;
                            html += `</div>`;
                        }
                    }

                    // Show generated files list (grouped by filename)
                    const saveCommands = assembledSaveCommands.filter(c =>
                        c.type === 'bin' || c.type === 'sna' || c.type === 'tap' ||
                        c.type === 'emptytap' || c.type === 'trd' || c.type === 'emptytrd'
                    );
                    // Group by filename
                    const fileMap = new Map();
                    for (const cmd of saveCommands) {
                        const fn = cmd.filename || cmd.trdFilename;
                        if (!fn) continue;
                        if (!fileMap.has(fn)) {
                            fileMap.set(fn, { commands: [], totalSize: 0, type: cmd.type });
                        }
                        const entry = fileMap.get(fn);
                        entry.commands.push(cmd);
                        if (cmd.capturedData) entry.totalSize += cmd.capturedData.length;
                        else if (cmd.length) entry.totalSize += cmd.length;
                        // Update type if we have a real command (not empty)
                        if (cmd.type !== 'emptytap' && cmd.type !== 'emptytrd') {
                            entry.type = cmd.type;
                        }
                    }

                    if (fileMap.size > 0) {
                        html += `<div class="asm-files-section">`;
                        html += `<div class="asm-files-header">Generated files:</div>`;
                        for (const [filename, info] of fileMap) {
                            let fileSize = 0;
                            let md5Hash = '';
                            let expectedMD5 = null;
                            let blockCount = 0;

                            // Get expected MD5 from first command with it
                            for (const cmd of info.commands) {
                                if (cmd.expectedMD5) {
                                    expectedMD5 = cmd.expectedMD5.toLowerCase();
                                    break;
                                }
                            }

                            if (info.type === 'tap') {
                                const tapCmds = info.commands.filter(c => c.type === 'tap');
                                blockCount = tapCmds.length;
                                // Generate TAP data to get accurate size and MD5
                                const allBlocks = [];
                                for (const cmd of tapCmds) {
                                    const blockData = generateTAPBlocks(cmd);
                                    if (blockData) allBlocks.push(blockData);
                                }
                                if (allBlocks.length > 0) {
                                    const totalLen = allBlocks.reduce((sum, b) => sum + b.length, 0);
                                    const tapData = new Uint8Array(totalLen);
                                    let offset = 0;
                                    for (const block of allBlocks) {
                                        tapData.set(block, offset);
                                        offset += block.length;
                                    }
                                    fileSize = tapData.length;
                                    md5Hash = MD5.hash(tapData);
                                }
                            } else if (info.type === 'bin') {
                                const cmd = info.commands.find(c => c.type === 'bin');
                                if (cmd && cmd.capturedData) {
                                    fileSize = cmd.capturedData.length;
                                    md5Hash = MD5.hash(cmd.capturedData);
                                }
                            } else if (info.type === 'sna') {
                                const cmd = info.commands.find(c => c.type === 'sna');
                                if (cmd) {
                                    const snaData = generateSNAFile(cmd);
                                    fileSize = snaData.length;
                                    md5Hash = MD5.hash(snaData);
                                }
                            } else {
                                fileSize = info.totalSize;
                            }

                            // Format details
                            let details = '';
                            if (info.type === 'tap' && blockCount > 1) {
                                details = `${blockCount} blocks, ${fileSize} bytes`;
                            } else if (fileSize > 0) {
                                details = `${fileSize} bytes`;
                            }

                            // MD5 verification
                            let md5Status = '';
                            if (expectedMD5 && md5Hash) {
                                if (md5Hash === expectedMD5) {
                                    md5Status = '<span class="asm-md5-pass">MD5 OK</span>';
                                } else {
                                    md5Status = `<span class="asm-md5-fail">MD5 MISMATCH (expected: ${expectedMD5})</span>`;
                                }
                            }

                            html += `<div class="asm-file-item">`;
                            html += `${escapeHtml(filename)}`;
                            if (details) html += ` <span class="asm-file-details">(${details})</span>`;
                            if (md5Hash) html += ` <span class="asm-file-md5">[${md5Hash}]</span>`;
                            if (md5Status) html += ` ${md5Status}`;
                            html += `</div>`;
                        }
                        html += `</div>`;
                    }

                    btnAsmInject.disabled = false;
                    btnAsmDebug.disabled = false;
                    btnAsmDownload.disabled = fileMap.size === 0;
                }

                asmOutput.innerHTML = html;

                // Add click handlers for error/warning navigation
                asmOutput.querySelectorAll('.asm-clickable').forEach(el => {
                    el.addEventListener('click', () => {
                        const file = el.dataset.file || null;
                        const line = el.dataset.line ? parseInt(el.dataset.line) : null;
                        goToFileLine(file, line);
                    });
                });

            } catch (e) {
                // Handle AssemblerError with file/line info
                const statusMsg = 'Assembly failed';
                let html = `<div class="asm-status-line error">${statusMsg}</div>`;
                if (e.file || e.line) {
                    html += formatErrorLocation(e.file, e.line, e.message, true);
                } else {
                    html += `<div class="asm-error">${escapeHtml(e.message || e.toString())}</div>`;
                }
                asmOutput.innerHTML = html;

                // Add click handlers for error navigation
                asmOutput.querySelectorAll('.asm-clickable').forEach(el => {
                    el.addEventListener('click', () => {
                        const file = el.dataset.file || null;
                        const line = el.dataset.line ? parseInt(el.dataset.line) : null;
                        goToFileLine(file, line);
                    });
                });

                assembledBytes = null;
                btnAsmInject.disabled = true;
                btnAsmDebug.disabled = true;
                btnAsmDownload.disabled = true;
            }
        }

        // Inject assembled code into memory (supports 128K paging)
        if (btnAsmInject) {
            btnAsmInject.addEventListener('click', () => {
                if (!spectrum.memory) {
                    showMessage('Emulator not ready');
                    return;
                }

                const deviceName = AsmMemory.getDeviceName();
                const emulatorIs128K = is128kCompat(spectrum.memory.machineType) || spectrum.memory.profile.ramPages > 1;

                // Check if we have paged assembly (DEVICE directive used)
                if (deviceName === 'ZXSPECTRUM128' || deviceName === 'ZXSPECTRUM512' || deviceName === 'ZXSPECTRUM1024') {
                    // 128K paged assembly
                    if (!emulatorIs128K) {
                        showMessage('Warning: 128K code cannot be fully injected to 48K machine. Only pages 5, 2, 0 will be injected.');
                    }

                    let totalBytes = 0;
                    const pagesInjected = [];

                    // For 128K emulator: inject all 8 pages to RAM banks
                    // For 48K emulator: inject pages 5,2,0 to corresponding addresses
                    const pagesToInject = emulatorIs128K ? [0, 1, 2, 3, 4, 5, 6, 7] : [5, 2, 0];

                    for (const pageNum of pagesToInject) {
                        const pageData = AsmMemory.getPage(pageNum);
                        if (!pageData) continue;

                        // Check if page has any non-zero content
                        let hasContent = false;
                        for (let i = 0; i < pageData.length; i++) {
                            if (pageData[i] !== 0) {
                                hasContent = true;
                                break;
                            }
                        }

                        if (hasContent) {
                            if (emulatorIs128K) {
                                // Direct bank copy for 128K
                                const ramBank = spectrum.memory.getRamBank(pageNum);
                                if (ramBank) {
                                    ramBank.set(pageData);
                                    totalBytes += pageData.length;
                                    pagesInjected.push(pageNum);
                                }
                            } else {
                                // 48K emulator - map pages to addresses
                                // Page 5 -> $4000, Page 2 -> $8000, Page 0 -> $C000
                                const addrMap = { 5: 0x4000, 2: 0x8000, 0: 0xC000 };
                                const baseAddr = addrMap[pageNum];
                                if (baseAddr !== undefined) {
                                    for (let i = 0; i < pageData.length; i++) {
                                        spectrum.memory.write(baseAddr + i, pageData[i]);
                                    }
                                    totalBytes += pageData.length;
                                    pagesInjected.push(pageNum);
                                }
                            }
                        }
                    }

                    // Reset paging state to match assembler's slot configuration
                    if (emulatorIs128K) {
                        const asmBank = AsmMemory.slots[3].page;
                        spectrum.memory.setPagingState({
                            ramBank: asmBank & 0x07,
                            romBank: 0,
                            screenBank: 5,
                            pagingDisabled: false
                        });
                    }

                    if (pagesInjected.length > 0) {
                        showMessage(`Injected ${totalBytes} bytes from pages [${pagesInjected.join(', ')}]`);
                    } else {
                        showMessage('No content to inject');
                    }

                } else if (deviceName === 'ZXSPECTRUM48') {
                    // 48K paged assembly - pages 1,2,3 map to $4000,$8000,$C000
                    let totalBytes = 0;
                    const addrMap = { 1: 0x4000, 2: 0x8000, 3: 0xC000 };

                    for (const pageNum of [1, 2, 3]) {
                        const pageData = AsmMemory.getPage(pageNum);
                        if (!pageData) continue;

                        // Check if page has any non-zero content
                        let hasContent = false;
                        for (let i = 0; i < pageData.length; i++) {
                            if (pageData[i] !== 0) {
                                hasContent = true;
                                break;
                            }
                        }

                        if (hasContent) {
                            const baseAddr = addrMap[pageNum];
                            if (emulatorIs128K) {
                                // 128K emulator - map 48K pages to 128K banks
                                // Page 1 -> Bank 5, Page 2 -> Bank 2, Page 3 -> Bank 0
                                const bankMap = { 1: 5, 2: 2, 3: 0 };
                                const ramBank = spectrum.memory.getRamBank(bankMap[pageNum]);
                                if (ramBank) {
                                    ramBank.set(pageData);
                                    totalBytes += pageData.length;
                                }
                            } else {
                                // 48K emulator - direct address write
                                for (let i = 0; i < pageData.length; i++) {
                                    spectrum.memory.write(baseAddr + i, pageData[i]);
                                }
                                totalBytes += pageData.length;
                            }
                        }
                    }

                    // Reset paging to bank 0 at C000 (48K default)
                    if (emulatorIs128K) {
                        spectrum.memory.setPagingState({
                            ramBank: 0,
                            romBank: 0,
                            screenBank: 5,
                            pagingDisabled: false
                        });
                    }

                    if (totalBytes > 0) {
                        showMessage(`Injected ${totalBytes} bytes (48K device)`);
                    } else {
                        showMessage('No content to inject');
                    }

                } else {
                    // No DEVICE - use linear output
                    if (!assembledBytes || assembledBytes.length === 0) {
                        showMessage('No assembled code to inject');
                        return;
                    }

                    for (let i = 0; i < assembledBytes.length; i++) {
                        spectrum.memory.write(assembledOrg + i, assembledBytes[i]);
                    }

                    showMessage(`Injected ${assembledBytes.length} bytes at ${assembledOrg.toString(16).toUpperCase()}h`);
                }

                updateDebugger();
            });
        }

        // Debug button - assemble, inject code and start debugging
        if (btnAsmDebug) {
            btnAsmDebug.addEventListener('click', async () => {
                if (!spectrum.memory) {
                    showMessage('Emulator not ready');
                    return;
                }

                // First, re-assemble the current code
                doAssemble();

                // Check if assembly succeeded
                if (!assembledBytes && !AsmMemory.getDeviceName()) {
                    showMessage('Assembly failed - cannot debug');
                    return;
                }

                // Then inject
                btnAsmInject.click();

                // Determine entry point - priority: @entry > SAVESNA > single ORG > multiple ORGs (ask)
                let entryPoint = assembledOrg;

                if (assembledEntryPoint !== null) {
                    // Use ; @entry marker
                    entryPoint = assembledEntryPoint;
                } else {
                    // Check if there's a SAVESNA command - use its start address
                    const snaCommand = assembledSaveCommands.find(c => c.type === 'sna');
                    if (snaCommand) {
                        entryPoint = snaCommand.start;
                    } else if (assembledOrgAddresses.length > 1) {
                        // Multiple ORGs - ask user to select
                        entryPoint = await showOrgSelectionDialog(assembledOrgAddresses);
                        if (entryPoint === null) return;  // User cancelled
                    } else if (assembledOrgAddresses.length === 1) {
                        entryPoint = assembledOrgAddresses[0];
                    }
                }

                // Reset CPU and frame timing state for clean debug start
                spectrum.cpu.halted = false;
                spectrum.cpu.iff1 = 0;
                spectrum.cpu.iff2 = 0;
                spectrum.cpu.tStates = 0;
                spectrum.frameStartOffset = 0;
                spectrum.accumulatedContention = 0;
                spectrum.pendingInt = false;

                spectrum.cpu.pc = entryPoint;

                // Inject assembler symbols as debugger labels
                if (assembledSymbols.length > 0) {
                    let injected = 0;
                    for (const sym of assembledSymbols) {
                        const addr = sym.value & 0xFFFF;
                        // Skip symbols outside addressable range or internal
                        if (sym.value < 0 || sym.value > 0xFFFF) continue;
                        if (sym.name.startsWith('__')) continue;
                        // Only add if no existing user label at this address
                        if (!labelManager.get(addr)) {
                            labelManager.add({ address: addr, name: sym.name });
                            injected++;
                        }
                    }
                    if (injected > 0) {
                        updateLabelsList();
                    }
                }

                // Switch to debugger tab
                const debuggerTab = document.querySelector('.tab-btn[data-tab="debugger"]');
                if (debuggerTab) {
                    debuggerTab.click();
                }

                // Update debugger view
                updateDebugger();
                updateStatus();

                showMessage(`Ready to debug at ${entryPoint.toString(16).toUpperCase()}h - press F7 to step`);
            });
        }

        // Download generated files
        if (btnAsmDownload) {
            btnAsmDownload.addEventListener('click', async () => {
                const saveCommands = assembledSaveCommands.filter(c =>
                    c.type === 'bin' || c.type === 'sna' || c.type === 'tap' ||
                    c.type === 'emptytap' || c.type === 'trd' || c.type === 'emptytrd'
                );

                if (saveCommands.length === 0) {
                    showMessage('No files to download');
                    return;
                }

                // Group commands by filename - multiple SAVETAP to same file = one TAP with multiple blocks
                const fileGroups = new Map();
                for (const cmd of saveCommands) {
                    const filename = cmd.filename || cmd.trdFilename;
                    if (!filename) continue;

                    if (!fileGroups.has(filename)) {
                        fileGroups.set(filename, []);
                    }
                    fileGroups.get(filename).push(cmd);
                }

                // Generate file data for each unique filename
                const files = [];
                for (const [filename, commands] of fileGroups) {
                    let data = null;

                    // Determine file type from first non-empty command
                    const firstCmd = commands.find(c => c.type !== 'emptytap' && c.type !== 'emptytrd') || commands[0];
                    const fileType = firstCmd.type === 'emptytap' ? 'tap' :
                                     firstCmd.type === 'emptytrd' ? 'trd' : firstCmd.type;

                    if (fileType === 'bin') {
                        // Binary file - use captured data directly
                        data = firstCmd.capturedData;
                    } else if (fileType === 'sna') {
                        // SNA snapshot - generate from assembler memory state
                        data = generateSNAFile(firstCmd);
                    } else if (fileType === 'tap') {
                        // TAP file - concatenate all blocks from all SAVETAP commands to this file
                        const tapCommands = commands.filter(c => c.type === 'tap');
                        if (tapCommands.length > 0) {
                            const allBlocks = [];
                            for (const cmd of tapCommands) {
                                const blockData = generateTAPBlocks(cmd);
                                if (blockData) allBlocks.push(blockData);
                            }
                            // Concatenate all blocks
                            const totalLen = allBlocks.reduce((sum, b) => sum + b.length, 0);
                            data = new Uint8Array(totalLen);
                            let offset = 0;
                            for (const block of allBlocks) {
                                data.set(block, offset);
                                offset += block.length;
                            }
                        }
                    } else if (fileType === 'trd') {
                        // TRD file - not yet implemented
                        console.log('TRD export not yet implemented:', filename);
                        continue;
                    }

                    if (data && data.length > 0) {
                        files.push({ filename, data });
                    }
                }

                if (files.length === 0) {
                    showMessage('No valid files to download');
                    return;
                }

                if (files.length === 1) {
                    // Single file - download directly
                    downloadBinaryFile(files[0].filename, files[0].data);
                    showMessage(`Downloaded: ${files[0].filename}`);
                } else {
                    // Multiple files - create ZIP
                    const zipData = await createZipFromFiles(files);
                    const zipName = currentProjectMainFile
                        ? currentProjectMainFile.replace(/\.[^.]+$/, '.zip')
                        : 'output.zip';
                    downloadBinaryFile(zipName, zipData);
                    showMessage(`Downloaded ${files.length} files as ${zipName}`);
                }
            });
        }

        // Generate SNA file from assembler memory state
        function generateSNAFile(cmd) {
            const deviceName = AsmMemory.getDeviceName();
            const is128k = AsmMemory.device &&
                (deviceName === 'ZXSPECTRUM128' || deviceName === 'ZXSPECTRUM512' || deviceName === 'ZXSPECTRUM1024');
            const size = is128k ? 131103 : 49179;
            const snaData = new Uint8Array(size);

            const startAddr = cmd.start;

            // SNA header (27 bytes)
            // I register
            snaData[0] = 0x3F;
            // HL', DE', BC', AF' (alternate registers)
            snaData[1] = 0; snaData[2] = 0;  // HL'
            snaData[3] = 0; snaData[4] = 0;  // DE'
            snaData[5] = 0; snaData[6] = 0;  // BC'
            snaData[7] = 0; snaData[8] = 0;  // AF'
            // HL, DE, BC (main registers)
            snaData[9] = 0; snaData[10] = 0;  // HL
            snaData[11] = 0; snaData[12] = 0; // DE
            snaData[13] = 0; snaData[14] = 0; // BC
            // IY, IX
            snaData[15] = 0x5C; snaData[16] = 0x3A; // IY = 5C3Ah (standard)
            snaData[17] = 0; snaData[18] = 0;        // IX
            // Interrupt (bit 2 = IFF2)
            snaData[19] = 0x04; // IFF2 enabled
            // R register
            snaData[20] = 0;
            // AF
            snaData[21] = 0; snaData[22] = 0;         // AF
            // SP
            if (is128k) {
                // 128K: PC stored in extended header, SP is actual value
                snaData[23] = 0; snaData[24] = 0; // SP = 0x0000
            } else {
                // 48K: PC stored on stack via RETN trick, SP points below pushed PC
                snaData[23] = 0xFE; snaData[24] = 0xFF; // SP = 0xFFFE
            }
            // Interrupt mode
            snaData[25] = 1; // IM 1
            // Border color
            snaData[26] = 7; // White border

            // RAM dump (48K starting at 0x4000)
            // Copy assembled data into 48K section
            if (AsmMemory.device) {
                if (is128k) {
                    // 128K: 48K section = banks 5, 2, and current bank at C000
                    const currentBank = AsmMemory.slots[3].page;
                    const pageMap = [5, 2, currentBank];
                    for (let section = 0; section < 3; section++) {
                        const pageData = AsmMemory.getPage(pageMap[section]);
                        if (pageData) {
                            snaData.set(pageData, 27 + section * 0x4000);
                        }
                    }
                } else {
                    // ZXSPECTRUM48: pages 5, 2, 0 map to 0x4000-0xFFFF
                    const pageMap = [5, 2, 0];
                    for (let page = 0; page < 3; page++) {
                        const pageData = AsmMemory.getPage(pageMap[page]);
                        if (pageData) {
                            snaData.set(pageData, 27 + page * 0x4000);
                        }
                    }
                }
            } else {
                // No DEVICE - linear output
                const outputStart = Assembler.outputStart;
                const output = Assembler.output;
                for (let i = 0; i < output.length; i++) {
                    const addr = outputStart + i;
                    if (addr >= 0x4000 && addr <= 0xFFFF) {
                        snaData[27 + (addr - 0x4000)] = output[i];
                    }
                }
            }

            if (is128k) {
                // 128K extended header at offset 49179
                const offset = 49179;
                // PC
                snaData[offset] = startAddr & 0xFF;
                snaData[offset + 1] = (startAddr >> 8) & 0xFF;
                // Port 0x7FFD value
                const currentBank = AsmMemory.slots[3].page;
                snaData[offset + 2] = currentBank & 0x07;
                // TR-DOS ROM not paged
                snaData[offset + 3] = 0;
                // Remaining RAM banks (excluding 5, 2, and current bank at C000)
                const banksToSave = [0, 1, 3, 4, 6, 7].filter(b => b !== currentBank);
                const banksToActuallySave = banksToSave.slice(0, 5);
                let bankOffset = offset + 4;
                for (const bankNum of banksToActuallySave) {
                    const pageData = AsmMemory.getPage(bankNum);
                    if (pageData) {
                        snaData.set(pageData, bankOffset);
                    }
                    bankOffset += 0x4000;
                }
            } else {
                // 48K: Place start address on stack for RETN
                snaData[27 + (0xFFFE - 0x4000)] = startAddr & 0xFF;
                snaData[27 + (0xFFFE - 0x4000) + 1] = (startAddr >> 8) & 0xFF;
            }

            return snaData;
        }

        // Generate TAP blocks for a single SAVETAP command (may include header + data blocks)
        function generateTAPBlocks(cmd) {
            if (cmd.blockType === 'HEADLESS') {
                // Headless block - just data with flag byte
                const flagByte = cmd.param1 !== undefined ? cmd.param1 : 0xFF;
                return createTAPBlock(cmd.capturedData, flagByte);
            }

            // Standard block with header
            const blocks = [];

            if (cmd.blockType === 'CODE') {
                // Header block (type 3 = CODE)
                const header = new Uint8Array(17);
                header[0] = 3; // CODE
                // Filename (10 chars, space padded)
                const name = (cmd.blockName || 'CODE').substring(0, 10).padEnd(10, ' ');
                for (let i = 0; i < 10; i++) {
                    header[1 + i] = name.charCodeAt(i);
                }
                const len = cmd.capturedData ? cmd.capturedData.length : cmd.length;
                header[11] = len & 0xFF;
                header[12] = (len >> 8) & 0xFF;
                header[13] = cmd.start & 0xFF;
                header[14] = (cmd.start >> 8) & 0xFF;
                const codeParam2 = (cmd.param2 >= 0) ? cmd.param2 : 32768;
                header[15] = codeParam2 & 0xFF;
                header[16] = (codeParam2 >> 8) & 0xFF;

                blocks.push(createTAPBlock(header, 0x00)); // Flag 0 = header
                blocks.push(createTAPBlock(cmd.capturedData, 0xFF)); // Flag FF = data
            } else if (cmd.blockType === 'BASIC') {
                // BASIC program header (type 0)
                const header = new Uint8Array(17);
                header[0] = 0; // BASIC
                const name = (cmd.blockName || 'PROGRAM').substring(0, 10).padEnd(10, ' ');
                for (let i = 0; i < 10; i++) {
                    header[1 + i] = name.charCodeAt(i);
                }
                const len = cmd.capturedData ? cmd.capturedData.length : cmd.length;
                header[11] = len & 0xFF;
                header[12] = (len >> 8) & 0xFF;
                const autorun = cmd.param1 !== undefined ? cmd.param1 : 0x8000;
                header[13] = autorun & 0xFF;
                header[14] = (autorun >> 8) & 0xFF;
                const varsOffset = (cmd.param2 >= 0) ? cmd.param2 : len;
                header[15] = varsOffset & 0xFF;
                header[16] = (varsOffset >> 8) & 0xFF;

                blocks.push(createTAPBlock(header, 0x00));
                blocks.push(createTAPBlock(cmd.capturedData, 0xFF));
            } else {
                // Default - just data block
                blocks.push(createTAPBlock(cmd.capturedData, 0xFF));
            }

            // Concatenate all blocks
            const totalLen = blocks.reduce((sum, b) => sum + b.length, 0);
            const tapData = new Uint8Array(totalLen);
            let offset = 0;
            for (const block of blocks) {
                tapData.set(block, offset);
                offset += block.length;
            }
            return tapData;
        }

        // Create a single TAP block with length prefix, flag, data, and checksum
        function createTAPBlock(data, flagByte) {
            const blockLen = data.length + 2; // +1 flag, +1 checksum
            const block = new Uint8Array(blockLen + 2); // +2 for length prefix
            block[0] = blockLen & 0xFF;
            block[1] = (blockLen >> 8) & 0xFF;
            block[2] = flagByte;
            block.set(data, 3);
            // Calculate checksum (XOR of flag and all data bytes)
            let checksum = flagByte;
            for (let i = 0; i < data.length; i++) {
                checksum ^= data[i];
            }
            block[block.length - 1] = checksum;
            return block;
        }

        // Create ZIP file from multiple files
        async function createZipFromFiles(files) {
            // Simple ZIP creation without compression (STORE method)
            const entries = [];
            let offset = 0;

            // Build local file headers and file data
            for (const file of files) {
                const nameBytes = new TextEncoder().encode(file.filename);
                const localHeader = new Uint8Array(30 + nameBytes.length);

                // Local file header signature
                localHeader[0] = 0x50; localHeader[1] = 0x4B;
                localHeader[2] = 0x03; localHeader[3] = 0x04;
                // Version needed (2.0)
                localHeader[4] = 20; localHeader[5] = 0;
                // Flags
                localHeader[6] = 0; localHeader[7] = 0;
                // Compression (0 = store)
                localHeader[8] = 0; localHeader[9] = 0;
                // Mod time/date (use fixed value)
                localHeader[10] = 0; localHeader[11] = 0;
                localHeader[12] = 0x21; localHeader[13] = 0;
                // CRC32
                const crc = crc32(file.data);
                localHeader[14] = crc & 0xFF;
                localHeader[15] = (crc >> 8) & 0xFF;
                localHeader[16] = (crc >> 16) & 0xFF;
                localHeader[17] = (crc >> 24) & 0xFF;
                // Compressed size
                localHeader[18] = file.data.length & 0xFF;
                localHeader[19] = (file.data.length >> 8) & 0xFF;
                localHeader[20] = (file.data.length >> 16) & 0xFF;
                localHeader[21] = (file.data.length >> 24) & 0xFF;
                // Uncompressed size
                localHeader[22] = file.data.length & 0xFF;
                localHeader[23] = (file.data.length >> 8) & 0xFF;
                localHeader[24] = (file.data.length >> 16) & 0xFF;
                localHeader[25] = (file.data.length >> 24) & 0xFF;
                // Filename length
                localHeader[26] = nameBytes.length & 0xFF;
                localHeader[27] = (nameBytes.length >> 8) & 0xFF;
                // Extra field length
                localHeader[28] = 0; localHeader[29] = 0;
                // Filename
                localHeader.set(nameBytes, 30);

                entries.push({
                    filename: file.filename,
                    nameBytes,
                    data: file.data,
                    localHeader,
                    offset,
                    crc
                });
                offset += localHeader.length + file.data.length;
            }

            // Build central directory
            const centralDir = [];
            for (const entry of entries) {
                const cdEntry = new Uint8Array(46 + entry.nameBytes.length);
                // Central directory signature
                cdEntry[0] = 0x50; cdEntry[1] = 0x4B;
                cdEntry[2] = 0x01; cdEntry[3] = 0x02;
                // Version made by
                cdEntry[4] = 20; cdEntry[5] = 0;
                // Version needed
                cdEntry[6] = 20; cdEntry[7] = 0;
                // Flags
                cdEntry[8] = 0; cdEntry[9] = 0;
                // Compression
                cdEntry[10] = 0; cdEntry[11] = 0;
                // Mod time/date
                cdEntry[12] = 0; cdEntry[13] = 0;
                cdEntry[14] = 0x21; cdEntry[15] = 0;
                // CRC32
                cdEntry[16] = entry.crc & 0xFF;
                cdEntry[17] = (entry.crc >> 8) & 0xFF;
                cdEntry[18] = (entry.crc >> 16) & 0xFF;
                cdEntry[19] = (entry.crc >> 24) & 0xFF;
                // Compressed size
                cdEntry[20] = entry.data.length & 0xFF;
                cdEntry[21] = (entry.data.length >> 8) & 0xFF;
                cdEntry[22] = (entry.data.length >> 16) & 0xFF;
                cdEntry[23] = (entry.data.length >> 24) & 0xFF;
                // Uncompressed size
                cdEntry[24] = entry.data.length & 0xFF;
                cdEntry[25] = (entry.data.length >> 8) & 0xFF;
                cdEntry[26] = (entry.data.length >> 16) & 0xFF;
                cdEntry[27] = (entry.data.length >> 24) & 0xFF;
                // Filename length
                cdEntry[28] = entry.nameBytes.length & 0xFF;
                cdEntry[29] = (entry.nameBytes.length >> 8) & 0xFF;
                // Extra, comment, disk start, internal/external attrs
                for (let i = 30; i < 42; i++) cdEntry[i] = 0;
                // Local header offset
                cdEntry[42] = entry.offset & 0xFF;
                cdEntry[43] = (entry.offset >> 8) & 0xFF;
                cdEntry[44] = (entry.offset >> 16) & 0xFF;
                cdEntry[45] = (entry.offset >> 24) & 0xFF;
                // Filename
                cdEntry.set(entry.nameBytes, 46);
                centralDir.push(cdEntry);
            }

            const cdSize = centralDir.reduce((sum, e) => sum + e.length, 0);
            const cdOffset = offset;

            // End of central directory
            const eocd = new Uint8Array(22);
            eocd[0] = 0x50; eocd[1] = 0x4B;
            eocd[2] = 0x05; eocd[3] = 0x06;
            // Disk numbers
            eocd[4] = 0; eocd[5] = 0;
            eocd[6] = 0; eocd[7] = 0;
            // Entry counts
            eocd[8] = entries.length & 0xFF;
            eocd[9] = (entries.length >> 8) & 0xFF;
            eocd[10] = entries.length & 0xFF;
            eocd[11] = (entries.length >> 8) & 0xFF;
            // Central directory size
            eocd[12] = cdSize & 0xFF;
            eocd[13] = (cdSize >> 8) & 0xFF;
            eocd[14] = (cdSize >> 16) & 0xFF;
            eocd[15] = (cdSize >> 24) & 0xFF;
            // Central directory offset
            eocd[16] = cdOffset & 0xFF;
            eocd[17] = (cdOffset >> 8) & 0xFF;
            eocd[18] = (cdOffset >> 16) & 0xFF;
            eocd[19] = (cdOffset >> 24) & 0xFF;
            // Comment length
            eocd[20] = 0; eocd[21] = 0;

            // Assemble final ZIP
            const totalSize = offset + cdSize + 22;
            const zipData = new Uint8Array(totalSize);
            let pos = 0;

            for (const entry of entries) {
                zipData.set(entry.localHeader, pos);
                pos += entry.localHeader.length;
                zipData.set(entry.data, pos);
                pos += entry.data.length;
            }
            for (const cd of centralDir) {
                zipData.set(cd, pos);
                pos += cd.length;
            }
            zipData.set(eocd, pos);

            return zipData;
        }

        // CRC32 calculation
        function crc32(data) {
            const table = [];
            for (let i = 0; i < 256; i++) {
                let c = i;
                for (let j = 0; j < 8; j++) {
                    c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
                }
                table[i] = c >>> 0;
            }
            let crc = 0xFFFFFFFF;
            for (let i = 0; i < data.length; i++) {
                crc = table[(crc ^ data[i]) & 0xFF] ^ (crc >>> 8);
            }
            return (crc ^ 0xFFFFFFFF) >>> 0;
        }

        // Download binary file
        function downloadBinaryFile(filename, data) {
            const blob = new Blob([data], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Dialog for selecting ORG address when multiple are present
        async function showOrgSelectionDialog(addresses) {
            return new Promise((resolve) => {
                const dialog = document.createElement('div');
                dialog.className = 'file-selector-dialog';
                dialog.innerHTML = `
                    <div class="file-selector-content" style="max-width: 300px;">
                        <div class="file-selector-header">
                            <h3>Select Entry Point</h3>
                            <button class="file-selector-close">&times;</button>
                        </div>
                        <div class="file-selector-body" style="max-height: 200px;">
                            ${addresses.map(addr =>
                                `<div class="file-item" data-addr="${addr}" style="cursor:pointer;padding:8px;">
                                    ${addr.toString(16).toUpperCase().padStart(4, '0')}h
                                </div>`
                            ).join('')}
                            <div class="file-item" data-custom="true" style="cursor:pointer;padding:8px;color:var(--cyan);">
                                Custom address...
                            </div>
                        </div>
                    </div>
                `;

                document.body.appendChild(dialog);

                const close = () => {
                    dialog.remove();
                    resolve(null);
                };

                dialog.querySelector('.file-selector-close').addEventListener('click', close);
                dialog.addEventListener('click', (e) => {
                    if (e.target === dialog) close();
                });

                dialog.querySelectorAll('.file-item').forEach(item => {
                    item.addEventListener('click', () => {
                        if (item.dataset.custom) {
                            const addr = prompt('Enter entry point address (hex):', addresses[0].toString(16).toUpperCase());
                            if (addr) {
                                const parsed = parseInt(addr, 16);
                                if (!isNaN(parsed) && parsed >= 0 && parsed <= 0xFFFF) {
                                    dialog.remove();
                                    resolve(parsed);
                                } else {
                                    showMessage('Invalid address', 'error');
                                }
                            }
                        } else {
                            dialog.remove();
                            resolve(parseInt(item.dataset.addr));
                        }
                    });
                });
            });
        }

        // Auto-map handlers
        function updateAutoMapStats() {
            const stats = spectrum.getAutoMapStats();
            if (stats.executed === 0 && stats.read === 0 && stats.written === 0) {
                autoMapStats.textContent = '';
                autoMapStats.classList.remove('active');
            } else {
                autoMapStats.textContent = `E:${stats.executed} R:${stats.read} W:${stats.written}`;
                autoMapStats.classList.add('active');
            }
        }

        chkAutoMap.addEventListener('change', () => {
            spectrum.setAutoMapEnabled(chkAutoMap.checked);
            if (chkAutoMap.checked) {
                showMessage('Auto-map tracking enabled');
            }
        });

        btnAutoMapClear.addEventListener('click', () => {
            spectrum.clearAutoMap();
            spectrum.pendingSnapCallback = null;  // Cancel any pending snap
            exportSnapshot = null;  // Clear snap when clearing auto-map
            btnAutoMapSnap.style.background = '';  // Reset button style
            updateAutoMapStats();
            showMessage('Auto-map tracking cleared');
        });

        btnAutoMapSnap.addEventListener('click', () => {
            // Function to capture snapshot
            const captureSnapshot = () => {
                const cpu = spectrum.cpu;
                const paging = spectrum.memory.getPagingState();
                exportSnapshot = {
                    cpu: {
                        a: cpu.a, f: cpu.f, b: cpu.b, c: cpu.c, d: cpu.d, e: cpu.e, h: cpu.h, l: cpu.l,
                        a_: cpu.a_, f_: cpu.f_, b_: cpu.b_, c_: cpu.c_, d_: cpu.d_, e_: cpu.e_, h_: cpu.h_, l_: cpu.l_,
                        ix: cpu.ix, iy: cpu.iy, sp: cpu.sp, pc: cpu.pc,
                        i: cpu.i, r: cpu.r, im: cpu.im, iff1: cpu.iff1, iff2: cpu.iff2
                    },
                    paging: {
                        ramBank: paging.ramBank,
                        romBank: paging.romBank,
                        screenBank: paging.screenBank,
                        pagingDisabled: paging.pagingDisabled
                    },
                    memory: spectrum.memory.getFullSnapshot(),
                    border: spectrum.ula.borderColor,
                    machineType: spectrum.machineType,
                    timestamp: new Date().toISOString()
                };
                btnAutoMapSnap.style.background = 'var(--green)';
                const pcHex = cpu.pc.toString(16).toUpperCase().padStart(4, '0');
                showMessage(`Snap captured at PC=$${pcHex} (frame boundary) - continue running to collect code paths, then Export`);
            };

            if (spectrum.isRunning()) {
                // Schedule snap at next frame boundary (safest state)
                spectrum.pendingSnapCallback = captureSnapshot;
                btnAutoMapSnap.style.background = 'var(--yellow)';  // Yellow = pending
                showMessage('Snap scheduled for next frame boundary...');
            } else {
                // Paused - capture immediately (already at instruction boundary)
                captureSnapshot();
            }
        });

        document.getElementById('btnClearRegions').addEventListener('click', () => {
            const count = regionManager.getAll().length;
            if (count === 0) {
                showMessage('No regions to clear');
                return;
            }
            regionManager.clear();
            updateDebugger();
            showMessage(`Cleared ${count} regions`);
        });

        // XRef controls
        const btnXrefScan = document.getElementById('btnXrefScan');
        const btnXrefScanAll = document.getElementById('btnXrefScanAll');
        const btnXrefClear = document.getElementById('btnXrefClear');
        const chkXrefRuntime = document.getElementById('chkXrefRuntime');
        const xrefStats = document.getElementById('xrefStats');

        function updateXrefStats() {
            const count = xrefManager.getCount();
            if (count > 0) {
                xrefStats.textContent = `${count} refs`;
                xrefStats.classList.add('active');
            } else {
                xrefStats.textContent = '';
                xrefStats.classList.remove('active');
            }
        }

        btnXrefScan.addEventListener('click', () => {
            // Scan visible range (approximate 4KB from current disasm view)
            const startAddr = disasmViewAddress || 0;
            const endAddr = (startAddr + 0x1000) & 0xffff;
            const count = xrefManager.scanRange(startAddr, endAddr);
            updateXrefStats();
            showMessage(`Scanned ${hex16(startAddr)}-${hex16(endAddr)}: ${count} refs found`);
        });

        btnXrefScanAll.addEventListener('click', async () => {
            btnXrefScanAll.disabled = true;
            btnXrefScanAll.textContent = 'Scanning...';
            try {
                const count = await xrefManager.scanRangeAsync(0x0000, 0xFFFF, (done, total, refs) => {
                    const pct = Math.round((done / total) * 100);
                    btnXrefScanAll.textContent = `${pct}%`;
                });
                updateXrefStats();
                showMessage(`Full scan: ${count} refs found`);
            } finally {
                btnXrefScanAll.disabled = false;
                btnXrefScanAll.textContent = 'Scan All';
            }
        });

        btnXrefClear.addEventListener('click', () => {
            xrefManager.clear();
            updateXrefStats();
            showMessage('XRefs cleared');
        });

        chkXrefRuntime.addEventListener('change', () => {
            xrefRuntimeEnabled = chkXrefRuntime.checked;
            spectrum.xrefTrackingEnabled = xrefRuntimeEnabled;
            if (xrefRuntimeEnabled) {
                showMessage('XRef runtime tracking enabled');
            }
        });

        // Set up xref tracking callback
        spectrum.onInstructionExecuted = (pc) => {
            if (!xrefRuntimeEnabled || !disasm) return;
            const instr = disasm.disassemble(pc, true);
            if (instr.refs) {
                for (const ref of instr.refs) {
                    xrefManager.add(ref.target, pc, ref.type, null);
                }
            }
        };

        // Trace controls
        const chkTraceEnabled = document.getElementById('chkTraceEnabled');
        const chkTraceRuntime = document.getElementById('chkTraceRuntime');
        const btnTraceBack = document.getElementById('btnTraceBack');
        const btnTraceForward = document.getElementById('btnTraceForward');
        const btnTraceLive = document.getElementById('btnTraceLive');
        const btnTraceClear = document.getElementById('btnTraceClear');
        const btnTraceExport = document.getElementById('btnTraceExport');
        const selTraceExportMode = document.getElementById('selTraceExportMode');
        const txtTraceExportCount = document.getElementById('txtTraceExportCount');
        const txtTraceStopAfter = document.getElementById('txtTraceStopAfter');
        const chkTraceBytes = document.getElementById('chkTraceBytes');
        const chkTraceAlt = document.getElementById('chkTraceAlt');
        const chkTraceSys = document.getElementById('chkTraceSys');
        const chkTracePorts = document.getElementById('chkTracePorts');
        const chkTraceSkipROM = document.getElementById('chkTraceSkipROM');
        const chkTraceCollapseBlock = document.getElementById('chkTraceCollapseBlock');
        const traceStatus = document.getElementById('traceStatus');
        const traceList = document.getElementById('traceList');

        // Set up trace recording callback
        spectrum.onBeforeStep = (cpu, memory, instrPC, portOps, memOps, instrBytes) => {
            try {
                traceManager.record(cpu, memory, instrPC, portOps, memOps, instrBytes);
            } catch (e) {
                console.error('Trace record error:', e);
            }
        };
        spectrum.traceEnabled = true;

        window.updateTraceStatus = function updateTraceStatus() {
            const len = traceManager.length;
            const pos = traceManager.getCurrentPosition();
            const stopped = traceManager.stopped;
            if (pos === -1) {
                traceStatus.textContent = stopped ? `${len} STOPPED` : `${len} instr`;
                traceStatus.classList.toggle('active', len > 0);
                traceStatus.style.color = stopped ? '#f44' : '';
            } else {
                traceStatus.textContent = `${pos + 1}/${len}`;
                traceStatus.classList.add('active');
                traceStatus.style.color = '';
            }
            btnTraceBack.disabled = len === 0 || pos === 0;
            btnTraceForward.disabled = pos === -1;
            btnTraceLive.disabled = pos === -1;
        }

        window.updateTraceList = function updateTraceList() {
            // Only update if trace panel is active
            const tracePanel = document.getElementById('panel-trace');
            if (!tracePanel || !tracePanel.classList.contains('active')) return;

            const currentPos = traceManager.getCurrentPosition();
            const totalLen = traceManager.length;

            // Get entries: either around current position or most recent
            let entries, startIdx, viewIdxInList;
            if (currentPos >= 0) {
                // Navigating history - show entries around current position
                const result = traceManager.getEntriesAround(currentPos, 20);
                entries = result.entries;
                startIdx = result.startIdx;
                viewIdxInList = result.viewIdx;
            } else {
                // Live view - show most recent entries
                entries = traceManager.getRecent(20);
                startIdx = totalLen - entries.length;
                viewIdxInList = -1;
            }

            if (entries.length === 0) {
                traceList.innerHTML = '<div style="padding:4px;color:var(--text-secondary)">No trace data</div>';
                return;
            }

            let html = '';
            const includeAlt = chkTraceAlt.checked;
            const includeSys = chkTraceSys.checked;
            let prev = null;

            for (let i = 0; i < entries.length; i++) {
                const entry = entries[i];
                const globalIdx = startIdx + i;
                const isFirst = (i === 0);
                const isViewing = currentPos === globalIdx;
                const isCurrent = currentPos === -1 && i === entries.length - 1;

                // Disassemble the instruction (use stored bytes as hex if disasm unavailable)
                let instrText = '';
                if (disasm) {
                    const instr = disasm.disassemble(entry.pc);
                    instrText = instr.mnemonic;
                } else {
                    instrText = entry.bytes.slice(0, 3).map(b => hex8(b)).join(' ');
                }

                const classes = ['trace-entry'];
                if (isViewing) classes.push('viewing');
                if (isCurrent) classes.push('current');

                // Format port operations if present
                let portsHtml = '';
                if (entry.ports && entry.ports.length > 0) {
                    const portStrs = entry.ports.map(p =>
                        `${p.dir === 'in' ? 'IN' : 'OUT'}(${hex16(p.port)})=${hex8(p.val)}`
                    );
                    portsHtml = `<span class="ports">${portStrs.join(' ')}</span>`;
                }

                // Format memory operations if present
                let memHtml = '';
                if (entry.mem && entry.mem.length > 0) {
                    const memStrs = entry.mem.map(m => `[${hex16(m.addr)}]=${hex8(m.val)}`);
                    const suffix = entry.mem.length >= 8 ? '...' : '';
                    memHtml = `<span class="memops">${memStrs.join(' ')}${suffix}</span>`;
                }

                // Build register string — only show registers that changed
                const regParts = [];
                if (isFirst || !prev || entry.af !== prev.af) regParts.push(`AF=${hex16(entry.af)}`);
                if (isFirst || !prev || entry.bc !== prev.bc) regParts.push(`BC=${hex16(entry.bc)}`);
                if (isFirst || !prev || entry.de !== prev.de) regParts.push(`DE=${hex16(entry.de)}`);
                if (isFirst || !prev || entry.hl !== prev.hl) regParts.push(`HL=${hex16(entry.hl)}`);
                if (isFirst || !prev || entry.sp !== prev.sp) regParts.push(`SP=${hex16(entry.sp)}`);
                if (isFirst || !prev || entry.ix !== prev.ix) regParts.push(`IX=${hex16(entry.ix)}`);
                if (isFirst || !prev || entry.iy !== prev.iy) regParts.push(`IY=${hex16(entry.iy)}`);
                if (includeAlt) {
                    if (isFirst || !prev || entry.af_ !== prev.af_) regParts.push(`AF'=${hex16(entry.af_)}`);
                    if (isFirst || !prev || entry.bc_ !== prev.bc_) regParts.push(`BC'=${hex16(entry.bc_)}`);
                    if (isFirst || !prev || entry.de_ !== prev.de_) regParts.push(`DE'=${hex16(entry.de_)}`);
                    if (isFirst || !prev || entry.hl_ !== prev.hl_) regParts.push(`HL'=${hex16(entry.hl_)}`);
                }
                if (includeSys) {
                    if (isFirst || !prev || entry.i !== prev.i) regParts.push(`I=${hex8(entry.i)}`);
                    if (isFirst || !prev || entry.r !== prev.r) regParts.push(`R=${hex8(entry.r)}`);
                    if (isFirst || !prev || entry.im !== prev.im) regParts.push(`IM=${entry.im}`);
                }
                const regsHtml = regParts.length > 0 ? `<span class="regs">${regParts.join(' ')}</span>` : '';

                html += `<div class="${classes.join(' ')}" data-idx="${globalIdx}">` +
                    `<span class="addr">${hex16(entry.pc)}</span>` +
                    `<span class="instr">${instrText}</span>` +
                    regsHtml + portsHtml + memHtml +
                    `</div>`;

                prev = entry;
            }
            traceList.innerHTML = html;

            // Scroll to show the relevant entry
            if (viewIdxInList >= 0) {
                // Navigating history - scroll to viewed entry
                const viewedEl = traceList.querySelector('.trace-entry.viewing');
                if (viewedEl) {
                    viewedEl.scrollIntoView({ block: 'center', behavior: 'auto' });
                }
            } else {
                // Live view - scroll to bottom
                traceList.scrollTop = traceList.scrollHeight;
            }
        }

        function showTraceEntry(entry) {
            if (!entry) return;
            // Set trace cursor address for highlighting
            traceViewAddress = entry.pc;
            // Show the trace list panel if hidden
            if (!traceList.classList.contains('visible')) {
                traceList.classList.add('visible');
            }
            // Update displays to show historical state
            updateTraceStatus();
            updateTraceList();
            updateDebugger();  // Update registers to show trace entry values
            // Navigate disasm to the traced PC
            goToAddress(entry.pc);
            showMessage(`Viewing trace: ${hex16(entry.pc)}`);
        }

        chkTraceEnabled.addEventListener('change', () => {
            traceManager.enabled = chkTraceEnabled.checked;
            spectrum.traceEnabled = chkTraceEnabled.checked;
            if (chkTraceEnabled.checked) {
                showMessage('Step trace enabled');
            } else {
                showMessage('Step trace disabled');
            }
        });

        chkTraceAlt.addEventListener('change', () => { updateTraceList(); });
        chkTraceSys.addEventListener('change', () => { updateTraceList(); });

        chkTraceRuntime.addEventListener('change', () => {
            spectrum.runtimeTraceEnabled = chkTraceRuntime.checked;
            spectrum.updateMemoryCallbacksFlag();
            if (chkTraceRuntime.checked) {
                showMessage('Runtime trace enabled');
            } else {
                showMessage('Runtime trace disabled');
            }
        });

        btnTraceBack.addEventListener('click', () => {
            const entry = traceManager.goBack();
            if (entry) {
                showTraceEntry(entry);
            }
        });

        btnTraceForward.addEventListener('click', () => {
            const entry = traceManager.goForward();
            if (entry) {
                showTraceEntry(entry);
            } else {
                // Returned to live
                traceManager.goToLive();
                traceViewAddress = null;  // Clear trace cursor
                updateTraceStatus();
                updateTraceList();
                updateDebugger();
                showMessage('Returned to live view');
            }
        });

        btnTraceLive.addEventListener('click', () => {
            traceManager.goToLive();
            traceViewAddress = null;  // Clear trace cursor
            updateTraceStatus();
            updateTraceList();
            updateDebugger();
            showMessage('Returned to live view');
        });

        btnTraceClear.addEventListener('click', () => {
            traceManager.clear();
            updateTraceStatus();
            updateTraceList();
            showMessage('Trace cleared');
        });

        btnTraceExport.addEventListener('click', () => {
            if (traceManager.length === 0) {
                showMessage('No trace data to export');
                return;
            }

            // Calculate range based on mode and count
            const mode = selTraceExportMode.value;  // 'first' or 'last'
            const count = parseInt(txtTraceExportCount.value, 10) || 0;
            const total = traceManager.length;

            let startIdx = 0;
            let endIdx = total;

            if (count > 0 && count < total) {
                if (mode === 'first') {
                    startIdx = 0;
                    endIdx = count;
                } else {
                    startIdx = total - count;
                    endIdx = total;
                }
            }

            const exportCount = endIdx - startIdx;

            const text = traceManager.exportToText({
                includeBytes: chkTraceBytes.checked,
                includeAlt: chkTraceAlt.checked,
                includeSys: chkTraceSys.checked,
                includePorts: chkTracePorts.checked,
                includeMem: false,
                collapseBlock: chkTraceCollapseBlock.checked,
                startIdx: startIdx,
                endIdx: endIdx
            });
            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `trace_${spectrum.machineType}_${mode}${count || 'all'}_${Date.now()}.txt`;
            a.click();
            URL.revokeObjectURL(url);
            showMessage(`Exported ${exportCount} trace entries (${mode} ${count || 'all'})`);
        });

        // Update stopAfter on change or input
        function updateTraceStopAfter() {
            const val = parseInt(txtTraceStopAfter.value, 10) || 0;
            traceManager.stopAfter = val;
            traceManager.stopped = false;  // Reset stopped state when limit changes
            // Ensure maxHistory is at least as large as stopAfter
            if (val > 0 && val > traceManager.maxHistory) {
                traceManager.maxHistory = val;
            }
        }
        txtTraceStopAfter.addEventListener('change', () => {
            updateTraceStopAfter();
            showMessage(traceManager.stopAfter > 0 ? `Trace will stop after ${traceManager.stopAfter} entries` : 'Trace limit disabled');
        });
        txtTraceStopAfter.addEventListener('input', updateTraceStopAfter);

        // Pause emulator when trace limit is reached
        traceManager.onStopped = () => {
            if (spectrum.running) {
                spectrum.stop();
                updateTraceStatus();
                showMessage(`Trace stopped at ${traceManager.length} entries - emulator paused`);
            }
        };

        // Initialize stopAfter from HTML default value
        updateTraceStopAfter();

        // Skip ROM checkbox
        chkTraceSkipROM.addEventListener('change', () => {
            traceManager.skipROM = chkTraceSkipROM.checked;
        });
        traceManager.skipROM = chkTraceSkipROM.checked;

        // Click on trace status to update trace list
        traceStatus.addEventListener('click', () => {
            updateTraceList();
        });

        // Click on trace entry to navigate
        traceList.addEventListener('click', (e) => {
            const entryEl = e.target.closest('.trace-entry');
            if (entryEl) {
                const idx = parseInt(entryEl.dataset.idx, 10);
                const entry = traceManager.getEntry(idx);
                if (entry) {
                    traceManager.position = idx;
                    showTraceEntry(entry);
                }
            }
        });

        // Memory Map Dialog
        const memmapDialog = document.getElementById('memmapDialog');
        const memmapCanvas = document.getElementById('memmapCanvas');
        const memmapCtx = memmapCanvas.getContext('2d');
        const memmapTooltip = document.getElementById('memmapTooltip');
        const memmapStats = document.getElementById('memmapStats');
        const memmapBar = document.getElementById('memmapBar');
        const memmapAddrInfo = document.getElementById('memmapAddrInfo');

        const MEMMAP_COLORS = {
            code: '#4080ff',
            smc: '#ff4040',
            db: '#ffcc00',
            dw: '#ff8800',
            text: '#40cc40',
            graphics: '#cc40cc',
            unmapped: '#606060',
            zero: '#000000'
        };

        let memmapViewMode = 'regions'; // 'regions' or 'heatmap'
        let memmapBankMode = '64k'; // '64k' or '128k'
        const btnMemmapRegions = document.getElementById('btnMemmapRegions');
        const btnMemmapHeatmap = document.getElementById('btnMemmapHeatmap');
        const memmapLegendRegions = document.getElementById('memmapLegendRegions');
        const memmapLegendHeatmap = document.getElementById('memmapLegendHeatmap');
        const memmapBankToggle = document.getElementById('memmapBankToggle');
        const btnMemmap64K = document.getElementById('btnMemmap64K');
        const btnMemmap128K = document.getElementById('btnMemmap128K');
        const memmapScale = document.querySelector('.memmap-scale');

        function updateMemmapScale() {
            const romLabel = document.getElementById('memmapRomLabel');
            const bankLabel = document.getElementById('memmapBankLabel');
            if (!spectrum) return;

            // Show/hide 128K toggle based on machine type
            if (spectrum.memory.machineType === '48k') {
                memmapBankToggle.style.display = 'none';
                memmapBankMode = '64k';
            } else {
                memmapBankToggle.style.display = 'flex';
            }

            // Update scale visibility based on bank mode
            memmapScale.style.display = (memmapBankMode === '128k') ? 'none' : 'flex';

            if (spectrum.memory.machineType === '48k') {
                romLabel.textContent = 'ROM';
                bankLabel.textContent = 'RAM';
            } else {
                romLabel.textContent = 'ROM ' + spectrum.memory.currentRomBank;
                bankLabel.textContent = 'Bank ' + spectrum.memory.currentRamBank;
            }
        }

        function openMemoryMap() {
            memmapDialog.classList.remove('hidden');
            updateMemmapScale();
            renderCurrentMemmapView();
        }

        function renderCurrentMemmapView() {
            if (memmapBankMode === '128k') {
                render128KMap();
            } else if (memmapViewMode === 'heatmap') {
                renderHeatmap();
            } else {
                renderMemoryMap();
            }
        }

        function closeMemoryMap() {
            memmapDialog.classList.add('hidden');
        }

        function setMemmapView(mode) {
            memmapViewMode = mode;
            btnMemmapRegions.classList.toggle('active', mode === 'regions');
            btnMemmapHeatmap.classList.toggle('active', mode === 'heatmap');
            memmapLegendRegions.classList.toggle('hidden', mode !== 'regions');
            memmapLegendHeatmap.classList.toggle('hidden', mode !== 'heatmap');
            renderCurrentMemmapView();
        }

        function setMemmapBankMode(mode) {
            memmapBankMode = mode;
            btnMemmap64K.classList.toggle('active', mode === '64k');
            btnMemmap128K.classList.toggle('active', mode === '128k');
            memmapScale.style.display = (mode === '128k') ? 'none' : 'flex';
            // Show legends in both modes
            memmapLegendRegions.classList.toggle('hidden', memmapViewMode !== 'regions');
            memmapLegendHeatmap.classList.toggle('hidden', memmapViewMode !== 'heatmap');
            renderCurrentMemmapView();
        }

        btnMemmapRegions.addEventListener('click', () => setMemmapView('regions'));
        btnMemmapHeatmap.addEventListener('click', () => setMemmapView('heatmap'));
        btnMemmap64K.addEventListener('click', () => setMemmapBankMode('64k'));
        btnMemmap128K.addEventListener('click', () => setMemmapBankMode('128k'));

        function getMemoryMapData() {
            const data = new Array(65536);
            const stats = {
                code: 0, smc: 0, db: 0, dw: 0, text: 0, graphics: 0, unmapped: 0, zero: 0
            };

            // First pass: mark all addresses based on memory content
            for (let addr = 0; addr < 65536; addr++) {
                const val = spectrum.memory.read(addr);
                const region = regionManager.get(addr);

                if (region) {
                    data[addr] = region.type;
                    stats[region.type]++;
                } else if (val === 0) {
                    data[addr] = 'zero';
                    stats.zero++;
                } else {
                    data[addr] = 'unmapped';
                    stats.unmapped++;
                }
            }

            return { data, stats };
        }

        function renderMemoryMap() {
            const { data, stats } = getMemoryMapData();
            const imageData = memmapCtx.createImageData(512, 512);

            // Render 512x512 grid (2x2 pixels per byte, row-major)
            for (let addr = 0; addr < 65536; addr++) {
                const type = data[addr];
                const color = MEMMAP_COLORS[type] || MEMMAP_COLORS.unmapped;

                // Parse hex color
                const r = parseInt(color.slice(1, 3), 16);
                const g = parseInt(color.slice(3, 5), 16);
                const b = parseInt(color.slice(5, 7), 16);

                // Calculate 2x2 pixel position
                const srcX = addr & 0xFF;
                const srcY = addr >> 8;
                const dstX = srcX * 2;
                const dstY = srcY * 2;

                // Draw 2x2 block
                for (let dy = 0; dy < 2; dy++) {
                    for (let dx = 0; dx < 2; dx++) {
                        const idx = ((dstY + dy) * 512 + (dstX + dx)) * 4;
                        imageData.data[idx] = r;
                        imageData.data[idx + 1] = g;
                        imageData.data[idx + 2] = b;
                        imageData.data[idx + 3] = 255;
                    }
                }
            }

            memmapCtx.putImageData(imageData, 0, 0);

            // Update statistics
            const total = 65536;
            const mapped = stats.code + stats.smc + stats.db + stats.dw + stats.text + stats.graphics;

            memmapStats.innerHTML = `
                <table>
                    <tr><td>Code</td><td>${stats.code.toLocaleString()}</td><td>${(stats.code/total*100).toFixed(1)}%</td></tr>
                    <tr><td>SMC</td><td>${stats.smc.toLocaleString()}</td><td>${(stats.smc/total*100).toFixed(1)}%</td></tr>
                    <tr><td>DB</td><td>${stats.db.toLocaleString()}</td><td>${(stats.db/total*100).toFixed(1)}%</td></tr>
                    <tr><td>DW</td><td>${stats.dw.toLocaleString()}</td><td>${(stats.dw/total*100).toFixed(1)}%</td></tr>
                    <tr><td>Text</td><td>${stats.text.toLocaleString()}</td><td>${(stats.text/total*100).toFixed(1)}%</td></tr>
                    <tr><td>Graphics</td><td>${stats.graphics.toLocaleString()}</td><td>${(stats.graphics/total*100).toFixed(1)}%</td></tr>
                    <tr><td>Unmapped</td><td>${stats.unmapped.toLocaleString()}</td><td>${(stats.unmapped/total*100).toFixed(1)}%</td></tr>
                    <tr><td>Zeroes</td><td>${stats.zero.toLocaleString()}</td><td>${(stats.zero/total*100).toFixed(1)}%</td></tr>
                    <tr class="total"><td>Mapped</td><td>${mapped.toLocaleString()}</td><td>${(mapped/total*100).toFixed(1)}%</td></tr>
                </table>
            `;

            // Update bar
            const barParts = [
                { type: 'code', width: stats.code / total * 100 },
                { type: 'smc', width: stats.smc / total * 100 },
                { type: 'db', width: stats.db / total * 100 },
                { type: 'dw', width: stats.dw / total * 100 },
                { type: 'text', width: stats.text / total * 100 },
                { type: 'graphics', width: stats.graphics / total * 100 },
                { type: 'unmapped', width: stats.unmapped / total * 100 },
                { type: 'zero', width: stats.zero / total * 100 }
            ];

            memmapBar.innerHTML = '<div class="memmap-bar-fill">' +
                barParts.map(p => `<div style="width:${p.width}%;background:${MEMMAP_COLORS[p.type]}"></div>`).join('') +
                '</div>';
        }

        // Heatmap data for tooltip access
        let heatmapData = null;

        function renderHeatmap() {
            const autoMapData = spectrum.getAutoMapData();
            const imageData = memmapCtx.createImageData(512, 512);

            // Find max counts for normalization
            let maxExec = 0, maxRead = 0, maxWrite = 0;
            for (const count of autoMapData.executed.values()) maxExec = Math.max(maxExec, count);
            for (const count of autoMapData.read.values()) maxRead = Math.max(maxRead, count);
            for (const count of autoMapData.written.values()) maxWrite = Math.max(maxWrite, count);

            // Use log scale for better visualization
            const logScale = (count, max) => {
                if (count === 0 || max === 0) return 0;
                return Math.log(count + 1) / Math.log(max + 1);
            };

            // Store heatmap data for tooltip
            heatmapData = {
                executed: autoMapData.executed,
                read: autoMapData.read,
                written: autoMapData.written,
                maxExec, maxRead, maxWrite
            };

            // Stats for display
            const stats = {
                executed: autoMapData.executed.size,
                read: autoMapData.read.size,
                written: autoMapData.written.size,
                totalExec: 0, totalRead: 0, totalWrite: 0
            };
            for (const count of autoMapData.executed.values()) stats.totalExec += count;
            for (const count of autoMapData.read.values()) stats.totalRead += count;
            for (const count of autoMapData.written.values()) stats.totalWrite += count;

            // Render heatmap
            // Color channels: B=execute, G=read, R=write
            for (let addr = 0; addr < 65536; addr++) {
                const key = spectrum.getAutoMapKey(addr);
                const execCount = autoMapData.executed.get(key) || 0;
                const readCount = autoMapData.read.get(key) || 0;
                const writeCount = autoMapData.written.get(key) || 0;

                // Calculate intensity using log scale
                const execIntensity = logScale(execCount, maxExec);
                const readIntensity = logScale(readCount, maxRead);
                const writeIntensity = logScale(writeCount, maxWrite);

                // Map to RGB: R=write (orange), G=read (green), B=execute (blue)
                let r = Math.floor(writeIntensity * 255);
                let g = Math.floor(readIntensity * 255);
                let b = Math.floor(execIntensity * 255);

                // Calculate 2x2 pixel position
                const srcX = addr & 0xFF;
                const srcY = addr >> 8;
                const dstX = srcX * 2;
                const dstY = srcY * 2;

                // Draw 2x2 block
                for (let dy = 0; dy < 2; dy++) {
                    for (let dx = 0; dx < 2; dx++) {
                        const idx = ((dstY + dy) * 512 + (dstX + dx)) * 4;
                        imageData.data[idx] = r;
                        imageData.data[idx + 1] = g;
                        imageData.data[idx + 2] = b;
                        imageData.data[idx + 3] = 255;
                    }
                }
            }

            memmapCtx.putImageData(imageData, 0, 0);

            // Update statistics for heatmap
            memmapStats.innerHTML = `
                <table>
                    <tr><td>Executed addrs</td><td>${stats.executed.toLocaleString()}</td></tr>
                    <tr><td>Total executions</td><td>${stats.totalExec.toLocaleString()}</td></tr>
                    <tr><td>Read addrs</td><td>${stats.read.toLocaleString()}</td></tr>
                    <tr><td>Total reads</td><td>${stats.totalRead.toLocaleString()}</td></tr>
                    <tr><td>Written addrs</td><td>${stats.written.toLocaleString()}</td></tr>
                    <tr><td>Total writes</td><td>${stats.totalWrite.toLocaleString()}</td></tr>
                    <tr class="total"><td>Max exec</td><td>${maxExec.toLocaleString()}</td></tr>
                    <tr class="total"><td>Max read</td><td>${maxRead.toLocaleString()}</td></tr>
                    <tr class="total"><td>Max write</td><td>${maxWrite.toLocaleString()}</td></tr>
                </table>
            `;

            // Update bar for heatmap (show proportions of exec/read/write)
            const totalAccesses = stats.executed + stats.read + stats.written;
            if (totalAccesses > 0) {
                const execWidth = stats.executed / totalAccesses * 100;
                const readWidth = stats.read / totalAccesses * 100;
                const writeWidth = stats.written / totalAccesses * 100;
                memmapBar.innerHTML = `<div class="memmap-bar-fill">
                    <div style="width:${execWidth}%;background:#0066ff" title="Execute"></div>
                    <div style="width:${readWidth}%;background:#00ff66" title="Read"></div>
                    <div style="width:${writeWidth}%;background:#ff6600" title="Write"></div>
                </div>`;
            } else {
                memmapBar.innerHTML = '<div class="memmap-bar-fill"><div style="width:100%;background:#333">No data</div></div>';
            }
        }

        // 128K view: Show all 8 banks in a 2x4 grid with x2 horizontal scale
        function render128KMap() {
            if (!spectrum || spectrum.memory.machineType === '48k') return;

            const imageData = memmapCtx.createImageData(512, 512);
            // Layout: 2 columns x 4 rows, each cell is 256x128 pixels showing 16KB
            // Each byte = 2x1 pixels (x2 horizontal scale)
            const cellWidth = 256;  // pixels
            const cellHeight = 128; // pixels
            const bytesPerRow = 128; // bytes per row in each cell

            // Get heatmap data if in heatmap mode
            let heatData = null, maxExec = 0, maxRead = 0, maxWrite = 0;
            if (memmapViewMode === 'heatmap') {
                const autoMapData = spectrum.getAutoMapData();
                heatData = autoMapData;
                for (const count of autoMapData.executed.values()) maxExec = Math.max(maxExec, count);
                for (const count of autoMapData.read.values()) maxRead = Math.max(maxRead, count);
                for (const count of autoMapData.written.values()) maxWrite = Math.max(maxWrite, count);
            }

            const logScale = (count, max) => {
                if (count === 0 || max === 0) return 0;
                return Math.log(count + 1) / Math.log(max + 1);
            };

            for (let bank = 0; bank < 8; bank++) {
                const col = bank % 2;
                const row = Math.floor(bank / 2);
                const baseX = col * cellWidth;
                const baseY = row * cellHeight;
                const ramBank = spectrum.memory.ram[bank];

                for (let addr = 0; addr < 0x4000; addr++) {
                    const val = ramBank[addr];
                    let r, g, b;

                    // Calculate the CPU address for this bank+offset
                    // Bank 5 is always at 4000-7FFF, Bank 2 at 8000-BFFF
                    // Other banks page into C000-FFFF
                    let cpuAddr;
                    if (bank === 5) cpuAddr = 0x4000 + addr;
                    else if (bank === 2) cpuAddr = 0x8000 + addr;
                    else cpuAddr = 0xC000 + addr;

                    if (memmapViewMode === 'heatmap' && heatData) {
                        // Heatmap mode: show execution/read/write as RGB
                        // Use same key format as getAutoMapKey:
                        // 4000-BFFF: just address string
                        // C000-FFFF: "${addr}:${bank}"
                        let key;
                        if (bank === 5 || bank === 2) {
                            key = cpuAddr.toString();
                        } else {
                            key = `${cpuAddr}:${bank}`;
                        }
                        const execCount = heatData.executed.get(key) || 0;
                        const readCount = heatData.read.get(key) || 0;
                        const writeCount = heatData.written.get(key) || 0;
                        r = Math.floor(logScale(writeCount, maxWrite) * 255);
                        g = Math.floor(logScale(readCount, maxRead) * 255);
                        b = Math.floor(logScale(execCount, maxExec) * 255);
                    } else {
                        // Regions mode: lookup region at CPU address
                        const region = regionManager.get(cpuAddr);
                        let color;
                        if (region) {
                            color = MEMMAP_COLORS[region.type];
                        } else if (val === 0) {
                            color = MEMMAP_COLORS.zero;
                        } else {
                            color = MEMMAP_COLORS.unmapped;
                        }
                        r = parseInt(color.slice(1, 3), 16);
                        g = parseInt(color.slice(3, 5), 16);
                        b = parseInt(color.slice(5, 7), 16);
                    }

                    // Calculate pixel position with x2 horizontal scale
                    const localX = addr % bytesPerRow;
                    const localY = Math.floor(addr / bytesPerRow);
                    const px = baseX + localX * 2;
                    const py = baseY + localY;

                    // Draw 2x1 pixel block
                    for (let dx = 0; dx < 2; dx++) {
                        if ((px + dx) < 512 && py < 512) {
                            const idx = (py * 512 + px + dx) * 4;
                            imageData.data[idx] = r;
                            imageData.data[idx + 1] = g;
                            imageData.data[idx + 2] = b;
                            imageData.data[idx + 3] = 255;
                        }
                    }
                }
            }

            memmapCtx.putImageData(imageData, 0, 0);

            // Draw grid lines
            memmapCtx.strokeStyle = '#444';
            memmapCtx.lineWidth = 1;
            // Vertical line (center)
            memmapCtx.beginPath();
            memmapCtx.moveTo(cellWidth, 0);
            memmapCtx.lineTo(cellWidth, 512);
            memmapCtx.stroke();
            // Horizontal lines
            for (let i = 1; i < 4; i++) {
                memmapCtx.beginPath();
                memmapCtx.moveTo(0, i * cellHeight);
                memmapCtx.lineTo(512, i * cellHeight);
                memmapCtx.stroke();
            }

            // Draw bank labels
            memmapCtx.font = '11px monospace';
            for (let bank = 0; bank < 8; bank++) {
                const col = bank % 2;
                const row = Math.floor(bank / 2);
                const x = col * cellWidth + 4;
                const y = row * cellHeight + 14;
                const isCurrentBank = (bank === spectrum.memory.currentRamBank);
                memmapCtx.fillStyle = isCurrentBank ? '#00ff00' : '#888';
                memmapCtx.fillText('Bank ' + bank, x, y);
            }

            // Update stats
            let totalZero = 0, totalNonZero = 0;
            for (let bank = 0; bank < 8; bank++) {
                const ramBank = spectrum.memory.ram[bank];
                for (let addr = 0; addr < 0x4000; addr++) {
                    if (ramBank[addr] === 0) totalZero++;
                    else totalNonZero++;
                }
            }
            const total = 128 * 1024;
            memmapStats.innerHTML = `
                <table>
                    <tr><td>Total RAM</td><td>128 KB</td></tr>
                    <tr><td>Non-zero</td><td>${totalNonZero.toLocaleString()}</td><td>${(totalNonZero/total*100).toFixed(1)}%</td></tr>
                    <tr><td>Zeroes</td><td>${totalZero.toLocaleString()}</td><td>${(totalZero/total*100).toFixed(1)}%</td></tr>
                    <tr class="total"><td>Current</td><td colspan="2">Bank ${spectrum.memory.currentRamBank}</td></tr>
                </table>
            `;
            memmapBar.innerHTML = '';
        }

        function getAddrFromCanvasPos(x, y) {
            const rect = memmapCanvas.getBoundingClientRect();
            const scaleX = 512 / rect.width;
            const scaleY = 512 / rect.height;
            const px = Math.floor((x - rect.left) * scaleX / 2);  // Divide by 2 for 2x scale
            const py = Math.floor((y - rect.top) * scaleY / 2);
            if (px < 0 || px >= 256 || py < 0 || py >= 256) return -1;
            return py * 256 + px;
        }

        memmapCanvas.addEventListener('mousemove', (e) => {
            const addr = getAddrFromCanvasPos(e.clientX, e.clientY);
            if (addr < 0) {
                memmapTooltip.style.display = 'none';
                return;
            }

            const val = spectrum.memory.read(addr);
            const label = labelManager.get(addr);
            let info, infoText;

            if (memmapViewMode === 'heatmap' && heatmapData) {
                // Heatmap tooltip
                const key = spectrum.getAutoMapKey(addr);
                const execCount = heatmapData.executed.get(key) || 0;
                const readCount = heatmapData.read.get(key) || 0;
                const writeCount = heatmapData.written.get(key) || 0;

                info = `${hex16(addr)}: E:${execCount} R:${readCount} W:${writeCount}`;
                if (label) info += ` [${label.name}]`;

                const addrHi = (addr >> 8).toString(16).toUpperCase().padStart(2, '0');
                const addrLo = (addr & 0xFF).toString(16).toUpperCase().padStart(2, '0');
                infoText = `Address: ${hex16(addr)} (${addrHi}xx + ${addrLo})\nValue: ${hex8(val)} (${val})`;
                infoText += `\nExecuted: ${execCount.toLocaleString()} times`;
                infoText += `\nRead: ${readCount.toLocaleString()} times`;
                infoText += `\nWritten: ${writeCount.toLocaleString()} times`;
                if (label) infoText += `\nLabel: ${label.name}`;
            } else {
                // Region tooltip
                const region = regionManager.get(addr);
                const type = region ? region.type : (val === 0 ? 'Zero' : 'Unmapped');

                info = `${hex16(addr)}: ${hex8(val)} - ${type}`;
                if (label) info += ` [${label.name}]`;

                const addrHi = (addr >> 8).toString(16).toUpperCase().padStart(2, '0');
                const addrLo = (addr & 0xFF).toString(16).toUpperCase().padStart(2, '0');
                infoText = `Address: ${hex16(addr)} (${addrHi}xx + ${addrLo})\nValue: ${hex8(val)} (${val})\nType: ${type}`;
                if (region && region.comment) infoText += `\n${region.comment}`;
                if (label) infoText += `\nLabel: ${label.name}`;
            }

            memmapTooltip.textContent = info;
            memmapTooltip.style.display = 'block';
            memmapTooltip.style.left = (e.clientX - memmapCanvas.getBoundingClientRect().left + 10) + 'px';
            memmapTooltip.style.top = (e.clientY - memmapCanvas.getBoundingClientRect().top - 20) + 'px';
            memmapAddrInfo.textContent = infoText;
        });

        memmapCanvas.addEventListener('mouseleave', () => {
            memmapTooltip.style.display = 'none';
        });

        memmapCanvas.addEventListener('click', (e) => {
            const addr = getAddrFromCanvasPos(e.clientX, e.clientY);
            if (addr >= 0) {
                closeMemoryMap();
                // Navigate disassembly (includes history)
                goToAddress(addr);
                // Navigate memory dump
                goToMemoryAddress(addr);
                updateDebugger();
            }
        });

        document.getElementById('btnMemoryMap').addEventListener('click', openMemoryMap);
        document.getElementById('btnMemmapClose').addEventListener('click', closeMemoryMap);
        document.getElementById('btnExportAsm').addEventListener('click', exportDisassembly);

        // Export disassembly as sjasmplus-compatible ASM file
        function exportDisassembly() {
            const SCREEN_START = 0x4000;
            const SCREEN_END = 0x5B00;  // Screen memory ends at 5AFF, attributes at 5B00

            const lines = [];
            const now = new Date();
            const timestamp = now.toISOString().replace('T', ' ').substring(0, 19);

            // Use snapped state if available, otherwise current state
            const usingSnapshot = exportSnapshot !== null;
            const cpu = usingSnapshot ? exportSnapshot.cpu : spectrum.cpu;

            // Paging state (for 128K/Pentagon)
            const paging = usingSnapshot && exportSnapshot.paging
                ? exportSnapshot.paging
                : spectrum.memory.getPagingState();

            // Memory read function - uses snapshot if available
            const readMem = usingSnapshot
                ? (addr) => exportSnapshot.memory[addr & 0xFFFF]
                : (addr) => spectrum.memory.read(addr);

            const hex16 = (v) => '$' + (v & 0xFFFF).toString(16).toUpperCase().padStart(4, '0');
            const hex8 = (v) => '$' + (v & 0xFF).toString(16).toUpperCase().padStart(2, '0');

            // Build register pairs from individual registers
            const af = (cpu.a << 8) | cpu.f;
            const bc = (cpu.b << 8) | cpu.c;
            const de = (cpu.d << 8) | cpu.e;
            const hl = (cpu.h << 8) | cpu.l;
            const af_ = (cpu.a_ << 8) | cpu.f_;
            const bc_ = (cpu.b_ << 8) | cpu.c_;
            const de_ = (cpu.d_ << 8) | cpu.e_;
            const hl_ = (cpu.h_ << 8) | cpu.l_;
            const stackDepth = 16;
            const sp = cpu.sp;

            // Calculate port $7FFD value for 128K paging
            // Bits 0-2: RAM bank, Bit 3: screen (0=bank5, 1=bank7), Bit 4: ROM, Bit 5: lock
            const port7FFD = (paging.ramBank & 0x07) |
                             (paging.screenBank === 7 ? 0x08 : 0x00) |
                             (paging.romBank ? 0x10 : 0x00) |
                             (paging.pagingDisabled ? 0x20 : 0x00);

            // DEVICE directive based on machine type
            const deviceMap = {
                '48k': 'ZXSPECTRUM48',
                '128k': 'ZXSPECTRUM128',
                '+2': 'ZXSPECTRUM128',      // +2 uses 128K memory model
                '+2a': 'ZXSPECTRUM128',     // +2A uses 128K memory model
                'pentagon': 'ZXSPECTRUM128'  // Pentagon uses 128K memory model
            };
            const device = deviceMap[spectrum.machineType] || 'ZXSPECTRUM48';

            // Header with DEVICE
            lines.push('; Disassembly exported from ZX-M8XXX v' + APP_VERSION);
            lines.push(`; Date: ${timestamp}`);
            lines.push(`; Machine: ${spectrum.machineType.toUpperCase()}`);
            if (usingSnapshot) {
                lines.push(`; Using SNAPSHOT from: ${exportSnapshot.timestamp || 'unknown'}`);
                lines.push('; NOTE: Byte values are from snapshot, but instruction disassembly');
                lines.push(';       uses current memory (may differ if memory changed)');
            }
            lines.push(';');
            lines.push('; CPU State:');
            lines.push(`; PC=${hex16(cpu.pc)}  SP=${hex16(cpu.sp)}  IM=${cpu.im}  IFF1=${cpu.iff1 ? 1 : 0}  IFF2=${cpu.iff2 ? 1 : 0}`);
            lines.push(`; AF=${hex16(af)}  BC=${hex16(bc)}  DE=${hex16(de)}  HL=${hex16(hl)}`);
            lines.push(`; IX=${hex16(cpu.ix)}  IY=${hex16(cpu.iy)}  I=${hex8(cpu.i)}  R=${hex8(cpu.r)}`);
            lines.push(`; AF'=${hex16(af_)}  BC'=${hex16(bc_)}  DE'=${hex16(de_)}  HL'=${hex16(hl_)}`);
            // Add paging info for 128K/Pentagon
            if (spectrum.machineType !== '48k') {
                lines.push(`;`);
                lines.push(`; Paging: RAM=${paging.ramBank}  ROM=${paging.romBank}  Screen=${paging.screenBank}  Lock=${paging.pagingDisabled ? 1 : 0}`);
                lines.push(`; Port $7FFD = ${hex8(port7FFD)}`);
            }
            lines.push(';');
            lines.push('; Stack contents (SP points to top, growing down):');
            let stackLine = '; SP->';
            for (let i = 0; i < stackDepth; i++) {
                const addr = (sp + i * 2) & 0xFFFF;
                const lo = readMem(addr);
                const hi = readMem((addr + 1) & 0xFFFF);
                const word = lo | (hi << 8);
                if (i > 0 && i % 8 === 0) {
                    lines.push(stackLine);
                    stackLine = ';     ';
                }
                stackLine += ` ${hex16(word)}`;
            }
            lines.push(stackLine);
            lines.push(';');
            lines.push('');
            lines.push(`    DEVICE ${device}`);
            lines.push('    OPT --syntax=abf  ; allow undocumented instructions');
            lines.push('');

            // Get all mapped regions and heatmap data
            const autoMapData = spectrum.getAutoMapData();
            const allRegions = regionManager.getAll();

            // Build address set of all addresses with activity (execute, read, write)
            // or marked regions
            const activeAddrs = new Set();
            const executedAddrs = new Set();  // Track which addresses were executed

            // Add executed addresses
            for (const key of autoMapData.executed.keys()) {
                const addr = parseInt(key, 10);  // Parse address (ignores ":page" suffix)
                if (!isNaN(addr) && addr >= 0 && addr < 65536) {
                    activeAddrs.add(addr);
                    executedAddrs.add(addr);  // Remember this was executed
                }
            }

            // Add read addresses
            for (const key of autoMapData.read.keys()) {
                const addr = parseInt(key, 10);
                if (!isNaN(addr) && addr >= 0 && addr < 65536) {
                    activeAddrs.add(addr);
                }
            }

            // Add written addresses
            for (const key of autoMapData.written.keys()) {
                const addr = parseInt(key, 10);
                if (!isNaN(addr) && addr >= 0 && addr < 65536) {
                    activeAddrs.add(addr);
                }
            }

            // Add addresses from marked regions
            for (const region of allRegions) {
                for (let a = region.start; a <= region.end; a++) {
                    activeAddrs.add(a);
                }
            }

            // Add diagnostic info to header
            lines.push(`; Auto-Map data: ${autoMapData.executed.size} executed, ${autoMapData.read.size} read, ${autoMapData.written.size} written`);
            lines.push(`; Regions: ${allRegions.length} marked regions`);
            lines.push(`; Parsed: ${executedAddrs.size} unique executed addresses`);
            lines.push('');


            if (activeAddrs.size === 0) {
                alert('No mapped regions or heatmap data to export.\nRun the program with Auto-Map tracking enabled first.');
                return;
            }

            // Sort addresses and group into contiguous blocks
            const sortedAddrs = Array.from(activeAddrs).sort((a, b) => a - b);

            // Check if there's executed code in ROM
            const execInROM = Array.from(executedAddrs).filter(a => a < 0x4000).length;
            const execInRAM = Array.from(executedAddrs).filter(a => a >= 0x5B00).length;

            // Ask user if they want to include ROM when ROM code was executed
            let includeROM = false;
            if (execInROM > 0 && execInRAM === 0) {
                includeROM = confirm(`All ${execInROM} executed addresses are in ROM (0000-3FFF).\n\nInclude ROM disassembly in export?`);
            } else if (execInROM > 0) {
                includeROM = confirm(`${execInROM} executed addresses are in ROM.\n\nInclude ROM disassembly in export?`);
            }

            // Check if user wants to include addresses and bytes (from checkbox)
            const includeAddrBytes = document.getElementById('chkExportAddrBytes').checked;
            const dedupLoops = document.getElementById('chkExportDedupLoops').checked;

            // Detect unrolled loops - finds repeating byte patterns in code
            // Returns {patternBytes: [...], repeatCount, totalBytes} or null if no loop found
            // Detect repeating pattern in an instruction array (for nested loop detection)
            function detectPatternInArray(instructions, minRepeats = 3, maxPatternBytes = 512) {
                if (instructions.length < minRepeats * 2) return null;

                let bestResult = null;
                let bestSavings = 0;

                for (let patternLen = 1; patternLen <= Math.min(256, Math.floor(instructions.length / minRepeats)); patternLen++) {
                    // Get pattern bytes
                    let patternBytes = [];
                    for (let i = 0; i < patternLen; i++) {
                        patternBytes = patternBytes.concat(instructions[i].bytes);
                    }
                    if (patternBytes.length > maxPatternBytes) break;

                    // Count repetitions
                    let repeatCount = 1;
                    let instrIdx = patternLen;

                    while (instrIdx + patternLen <= instructions.length) {
                        let matches = true;
                        for (let i = 0; i < patternLen && matches; i++) {
                            const patternInstr = instructions[i];
                            const testInstr = instructions[instrIdx + i];
                            if (patternInstr.bytes.length !== testInstr.bytes.length) {
                                matches = false;
                            } else {
                                for (let b = 0; b < patternInstr.bytes.length; b++) {
                                    if (patternInstr.bytes[b] !== testInstr.bytes[b]) {
                                        matches = false;
                                        break;
                                    }
                                }
                            }
                        }
                        if (matches) {
                            repeatCount++;
                            instrIdx += patternLen;
                        } else {
                            break;
                        }
                    }

                    if (repeatCount >= minRepeats) {
                        const totalBytes = patternBytes.length * repeatCount;
                        const savings = totalBytes - patternBytes.length;
                        if (savings > bestSavings) {
                            bestSavings = savings;
                            bestResult = {
                                patternInstructions: instructions.slice(0, patternLen),
                                patternBytes,
                                repeatCount,
                                totalBytes,
                                instrCount: patternLen * repeatCount
                            };
                        }
                    }
                }

                return bestResult;
            }

            function detectUnrolledLoop(startAddr, blockEnd, minRepeats = 3, maxPatternBytes = 512) {
                // First, disassemble to find instruction boundaries
                const instructions = [];
                let addr = startAddr;
                const maxScanBytes = Math.min(4096, (blockEnd - startAddr + 1));
                let scannedBytes = 0;

                while (scannedBytes < maxScanBytes && addr <= blockEnd) {
                    // Stop at labels (they break the loop pattern)
                    if (addr !== startAddr && labelManager.get(addr)) break;
                    // Stop at non-code region boundaries (data/text regions break the pattern)
                    const region = regionManager.get(addr);
                    if (region && region.start === addr && addr !== startAddr && region.type !== 'code') break;

                    const dis = disasm.disassemble(addr);
                    const bytes = [];
                    for (let i = 0; i < dis.length; i++) {
                        bytes.push(readMem((addr + i) & 0xFFFF));
                    }
                    instructions.push({ addr, bytes, length: dis.length, mnemonic: dis.mnemonic });
                    scannedBytes += dis.length;
                    addr += dis.length;
                }

                if (instructions.length < minRepeats * 2) return null;

                // Try pattern lengths from 1 instruction up to maxPatternBytes worth
                let bestResult = null;
                let bestSavings = 0;

                for (let patternLen = 1; patternLen <= Math.min(256, Math.floor(instructions.length / minRepeats)); patternLen++) {
                    // Get pattern bytes
                    let patternBytes = [];
                    for (let i = 0; i < patternLen; i++) {
                        patternBytes = patternBytes.concat(instructions[i].bytes);
                    }
                    if (patternBytes.length > maxPatternBytes) break;

                    // Count repetitions
                    let repeatCount = 1;
                    let instrIdx = patternLen;

                    while (instrIdx + patternLen <= instructions.length) {
                        // Compare next patternLen instructions
                        let matches = true;
                        for (let i = 0; i < patternLen && matches; i++) {
                            const patternInstr = instructions[i];
                            const testInstr = instructions[instrIdx + i];
                            if (patternInstr.bytes.length !== testInstr.bytes.length) {
                                matches = false;
                            } else {
                                for (let b = 0; b < patternInstr.bytes.length; b++) {
                                    if (patternInstr.bytes[b] !== testInstr.bytes[b]) {
                                        matches = false;
                                        break;
                                    }
                                }
                            }
                        }
                        if (matches) {
                            repeatCount++;
                            instrIdx += patternLen;
                        } else {
                            break;
                        }
                    }

                    if (repeatCount >= minRepeats) {
                        const totalBytes = patternBytes.length * repeatCount;
                        const savings = totalBytes - patternBytes.length; // Bytes saved by not repeating
                        if (savings > bestSavings) {
                            bestSavings = savings;
                            bestResult = {
                                patternInstructions: instructions.slice(0, patternLen),
                                patternBytes,
                                repeatCount,
                                totalBytes
                            };
                        }
                    }
                }

                return bestResult;
            }

            // Filter out screen memory, and optionally ROM
            // Keep: addresses >= 0x5B00 (above screen, in RAM)
            // Optionally keep: ROM (< 0x4000)
            // Always exclude: screen (0x4000-0x5AFF)
            const filteredAddrs = sortedAddrs.filter(addr => {
                if (addr >= SCREEN_END) return true;  // Above screen - always include
                if (addr < 0x4000 && includeROM) return true;  // ROM - include if requested
                return false;  // Screen memory - exclude
            });

            // Create Set for O(1) lookup when checking label references
            const exportedAddrs = new Set(filteredAddrs);
            // Track external labels (referenced but not in exported range)
            const externalLabels = new Map();  // addr -> label name

            if (filteredAddrs.length === 0) {
                alert('No exportable addresses found.');
                return;
            }

            // Group into contiguous blocks (gap of 16+ bytes starts new block)
            const blocks = [];
            let blockStart = filteredAddrs[0];
            let blockEnd = filteredAddrs[0];

            for (let i = 1; i < filteredAddrs.length; i++) {
                const addr = filteredAddrs[i];
                if (addr > blockEnd + 16) {
                    // Start new block
                    blocks.push({ start: blockStart, end: blockEnd });
                    blockStart = addr;
                }
                blockEnd = addr;
            }
            blocks.push({ start: blockStart, end: blockEnd });

            // Check for 128K paged memory (addresses >= 0xC000)
            const is128K = is128kCompat(spectrum.machineType) || spectrum.profile.ramPages > 1;
            let currentBank = -1;

            // Generate disassembly for each block
            for (const block of blocks) {
                // Skip screen memory
                if (block.start >= SCREEN_START && block.end < SCREEN_END) continue;

                // Handle bank paging for 128K
                if (is128K && block.start >= 0xC000) {
                    const bank = spectrum.memory.currentBank || 0;
                    if (bank !== currentBank) {
                        lines.push('');
                        lines.push(`    PAGE ${bank}`);
                        currentBank = bank;
                    }
                }

                // ORG directive
                lines.push('');
                lines.push(`    ORG $${block.start.toString(16).toUpperCase().padStart(4, '0')}`);
                lines.push('');

                // Disassemble the block
                let addr = block.start;
                while (addr <= block.end) {
                    // Skip screen memory within block
                    if (addr >= SCREEN_START && addr < SCREEN_END) {
                        addr = SCREEN_END;
                        if (addr > block.end) break;
                        lines.push('');
                        lines.push(`    ORG $${addr.toString(16).toUpperCase().padStart(4, '0')}`);
                        lines.push('');
                    }

                    const region = regionManager.get(addr);
                    const wasExecuted = executedAddrs.has(addr);
                    const labelObj = labelManager.get(addr);

                    // Add label if exists
                    if (labelObj && labelObj.name) {
                        lines.push(`${labelObj.name}:`);
                    }

                    const addrHex = '$' + addr.toString(16).toUpperCase().padStart(4, '0');

                    if (region && region.type === 'text') {
                        // Text region - output as DEFM
                        let text = '';
                        let textStart = addr;
                        const textBytes = [];
                        while (addr <= block.end && addr <= region.end) {
                            const byte = readMem(addr);
                            if (byte >= 32 && byte < 127) {
                                text += String.fromCharCode(byte);
                                textBytes.push(byte.toString(16).toUpperCase().padStart(2, '0'));
                            } else {
                                break;
                            }
                            addr++;
                        }
                        if (text.length > 0) {
                            let line = `    DEFM "${text.replace(/"/g, '""')}"`;
                            if (includeAddrBytes) {
                                line += `  ; ${textStart.toString(16).toUpperCase().padStart(4, '0')}: ${textBytes.join(' ')}`;
                            }
                            lines.push(line);
                        }
                    } else if (region && region.type === 'dw') {
                        // Word data
                        const lo = readMem(addr);
                        const hi = readMem(addr + 1);
                        const word = lo | (hi << 8);
                        let line = `    DEFW $${word.toString(16).toUpperCase().padStart(4, '0')}`;
                        if (includeAddrBytes) {
                            line += `  ; ${addr.toString(16).toUpperCase().padStart(4, '0')}: ${lo.toString(16).toUpperCase().padStart(2, '0')} ${hi.toString(16).toUpperCase().padStart(2, '0')}`;
                        }
                        lines.push(line);
                        addr += 2;
                    } else if (region && (region.type === 'db' || region.type === 'graphics')) {
                        // Byte data or graphics - output as DEFB
                        const bytesPerLine = region.type === 'graphics' ? 8 : 16;
                        let byteCount = 0;
                        let byteValues = [];
                        const startAddr = addr;
                        const rawBytes = [];

                        while (addr <= block.end && addr <= region.end && byteCount < bytesPerLine) {
                            const byte = readMem(addr);
                            byteValues.push('$' + byte.toString(16).toUpperCase().padStart(2, '0'));
                            rawBytes.push(byte.toString(16).toUpperCase().padStart(2, '0'));
                            addr++;
                            byteCount++;
                        }
                        if (byteValues.length > 0) {
                            let line = `    DEFB ${byteValues.join(',')}`;
                            if (includeAddrBytes) {
                                line += `  ; ${startAddr.toString(16).toUpperCase().padStart(4, '0')}: ${rawBytes.join(' ')}`;
                            }
                            lines.push(line);
                        }
                    } else if (wasExecuted || (region && region.type === 'code')) {
                        // Code - check for unrolled loops first
                        let loopHandled = false;
                        if (dedupLoops) {
                            const loop = detectUnrolledLoop(addr, block.end);
                            if (loop && loop.repeatCount >= 3) {
                                // Helper function to format a mnemonic (replace addresses with labels)
                                const formatMnemonic = (mnemonic) => {
                                    const addrMatch = mnemonic.match(/([0-9A-F]{4})h/i);
                                    if (addrMatch) {
                                        const refAddr = parseInt(addrMatch[1], 16);
                                        const refLabelObj = labelManager.get(refAddr);
                                        if (refLabelObj && refLabelObj.name) {
                                            mnemonic = mnemonic.replace(addrMatch[0], refLabelObj.name);
                                            if (!exportedAddrs.has(refAddr)) {
                                                externalLabels.set(refAddr, refLabelObj.name);
                                            }
                                        } else {
                                            mnemonic = mnemonic.replace(/([0-9A-F]{4})h/gi, '$$$1');
                                        }
                                    }
                                    return mnemonic.replace(/([0-9A-F]{2})h/gi, '$$$1');
                                };

                                // Recursive function to output instructions with nested loop detection
                                const outputWithNesting = (instructions, indent) => {
                                    let i = 0;
                                    while (i < instructions.length) {
                                        // Look for inner loop starting at this instruction
                                        const remaining = instructions.slice(i);
                                        const innerLoop = detectPatternInArray(remaining);

                                        if (innerLoop && innerLoop.repeatCount >= 3) {
                                            // Calculate inner loop byte size for comment
                                            const innerBytes = innerLoop.patternBytes.length * innerLoop.repeatCount;
                                            lines.push('');
                                            lines.push(`${indent}; Unrolled loop detected: ${innerLoop.repeatCount} repetitions, ${innerBytes} bytes`);
                                            lines.push(`${indent}REPT ${innerLoop.repeatCount}`);
                                            // Recursively output inner pattern (may have deeper nesting)
                                            outputWithNesting(innerLoop.patternInstructions, indent + '    ');
                                            lines.push(`${indent}ENDR`);
                                            lines.push('');
                                            i += innerLoop.instrCount;
                                        } else {
                                            // Output single instruction
                                            lines.push(`${indent}${formatMnemonic(instructions[i].mnemonic)}`);
                                            i++;
                                        }
                                    }
                                };

                                // Output as REPT block
                                const startAddrHex = addr.toString(16).toUpperCase().padStart(4, '0');
                                lines.push('');  // Empty line before REPT block
                                lines.push(`    ; Unrolled loop detected: ${loop.repeatCount} repetitions, ${loop.totalBytes} bytes`);
                                lines.push(`    REPT ${loop.repeatCount}`);

                                // Output pattern instructions with nested loop detection
                                outputWithNesting(loop.patternInstructions, '        ');

                                lines.push(`    ENDR`);
                                if (includeAddrBytes) {
                                    lines.push(`    ; ${startAddrHex}-${((addr + loop.totalBytes - 1) & 0xFFFF).toString(16).toUpperCase().padStart(4, '0')}`);
                                }
                                lines.push('');  // Empty line after REPT block

                                addr += loop.totalBytes;
                                loopHandled = true;
                            }
                        }

                        if (!loopHandled) {
                            // Regular code disassembly
                            const dis = disasm.disassemble(addr);
                            let mnemonic = dis.mnemonic;

                            // Replace numeric addresses with labels where possible
                            const addrMatch = mnemonic.match(/([0-9A-F]{4})h/i);
                            if (addrMatch) {
                                const refAddr = parseInt(addrMatch[1], 16);
                                const refLabelObj = labelManager.get(refAddr);
                                if (refLabelObj && refLabelObj.name) {
                                    // Use label - either in exported range or will be EQU
                                    mnemonic = mnemonic.replace(addrMatch[0], refLabelObj.name);
                                    // Track external labels for EQU generation
                                    if (!exportedAddrs.has(refAddr)) {
                                        externalLabels.set(refAddr, refLabelObj.name);
                                    }
                                } else {
                                    mnemonic = mnemonic.replace(/([0-9A-F]{4})h/gi, '$$$1');
                                }
                            }
                            // Replace 2-digit hex
                            mnemonic = mnemonic.replace(/([0-9A-F]{2})h/gi, '$$$1');

                            // Build bytes array for address+bytes comment
                            const codeBytes = [];
                            for (let bi = 0; bi < dis.length; bi++) {
                                codeBytes.push(readMem(addr + bi).toString(16).toUpperCase().padStart(2, '0'));
                            }
                            const addrBytesComment = includeAddrBytes
                                ? `  ; ${addr.toString(16).toUpperCase().padStart(4, '0')}: ${codeBytes.join(' ')}`
                                : '';

                            // When using snapshot, output bytes from snapshot with mnemonic as comment
                            // (in case memory changed between snap and export)
                            if (usingSnapshot) {
                                const bytes = codeBytes.map(b => '$' + b);
                                lines.push(`    DEFB ${bytes.join(',')}  ; ${mnemonic}${addrBytesComment ? addrBytesComment.replace('  ; ', ' @ ') : ''}`);
                            } else {
                                lines.push(`    ${mnemonic}${addrBytesComment}`);
                            }
                            addr += dis.length;
                        }
                    } else {
                        // Unknown - just data byte (read/write but not executed)
                        const byte = readMem(addr);
                        const startAddr = addr;

                        // Check for run of same byte (for DS compression)
                        let runLength = 1;
                        while (addr + runLength <= block.end &&
                               readMem(addr + runLength) === byte &&
                               !executedAddrs.has(addr + runLength) &&
                               !regionManager.get(addr + runLength) &&
                               !labelManager.get(addr + runLength)) {
                            runLength++;
                        }

                        if (runLength > 10) {
                            // Use DS for long runs
                            let line = `    DS ${runLength}, $${byte.toString(16).toUpperCase().padStart(2, '0')}`;
                            if (includeAddrBytes) {
                                line += `  ; ${startAddr.toString(16).toUpperCase().padStart(4, '0')}: ${runLength}x ${byte.toString(16).toUpperCase().padStart(2, '0')}`;
                            }
                            lines.push(line);
                            addr += runLength;
                        } else {
                            let line = `    DEFB $${byte.toString(16).toUpperCase().padStart(2, '0')}`;
                            if (includeAddrBytes) {
                                line += `  ; ${addr.toString(16).toUpperCase().padStart(4, '0')}: ${byte.toString(16).toUpperCase().padStart(2, '0')}`;
                            }
                            lines.push(line);
                            addr++;
                        }
                    }
                }
            }

            // Generate EQUs for external labels (referenced but outside exported range)
            if (externalLabels.size > 0) {
                // Find position after DEVICE line to insert EQUs
                const deviceIndex = lines.findIndex(l => l.includes('DEVICE '));
                if (deviceIndex !== -1) {
                    const equLines = [];
                    equLines.push('');
                    equLines.push('; External labels (referenced but not in exported code)');
                    // Sort by address
                    const sortedExternal = Array.from(externalLabels.entries()).sort((a, b) => a[0] - b[0]);
                    for (const [addr, name] of sortedExternal) {
                        equLines.push(`${name} EQU $${addr.toString(16).toUpperCase().padStart(4, '0')}`);
                    }
                    equLines.push('');
                    // Insert after DEVICE line
                    lines.splice(deviceIndex + 1, 0, ...equLines);
                }
            }

            // Restoration code at the bottom
            // Calculate size: DI(1) + [paging: LD A(2) + LD BC(3) + OUT(2) = 7] + LD SP(3) + LD A(2) + LD I,A(2) + LD A(2) + LD R,A(2) +
            // LD BC(3) + LD DE(3) + LD HL(3) + PUSH(1) + LD HL(3) + PUSH(1) + POP AF(1) + POP HL(1) +
            // EX AF,AF'(1) + EXX(1) + LD BC(3) + LD DE(3) + LD IX(4) + LD IY(4) +
            // LD HL(3) + PUSH(1) + LD HL(3) + PUSH(1) + POP AF(1) + POP HL(1) + IM(2) + EI?(1) + JP(3)
            const pagingCodeSize = is128K ? 7 : 0;  // LD A + LD BC + OUT (C),A
            const restoreCodeSize = 59 + (cpu.iff1 ? 1 : 0) + pagingCodeSize;  // 59 bytes base, +1 if EI, +7 if 128K
            const stackDataSize = stackDepth * 2;  // 32 bytes for 16 words
            const totalRestoreSize = restoreCodeSize + stackDataSize;

            // IM2 vector table (257 bytes at I*256)
            if (cpu.im === 2) {
                const vectorBase = cpu.i << 8;
                lines.push('');
                lines.push('');
                lines.push('; ============ IM2 VECTOR TABLE ============');
                lines.push(`; 257 bytes at I*256 = ${hex16(vectorBase)}`);
                lines.push('');
                lines.push(`    ORG ${hex16(vectorBase)}`);
                lines.push('');
                lines.push('im2_vectors:');
                // Output 257 bytes with DS compression for runs
                let i = 0;
                while (i < 257) {
                    const addr = (vectorBase + i) & 0xFFFF;
                    const byte = readMem(addr);

                    // Check for run of same byte
                    let runLength = 1;
                    while (i + runLength < 257 &&
                           readMem((vectorBase + i + runLength) & 0xFFFF) === byte) {
                        runLength++;
                    }

                    if (runLength > 10) {
                        let line = `    DS ${runLength}, $${byte.toString(16).toUpperCase().padStart(2, '0')}`;
                        if (includeAddrBytes) {
                            line += `  ; ${addr.toString(16).toUpperCase().padStart(4, '0')}: ${runLength}x ${byte.toString(16).toUpperCase().padStart(2, '0')}`;
                        }
                        lines.push(line);
                        i += runLength;
                    } else {
                        // Output up to 16 bytes as DEFB
                        const count = Math.min(16, 257 - i);
                        const bytes = [];
                        const rawBytes = [];
                        for (let j = 0; j < count; j++) {
                            const a = (vectorBase + i + j) & 0xFFFF;
                            const b = readMem(a);
                            bytes.push('$' + b.toString(16).toUpperCase().padStart(2, '0'));
                            rawBytes.push(b.toString(16).toUpperCase().padStart(2, '0'));
                        }
                        let line = `    DEFB ${bytes.join(',')}`;
                        if (includeAddrBytes) {
                            line += `  ; ${addr.toString(16).toUpperCase().padStart(4, '0')}: ${rawBytes.join(' ')}`;
                        }
                        lines.push(line);
                        i += count;
                    }
                }
            }

            lines.push('');
            lines.push('');
            lines.push('; ============ STACK DATA ============');
            lines.push(`; ${stackDataSize} bytes at SP=${hex16(sp)}`);
            lines.push('');
            lines.push(`    ORG ${hex16(sp)}  ; SP value`);
            lines.push('');
            lines.push('stack_top:');
            for (let i = 0; i < stackDepth; i++) {
                const addr = (sp + i * 2) & 0xFFFF;
                const lo = readMem(addr);
                const hi = readMem((addr + 1) & 0xFFFF);
                const word = lo | (hi << 8);
                let line = `    DEFW ${hex16(word)}  ; SP+${(i * 2).toString().padStart(2)}`;
                if (includeAddrBytes) {
                    line += ` @ ${addr.toString(16).toUpperCase().padStart(4, '0')}: ${lo.toString(16).toUpperCase().padStart(2, '0')} ${hi.toString(16).toUpperCase().padStart(2, '0')}`;
                }
                lines.push(line);
            }
            lines.push('stack_bottom:');
            lines.push('');
            lines.push('');
            lines.push('; ============ RESTORATION CODE ============');
            lines.push(`; ${restoreCodeSize} bytes`);
            lines.push('');
            lines.push('    ORG $4000  ; <-- change to your safe address');
            lines.push('');
            lines.push('restore_state:');
            lines.push('    DI');
            lines.push('');
            // Add 128K paging restoration
            if (is128K) {
                lines.push('    ; Restore 128K paging');
                lines.push(`    LD A,${hex8(port7FFD)}  ; RAM=${paging.ramBank}, ROM=${paging.romBank}, Screen=${paging.screenBank}`);
                lines.push('    LD BC,$7FFD');
                lines.push('    OUT (C),A');
                lines.push('');
            }
            lines.push('    ; Setup stack');
            lines.push('    LD SP,stack_top');
            lines.push('');
            lines.push('    ; Restore I and R registers');
            lines.push(`    LD A,${hex8(cpu.i)}`);
            lines.push('    LD I,A');
            // R increments with each M1 cycle after LD R,A
            // Count M1 cycles from after LD R,A until PC reaches target:
            // LD BC(1) + LD DE(1) + LD HL(1) + PUSH(1) + LD HL(1) + PUSH(1) + POP AF(1) + POP HL(1) +
            // EX AF,AF'(1) + EXX(1) + LD BC(1) + LD DE(1) + LD IX(2) + LD IY(2) +
            // LD HL(1) + PUSH(1) + LD HL(1) + PUSH(1) + POP AF(1) + POP HL(1) + IM(2) + [EI(1)] + JP(1)
            // = 25 without EI, 26 with EI
            const m1CyclesAfterR = 25 + (cpu.iff1 ? 1 : 0);
            const adjustedR = (((cpu.r & 0x7F) - m1CyclesAfterR) & 0x7F) | (cpu.r & 0x80);
            lines.push(`    LD A,${hex8(adjustedR)}  ; R=${hex8(cpu.r)}, minus ${m1CyclesAfterR} M1 cycles`);
            lines.push('    LD R,A');
            lines.push('');
            lines.push('    ; Restore alternate registers (load into main, then swap)');
            lines.push(`    LD BC,${hex16(bc_)}`);
            lines.push(`    LD DE,${hex16(de_)}`);
            lines.push(`    LD HL,${hex16(hl_)}`);
            lines.push('    PUSH HL');
            lines.push(`    LD HL,${hex16(af_)}`);
            lines.push('    PUSH HL');
            lines.push('    POP AF');
            lines.push('    POP HL');
            lines.push('    EX AF,AF\'');
            lines.push('    EXX');
            lines.push('');
            lines.push('    ; Restore main registers');
            lines.push(`    LD BC,${hex16(bc)}`);
            lines.push(`    LD DE,${hex16(de)}`);
            lines.push(`    LD IX,${hex16(cpu.ix)}`);
            lines.push(`    LD IY,${hex16(cpu.iy)}`);
            lines.push('');
            lines.push('    ; Restore HL, AF and jump');
            lines.push(`    LD HL,${hex16(hl)}`);
            lines.push('    PUSH HL');
            lines.push(`    LD HL,${hex16(af)}`);
            lines.push('    PUSH HL');
            lines.push('    POP AF');
            lines.push('    POP HL');
            lines.push('');
            lines.push(`    IM ${cpu.im}`);
            if (cpu.iff1) {
                lines.push('    EI');
            }
            lines.push(`    JP ${hex16(cpu.pc)}`);
            lines.push('');
            lines.push('    SAVESNA "output.sna",restore_state');
            lines.push('');

            // Create and download file
            const content = lines.join('\n');
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `disasm_${now.toISOString().substring(0,10)}.asm`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        memmapDialog.addEventListener('click', (e) => {
            if (e.target === memmapDialog) closeMemoryMap();
        });

        btnAutoMapApply.addEventListener('click', () => {
            const data = spectrum.getAutoMapData();
            if (data.executed.size === 0) {
                showMessage('No execution data to apply', 'error');
                return;
            }

            // Merge consecutive addresses into regions
            function mergeToRegions(addrMap, type) {
                // Parse all addresses and group by page
                const byPage = new Map(); // page -> sorted addresses
                for (const key of addrMap.keys()) {
                    const { addr, page } = spectrum.parseAutoMapKey(key);
                    const pageKey = page || '';
                    if (!byPage.has(pageKey)) byPage.set(pageKey, []);
                    byPage.get(pageKey).push(addr);
                }

                const regions = [];
                for (const [pageKey, addrs] of byPage) {
                    addrs.sort((a, b) => a - b);
                    let start = addrs[0];
                    let end = addrs[0];

                    for (let i = 1; i < addrs.length; i++) {
                        if (addrs[i] === end + 1) {
                            end = addrs[i];
                        } else {
                            // Gap - finish this region
                            regions.push({
                                start,
                                end,
                                type,
                                page: pageKey || null
                            });
                            start = addrs[i];
                            end = addrs[i];
                        }
                    }
                    // Add final region
                    regions.push({
                        start,
                        end,
                        type,
                        page: pageKey || null
                    });
                }
                return regions;
            }

            // Find SMC: addresses that are both executed AND written
            const smcAddrs = new Map();
            for (const [key, count] of data.executed) {
                if (data.written.has(key)) {
                    smcAddrs.set(key, count);
                }
            }

            // Find CODE: addresses executed but NOT written (pure code)
            const codeAddrs = new Map();
            for (const [key, count] of data.executed) {
                if (!data.written.has(key)) {
                    codeAddrs.set(key, count);
                }
            }

            // Find DATA: addresses read but NOT executed
            const dataAddrs = new Map();
            for (const [key, count] of data.read) {
                if (!data.executed.has(key)) {
                    dataAddrs.set(key, count);
                }
            }

            // Generate regions
            const smcRegions = mergeToRegions(smcAddrs, REGION_TYPES.SMC);
            const codeRegions = mergeToRegions(codeAddrs, REGION_TYPES.CODE);
            const dataRegions = mergeToRegions(dataAddrs, REGION_TYPES.DB);

            // Apply to region manager (skip overlapping regions)
            let added = 0, skipped = 0;
            for (const region of smcRegions) {
                const result = regionManager.add(region);
                if (result.error) skipped++; else added++;
            }
            for (const region of codeRegions) {
                const result = regionManager.add(region);
                if (result.error) skipped++; else added++;
            }
            for (const region of dataRegions) {
                const result = regionManager.add(region);
                if (result.error) skipped++; else added++;
            }

            // Detect subroutines from CALL targets in executed code
            const subsDetected = subroutineManager.detectFromCode(data.executed);

            updateDebugger();
            const msg = `Applied ${added} regions` + (skipped ? `, skipped ${skipped} overlapping` : '') + (subsDetected ? `, ${subsDetected} subroutines` : '');
            showMessage(msg);
        });

        // Code-flow analysis handlers
        btnCfaRun.addEventListener('click', async () => {
            // Collect entry points
            const entries = new Set();

            // Current PC
            entries.add(spectrum.cpu.pc & 0xFFFF);

            // ISR handler at $0038
            if (chkCfaISR.checked) {
                entries.add(0x0038);
            }

            // All existing subroutine entries
            const subs = subroutineManager.getAll();
            for (const sub of subs) {
                entries.add(sub.address & 0xFFFF);
            }

            // Extra entry points from text input
            const extraText = cfaExtraEntries.value.trim();
            if (extraText) {
                for (const part of extraText.split(',')) {
                    const addr = parseInt(part.trim(), 16);
                    if (!isNaN(addr)) {
                        entries.add(addr & 0xFFFF);
                    }
                }
            }

            // All label addresses
            const labels = labelManager.getAll();
            for (const lbl of labels) {
                entries.add(lbl.address & 0xFFFF);
            }

            const skipRom = chkCfaSkipRom.checked;

            // Build isDataRegion callback
            const isDataRegion = addr => regionManager.isData(addr);

            // Disable button, show progress
            btnCfaRun.disabled = true;
            cfaStatus.textContent = 'Analyzing...';

            try {
                const result = await spectrum.analyzeCodeFlow({
                    entryPoints: Array.from(entries),
                    skipRom: skipRom,
                    isDataRegion: isDataRegion,
                    onProgress: (processed, queued) => {
                        cfaStatus.textContent = `Analyzing... ${processed} instructions, ${queued} queued`;
                    },
                    maxInstructions: 100000
                });

                // Convert codeAddresses to sorted array and merge consecutive into regions
                const sortedAddrs = Array.from(result.codeAddresses).sort((a, b) => a - b);
                const regions = [];
                let i = 0;
                while (i < sortedAddrs.length) {
                    const start = sortedAddrs[i];
                    let end = start;
                    while (i + 1 < sortedAddrs.length && sortedAddrs[i + 1] === end + 1) {
                        i++;
                        end = sortedAddrs[i];
                    }
                    regions.push({ start: start, end: end, type: REGION_TYPES.CODE });
                    i++;
                }

                // Apply regions (skip overlaps)
                let added = 0, skipped = 0;
                for (const region of regions) {
                    const res = regionManager.add(region);
                    if (res.error) skipped++; else added++;
                }

                // Add subroutine entries
                let subsAdded = 0;
                for (const target of result.callTargets) {
                    subroutineManager.add(target, null, null, true);
                    subsAdded++;
                }

                // Add xrefs
                for (const xref of result.xrefs) {
                    xrefManager.add(xref.target, xref.from, xref.type);
                }

                updateDebugger();

                // Log warnings
                for (const w of result.warnings) {
                    console.warn('[CFA]', w);
                }

                const msg = `Flow: ${added} regions, ${subsAdded} subs, ${result.xrefs.length} xrefs` +
                    (skipped ? `, ${skipped} overlaps skipped` : '') +
                    (result.indirectJumps.length ? `, ${result.indirectJumps.length} indirect jumps` : '');
                cfaStatus.textContent = msg;
                showMessage(msg);
            } catch (err) {
                cfaStatus.textContent = 'Error: ' + err.message;
                console.error('[CFA]', err);
            } finally {
                btnCfaRun.disabled = false;
            }
        });

        btnCfaClear.addEventListener('click', () => {
            cfaStatus.textContent = '';
        });

        // Update auto-map stats periodically
        setInterval(updateAutoMapStats, 1000);

        // Disassembly navigation handlers
        btnDisasmGo.addEventListener('click', () => {
            const addr = parseInt(disasmAddressInput.value, 16);
            if (!isNaN(addr)) {
                // If history is empty, save current view position first
                if (leftNavHistory.length === 0 && disasmViewAddress !== null) {
                    navPushHistory(disasmViewAddress);
                }
                navPushHistory(addr & 0xffff);
                disasmViewAddress = addr & 0xffff;
                updateDebugger();
            }
        });

        disasmAddressInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const addr = parseInt(disasmAddressInput.value, 16);
                if (!isNaN(addr)) {
                    // If history is empty, save current view position first
                    if (leftNavHistory.length === 0 && disasmViewAddress !== null) {
                        navPushHistory(disasmViewAddress);
                    }
                    navPushHistory(addr & 0xffff);
                    disasmViewAddress = addr & 0xffff;
                    updateDebugger();
                }
            }
        });
        
        btnDisasmPC.addEventListener('click', () => {
            disasmViewAddress = null; // Follow PC
            disasmAddressInput.value = '';
            updateDebugger();
        });

        // Keyboard shortcuts for navigation (Alt+Left/Right)
        document.addEventListener('keydown', (e) => {
            if (e.altKey && e.key === 'ArrowLeft') {
                e.preventDefault();
                navBack();
            } else if (e.altKey && e.key === 'ArrowRight') {
                e.preventDefault();
                navForward();
            }
        });

        btnDisasmPgUp.addEventListener('click', () => navBack());
        btnDisasmPgDn.addEventListener('click', () => navForward());
        updateNavButtons();  // Initialize disabled state

        // Generate assembly output for sjasmplus
        function generateAssemblyOutput(startAddr, endAddr, options = {}) {
            if (!disasm || !spectrum.memory) return '';

            const withOrg = options.withOrg !== false;
            const withAddr = options.withAddr !== false;
            const withBytes = options.withBytes === true;
            const withTstates = options.withTstates === true;

            // Format current datetime
            const now = new Date();
            const datetime = now.getFullYear() + '-' +
                String(now.getMonth() + 1).padStart(2, '0') + '-' +
                String(now.getDate()).padStart(2, '0') + ' ' +
                String(now.getHours()).padStart(2, '0') + ':' +
                String(now.getMinutes()).padStart(2, '0') + ':' +
                String(now.getSeconds()).padStart(2, '0');

            let output = '; Disassembly exported from ZX-M8XXX v' + APP_VERSION + '\n';
            output += `; Date: ${datetime}\n`;
            if (labelManager.currentFile) {
                output += `; Source: ${labelManager.currentFile}\n`;
            }
            output += `; Range: $${hex16(startAddr)} - $${hex16(endAddr)}\n\n`;

            if (withOrg) {
                output += `        ORG $${hex16(startAddr)}\n\n`;
            }

            let addr = startAddr;
            while (addr <= endAddr && addr < 0x10000) {
                const region = regionManager.get(addr);
                const label = labelManager.get(addr);
                const comment = commentManager.get(addr);
                const instrStartAddr = addr;

                // Output comments before instruction
                if (comment) {
                    if (comment.separator) {
                        output += `; ----------\n`;
                    }
                    if (comment.before) {
                        const beforeLines = comment.before.split('\n');
                        for (const line of beforeLines) {
                            output += `; ${line}\n`;
                        }
                    }
                }

                // Output label on its own line if exists
                if (label) {
                    output += `${label.name}:\n`;
                }

                let mnemonic = '';
                let bytes = [];
                let isData = false;
                let addBlankAfter = false;

                if (!region || region.type === REGION_TYPES.CODE || region.type === REGION_TYPES.SMC) {
                    // Normal disassembly
                    const instr = disasm.disassemble(addr);
                    if (!instr) break;

                    mnemonic = instr.mnemonic;
                    bytes = instr.bytes;

                    // Check for flow control
                    const mnemonicUpper = mnemonic.toUpperCase();
                    if (mnemonicUpper.startsWith('RET') || mnemonicUpper.startsWith('JP ') ||
                        mnemonicUpper.startsWith('JR ') || mnemonicUpper.startsWith('CALL ') ||
                        mnemonicUpper.startsWith('DJNZ') || mnemonicUpper.startsWith('RST') ||
                        mnemonicUpper === 'HALT') {
                        addBlankAfter = true;
                    }

                    addr += bytes.length;
                } else if (region.type === REGION_TYPES.TEXT) {
                    // Text region - use shared helper
                    const regionEnd = Math.min(region.end, endAddr);
                    const result = parseTextRegion(spectrum.memory, addr, regionEnd);
                    bytes = result.bytes;

                    if (result.singleByte) {
                        mnemonic = `DB $${hex8(bytes[0])}`;
                    } else if (result.text.length > 0) {
                        const suffix = result.bit7Terminated ? '+$80' : '';
                        mnemonic = `DB "${result.text}"${suffix}`;
                    }
                    addr = result.nextAddr;
                    isData = true;
                } else if (region.type === REGION_TYPES.DW) {
                    // Word data - use shared helper
                    const regionEnd = Math.min(region.end, endAddr);
                    const result = parseWordRegion(spectrum.memory, addr, regionEnd);
                    bytes = result.bytes;
                    mnemonic = `DW ${result.wordStrs.join(', ')}`;
                    addr = result.nextAddr;
                    isData = true;
                } else if (region.type === REGION_TYPES.DB || region.type === REGION_TYPES.GRAPHICS) {
                    // Byte data - use shared helper
                    const regionEnd = Math.min(region.end, endAddr);
                    const result = parseByteRegion(spectrum.memory, addr, regionEnd);
                    bytes = result.bytes;
                    mnemonic = `DB ${result.byteStrs.join(', ')}`;
                    addr = result.nextAddr;
                    isData = true;
                } else {
                    // Unknown region - fallback
                    const instr = disasm.disassemble(addr);
                    if (!instr) break;
                    mnemonic = instr.mnemonic;
                    bytes = instr.bytes;
                    addr += bytes.length;
                }

                // Build instruction line
                let line = '        '; // 8 spaces for indentation

                // Convert mnemonic to sjasmplus format (for code lines)
                if (!isData) {
                    mnemonic = mnemonic.replace(/([0-9A-F]{4})h/gi, (m, hex) => `$${hex}`);
                    mnemonic = mnemonic.replace(/([0-9A-F]{2})h/gi, (m, hex) => `$${hex}`);
                }

                line += mnemonic;

                // Add aligned comments
                const hasMetaComments = withAddr || withBytes || (withTstates && !isData);
                if (hasMetaComments) {
                    line = line.padEnd(40);
                    line += '; ';

                    if (withAddr) {
                        line += `$${hex16(instrStartAddr)} `;
                    }
                    if (withBytes) {
                        const bytesStr = bytes.map(b => hex8(b)).join(' ');
                        if (withAddr) line += '| ';
                        line += bytesStr.padEnd(24);
                    }
                    if (withTstates && !isData) {
                        const timing = disasm.getTiming(bytes);
                        if (timing) {
                            if (withAddr || withBytes) line += '| ';
                            line += timing;
                        }
                    }
                }

                // Add inline comment
                if (comment && comment.inline) {
                    if (!hasMetaComments) {
                        line = line.padEnd(40);
                    }
                    line += (hasMetaComments ? ' | ' : '; ') + comment.inline;
                }

                output += line + '\n';

                // Add after comments
                if (comment && comment.after) {
                    const afterLines = comment.after.split('\n');
                    for (const afterLine of afterLines) {
                        output += `; ${afterLine}\n`;
                    }
                }

                if (addBlankAfter) {
                    output += '\n';
                }
            }

            return output;
        }

        // Export visible disassembly
        btnDisasmExport.addEventListener('click', () => {
            if (!disasm) return;

            // Get visible range
            let startAddr = disasmViewAddress;
            if (startAddr === null && spectrum.cpu) {
                startAddr = disasm.findStartForPosition(spectrum.cpu.pc, DISASM_PC_POSITION, DISASM_LINES);
            }
            if (startAddr === null) startAddr = 0;

            const endAddr = (disasmLastLineAddr) & 0xffff;

            const output = generateAssemblyOutput(startAddr, endAddr, {
                withOrg: true,
                withAddr: true,
                withBytes: false
            });

            downloadFile(`disasm_${hex16(startAddr)}_${hex16(endAddr)}.asm`, output);
            showMessage(`Exported ${hex16(startAddr)}-${hex16(endAddr)}`);
        });

        // Show export range dialog
        btnDisasmExportRange.addEventListener('click', () => {
            let startAddr = disasmViewAddress;
            if (startAddr === null && spectrum.cpu) {
                startAddr = spectrum.cpu.pc;
            }
            if (startAddr === null) startAddr = 0;

            exportStartAddr.value = hex16(startAddr);
            exportEndAddr.value = hex16((startAddr + 0x100) & 0xffff);
            exportDisasmDialog.classList.remove('hidden');
            exportStartAddr.focus();
            exportStartAddr.select();
        });

        btnExportCancel.addEventListener('click', () => {
            exportDisasmDialog.classList.add('hidden');
        });

        btnExportSave.addEventListener('click', () => {
            const startAddr = parseInt(exportStartAddr.value, 16);
            const endAddr = parseInt(exportEndAddr.value, 16);

            if (isNaN(startAddr) || isNaN(endAddr)) {
                showMessage('Invalid address', 'error');
                return;
            }

            const output = generateAssemblyOutput(startAddr & 0xffff, endAddr & 0xffff, {
                withOrg: exportWithOrg.checked,
                withAddr: exportWithAddr.checked,
                withBytes: exportWithBytes.checked,
                withTstates: exportWithTstates.checked
            });

            downloadFile(`disasm_${hex16(startAddr)}_${hex16(endAddr)}.asm`, output);
            exportDisasmDialog.classList.add('hidden');
            showMessage(`Exported ${hex16(startAddr)}-${hex16(endAddr)}`);
        });

        // Close export dialog on Escape
        exportStartAddr.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') exportDisasmDialog.classList.add('hidden');
            if (e.key === 'Enter') exportEndAddr.focus();
        });
        exportEndAddr.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') exportDisasmDialog.classList.add('hidden');
            if (e.key === 'Enter') btnExportSave.click();
        });

        // Disasm scroll wheel navigation
        disassemblyView.addEventListener('wheel', (e) => {
            e.preventDefault();
            if (!disasm) return;

            // Scroll by ~3 instructions per wheel tick
            const scrollLines = e.deltaY > 0 ? 3 : -3;

            if (disasmViewAddress === null && spectrum.cpu) {
                disasmViewAddress = spectrum.cpu.pc;
            }
            if (disasmViewAddress !== null) {
                if (scrollLines > 0) {
                    // Scroll down - move forward by approximate bytes
                    disasmViewAddress = (disasmViewAddress + scrollLines * 2) & 0xffff;
                } else {
                    // Scroll up - move back by approximate bytes
                    disasmViewAddress = (disasmViewAddress + scrollLines * 2) & 0xffff;
                }
                disasmAddressInput.value = hex16(disasmViewAddress);
                updateDebugger();
            }
        }, { passive: false });

        chkShowTstates.addEventListener('change', () => {
            updateDebugger();
        });

        labelDisplayMode.addEventListener('change', () => {
            updateDebugger();
        });

        chkShowRomLabels.addEventListener('change', () => {
            labelManager.showRomLabels = chkShowRomLabels.checked;
            updateDebugger();
        });

        function formatMnemonic(mnemonic) {
            // Split into opcode and operands
            const spaceIdx = mnemonic.indexOf(' ');
            if (spaceIdx === -1) {
                return `<span class="op">${mnemonic}</span>`;
            }

            const opcode = mnemonic.substring(0, spaceIdx);
            let operands = mnemonic.substring(spaceIdx + 1);

            // Tokenize operands to avoid replacing inside HTML tags
            // Process each comma-separated operand
            const parts = operands.split(',');
            const coloredParts = parts.map(part => {
                let p = part.trim();

                // Character literals ('X' or "X")
                if (/^'.'$/.test(p) || /^".*"$/.test(p)) {
                    return `<span class="disasm-char">${p}</span>`;
                }

                // Binary numbers (%...)
                if (p.startsWith('%')) {
                    return `<span class="disasm-bin">${p}</span>`;
                }

                // Check for indirect addressing (...)
                const indirectMatch = p.match(/^\((.+)\)$/);
                if (indirectMatch) {
                    const inner = colorOperand(indirectMatch[1]);
                    return `<span class="disasm-ptr">(</span>${inner}<span class="disasm-ptr">)</span>`;
                }

                return colorOperand(p);
            });

            function colorOperand(p) {
                // Already has HTML (from replaceMnemonicAddresses)
                if (p.includes('<span')) {
                    return p;
                }

                // Hex numbers (XXh or XXXXh)
                if (/^[0-9A-F]+h$/i.test(p)) {
                    return `<span class="disasm-num">${p}</span>`;
                }

                // Decimal numbers
                if (/^\d+$/.test(p)) {
                    return `<span class="disasm-num">${p}</span>`;
                }

                // IX+d or IY+d patterns
                const ixMatch = p.match(/^(IX|IY)([+-])(.+)$/i);
                if (ixMatch) {
                    const reg = ixMatch[1].toUpperCase();
                    const sign = ixMatch[2];
                    const disp = colorOperand(ixMatch[3]);
                    return `<span class="disasm-reg">${reg}</span>${sign}${disp}`;
                }

                // 16-bit registers
                if (/^(AF'|BC'|DE'|HL'|AF|BC|DE|HL|SP|IX|IY|PC)$/i.test(p)) {
                    return `<span class="disasm-reg">${p}</span>`;
                }

                // 8-bit registers
                if (/^(A|B|C|D|E|H|L|I|R|IXH|IXL|IYH|IYL)$/i.test(p)) {
                    return `<span class="disasm-reg">${p}</span>`;
                }

                // Condition flags
                if (/^(NZ|NC|PO|PE|Z|C|P|M)$/i.test(p)) {
                    return `<span class="disasm-reg">${p}</span>`;
                }

                return p;
            }

            return `<span class="op">${opcode}</span> ${coloredParts.join(',')}`;
        }
        
        function updateRomStatus() {
            const statusTrdosRom = document.getElementById('statusTrdosRom');
            // Clear any inline error color from size validation
            [status48Rom, status128Rom, statusPlus2Rom, statusPlus2aRom, statusPlus3Rom, statusPentagonRom, statusScorpionRom, statusTrdosRom].forEach(el => { if (el) el.style.color = ''; });

            if (romData['48.rom']) {
                status48Rom.textContent = '✓ Loaded (' + (romData['48.rom'].byteLength / 1024) + 'KB)';
                status48Rom.classList.add('loaded');
            } else {
                status48Rom.textContent = 'Not loaded';
                status48Rom.classList.remove('loaded');
            }

            if (romData['128.rom']) {
                status128Rom.textContent = '✓ Loaded (' + (romData['128.rom'].byteLength / 1024) + 'KB)';
                status128Rom.classList.add('loaded');
            } else {
                status128Rom.textContent = 'Not loaded (128K mode unavailable)';
                status128Rom.classList.remove('loaded');
            }

            if (romData['plus2.rom']) {
                statusPlus2Rom.textContent = '✓ Loaded (' + (romData['plus2.rom'].byteLength / 1024) + 'KB)';
                statusPlus2Rom.classList.add('loaded');
            } else {
                statusPlus2Rom.textContent = 'Not loaded (+2 mode unavailable)';
                statusPlus2Rom.classList.remove('loaded');
            }

            if (romData['plus2a.rom']) {
                // Check if ROM bank 0 contains +2A/+3 menu by looking for "Loader" string
                const bank0 = new Uint8Array(romData['plus2a.rom'].slice(0, 16384));
                const romStr = String.fromCharCode(...bank0.slice(0, 16384));
                const hasMenu = romStr.indexOf('Loader') !== -1 || romStr.indexOf('+3') !== -1;
                if (hasMenu) {
                    statusPlus2aRom.textContent = '✓ Loaded (' + (romData['plus2a.rom'].byteLength / 1024) + 'KB)';
                    statusPlus2aRom.classList.add('loaded');
                } else {
                    statusPlus2aRom.textContent = '⚠ Loaded but may be wrong ROM (no +2A menu in bank 0)';
                    statusPlus2aRom.classList.add('loaded');
                    statusPlus2aRom.style.color = '#e67e22';
                }
            } else {
                statusPlus2aRom.textContent = 'Not loaded (+2A mode unavailable)';
                statusPlus2aRom.classList.remove('loaded');
            }

            if (statusPlus3Rom) {
                if (romData['plus3.rom']) {
                    const bank0 = new Uint8Array(romData['plus3.rom'].slice(0, 16384));
                    const romStr = String.fromCharCode(...bank0.slice(0, 16384));
                    const hasMenu = romStr.indexOf('Loader') !== -1 || romStr.indexOf('+3') !== -1;
                    if (hasMenu) {
                        statusPlus3Rom.textContent = '\u2713 Loaded (' + (romData['plus3.rom'].byteLength / 1024) + 'KB)';
                        statusPlus3Rom.classList.add('loaded');
                    } else {
                        statusPlus3Rom.textContent = '\u26A0 Loaded but may be wrong ROM (no +3 menu in bank 0)';
                        statusPlus3Rom.classList.add('loaded');
                        statusPlus3Rom.style.color = '#e67e22';
                    }
                } else {
                    statusPlus3Rom.textContent = 'Not loaded (+3 mode unavailable)';
                    statusPlus3Rom.classList.remove('loaded');
                }
            }

            if (romData['pentagon.rom']) {
                statusPentagonRom.textContent = '✓ Loaded (' + (romData['pentagon.rom'].byteLength / 1024) + 'KB)';
                statusPentagonRom.classList.add('loaded');
            } else {
                statusPentagonRom.textContent = 'Not loaded (Pentagon mode unavailable)';
                statusPentagonRom.classList.remove('loaded');
            }

            if (statusScorpionRom) {
                if (romData['scorpion.rom']) {
                    statusScorpionRom.textContent = '✓ Loaded (' + (romData['scorpion.rom'].byteLength / 1024) + 'KB)';
                    statusScorpionRom.classList.add('loaded');
                } else {
                    statusScorpionRom.textContent = 'Not loaded (Scorpion mode unavailable)';
                    statusScorpionRom.classList.remove('loaded');
                }
            }

            if (statusTrdosRom) {
                if (romData['trdos.rom']) {
                    statusTrdosRom.textContent = '✓ Loaded (' + (romData['trdos.rom'].byteLength / 1024) + 'KB)';
                    statusTrdosRom.classList.add('loaded');
                } else {
                    statusTrdosRom.textContent = 'Not loaded (required for TRD/SCL disk images)';
                    statusTrdosRom.classList.remove('loaded');
                }
            }

            btnStartEmulator.disabled = !romData['48.rom'];
        }
        
        const ROM_EXPECTED_SIZES = {
            '48k': [16384], 'trdos': [16384],
            '128k': [32768], 'plus2': [32768], 'pentagon': [32768],
            'plus2a': [65536], 'plus3': [65536], 'scorpion': [65536]
        };

        const ROM_STATUS_IDS = {
            '48k': 'status48Rom', '128k': 'status128Rom', 'plus2': 'statusPlus2Rom',
            'plus2a': 'statusPlus2aRom', 'plus3': 'statusPlus3Rom', 'pentagon': 'statusPentagonRom', 'scorpion': 'statusScorpionRom', 'trdos': 'statusTrdosRom'
        };

        async function loadRomFile(data, type) {
            const expected = ROM_EXPECTED_SIZES[type];
            if (expected && !expected.includes(data.byteLength)) {
                const msg = 'Wrong size: expected ' + (expected[0] / 1024) + 'KB, got ' + (data.byteLength / 1024) + 'KB';
                const statusEl = document.getElementById(ROM_STATUS_IDS[type]);
                if (statusEl && !romModal.classList.contains('hidden')) {
                    statusEl.textContent = msg;
                    statusEl.classList.remove('loaded');
                    statusEl.style.color = 'var(--error, #e74c3c)';
                } else {
                    showMessage(type + ' ROM: ' + msg, 'error');
                }
                return;
            }
            setRomByType(type, data);
            updateRomStatus();
        }

        // Profile-driven ROM loader — works for any machine type
        // Can operate on any spectrum instance (used by test runner too)
        function loadRomsForMachineType(spec, machineType) {
            const profile = getMachineProfile(machineType);
            const rom = romData[profile.romFile];
            if (!rom) return false;
            for (let bank = 0; bank < profile.romBanks; bank++) {
                spec.memory.loadRom(rom.slice(bank * 16384, (bank + 1) * 16384), bank);
            }
            // Load TR-DOS ROM if available (for Beta Disk interface)
            // Skip for machines with TR-DOS built into main ROM (e.g. Scorpion)
            if (!profile.trdosInRom && romData['trdos.rom'] && (profile.betaDiskDefault || spec.betaDiskEnabled)) {
                spec.memory.loadTrdosRom(romData['trdos.rom']);
            }
            // Update TR-DOS ROM flag for trap handler (must be called for all machines,
            // including Scorpion where TR-DOS is in main ROM bank)
            if (spec.trdosTrap) spec.trdosTrap.updateTrdosRomFlag();
            spec.updateBetaDiskPagingFlag();
            spec.romLoaded = true;
            return true;
        }

        function applyRomsToEmulator() {
            loadRomsForMachineType(spectrum, spectrum.machineType);
        }
        
        function initializeEmulator() {
            // Validate saved machine type has required ROM, fallback to 48k if not
            if (spectrum.machineType !== '48k') {
                const profile = getMachineProfile(spectrum.machineType);
                if (!romData[profile.romFile]) {
                    spectrum.setMachineType('48k');
                    if (typeof updateULAplusStatus === 'function') updateULAplusStatus();
                }
            }

            applyRomsToEmulator();
            romModal.classList.add('hidden');

            // Reset and start emulator immediately
            spectrum.reset();
            spectrum.start();

            // Update Beta Disk status after machine type is finalized
            if (typeof updateBetaDiskStatus === 'function') {
                updateBetaDiskStatus();
            }

            showMessage('Emulator started');
        }
        
        // ROM Modal handlers
        btnSelect48Rom.addEventListener('click', () => rom48Input.click());
        btnSelect128Rom.addEventListener('click', () => rom128Input.click());
        btnSelectPlus2Rom.addEventListener('click', () => romPlus2Input.click());
        btnSelectPlus2aRom.addEventListener('click', () => romPlus2aInput.click());
        if (btnSelectPlus3Rom) btnSelectPlus3Rom.addEventListener('click', () => romPlus3Input.click());
        btnSelectPentagonRom.addEventListener('click', () => romPentagonInput.click());
        if (btnSelectScorpionRom) btnSelectScorpionRom.addEventListener('click', () => romScorpionInput.click());
        if (btnSelectTrdosRom) btnSelectTrdosRom.addEventListener('click', () => romTrdosInput.click());
        
        rom48Input.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                const data = await file.arrayBuffer();
                await loadRomFile(data, '48k');
                showMessage('48K ROM loaded');
            }
            rom48Input.value = '';
        });
        
        rom128Input.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                const data = await file.arrayBuffer();
                await loadRomFile(data, '128k');
                showMessage('128K ROM loaded');
            }
            rom128Input.value = '';
        });
        
        romPlus2Input.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                const data = await file.arrayBuffer();
                await loadRomFile(data, 'plus2');
                showMessage('+2 ROM loaded');
            }
            romPlus2Input.value = '';
        });

        romPlus2aInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                const data = await file.arrayBuffer();
                await loadRomFile(data, 'plus2a');
                showMessage('+2A ROM loaded');
            }
            romPlus2aInput.value = '';
        });

        romPlus3Input.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                const data = await file.arrayBuffer();
                await loadRomFile(data, 'plus3');
                showMessage('+3 ROM loaded');
            }
            romPlus3Input.value = '';
        });

        romPentagonInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                const data = await file.arrayBuffer();
                await loadRomFile(data, 'pentagon');
                showMessage('Pentagon ROM loaded');
            }
            romPentagonInput.value = '';
        });

        romScorpionInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                const data = await file.arrayBuffer();
                await loadRomFile(data, 'scorpion');
                showMessage('Scorpion ROM loaded');
            }
            romScorpionInput.value = '';
        });

        romTrdosInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                const data = await file.arrayBuffer();
                await loadRomFile(data, 'trdos');
                showMessage('TR-DOS ROM loaded');
                if (typeof updateBetaDiskStatus === 'function') {
                    updateBetaDiskStatus();
                }
            }
            romTrdosInput.value = '';
        });

        btnStartEmulator.addEventListener('click', () => {
            initializeEmulator();
        });

        const btnCloseRomModal = document.getElementById('btnCloseRomModal');
        btnCloseRomModal.addEventListener('click', () => {
            romModal.classList.add('hidden');
        });

        // Allow dropping ROMs on modal
        romModal.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
        });
        
        romModal.addEventListener('drop', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            const file = e.dataTransfer.files[0];
            if (!file) return;

            const data = await file.arrayBuffer();
            const name = file.name.toLowerCase();

            if (name.includes('trdos') || name === 'trdos.rom') {
                await loadRomFile(data, 'trdos');
                showMessage('TR-DOS ROM loaded');
                if (typeof updateBetaDiskStatus === 'function') {
                    updateBetaDiskStatus();
                }
            } else if (name.includes('plus3') || name.includes('+3')) {
                await loadRomFile(data, 'plus3');
                showMessage('+3 ROM loaded');
            } else if (name.includes('plus2a') || name.includes('+2a')) {
                await loadRomFile(data, 'plus2a');
                showMessage('+2A ROM loaded');
            } else if (name.includes('plus2') || name.includes('+2')) {
                await loadRomFile(data, 'plus2');
                showMessage('+2 ROM loaded');
            } else if (name.includes('scorpion')) {
                await loadRomFile(data, 'scorpion');
                showMessage('Scorpion ROM loaded');
            } else if (name.includes('pentagon')) {
                await loadRomFile(data, 'pentagon');
                showMessage('Pentagon ROM loaded');
            } else if (name.includes('128') || (data.byteLength >= 32768 && !name.includes('48') && !name.includes('trdos'))) {
                await loadRomFile(data, '128k');
                showMessage('128K ROM loaded');
            } else {
                await loadRomFile(data, '48k');
                showMessage('48K ROM loaded');
            }
        });
        
        setInterval(updateStatus, 500);
        
        btnRun.addEventListener('click', () => {
            if (!spectrum.romLoaded) {
                romModal.classList.remove('hidden');
                return;
            }
            spectrum.toggle();
            updateStatus();
        });
        
        // Step Into button
        const chkAutoComment = document.getElementById('chkAutoComment');
        btnStepInto.addEventListener('click', () => {
            if (!spectrum.romLoaded) {
                showMessage('ROM not loaded', 'error');
                return;
            }
            if (spectrum.isRunning()) {
                spectrum.stop();
            }
            // Auto-comment feature: add separator comment before stepping
            if (chkAutoComment.checked) {
                const pc = spectrum.cpu.pc;
                commentManager.set(pc, { before: '--------------------' });
            }
            // Return to live view when stepping
            traceManager.goToLive();
            traceViewAddress = null;
            spectrum.stepInto();
            openDebuggerPanel();
            updateDebugger();
            updateStatus();
        });

        // Step Over button
        btnStepOver.addEventListener('click', () => {
            if (!spectrum.romLoaded) {
                showMessage('ROM not loaded', 'error');
                return;
            }
            if (spectrum.isRunning()) {
                spectrum.stop();
            }
            // Return to live view when stepping
            traceManager.goToLive();
            traceViewAddress = null;
            spectrum.stepOver();
            openDebuggerPanel();
            updateDebugger();
            updateStatus();
        });
        
        function openDebuggerPanel() {
            // Expand tabs and switch to debugger tab
            tabContainer.classList.remove('collapsed');
            tabBtns.forEach(b => b.classList.remove('active'));
            tabContents.forEach(c => c.classList.remove('active'));
            document.querySelector('[data-tab="debugger"]').classList.add('active');
            document.getElementById('tab-debugger').classList.add('active');
        }
        
        // Disassembly view click handler
        disassemblyView.addEventListener('click', (e) => {
            // Check if clicking on fold toggle or fold summary
            const foldToggle = e.target.closest('.disasm-fold-toggle, .disasm-fold-summary');
            if (foldToggle) {
                const addr = parseInt(foldToggle.dataset.foldAddr, 10);
                if (!isNaN(addr)) {
                    foldManager.toggle(addr);
                    updateDebugger();
                }
                return;
            }

            // Check if clicking on breakpoint marker
            const bpMarker = e.target.closest('.disasm-bp');
            if (bpMarker) {
                const addr = parseInt(bpMarker.dataset.addr, 10);
                const isSet = spectrum.toggleBreakpoint(addr);
                showMessage(isSet ? `Breakpoint set at ${hex16(addr)}` : `Breakpoint removed at ${hex16(addr)}`);
                updateDebugger();
                return;
            }

            // Check if clicking on address column
            // Click = go to memory, Ctrl+Click = center disasm on that line
            const addrSpan = e.target.closest('.disasm-addr');
            if (addrSpan) {
                const line = addrSpan.closest('.disasm-line');
                if (line) {
                    const addr = parseInt(line.dataset.addr, 10);
                    if (e.ctrlKey) {
                        goToAddress(addr);
                        updateDebugger();
                        showMessage(`Disasm: ${hex16(addr)}`);
                    } else {
                        goToMemoryAddress(addr);
                        showMessage(`Memory: ${hex16(addr)}`);
                    }
                }
                return;
            }

            // Check if clicking on operand address (e.g., JP 4000h)
            // Click = go to disasm, Ctrl+Click = go to memory
            const operandAddr = e.target.closest('.disasm-operand-addr');
            if (operandAddr) {
                const addr = parseInt(operandAddr.dataset.addr, 10);
                if (e.ctrlKey) {
                    goToMemoryAddress(addr);
                    showMessage(`Memory: ${hex16(addr)}`);
                } else {
                    goToAddress(addr);
                    updateDebugger();
                    showMessage(`Disasm: ${hex16(addr)}`);
                }
                return;
            }

            // Otherwise, set run target
            const line = e.target.closest('.disasm-line');
            if (line) {
                runToTarget = parseInt(line.dataset.addr, 10);
                // Highlight selected line
                disassemblyView.querySelectorAll('.disasm-line').forEach(el => {
                    el.classList.remove('target');
                });
                line.classList.add('target');
                showMessage(`Run target: ${hex16(runToTarget)}`);
            }
        });

        // XRef tooltip handlers
        const xrefTooltip = document.getElementById('xrefTooltip');
        let xrefTooltipTimeout = null;

        function showXRefTooltip(addr, refs, x, y) {
            const typeNames = {
                'call': 'CALL',
                'jp': 'JP',
                'jr': 'JR',
                'djnz': 'DJNZ',
                'rst': 'RST',
                'ld_imm': 'LD',
                'ld_ind': 'LD'
            };

            let html = `<div class="xref-tooltip-header">XRefs to ${hex16(addr)} (${refs.length})</div>`;

            // Sort by address
            refs.sort((a, b) => a.fromAddr - b.fromAddr);

            // Limit display
            const maxShow = 20;
            const shown = refs.slice(0, maxShow);

            for (const ref of shown) {
                const label = labelManager.get(ref.fromAddr);
                const labelStr = label ? ` [${label.name}]` : '';
                const typeClass = ref.type.startsWith('ld') ? 'ld' : ref.type;
                html += `<div class="xref-tooltip-item">
                    <span class="xref-type-${typeClass}">${typeNames[ref.type] || ref.type}</span>
                    from ${hex16(ref.fromAddr)}${labelStr}
                </div>`;
            }

            if (refs.length > maxShow) {
                html += `<div class="xref-tooltip-item">...and ${refs.length - maxShow} more</div>`;
            }

            xrefTooltip.innerHTML = html;
            xrefTooltip.style.display = 'block';
            xrefTooltip.style.left = (x + 15) + 'px';
            xrefTooltip.style.top = (y + 10) + 'px';

            // Adjust if off-screen
            const rect = xrefTooltip.getBoundingClientRect();
            if (rect.right > window.innerWidth) {
                xrefTooltip.style.left = (x - rect.width - 5) + 'px';
            }
            if (rect.bottom > window.innerHeight) {
                xrefTooltip.style.top = (y - rect.height - 5) + 'px';
            }
        }

        function hideXRefTooltip() {
            xrefTooltip.style.display = 'none';
            if (xrefTooltipTimeout) {
                clearTimeout(xrefTooltipTimeout);
                xrefTooltipTimeout = null;
            }
        }

        disassemblyView.addEventListener('mouseover', (e) => {
            const operandAddr = e.target.closest('.disasm-operand-addr');
            if (!operandAddr) return;

            const addr = parseInt(operandAddr.dataset.addr, 10);
            if (isNaN(addr)) return;

            const refs = xrefManager.get(addr);
            if (refs.length === 0) return;

            // Delay showing tooltip
            if (xrefTooltipTimeout) clearTimeout(xrefTooltipTimeout);
            xrefTooltipTimeout = setTimeout(() => {
                showXRefTooltip(addr, refs, e.clientX, e.clientY);
            }, 300);
        });

        disassemblyView.addEventListener('mouseout', (e) => {
            const operandAddr = e.target.closest('.disasm-operand-addr');
            if (operandAddr) {
                hideXRefTooltip();
            }
        });

        // Label context menu and dialog
        let labelContextMenu = null;
        let labelDialogAddr = null;
        const labelDialog = document.getElementById('labelDialog');
        const labelDialogTitle = document.getElementById('labelDialogTitle');
        const labelAddrInput = document.getElementById('labelAddrInput');
        const labelNameInput = document.getElementById('labelNameInput');
        const labelCommentInput = document.getElementById('labelCommentInput');
        const labelSizeInput = document.getElementById('labelSizeInput');
        const btnLabelCancel = document.getElementById('btnLabelCancel');
        const btnLabelSave = document.getElementById('btnLabelSave');

        function closeLabelContextMenu() {
            if (labelContextMenu) {
                labelContextMenu.remove();
                labelContextMenu = null;
            }
        }

        function showLabelDialog(addr, pageOrLabel = null) {
            // If addr is null, we're adding a new label with editable address
            // If pageOrLabel is an object, it's an existing label; if number/null, it's a page
            let existingLabel = null;
            let page = null;

            if (pageOrLabel !== null && typeof pageOrLabel === 'object') {
                existingLabel = pageOrLabel;
                page = existingLabel.page;
            } else if (addr !== null) {
                page = pageOrLabel;
                existingLabel = labelManager.get(addr, page);
            }

            labelDialogAddr = addr;
            labelAddrInput.value = addr !== null ? hex16(addr) : '';
            labelAddrInput.readOnly = addr !== null;
            labelDialogTitle.textContent = existingLabel ? 'Edit Label' : 'Add Label';

            if (existingLabel) {
                labelNameInput.value = existingLabel.name;
                labelCommentInput.value = existingLabel.comment || '';
                labelSizeInput.value = existingLabel.size || 1;
            } else {
                labelNameInput.value = '';
                labelCommentInput.value = '';
                labelSizeInput.value = 1;
            }

            labelDialog.classList.remove('hidden');
            if (addr === null) {
                labelAddrInput.focus();
                labelAddrInput.select();
            } else {
                labelNameInput.focus();
                labelNameInput.select();
            }
        }

        function closeLabelDialog() {
            labelDialog.classList.add('hidden');
            labelDialogAddr = null;
        }

        function saveLabelFromDialog() {
            let addr = labelDialogAddr;

            // If addr is null, parse from input
            if (addr === null) {
                const addrStr = labelAddrInput.value.trim().toUpperCase();
                if (!addrStr || !/^[0-9A-F]{1,4}$/.test(addrStr)) {
                    showMessage('Valid hex address required (0000-FFFF)', 'error');
                    labelAddrInput.focus();
                    return;
                }
                addr = parseInt(addrStr, 16);
            }

            const name = labelNameInput.value.trim();
            if (!name) {
                showMessage('Label name is required', 'error');
                labelNameInput.focus();
                return;
            }

            // Validate label name: must start with letter/underscore, contain only letters/digits/underscores
            if (!/^[A-Za-z_][A-Za-z0-9_]*$/.test(name)) {
                showMessage('Invalid label: use letters, digits, _ (start with letter or _)', 'error');
                labelNameInput.focus();
                return;
            }

            // Check for duplicate name (case-insensitive, different address)
            const existing = labelManager.findByName(name);
            if (existing && existing.address !== addr) {
                showMessage(`Label "${existing.name}" already exists at ${hex16(existing.address)}`, 'error');
                labelNameInput.focus();
                return;
            }

            // Capture old label for undo
            const oldLabel = labelManager.get(addr);
            const newLabel = {
                address: addr,
                name: name,
                comment: labelCommentInput.value.trim(),
                size: parseInt(labelSizeInput.value, 10) || 1
            };

            labelManager.add(newLabel);

            // Push undo action
            undoManager.push({
                type: 'label',
                description: oldLabel ? `Update label "${name}"` : `Add label "${name}"`,
                undo: () => {
                    if (oldLabel) {
                        labelManager.add(oldLabel);
                    } else {
                        labelManager.remove(addr);
                    }
                    updateLabelsList();
                },
                redo: () => {
                    labelManager.add(newLabel);
                    updateLabelsList();
                }
            });

            showMessage(`Label "${name}" saved at ${hex16(addr)}`);
            closeLabelDialog();
            updateLabelsList();
            updateDebugger();
        }

        btnLabelCancel.addEventListener('click', closeLabelDialog);
        btnLabelSave.addEventListener('click', saveLabelFromDialog);

        labelDialog.addEventListener('click', (e) => {
            if (e.target === labelDialog) closeLabelDialog();
        });

        labelNameInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') saveLabelFromDialog();
            if (e.key === 'Escape') closeLabelDialog();
        });

        // Region dialog
        const regionDialog = document.getElementById('regionDialog');
        const regionDialogTitle = document.getElementById('regionDialogTitle');
        const regionStartInput = document.getElementById('regionStartInput');
        const regionEndInput = document.getElementById('regionEndInput');
        const regionTypeSelect = document.getElementById('regionTypeSelect');
        const regionCommentInput = document.getElementById('regionCommentInput');
        const btnRegionSave = document.getElementById('btnRegionSave');
        const btnRegionCancel = document.getElementById('btnRegionCancel');
        let regionDialogStartAddr = null;

        function showRegionDialog(startAddr, type = REGION_TYPES.CODE, endAddr = null) {
            regionDialogStartAddr = startAddr;
            regionStartInput.value = hex16(startAddr);
            regionEndInput.value = hex16(endAddr !== null ? endAddr : startAddr);
            regionTypeSelect.value = type;
            regionCommentInput.value = '';

            const typeNames = {
                [REGION_TYPES.CODE]: 'Code',
                [REGION_TYPES.DB]: 'DB (bytes)',
                [REGION_TYPES.DW]: 'DW (words)',
                [REGION_TYPES.TEXT]: 'Text',
                [REGION_TYPES.GRAPHICS]: 'Graphics',
                [REGION_TYPES.SMC]: 'SMC'
            };
            regionDialogTitle.textContent = `Mark Region as ${typeNames[type] || 'Unknown'}`;

            regionDialog.classList.remove('hidden');
            regionEndInput.focus();
            regionEndInput.select();
        }

        function closeRegionDialog() {
            regionDialog.classList.add('hidden');
            regionDialogStartAddr = null;
        }

        function saveRegionFromDialog() {
            const startAddr = regionDialogStartAddr;
            const endStr = regionEndInput.value.trim().toUpperCase();

            if (!/^[0-9A-F]{1,4}$/.test(endStr)) {
                showMessage('Valid hex end address required', 'error');
                regionEndInput.focus();
                return;
            }

            const endAddr = parseInt(endStr, 16);

            if (endAddr < startAddr) {
                showMessage('End address must be >= start address', 'error');
                regionEndInput.focus();
                return;
            }

            // Check for overlapping regions
            const overlapping = regionManager.getOverlapping(startAddr, endAddr);
            if (overlapping.length > 0) {
                const r = overlapping[0];
                const existingRange = `${r.start.toString(16).toUpperCase()}-${r.end.toString(16).toUpperCase()}`;
                const existingType = r.type.toUpperCase();
                showMessage(`Overlap with existing ${existingType} region at ${existingRange}. Remove it first.`, 'error');
                return;
            }

            const newRegion = {
                start: startAddr,
                end: endAddr,
                type: regionTypeSelect.value,
                comment: regionCommentInput.value.trim()
            };

            regionManager.add(newRegion);

            undoManager.push({
                type: 'region',
                description: `Add region ${hex16(startAddr)}-${hex16(endAddr)}`,
                undo: () => {
                    regionManager.remove(startAddr);
                },
                redo: () => {
                    regionManager.add(newRegion, true);  // allowOverwrite for redo
                }
            });

            showMessage(`Region ${hex16(startAddr)}-${hex16(endAddr)} marked as ${regionTypeSelect.value}`);
            closeRegionDialog();
            updateDebugger();
        }

        btnRegionSave.addEventListener('click', saveRegionFromDialog);
        btnRegionCancel.addEventListener('click', closeRegionDialog);

        regionDialog.addEventListener('click', (e) => {
            if (e.target === regionDialog) closeRegionDialog();
        });

        regionEndInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') saveRegionFromDialog();
            if (e.key === 'Escape') closeRegionDialog();
        });

        // Fold dialog elements and state
        const foldDialog = document.getElementById('foldDialog');
        const foldStartInput = document.getElementById('foldStartInput');
        const foldEndInput = document.getElementById('foldEndInput');
        const foldNameInput = document.getElementById('foldNameInput');
        const btnFoldSave = document.getElementById('btnFoldSave');
        const btnFoldCancel = document.getElementById('btnFoldCancel');
        let foldDialogStartAddr = null;

        function showFoldDialog(startAddr) {
            foldDialogStartAddr = startAddr;
            foldStartInput.value = hex16(startAddr);
            foldEndInput.value = '';
            foldNameInput.value = '';

            foldDialog.classList.remove('hidden');
            foldEndInput.focus();
        }

        function closeFoldDialog() {
            foldDialog.classList.add('hidden');
            foldDialogStartAddr = null;
        }

        function saveFoldFromDialog() {
            const startAddr = foldDialogStartAddr;
            const endStr = foldEndInput.value.trim().toUpperCase();

            if (!/^[0-9A-F]{1,4}$/.test(endStr)) {
                showMessage('Valid hex end address required', 'error');
                foldEndInput.focus();
                return;
            }

            const endAddr = parseInt(endStr, 16);

            if (endAddr < startAddr) {
                showMessage('End address must be >= start address', 'error');
                foldEndInput.focus();
                return;
            }

            const foldName = foldNameInput.value.trim() || null;

            foldManager.addUserFold(startAddr, endAddr, foldName);

            undoManager.push({
                type: 'fold',
                description: `Create fold block ${hex16(startAddr)}-${hex16(endAddr)}`,
                undo: () => {
                    foldManager.removeUserFold(startAddr);
                },
                redo: () => {
                    foldManager.addUserFold(startAddr, endAddr, foldName);
                }
            });

            showMessage(`Fold block created: ${hex16(startAddr)}-${hex16(endAddr)}`);
            closeFoldDialog();
            updateDebugger();
        }

        btnFoldSave.addEventListener('click', saveFoldFromDialog);
        btnFoldCancel.addEventListener('click', closeFoldDialog);

        foldDialog.addEventListener('click', (e) => {
            if (e.target === foldDialog) closeFoldDialog();
        });

        foldEndInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') saveFoldFromDialog();
            if (e.key === 'Escape') closeFoldDialog();
        });

        foldNameInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') saveFoldFromDialog();
            if (e.key === 'Escape') closeFoldDialog();
        });

        // Comment dialog elements and state
        const commentDialog = document.getElementById('commentDialog');
        const commentDialogTitle = document.getElementById('commentDialogTitle');
        const commentAddrInput = document.getElementById('commentAddrInput');
        const commentSeparator = document.getElementById('commentSeparator');
        const commentBeforeInput = document.getElementById('commentBeforeInput');
        const commentInlineInput = document.getElementById('commentInlineInput');
        const commentAfterInput = document.getElementById('commentAfterInput');
        const btnCommentSave = document.getElementById('btnCommentSave');
        const btnCommentDelete = document.getElementById('btnCommentDelete');
        const btnCommentCancel = document.getElementById('btnCommentCancel');
        let commentDialogAddr = null;

        function showCommentDialog(addr) {
            commentDialogAddr = addr;
            commentAddrInput.value = hex16(addr);

            const existing = commentManager.get(addr);
            if (existing) {
                commentDialogTitle.textContent = 'Edit Comment';
                commentSeparator.checked = existing.separator || false;
                commentBeforeInput.value = existing.before || '';
                commentInlineInput.value = existing.inline || '';
                commentAfterInput.value = existing.after || '';
                btnCommentDelete.style.display = 'inline-block';
            } else {
                commentDialogTitle.textContent = 'Add Comment';
                commentSeparator.checked = false;
                commentBeforeInput.value = '';
                commentInlineInput.value = '';
                commentAfterInput.value = '';
                btnCommentDelete.style.display = 'none';
            }

            commentDialog.classList.remove('hidden');
            commentInlineInput.focus();
        }

        function closeCommentDialog() {
            commentDialog.classList.add('hidden');
            commentDialogAddr = null;
        }

        function saveCommentFromDialog() {
            const addr = commentDialogAddr;
            if (addr === null) return;

            const oldComment = commentManager.get(addr);
            const newComment = {
                separator: commentSeparator.checked,
                before: commentBeforeInput.value,
                inline: commentInlineInput.value,
                after: commentAfterInput.value
            };

            commentManager.set(addr, newComment);

            undoManager.push({
                type: 'comment',
                description: oldComment ? `Update comment at ${hex16(addr)}` : `Add comment at ${hex16(addr)}`,
                undo: () => {
                    if (oldComment) {
                        commentManager.set(addr, oldComment);
                    } else {
                        commentManager.remove(addr);
                    }
                },
                redo: () => {
                    commentManager.set(addr, newComment);
                }
            });

            showMessage(`Comment ${commentManager.get(addr) ? 'saved' : 'removed'} at ${hex16(addr)}`);
            closeCommentDialog();
            updateDebugger();
        }

        function deleteCommentFromDialog() {
            const addr = commentDialogAddr;
            if (addr === null) return;

            const oldComment = commentManager.get(addr);
            if (!oldComment) return;

            commentManager.remove(addr);

            undoManager.push({
                type: 'comment',
                description: `Delete comment at ${hex16(addr)}`,
                undo: () => {
                    commentManager.set(addr, oldComment);
                },
                redo: () => {
                    commentManager.remove(addr);
                }
            });

            showMessage(`Comment removed at ${hex16(addr)}`);
            closeCommentDialog();
            updateDebugger();
        }

        btnCommentSave.addEventListener('click', saveCommentFromDialog);
        btnCommentDelete.addEventListener('click', deleteCommentFromDialog);
        btnCommentCancel.addEventListener('click', closeCommentDialog);

        commentDialog.addEventListener('click', (e) => {
            if (e.target === commentDialog) closeCommentDialog();
        });

        commentInlineInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') saveCommentFromDialog();
            if (e.key === 'Escape') closeCommentDialog();
        });

        labelAddrInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                labelNameInput.focus();
                labelNameInput.select();
            }
            if (e.key === 'Escape') closeLabelDialog();
        });

        labelCommentInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') saveLabelFromDialog();
            if (e.key === 'Escape') closeLabelDialog();
        });

        // Disassembly right-click context menu for labels
        disassemblyView.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            closeLabelContextMenu();

            const line = e.target.closest('.disasm-line');
            if (!line) return;

            const lineAddr = parseInt(line.dataset.addr, 10);

            // Check if clicking on operand address (e.g., JP 4000h)
            const operandAddrEl = e.target.closest('.disasm-operand-addr');
            const targetAddr = operandAddrEl ? parseInt(operandAddrEl.dataset.addr, 10) : null;

            // Use target address if clicking on operand, otherwise use line address
            const addr = targetAddr !== null ? targetAddr : lineAddr;
            const existingLabel = labelManager.get(addr);

            labelContextMenu = document.createElement('div');
            labelContextMenu.className = 'label-context-menu';

            const existingRegion = regionManager.get(addr);

            let menuHtml = `<div class="menu-header">Address ${hex16(addr)}</div>`;
            menuHtml += `<div class="menu-separator"></div>`;
            menuHtml += `<div data-action="disasm-left">Disasm left</div>`;
            menuHtml += `<div data-action="disasm-right">Disasm right</div>`;
            menuHtml += `<div class="menu-separator"></div>`;
            menuHtml += `<div data-action="mem-left">Memory left</div>`;
            menuHtml += `<div data-action="mem-right">Memory right</div>`;
            menuHtml += `<div class="menu-separator"></div>`;
            if (existingLabel) {
                menuHtml += `<div data-action="edit">Edit label "${existingLabel.name}"</div>`;
                menuHtml += `<div data-action="delete" class="danger">Delete label</div>`;
            } else {
                menuHtml += `<div data-action="add">Add label</div>`;
            }
            // Comment option
            const existingComment = commentManager.get(addr);
            if (existingComment) {
                menuHtml += `<div data-action="edit-comment">Edit comment</div>`;
                menuHtml += `<div data-action="delete-comment" class="danger">Delete comment</div>`;
            } else {
                menuHtml += `<div data-action="add-comment">Add comment</div>`;
            }
            menuHtml += `<div class="menu-separator"></div>`;
            // Operand format submenu (show for all lines - format applies to instruction)
            const currentFormat = operandFormatManager.get(lineAddr);
            menuHtml += `<div class="menu-submenu">Operand format...
                <div class="menu-submenu-items">
                    <div data-action="format-hex"${currentFormat === 'hex' ? ' class="selected"' : ''}>Hex (FFh)</div>
                    <div data-action="format-dec"${currentFormat === 'dec' ? ' class="selected"' : ''}>Decimal (255)</div>
                    <div data-action="format-bin"${currentFormat === 'bin' ? ' class="selected"' : ''}>Binary (%11111111)</div>
                    <div data-action="format-char"${currentFormat === 'char' ? ' class="selected"' : ''}>Char ('A')</div>
                </div>
            </div>`;
            menuHtml += `<div class="menu-submenu">Mark as...
                <div class="menu-submenu-items">
                    <div data-action="mark-code">Code</div>
                    <div data-action="mark-db">DB (bytes)</div>
                    <div data-action="mark-dw">DW (words)</div>
                    <div data-action="mark-text">Text (ASCII)</div>
                    <div data-action="mark-gfx">Graphics</div>
                    <div data-action="mark-smc">SMC (self-mod)</div>
                </div>
            </div>`;
            if (existingRegion) {
                menuHtml += `<div data-action="remove-region" class="danger">Remove region mark</div>`;
            }
            menuHtml += `<div class="menu-separator"></div>`;
            const existingSub = subroutineManager.get(addr);
            if (existingSub) {
                menuHtml += `<div data-action="remove-sub" class="danger">Remove subroutine mark</div>`;
            } else {
                menuHtml += `<div data-action="add-sub">Mark as subroutine</div>`;
            }
            // Fold options
            menuHtml += `<div class="menu-separator"></div>`;
            const existingUserFold = foldManager.getUserFold(addr);
            if (existingUserFold) {
                menuHtml += `<div data-action="remove-fold" class="danger">Remove fold block</div>`;
            } else {
                menuHtml += `<div data-action="add-fold">Create fold block...</div>`;
            }
            menuHtml += `<div data-action="collapse-all">Collapse all folds</div>`;
            menuHtml += `<div data-action="expand-all">Expand all folds</div>`;
            labelContextMenu.innerHTML = menuHtml;

            labelContextMenu.style.left = e.clientX + 'px';
            labelContextMenu.style.top = e.clientY + 'px';
            document.body.appendChild(labelContextMenu);

            // Adjust submenu position if it would overflow viewport
            const submenu = labelContextMenu.querySelector('.menu-submenu');
            if (submenu) {
                const menuRect = labelContextMenu.getBoundingClientRect();
                const submenuItems = submenu.querySelector('.menu-submenu-items');
                if (submenuItems) {
                    // Temporarily show to measure
                    submenuItems.style.display = 'block';
                    const subRect = submenuItems.getBoundingClientRect();
                    submenuItems.style.display = '';

                    // Check horizontal overflow
                    if (menuRect.right + subRect.width > window.innerWidth) {
                        submenu.classList.add('submenu-left');
                    }
                    // Check vertical overflow
                    if (menuRect.top + subRect.height > window.innerHeight) {
                        submenu.classList.add('submenu-up');
                    }
                }
            }

            labelContextMenu.addEventListener('click', (menuE) => {
                const action = menuE.target.dataset.action;
                if (action === 'disasm-left') {
                    goToLeftDisasm(addr);
                } else if (action === 'disasm-right') {
                    goToRightDisasm(addr);
                } else if (action === 'mem-left') {
                    goToLeftMemory(addr);
                } else if (action === 'mem-right') {
                    goToRightMemory(addr);
                } else if (action === 'add') {
                    showLabelDialog(addr);
                } else if (action === 'edit') {
                    showLabelDialog(addr, existingLabel);
                } else if (action === 'delete') {
                    const oldLabel = existingLabel;
                    labelManager.remove(addr);
                    undoManager.push({
                        type: 'label',
                        description: `Delete label "${oldLabel.name}"`,
                        undo: () => {
                            labelManager.add(oldLabel);
                            updateLabelsList();
                        },
                        redo: () => {
                            labelManager.remove(addr);
                            updateLabelsList();
                        }
                    });
                    showMessage(`Label "${existingLabel.name}" deleted`);
                    updateDebugger();
                } else if (action === 'format-hex') {
                    operandFormatManager.set(lineAddr, OPERAND_FORMATS.HEX);
                    updateDebugger();
                } else if (action === 'format-dec') {
                    operandFormatManager.set(lineAddr, OPERAND_FORMATS.DEC);
                    updateDebugger();
                } else if (action === 'format-bin') {
                    operandFormatManager.set(lineAddr, OPERAND_FORMATS.BIN);
                    updateDebugger();
                } else if (action === 'format-char') {
                    operandFormatManager.set(lineAddr, OPERAND_FORMATS.CHAR);
                    updateDebugger();
                } else if (action === 'mark-code') {
                    showRegionDialog(addr, REGION_TYPES.CODE);
                } else if (action === 'mark-db') {
                    showRegionDialog(addr, REGION_TYPES.DB);
                } else if (action === 'mark-dw') {
                    showRegionDialog(addr, REGION_TYPES.DW);
                } else if (action === 'mark-text') {
                    showRegionDialog(addr, REGION_TYPES.TEXT);
                } else if (action === 'mark-gfx') {
                    showRegionDialog(addr, REGION_TYPES.GRAPHICS);
                } else if (action === 'mark-smc') {
                    showRegionDialog(addr, REGION_TYPES.SMC);
                } else if (action === 'remove-region') {
                    const oldRegion = regionManager.get(addr);
                    if (oldRegion) {
                        regionManager.remove(addr);
                        undoManager.push({
                            type: 'region',
                            description: `Remove region ${hex16(oldRegion.start)}-${hex16(oldRegion.end)}`,
                            undo: () => {
                                regionManager.add(oldRegion, true);  // allowOverwrite for undo
                            },
                            redo: () => {
                                regionManager.remove(addr);
                            }
                        });
                        showMessage('Region mark removed');
                        updateDebugger();
                    }
                } else if (action === 'add-comment' || action === 'edit-comment') {
                    showCommentDialog(addr);
                } else if (action === 'delete-comment') {
                    const oldComment = commentManager.get(addr);
                    if (oldComment) {
                        commentManager.remove(addr);
                        undoManager.push({
                            type: 'comment',
                            description: `Delete comment at ${hex16(addr)}`,
                            undo: () => {
                                commentManager.set(addr, oldComment);
                            },
                            redo: () => {
                                commentManager.remove(addr);
                            }
                        });
                        showMessage(`Comment removed at ${hex16(addr)}`);
                        updateDebugger();
                    }
                } else if (action === 'add-sub') {
                    subroutineManager.add(addr);
                    undoManager.push({
                        type: 'subroutine',
                        description: `Mark subroutine at ${hex16(addr)}`,
                        undo: () => {
                            subroutineManager.remove(addr);
                        },
                        redo: () => {
                            subroutineManager.add(addr);
                        }
                    });
                    showMessage(`Marked as subroutine at ${hex16(addr)}`);
                    updateDebugger();
                } else if (action === 'remove-sub') {
                    const oldSub = subroutineManager.get(addr);
                    subroutineManager.remove(addr);
                    undoManager.push({
                        type: 'subroutine',
                        description: `Remove subroutine at ${hex16(addr)}`,
                        undo: () => {
                            subroutineManager.add(addr, oldSub?.name, oldSub?.comment, oldSub?.auto);
                        },
                        redo: () => {
                            subroutineManager.remove(addr);
                        }
                    });
                    showMessage(`Subroutine mark removed at ${hex16(addr)}`);
                    updateDebugger();
                } else if (action === 'add-fold') {
                    showFoldDialog(addr);
                } else if (action === 'remove-fold') {
                    const oldFold = foldManager.getUserFold(addr);
                    if (oldFold) {
                        foldManager.removeUserFold(addr);
                        undoManager.push({
                            type: 'fold',
                            description: `Remove fold block at ${hex16(addr)}`,
                            undo: () => {
                                foldManager.addUserFold(addr, oldFold.endAddress, oldFold.name);
                            },
                            redo: () => {
                                foldManager.removeUserFold(addr);
                            }
                        });
                        showMessage(`Fold block removed at ${hex16(addr)}`);
                        updateDebugger();
                    }
                } else if (action === 'collapse-all') {
                    foldManager.collapseAll();
                    showMessage('All folds collapsed');
                    updateDebugger();
                } else if (action === 'expand-all') {
                    foldManager.expandAll();
                    showMessage('All folds expanded');
                    updateDebugger();
                }
                closeLabelContextMenu();
            });
        });

        // Right panel disassembly right-click context menu (same as left panel)
        rightDisassemblyView.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            closeLabelContextMenu();

            const line = e.target.closest('.disasm-line');
            if (!line) return;

            const lineAddr = parseInt(line.dataset.addr, 10);
            const operandAddrEl = e.target.closest('.disasm-operand-addr');
            const targetAddr = operandAddrEl ? parseInt(operandAddrEl.dataset.addr, 10) : null;
            const addr = targetAddr !== null ? targetAddr : lineAddr;
            const existingLabel = labelManager.get(addr);

            labelContextMenu = document.createElement('div');
            labelContextMenu.className = 'label-context-menu';

            const existingRegion = regionManager.get(addr);

            let menuHtml = `<div class="menu-header">Address ${hex16(addr)}</div>`;
            menuHtml += `<div class="menu-separator"></div>`;
            menuHtml += `<div data-action="disasm-left">Disasm left</div>`;
            menuHtml += `<div data-action="disasm-right">Disasm right</div>`;
            menuHtml += `<div class="menu-separator"></div>`;
            menuHtml += `<div data-action="mem-left">Memory left</div>`;
            menuHtml += `<div data-action="mem-right">Memory right</div>`;
            menuHtml += `<div class="menu-separator"></div>`;
            if (existingLabel) {
                menuHtml += `<div data-action="edit">Edit label "${existingLabel.name}"</div>`;
                menuHtml += `<div data-action="delete" class="danger">Delete label</div>`;
            } else {
                menuHtml += `<div data-action="add">Add label</div>`;
            }
            const existingComment = commentManager.get(addr);
            if (existingComment) {
                menuHtml += `<div data-action="edit-comment">Edit comment</div>`;
                menuHtml += `<div data-action="delete-comment" class="danger">Delete comment</div>`;
            } else {
                menuHtml += `<div data-action="add-comment">Add comment</div>`;
            }
            menuHtml += `<div class="menu-separator"></div>`;
            const currentFormat = operandFormatManager.get(lineAddr);
            menuHtml += `<div class="menu-submenu">Operand format...
                <div class="menu-submenu-items">
                    <div data-action="format-hex"${currentFormat === 'hex' ? ' class="selected"' : ''}>Hex (FFh)</div>
                    <div data-action="format-dec"${currentFormat === 'dec' ? ' class="selected"' : ''}>Decimal (255)</div>
                    <div data-action="format-bin"${currentFormat === 'bin' ? ' class="selected"' : ''}>Binary (%11111111)</div>
                    <div data-action="format-char"${currentFormat === 'char' ? ' class="selected"' : ''}>Char ('A')</div>
                </div>
            </div>`;
            menuHtml += `<div class="menu-submenu">Mark as...
                <div class="menu-submenu-items">
                    <div data-action="mark-code">Code</div>
                    <div data-action="mark-db">DB (bytes)</div>
                    <div data-action="mark-dw">DW (words)</div>
                    <div data-action="mark-text">Text (ASCII)</div>
                    <div data-action="mark-gfx">Graphics</div>
                    <div data-action="mark-smc">SMC (self-mod)</div>
                </div>
            </div>`;
            if (existingRegion) {
                menuHtml += `<div data-action="remove-region" class="danger">Remove region mark</div>`;
            }
            menuHtml += `<div class="menu-separator"></div>`;
            const existingSub = subroutineManager.get(addr);
            if (existingSub) {
                menuHtml += `<div data-action="remove-sub" class="danger">Remove subroutine mark</div>`;
            } else {
                menuHtml += `<div data-action="add-sub">Mark as subroutine</div>`;
            }
            // Fold options
            menuHtml += `<div class="menu-separator"></div>`;
            const existingUserFold = foldManager.getUserFold(addr);
            if (existingUserFold) {
                menuHtml += `<div data-action="remove-fold" class="danger">Remove fold block</div>`;
            } else {
                menuHtml += `<div data-action="add-fold">Create fold block...</div>`;
            }
            menuHtml += `<div data-action="collapse-all">Collapse all folds</div>`;
            menuHtml += `<div data-action="expand-all">Expand all folds</div>`;
            labelContextMenu.innerHTML = menuHtml;

            labelContextMenu.style.left = e.clientX + 'px';
            labelContextMenu.style.top = e.clientY + 'px';
            document.body.appendChild(labelContextMenu);

            labelContextMenu.addEventListener('click', (menuE) => {
                const action = menuE.target.dataset.action;
                if (action === 'disasm-left') {
                    goToLeftDisasm(addr);
                } else if (action === 'disasm-right') {
                    goToRightDisasm(addr);
                } else if (action === 'mem-left') {
                    goToLeftMemory(addr);
                } else if (action === 'mem-right') {
                    goToRightMemory(addr);
                } else if (action === 'add') {
                    showLabelDialog(addr);
                } else if (action === 'edit') {
                    showLabelDialog(addr, existingLabel);
                } else if (action === 'delete') {
                    labelManager.remove(addr);
                    showMessage(`Label "${existingLabel.name}" deleted`);
                    updateDebugger();
                } else if (action === 'format-hex') {
                    operandFormatManager.set(lineAddr, OPERAND_FORMATS.HEX);
                    updateDebugger();
                } else if (action === 'format-dec') {
                    operandFormatManager.set(lineAddr, OPERAND_FORMATS.DEC);
                    updateDebugger();
                } else if (action === 'format-bin') {
                    operandFormatManager.set(lineAddr, OPERAND_FORMATS.BIN);
                    updateDebugger();
                } else if (action === 'format-char') {
                    operandFormatManager.set(lineAddr, OPERAND_FORMATS.CHAR);
                    updateDebugger();
                } else if (action === 'mark-code') {
                    showRegionDialog(addr, REGION_TYPES.CODE);
                } else if (action === 'mark-db') {
                    showRegionDialog(addr, REGION_TYPES.DB);
                } else if (action === 'mark-dw') {
                    showRegionDialog(addr, REGION_TYPES.DW);
                } else if (action === 'mark-text') {
                    showRegionDialog(addr, REGION_TYPES.TEXT);
                } else if (action === 'mark-gfx') {
                    showRegionDialog(addr, REGION_TYPES.GRAPHICS);
                } else if (action === 'mark-smc') {
                    showRegionDialog(addr, REGION_TYPES.SMC);
                } else if (action === 'remove-region') {
                    regionManager.remove(addr);
                    showMessage('Region mark removed');
                    updateDebugger();
                } else if (action === 'add-comment' || action === 'edit-comment') {
                    showCommentDialog(addr);
                } else if (action === 'delete-comment') {
                    commentManager.remove(addr);
                    showMessage(`Comment removed at ${hex16(addr)}`);
                    updateDebugger();
                } else if (action === 'add-sub') {
                    subroutineManager.add(addr);
                    showMessage(`Marked as subroutine at ${hex16(addr)}`);
                    updateDebugger();
                } else if (action === 'remove-sub') {
                    subroutineManager.remove(addr);
                    showMessage(`Subroutine mark removed at ${hex16(addr)}`);
                    updateDebugger();
                } else if (action === 'add-fold') {
                    showFoldDialog(addr);
                } else if (action === 'remove-fold') {
                    foldManager.removeUserFold(addr);
                    showMessage(`Fold block removed at ${hex16(addr)}`);
                    updateDebugger();
                } else if (action === 'collapse-all') {
                    foldManager.collapseAll();
                    showMessage('All folds collapsed');
                    updateDebugger();
                } else if (action === 'expand-all') {
                    foldManager.expandAll();
                    showMessage('All folds expanded');
                    updateDebugger();
                }
                closeLabelContextMenu();
            });
        });

        // Close context menu on click elsewhere
        document.addEventListener('click', (e) => {
            if (labelContextMenu && !labelContextMenu.contains(e.target)) {
                closeLabelContextMenu();
            }
        });

        // Unified Trigger handlers
        triggerType.addEventListener('change', () => {
            const type = triggerType.value;
            if (type.startsWith('port')) {
                triggerAddrInput.placeholder = 'PORT[&MASK]';
            } else {
                triggerAddrInput.placeholder = '[P:]ADDR[-END]';
            }
        });

        btnAddTrigger.addEventListener('click', () => {
            const type = triggerType.value;
            const addrStr = triggerAddrInput.value.trim();
            if (!addrStr) return;
            const condition = triggerCondInput.value.trim();
            const skipCount = parseInt(document.getElementById('triggerSkipInput').value) || 0;

            // Parse address based on type
            let triggerSpec;
            if (type.startsWith('port')) {
                const parsed = spectrum.parsePortSpec(addrStr);
                if (!parsed) {
                    showMessage('Invalid port address', 'error');
                    return;
                }
                triggerSpec = { type, start: parsed.port, end: parsed.port, mask: parsed.mask };
            } else {
                const parsed = spectrum.parseAddressSpec(addrStr);
                if (!parsed) {
                    showMessage('Invalid address', 'error');
                    return;
                }
                triggerSpec = { type, start: parsed.start, end: parsed.end, page: parsed.page };
            }

            if (condition) triggerSpec.condition = condition;
            if (skipCount > 0) triggerSpec.skipCount = skipCount;

            if (spectrum.addTrigger(triggerSpec) < 0) {
                showMessage('Failed to add trigger', 'error');
                return;
            }

            triggerAddrInput.value = '';
            triggerCondInput.value = '';
            document.getElementById('triggerSkipInput').value = '0';
            const typeLabel = spectrum.getTriggerLabel(type);
            let msg = `${typeLabel} trigger set: ${addrStr.toUpperCase()}`;
            if (condition) msg += ` if ${condition}`;
            if (skipCount > 0) msg += ` (skip ${skipCount})`;
            showMessage(msg);
            updateDebugger();
        });

        triggerAddrInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') btnAddTrigger.click();
        });

        triggerCondInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') btnAddTrigger.click();
        });

        btnClearTriggers.addEventListener('click', () => {
            const count = spectrum.getTriggers().length;
            if (count === 0) {
                showMessage('No triggers to clear', 'error');
                return;
            }
            spectrum.clearTriggers();
            showMessage(`Cleared ${count} trigger(s)`);
            updateDebugger();
        });

        // Trigger list click handler (remove, toggle, navigate)
        triggerList.addEventListener('click', (e) => {
            const index = parseInt(e.target.dataset.index, 10);
            if (isNaN(index)) return;

            if (e.target.classList.contains('trigger-remove')) {
                const triggers = spectrum.getTriggers();
                const t = triggers.find(tr => tr.index === index);
                spectrum.removeTrigger(index);
                showMessage(`Trigger removed: ${t ? spectrum.formatTrigger(t) : index}`);
                updateDebugger();
            } else if (e.target.classList.contains('trigger-toggle')) {
                const enabled = spectrum.toggleTrigger(index);
                showMessage(`Trigger ${enabled ? 'enabled' : 'disabled'}`);
                updateDebugger();
            } else if (e.target.classList.contains('trigger-desc')) {
                // Navigate to address
                const triggers = spectrum.getTriggers();
                const t = triggers.find(tr => tr.index === index);
                if (t && !t.type.startsWith('port')) {
                    goToDisassembly(t.start);
                    goToMemoryAddress(t.start);
                    updateDebugger();
                }
            }
        });

        // Breakpoint/Watchpoint/Port hit callbacks (for compatibility)
        spectrum.onBreakpoint = (addr) => {
            showMessage(`Breakpoint hit at ${hex16(addr)}`);
            disasmViewAddress = null; // Force disasm to show PC
            openDebuggerPanel();
            updateDebugger();
            updateStatus();
        };

        spectrum.onWatchpoint = (wp) => {
            const typeStr = wp.type === 'read' ? 'Read' : 'Write';
            showMessage(`Watchpoint: ${typeStr} at ${hex16(wp.addr)} = ${hex8(wp.val)}`);
            disasmViewAddress = null; // Force disasm to show PC
            openDebuggerPanel();
            goToMemoryAddress(wp.addr);
            updateDebugger();
            updateStatus();
        };

        spectrum.onPortBreakpoint = (pb) => {
            const dirStr = pb.direction === 'in' ? 'IN' : 'OUT';
            const portHex = pb.port.toString(16).toUpperCase().padStart(4, '0');
            let msg = `Port breakpoint: ${dirStr} ${portHex}`;
            if (pb.val !== undefined) msg += ` = ${hex8(pb.val)}`;
            showMessage(msg);
            disasmViewAddress = null; // Force disasm to show PC
            openDebuggerPanel();
            updateDebugger();
            updateStatus();
        };

        // Unified trigger callback
        spectrum.onTrigger = (info) => {
            // Already handled by individual callbacks above
            // This is for future unified handling
            disasmViewAddress = null; // Force disasm to show PC
            updateDebugger();
        };

        // Labels panel handlers
        labelFilterInput.addEventListener('input', () => {
            updateLabelsList();
        });

        btnAddLabel.addEventListener('click', () => {
            showLabelDialog(null, null);
        });

        btnClearLabels.addEventListener('click', () => {
            const count = labelManager.getAll().length;
            if (count === 0) {
                showMessage('No labels to clear', 'error');
                return;
            }
            if (confirm(`Clear all ${count} label(s)?`)) {
                labelManager.labels.clear();
                labelManager._autoSave();
                showMessage(`Cleared ${count} label(s)`);
                updateLabelsList();
                updateDebugger();
            }
        });

        btnExportLabels.addEventListener('click', () => {
            const labels = labelManager.getAll();
            if (labels.length === 0) {
                showMessage('No labels to export', 'error');
                return;
            }
            try {
                const json = labelManager.exportJSON();
                const blob = new Blob([json], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const filename = labelManager.currentFile
                    ? labelManager.currentFile.replace(/\.[^.]+$/, '') + '_labels.json'
                    : 'labels.json';
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
                showMessage(`Exported ${labels.length} label(s)`);
            } catch (e) {
                showMessage('Export failed: ' + e.message, 'error');
            }
        });

        btnImportLabels.addEventListener('click', () => {
            labelFileInput.click();
        });

        labelFileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const merge = labelManager.getAll().length > 0 &&
                                  confirm('Merge with existing labels?\n(Cancel to replace all)');
                    const count = labelManager.importJSON(event.target.result, merge);
                    showMessage(`Imported ${count} label(s)${merge ? ' (merged)' : ''}`);
                    updateLabelsList();
                    updateDebugger();
                } catch (err) {
                    showMessage('Invalid labels file: ' + err.message, 'error');
                }
            };
            reader.readAsText(file);
            labelFileInput.value = '';
        });

        labelsList.addEventListener('click', (e) => {
            const removeBtn = e.target.closest('.label-remove');
            if (removeBtn) {
                const addr = parseInt(removeBtn.dataset.addr, 10);
                const page = removeBtn.dataset.page === 'null' ? null : parseInt(removeBtn.dataset.page, 10);
                const oldLabel = labelManager.get(addr, page);
                if (!oldLabel) return;
                labelManager.remove(addr, page);
                undoManager.push({
                    type: 'label',
                    description: `Delete label "${oldLabel.name}"`,
                    undo: () => {
                        labelManager.add(oldLabel);
                        updateLabelsList();
                    },
                    redo: () => {
                        labelManager.remove(addr, page);
                        updateLabelsList();
                    }
                });
                showMessage(`Label removed: ${oldLabel.name}`);
                updateLabelsList();
                updateDebugger();
                return;
            }

            const editBtn = e.target.closest('.label-edit');
            if (editBtn) {
                const addr = parseInt(editBtn.dataset.addr, 10);
                const page = editBtn.dataset.page === 'null' ? null : parseInt(editBtn.dataset.page, 10);
                const label = labelManager.get(addr, page);
                showLabelDialog(addr, label);
                return;
            }

            const item = e.target.closest('.label-item');
            if (item) {
                const addr = parseInt(item.dataset.addr, 10);
                goToAddress(addr);
                updateDebugger();
            }
        });

        btnRunTo.addEventListener('click', () => {
            if (!spectrum.romLoaded) return;
            if (runToTarget === null) {
                showMessage('Click a line in disassembly to set target', 'error');
                return;
            }
            if (spectrum.isRunning()) {
                spectrum.stop();
            }
            traceManager.goToLive();
            traceViewAddress = null;
            const reached = spectrum.runToAddress(runToTarget);
            if (reached) {
                showMessage(`Reached ${hex16(runToTarget)}`);
            } else {
                showMessage('Target not reached (max cycles)', 'error');
            }
            updateDebugger();
            updateStatus();
        });

        btnRunToInt.addEventListener('click', () => {
            if (!spectrum.romLoaded) return;
            if (spectrum.isRunning()) {
                spectrum.stop();
            }
            traceManager.goToLive();
            traceViewAddress = null;
            const reached = spectrum.runToInterrupt();
            if (reached) {
                showMessage('Interrupt reached');
            } else {
                showMessage('Interrupt not reached (max cycles)', 'error');
            }
            updateDebugger();
            updateStatus();
        });

        btnRunToRet.addEventListener('click', () => {
            if (!spectrum.romLoaded) return;
            if (spectrum.isRunning()) {
                spectrum.stop();
            }
            traceManager.goToLive();
            traceViewAddress = null;
            const reached = spectrum.runToRet();
            if (reached) {
                showMessage(`RET at ${hex16(spectrum.cpu.pc)}`);
            } else {
                showMessage('RET not reached (max cycles)', 'error');
            }
            updateDebugger();
            updateStatus();
        });

        btnRunTstates.addEventListener('click', () => {
            if (!spectrum.romLoaded) return;
            const tstates = parseInt(tstatesInput.value, 10);
            if (isNaN(tstates) || tstates <= 0) {
                showMessage('Invalid T-states value', 'error');
                return;
            }
            if (spectrum.isRunning()) {
                spectrum.stop();
            }
            traceManager.goToLive();
            traceViewAddress = null;
            const executed = spectrum.runTstates(tstates);
            // Auto-comment feature: add separator comment at stop address
            if (chkAutoComment.checked) {
                const pc = spectrum.cpu.pc;
                commentManager.set(pc, { before: '--------------------' });
            }
            showMessage(`Executed ${executed} T-states`);
            updateDebugger();
            updateStatus();
        });

        // Right panel step button handlers (mirror left panel functionality)
        btnRightStepInto.addEventListener('click', () => {
            if (!spectrum.romLoaded) {
                showMessage('ROM not loaded', 'error');
                return;
            }
            if (spectrum.isRunning()) {
                spectrum.stop();
            }
            if (chkAutoComment.checked) {
                const pc = spectrum.cpu.pc;
                commentManager.set(pc, { before: '--------------------' });
            }
            traceManager.goToLive();
            traceViewAddress = null;
            spectrum.stepInto();
            openDebuggerPanel();
            updateDebugger();
            updateStatus();
        });

        btnRightStepOver.addEventListener('click', () => {
            if (!spectrum.romLoaded) {
                showMessage('ROM not loaded', 'error');
                return;
            }
            if (spectrum.isRunning()) {
                spectrum.stop();
            }
            traceManager.goToLive();
            traceViewAddress = null;
            spectrum.stepOver();
            openDebuggerPanel();
            updateDebugger();
            updateStatus();
        });

        btnRightRunTo.addEventListener('click', () => {
            if (!spectrum.romLoaded) return;
            if (runTargetAddress === null) {
                showMessage('Click on a disasm line to set cursor', 'error');
                return;
            }
            if (spectrum.isRunning()) {
                spectrum.stop();
            }
            traceManager.goToLive();
            traceViewAddress = null;
            const reached = spectrum.runTo(runTargetAddress);
            if (reached) {
                showMessage(`Reached ${hex16(runTargetAddress)}`);
            } else {
                showMessage(`Target ${hex16(runTargetAddress)} not reached (max cycles)`, 'error');
            }
            updateDebugger();
            updateStatus();
        });

        btnRightRunToInt.addEventListener('click', () => {
            if (!spectrum.romLoaded) return;
            if (spectrum.isRunning()) {
                spectrum.stop();
            }
            traceManager.goToLive();
            traceViewAddress = null;
            const reached = spectrum.runToInterrupt();
            if (reached) {
                showMessage(`Interrupt at ${hex16(spectrum.cpu.pc)}`);
            } else {
                showMessage('Interrupt not reached (max cycles)', 'error');
            }
            updateDebugger();
            updateStatus();
        });

        btnRightRunToRet.addEventListener('click', () => {
            if (!spectrum.romLoaded) return;
            if (spectrum.isRunning()) {
                spectrum.stop();
            }
            traceManager.goToLive();
            traceViewAddress = null;
            const reached = spectrum.runToRet();
            if (reached) {
                showMessage(`RET at ${hex16(spectrum.cpu.pc)}`);
            } else {
                showMessage('RET not reached (max cycles)', 'error');
            }
            updateDebugger();
            updateStatus();
        });

        btnRightRunTstates.addEventListener('click', () => {
            if (!spectrum.romLoaded) return;
            const tstates = parseInt(rightTstatesInput.value, 10);
            if (isNaN(tstates) || tstates <= 0) {
                showMessage('Invalid T-states value', 'error');
                return;
            }
            if (spectrum.isRunning()) {
                spectrum.stop();
            }
            traceManager.goToLive();
            traceViewAddress = null;
            const executed = spectrum.runTstates(tstates);
            if (chkAutoComment.checked) {
                const pc = spectrum.cpu.pc;
                commentManager.set(pc, { before: '--------------------' });
            }
            showMessage(`Executed ${executed} T-states`);
            updateDebugger();
            updateStatus();
        });

        // Global hotkeys for debugger
        document.addEventListener('keydown', (e) => {
            // Don't capture if typing in input fields or editing registers
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            if (e.target.isContentEditable || isEditingRegister) return;

            // Ctrl+Z - Undo (only when emulator is paused to not interfere with BASIC)
            if (e.ctrlKey && e.key === 'z' && !spectrum.isRunning()) {
                e.preventDefault();
                undoManager.undo();
                return;
            }
            // Ctrl+Y - Redo (only when emulator is paused)
            if (e.ctrlKey && e.key === 'y' && !spectrum.isRunning()) {
                e.preventDefault();
                undoManager.redo();
                return;
            }

            // Alt+Left - Trace back
            if (e.altKey && e.key === 'ArrowLeft' && !spectrum.isRunning()) {
                e.preventDefault();
                const entry = traceManager.goBack();
                if (entry) {
                    showTraceEntry(entry);
                }
                return;
            }
            // Alt+Right - Trace forward
            if (e.altKey && e.key === 'ArrowRight' && !spectrum.isRunning()) {
                e.preventDefault();
                const entry = traceManager.goForward();
                if (entry) {
                    showTraceEntry(entry);
                } else {
                    traceManager.goToLive();
                    updateTraceStatus();
                    updateTraceList();
                    showMessage('Returned to live view');
                }
                return;
            }

            // PageUp/PageDown - Scroll disassembly view (left or right panel)
            if (e.key === 'PageUp' || e.key === 'PageDown') {
                e.preventDefault();
                if (!disasm) return;
                const delta = e.key === 'PageDown' ? DISASM_LINES * 2 : -(DISASM_LINES * 2);
                if (leftPanelType === 'disasm') {
                    if (disasmViewAddress === null && spectrum.cpu) {
                        disasmViewAddress = spectrum.cpu.pc;
                    }
                    if (disasmViewAddress !== null) {
                        disasmViewAddress = (disasmViewAddress + delta) & 0xffff;
                        disasmAddressInput.value = hex16(disasmViewAddress);
                        updateDebugger();
                    }
                } else if (rightPanelType === 'disasm') {
                    if (rightDisasmViewAddress === null && spectrum.cpu) {
                        rightDisasmViewAddress = spectrum.cpu.pc;
                    }
                    if (rightDisasmViewAddress !== null) {
                        goToRightDisasmAddress(rightDisasmViewAddress + delta);
                    }
                }
                return;
            }

            // Paused-mode hotkeys: bookmarks and tilde-run
            if (!spectrum.isRunning() && !e.ctrlKey && !e.altKey) {
                // Tilde (`) - Resume emulation
                if (e.key === '`' || e.key === '~') {
                    e.preventDefault();
                    if (spectrum.romLoaded) {
                        spectrum.start();
                        updateStatus();
                        showMessage('Resumed');
                    }
                    return;
                }

                // ArrowUp/ArrowDown - scroll disasm by 1 line
                if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                    e.preventDefault();
                    if (!disasm) return;
                    const delta = e.key === 'ArrowDown' ? 2 : -2;
                    if (leftPanelType === 'disasm') {
                        if (disasmViewAddress === null && spectrum.cpu) {
                            disasmViewAddress = spectrum.cpu.pc;
                        }
                        if (disasmViewAddress !== null) {
                            disasmViewAddress = (disasmViewAddress + delta) & 0xffff;
                            disasmAddressInput.value = hex16(disasmViewAddress);
                            updateDebugger();
                        }
                    } else if (rightPanelType === 'disasm') {
                        if (rightDisasmViewAddress === null && spectrum.cpu) {
                            rightDisasmViewAddress = spectrum.cpu.pc;
                        }
                        if (rightDisasmViewAddress !== null) {
                            goToRightDisasmAddress(rightDisasmViewAddress + delta);
                        }
                    }
                    return;
                }

                // Digit code to index mapping (works regardless of Shift)
                const digitCode = e.code;  // 'Digit1'..'Digit0'
                const digitMatch = digitCode && digitCode.match(/^Digit(\d)$/);
                if (digitMatch) {
                    const digit = digitMatch[1]; // '0'..'9'
                    const leftMap = { '1': 0, '2': 1, '3': 2, '4': 3, '5': 4 };
                    const rightMap = { '6': 0, '7': 1, '8': 2, '9': 3, '0': 4 };

                    if (!e.shiftKey) {
                        // Jump to bookmark
                        if (digit in leftMap && leftPanelType !== 'calc') {
                            e.preventDefault();
                            const bm = leftBookmarks[leftMap[digit]];
                            if (bm !== null) {
                                const addr = typeof bm === 'object' ? bm.addr : bm;
                                const type = typeof bm === 'object' ? bm.type : 'disasm';
                                if (type !== leftPanelType) switchLeftPanelType(type);
                                if (leftPanelType === 'disasm') goToAddress(addr);
                                else goToLeftMemoryAddress(addr);
                            }
                            return;
                        }
                        if (digit in rightMap && rightPanelType !== 'calc') {
                            e.preventDefault();
                            const bm = rightBookmarks[rightMap[digit]];
                            if (bm !== null) {
                                const addr = typeof bm === 'object' ? bm.addr : bm;
                                const type = typeof bm === 'object' ? bm.type : 'memdump';
                                if (type !== rightPanelType) switchRightPanelType(type);
                                if (rightPanelType === 'memdump') goToMemoryAddress(addr);
                                else goToRightDisasmAddress(addr);
                            }
                            return;
                        }
                    } else {
                        // Shift+digit: set bookmark at current address
                        if (digit in leftMap && leftPanelType !== 'calc') {
                            e.preventDefault();
                            const idx = leftMap[digit];
                            let addr, type = leftPanelType;
                            if (type === 'disasm') {
                                addr = disasmViewAddress !== null ? disasmViewAddress : (spectrum.cpu ? spectrum.cpu.pc : null);
                            } else {
                                addr = leftMemoryViewAddress;
                            }
                            if (addr !== null) {
                                const oldBm = leftBookmarks[idx];
                                leftBookmarks[idx] = { addr, type };
                                updateBookmarkButtons(disasmBookmarksBar, leftBookmarks, 'left');
                                undoManager.push({
                                    type: 'bookmark',
                                    description: oldBm !== null ? `Update left bookmark ${idx + 1}` : `Set left bookmark ${idx + 1}`,
                                    undo: () => { leftBookmarks[idx] = oldBm; updateBookmarkButtons(disasmBookmarksBar, leftBookmarks, 'left'); },
                                    redo: () => { leftBookmarks[idx] = { addr, type }; updateBookmarkButtons(disasmBookmarksBar, leftBookmarks, 'left'); }
                                });
                                showMessage(`Left bookmark ${idx + 1} set to ${hex16(addr)}`);
                            }
                            return;
                        }
                        if (digit in rightMap && rightPanelType !== 'calc') {
                            e.preventDefault();
                            const idx = rightMap[digit];
                            let addr, type = rightPanelType;
                            if (type === 'memdump') {
                                addr = memoryViewAddress;
                            } else {
                                addr = rightDisasmViewAddress !== null ? rightDisasmViewAddress : (spectrum.cpu ? spectrum.cpu.pc : null);
                            }
                            if (addr !== null) {
                                const oldBm = rightBookmarks[idx];
                                rightBookmarks[idx] = { addr, type };
                                updateBookmarkButtons(memoryBookmarksBar, rightBookmarks, 'right');
                                undoManager.push({
                                    type: 'bookmark',
                                    description: oldBm !== null ? `Update right bookmark ${idx + 1}` : `Set right bookmark ${idx + 1}`,
                                    undo: () => { rightBookmarks[idx] = oldBm; updateBookmarkButtons(memoryBookmarksBar, rightBookmarks, 'right'); },
                                    redo: () => { rightBookmarks[idx] = { addr, type }; updateBookmarkButtons(memoryBookmarksBar, rightBookmarks, 'right'); }
                                });
                                showMessage(`Right bookmark ${idx + 1} set to ${hex16(addr)}`);
                            }
                            return;
                        }
                    }
                }
            }

            // F1 - Cycle zoom (x1 → x2 → x3 → x1)
            if (e.key === 'F1') {
                e.preventDefault();
                const nextZoom = currentZoom >= 3 ? 1 : currentZoom + 1;
                setZoom(nextZoom);
                showMessage(`Zoom x${nextZoom}`);
                return;
            }

            // F10 - Cycle overlay mode
            if (e.key === 'F10') {
                e.preventDefault();
                const modes = ['normal', 'grid', 'box', 'screen', 'reveal', 'beam', 'beamscreen', 'noattr', 'nobitmap'];
                const curIdx = modes.indexOf(overlaySelect.value);
                const nextIdx = (curIdx + 1) % modes.length;
                overlaySelect.value = modes[nextIdx];
                spectrum.setOverlayMode(modes[nextIdx]);
                spectrum.redraw();
                showMessage(`Overlay: ${overlaySelect.options[overlaySelect.selectedIndex].text}`);
                return;
            }

            // F6 - Pause/Resume
            if (e.code === 'F6' || e.key === 'F6' || e.key === 'Pause') {
                e.preventDefault();
                if (spectrum.romLoaded) {
                    spectrum.toggle();
                    updateStatus();
                    showMessage(spectrum.isRunning() ? 'Resumed' : 'Paused');
                }
                return;
            }
            // F7 - Step Into
            if (e.code === 'F7' || e.key === 'F7') {
                e.preventDefault();
                if (!spectrum.romLoaded) return;
                if (spectrum.isRunning()) {
                    spectrum.stop();
                    updateStatus();
                }
                traceManager.goToLive();
                traceViewAddress = null;
                spectrum.stepInto();
                openDebuggerPanel();
                updateDebugger();
                updateStatus();
                return;
            }
            // F8 - Step Over
            if (e.code === 'F8' || e.key === 'F8') {
                e.preventDefault();
                if (!spectrum.romLoaded) return;
                if (spectrum.isRunning()) {
                    spectrum.stop();
                    updateStatus();
                }
                traceManager.goToLive();
                traceViewAddress = null;
                spectrum.stepOver();
                openDebuggerPanel();
                updateDebugger();
                updateStatus();
                return;
            }
            // F4 - Run to Cursor
            if (e.key === 'F4') {
                e.preventDefault();
                if (!spectrum.romLoaded) return;
                if (runToTarget === null) {
                    showMessage('Click a disassembly line first', 'error');
                    return;
                }
                if (spectrum.isRunning()) {
                    spectrum.stop();
                }
                traceManager.goToLive();
                traceViewAddress = null;
                const reached = spectrum.runToAddress(runToTarget);
                if (reached) {
                    showMessage(`Reached ${hex16(runToTarget)}`);
                } else {
                    showMessage('Target not reached', 'error');
                }
                openDebuggerPanel();
                updateDebugger();
                updateStatus();
                return;
            }
            // F9 - Toggle Breakpoint at PC
            if (e.key === 'F9') {
                e.preventDefault();
                if (!spectrum.romLoaded) return;
                const pc = spectrum.cpu.pc;
                const isSet = spectrum.toggleBreakpoint(pc);
                showMessage(isSet ? `Breakpoint set at ${hex16(pc)}` : `Breakpoint removed at ${hex16(pc)}`);
                openDebuggerPanel();
                updateDebugger();
                return;
            }
        });
        
        btnReset.addEventListener('click', () => {
            if (!confirm('Reset machine? This will lose current state.')) return;
            cancelAutoLoad();
            spectrum.reset();
            // Hide media indicators (tape/disk cleared on reset)
            diskActivityEl.style.display = 'none';
            document.getElementById('tapeInfo').style.display = 'none';
            document.getElementById('diskInfo').style.display = 'none';
            if (tapeCatalogEl) { tapeCatalogEl.innerHTML = ''; }
            if (diskCatalogEl) { diskCatalogEl.innerHTML = ''; }
            if (mediaCatalogContainer) { mediaCatalogContainer.style.display = 'none'; }
            showMessage('Machine reset');
        });

        document.getElementById('btnScreenshot').addEventListener('click', () => {
            const format = document.getElementById('frameExportFormat').value;
            const baseName = getExportBaseName() || 'screenshot';
            const timestamp = Date.now();

            if (format === 'png') {
                const canvas = document.getElementById('screen');
                canvas.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${baseName}_${timestamp}.png`;
                    a.click();
                    URL.revokeObjectURL(url);
                    showMessage('Screenshot saved as PNG');
                }, 'image/png');
            } else if (format === 'scr') {
                // Export SCR - with ULAplus palette if active and modified
                let data, msg;
                if (spectrum.ula.ulaplus.enabled && spectrum.ula.ulaplus.paletteEnabled && spectrum.ula.ulaplus.paletteModified) {
                    data = new Uint8Array(6912 + 64);
                    for (let i = 0; i < 6912; i++) {
                        data[i] = spectrum.memory.read(0x4000 + i);
                    }
                    data.set(spectrum.ula.ulaplus.palette, 6912);
                    msg = 'SCR saved with ULAplus palette (6976 bytes)';
                } else {
                    data = new Uint8Array(6912);
                    for (let i = 0; i < 6912; i++) {
                        data[i] = spectrum.memory.read(0x4000 + i);
                    }
                    msg = 'SCR saved (6912 bytes)';
                }
                const blob = new Blob([data], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${baseName}_${timestamp}.scr`;
                a.click();
                URL.revokeObjectURL(url);
                showMessage(msg);
            } else if (format === 'bsc') {
                // BSC requires frame capture - start single frame capture
                showMessage('Use Start/Stop for BSC format', 'info');
            } else {
                // Other formats (zip, gif, sca) need frame sequence
                showMessage(`Use Start/Stop for ${format.toUpperCase()} format`, 'info');
            }
        });

        document.getElementById('btnScreenshotMain').addEventListener('click', () => {
            const canvas = document.getElementById('screen');
            canvas.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `screenshot_${spectrum.machineType}_${Date.now()}.png`;
                a.click();
                URL.revokeObjectURL(url);
                showMessage('Screenshot saved');
            }, 'image/png');
        });

        // Load dropdown handler
        loadSelect.addEventListener('change', (e) => {
            const action = e.target.value;
            e.target.selectedIndex = 0; // Reset dropdown
            if (!action) return;

            if (action === 'file') {
                fileInput.click();
            } else if (action === 'browse') {
                gameBrowserDialog.classList.remove('hidden');
                gameBrowserSearch.focus();
            } else if (action === 'project') {
                projectFileInput.click();
            } else if (action === 'quick') {
                quickload();
            }
        });

        // Save dropdown handler
        saveSelect.addEventListener('change', (e) => {
            const action = e.target.value;
            e.target.selectedIndex = 0; // Reset dropdown
            if (!action) return;

            if (action === 'project') {
                saveProject();
            } else if (action === 'quick') {
                quicksave();
            } else {
                // Save snapshot (sna, z80, szx)
                try {
                    const profile = getMachineProfile(spectrum.machineType);
                    // Warn if format can't preserve all RAM pages
                    if (action !== 'szx' && profile.ramPages > 8) {
                        showMessage(`${action.toUpperCase()} format limited to 8 RAM pages — ${profile.ramPages - 8} pages will be lost. Use SZX for full save.`, 'warning');
                    }
                    const data = spectrum.saveSnapshot(action);
                    const blob = new Blob([data], { type: 'application/octet-stream' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `snapshot_${spectrum.machineType}.${action}`;
                    a.click();
                    URL.revokeObjectURL(url);
                    showMessage(`Snapshot saved as ${action.toUpperCase()}`);
                } catch (err) {
                    showMessage('Failed to save: ' + err.message, 'error');
                }
            }
        });

        // Project save/load
        const projectFileInput = document.getElementById('projectFileInput');

        // Helper to convert array/Uint8Array to base64 (handles large arrays)
        function arrayToBase64(data) {
            // Ensure we have a Uint8Array
            const arr = data instanceof Uint8Array ? data : new Uint8Array(data);
            let binary = '';
            const chunkSize = 8192;
            for (let i = 0; i < arr.length; i += chunkSize) {
                const end = Math.min(i + chunkSize, arr.length);
                // Convert chunk to regular array for String.fromCharCode.apply
                const chunk = Array.from(arr.subarray(i, end));
                binary += String.fromCharCode.apply(null, chunk);
            }
            return btoa(binary);
        }

        function saveProject() {
            try {
                // Get emulator snapshot as base64
                const snapshotData = spectrum.saveSnapshot();
                const snapshotBase64 = arrayToBase64(snapshotData);

                // Collect all project state
                const project = {
                    version: 2,  // v2 adds media storage
                    timestamp: new Date().toISOString(),
                    machineType: spectrum.machineType,
                    snapshot: snapshotBase64,
                    debugger: {
                        disasmAddress: disasmViewAddress,
                        memoryAddress: memoryViewAddress,
                        leftMemoryAddress: leftMemoryViewAddress,
                        rightDisasmAddress: rightDisasmViewAddress,
                        leftPanelType: leftPanelType,
                        rightPanelType: rightPanelType,
                        leftBookmarks: leftBookmarks.slice(),
                        rightBookmarks: rightBookmarks.slice(),
                        // Legacy format for backward compatibility
                        disasmBookmarks: leftBookmarks.slice(),
                        memoryBookmarks: rightBookmarks.slice(),
                        // Unified triggers (new format)
                        triggers: spectrum.getTriggers().map(t => ({
                            type: t.type,
                            start: t.start,
                            end: t.end,
                            page: t.page,
                            mask: t.mask,
                            condition: t.condition || '',
                            enabled: t.enabled,
                            skipCount: t.skipCount || 0,
                            hitCount: t.hitCount || 0,
                            name: t.name || ''
                        })),
                        labels: JSON.parse(labelManager.exportJSON()),
                        regions: JSON.parse(regionManager.exportJSON()),
                        comments: JSON.parse(commentManager.exportJSON()),
                        xrefs: xrefManager.exportJSON() ? JSON.parse(xrefManager.exportJSON()) : [],
                        subroutines: JSON.parse(subroutineManager.exportJSON()),
                        folds: foldManager.exportJSON() ? JSON.parse(foldManager.exportJSON()) : { userFolds: [], collapsed: [] },
                        operandFormats: operandFormatManager.getAll(),
                        watches: watches.map(w => ({ addr: w.addr, name: w.name, page: w.page })),
                        portTraceFilters: spectrum.getPortTraceFilters().map(f => ({ port: f.port, mask: f.mask }))
                    },
                    settings: {
                        kempston: chkKempston.checked,
                        kempstonExtended: document.getElementById('chkKempstonExtended').checked,
                        gamepad: document.getElementById('chkGamepad').checked,
                        gamepadMapping: spectrum.gamepadMapping,
                        kempstonMouse: document.getElementById('chkKempstonMouse').checked,
                        mouseWheel: document.getElementById('chkMouseWheel').checked,
                        mouseSwap: document.getElementById('chkMouseSwap').checked,
                        borderPreset: borderSizeSelect.value,
                        invertDisplay: chkInvertDisplay.checked,
                        lateTimings: chkLateTimings.checked,
                        speed: parseInt(speedSelect.value),
                        palette: paletteSelect.value,
                        labelDisplayMode: document.getElementById('labelDisplayMode').value,
                        showRomLabels: labelManager.showRomLabels,
                        darkTheme: darkTheme,
                        debuggerOpen: !tabContainer.classList.contains('collapsed'),
                        zoom: document.querySelector('.zoom-btn.active')?.textContent.replace('x', '') || '2',
                        running: spectrum.isRunning(),
                        overlayMode: overlaySelect.value,
                        fullscreenMode: fullscreenMode.value,
                        tapeFlashLoad: spectrum.getTapeFlashLoad(),
                        tapeAudioEnabled: spectrum.tapeAudioEnabled,
                        autoLoad: chkAutoLoad.checked,
                        cfaSkipRom: chkCfaSkipRom.checked,
                        cfaISR: chkCfaISR.checked,
                        cfaEntries: cfaExtraEntries.value
                    },
                    // CPU timing state (not stored in SNA format)
                    cpuTiming: {
                        tStates: spectrum.cpu.tStates,
                        halted: spectrum.cpu.halted,
                        iff1: spectrum.cpu.iff1,
                        iff2: spectrum.cpu.iff2
                    },
                    // ULA state for rainbow border graphics
                    ulaState: {
                        borderColor: spectrum.ula.borderColor,
                        borderChanges: spectrum.ula.borderChanges.slice()  // Copy of border change array
                    },
                    // AY-3-8910 sound chip state
                    ayState: spectrum.ay ? spectrum.ay.exportState() : null
                };

                // Add source file name if loaded
                if (labelManager.currentFile) {
                    project.sourceFile = labelManager.currentFile;
                }

                // Add RZX state if RZX data exists (even if paused)
                if (spectrum.getRZXData()) {
                    const rzxData = spectrum.getRZXData();
                    project.rzx = {
                        data: arrayToBase64(rzxData),
                        frame: spectrum.getRZXFrame(),
                        instructions: spectrum.getRZXInstructions(),
                        totalFrames: spectrum.getRZXTotalFrames()
                    };
                }

                // Add loaded media (multi-drive format v2)
                const mediaState = spectrum.getLoadedMedia();
                if (mediaState) {
                    project.mediaVersion = 2;
                    project.media = {};

                    if (mediaState.tape && mediaState.tape.data) {
                        project.media.tape = {
                            type: mediaState.tape.type,
                            name: mediaState.tape.name,
                            data: arrayToBase64(mediaState.tape.data),
                            tapeBlock: mediaState.tapeBlock
                        };
                    }

                    project.media.betaDisks = [];
                    for (let i = 0; i < 4; i++) {
                        if (mediaState.betaDisks[i] && mediaState.betaDisks[i].data) {
                            project.media.betaDisks.push({
                                drive: i,
                                name: mediaState.betaDisks[i].name,
                                data: arrayToBase64(mediaState.betaDisks[i].data)
                            });
                        }
                    }

                    project.media.fdcDisks = [];
                    for (let i = 0; i < 2; i++) {
                        if (mediaState.fdcDisks[i] && mediaState.fdcDisks[i].data) {
                            project.media.fdcDisks.push({
                                drive: i,
                                name: mediaState.fdcDisks[i].name,
                                data: arrayToBase64(mediaState.fdcDisks[i].data)
                            });
                        }
                    }
                }

                // Add assembler state (VFS and editor content)
                if (asmEditor && (asmEditor.value || Object.keys(VFS.files).length > 0)) {
                    // Sync current editor to VFS before saving
                    if (currentOpenFile && VFS.files[currentOpenFile] && !VFS.files[currentOpenFile].binary) {
                        VFS.files[currentOpenFile].content = asmEditor.value;
                    }

                    project.assembler = {
                        editorContent: asmEditor.value,
                        mainFile: currentProjectMainFile,
                        openTabs: openTabs,
                        currentOpenFile: currentOpenFile,
                        files: {},
                        binaryFiles: {}
                    };
                    // Save all files from VFS
                    for (const path in VFS.files) {
                        const file = VFS.files[path];
                        if (file.binary) {
                            // Binary files as base64
                            project.assembler.binaryFiles[path] = arrayToBase64(file.content);
                        } else {
                            project.assembler.files[path] = file.content;
                        }
                    }
                }

                const json = JSON.stringify(project, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const fileName = labelManager.currentFile ?
                    labelManager.currentFile.replace(/\.[^.]+$/, '') :
                    `project_${spectrum.machineType}`;
                a.download = `${fileName}_${Date.now()}.zxproj`;
                a.click();
                URL.revokeObjectURL(url);
                showMessage('Project saved');
            } catch (e) {
                showMessage('Failed to save project: ' + e.message, 'error');
                console.error(e);
            }
        }

        async function loadProject(jsonStr) {
            try {
                const project = JSON.parse(jsonStr);

                if (!project.version || !project.snapshot) {
                    throw new Error('Invalid project file');
                }

                // Stop emulator during load
                const wasRunning = spectrum.isRunning();
                spectrum.stop();

                // Switch machine type if needed
                if (project.machineType && project.machineType !== spectrum.machineType) {
                    spectrum.setMachineType(project.machineType);
                    applyRomsToEmulator();
                    machineSelect.value = project.machineType;
                    if (typeof updateULAplusStatus === 'function') updateULAplusStatus();
                }

                // Restore snapshot
                const snapshotBinary = Uint8Array.from(atob(project.snapshot), c => c.charCodeAt(0));
                spectrum.loadSnapshot(snapshotBinary);

                // Reset disassembler to use fresh memory reference
                disasm = null;

                // Clear existing debugger state
                spectrum.clearTriggers();
                labelManager.clear();

                // Restore debugger state
                if (project.debugger) {
                    // Restore addresses
                    if (project.debugger.disasmAddress !== undefined) {
                        disasmViewAddress = project.debugger.disasmAddress;
                        if (disasmViewAddress !== null) {
                            disasmAddressInput.value = hex16(disasmViewAddress);
                        }
                    }
                    if (project.debugger.memoryAddress !== undefined) {
                        memoryViewAddress = project.debugger.memoryAddress;
                        memoryAddressInput.value = hex16(memoryViewAddress);
                    }
                    if (project.debugger.leftMemoryAddress !== undefined) {
                        leftMemoryViewAddress = project.debugger.leftMemoryAddress;
                        leftMemAddressInput.value = hex16(leftMemoryViewAddress);
                    }
                    if (project.debugger.rightDisasmAddress !== undefined) {
                        rightDisasmViewAddress = project.debugger.rightDisasmAddress;
                        if (rightDisasmViewAddress !== null) {
                            rightDisasmAddressInput.value = hex16(rightDisasmViewAddress);
                        }
                    }

                    // Restore panel types
                    if (project.debugger.leftPanelType) {
                        switchLeftPanelType(project.debugger.leftPanelType);
                    }
                    if (project.debugger.rightPanelType) {
                        switchRightPanelType(project.debugger.rightPanelType);
                    }

                    // Restore bookmarks (new format first, then legacy)
                    if (project.debugger.leftBookmarks) {
                        leftBookmarks = project.debugger.leftBookmarks.slice();
                        disasmBookmarks = leftBookmarks;
                        updateBookmarkButtons(disasmBookmarksBar, leftBookmarks, 'left');
                    } else if (project.debugger.disasmBookmarks) {
                        leftBookmarks = project.debugger.disasmBookmarks.slice();
                        disasmBookmarks = leftBookmarks;
                        updateBookmarkButtons(disasmBookmarksBar, leftBookmarks, 'left');
                    }
                    if (project.debugger.rightBookmarks) {
                        rightBookmarks = project.debugger.rightBookmarks.slice();
                        memoryBookmarks = rightBookmarks;
                        updateBookmarkButtons(memoryBookmarksBar, rightBookmarks, 'right');
                    } else if (project.debugger.memoryBookmarks) {
                        rightBookmarks = project.debugger.memoryBookmarks.slice();
                        memoryBookmarks = rightBookmarks;
                        updateBookmarkButtons(memoryBookmarksBar, rightBookmarks, 'right');
                    }

                    // Restore triggers (new unified format)
                    if (project.debugger.triggers) {
                        for (const t of project.debugger.triggers) {
                            spectrum.addTrigger(t);
                        }
                    } else {
                        // Legacy format - convert breakpoints/watchpoints/portBreakpoints
                        if (project.debugger.breakpoints) {
                            for (const bp of project.debugger.breakpoints) {
                                spectrum.addTrigger({
                                    type: 'exec',
                                    start: bp.start,
                                    end: bp.end,
                                    page: bp.page,
                                    condition: bp.condition || ''
                                });
                            }
                        }
                        if (project.debugger.watchpoints) {
                            for (const wp of project.debugger.watchpoints) {
                                const wpType = wp.type === 'read' ? 'read' : wp.type === 'write' ? 'write' : 'rw';
                                spectrum.addTrigger({
                                    type: wpType,
                                    start: wp.start,
                                    end: wp.end,
                                    page: wp.page
                                });
                            }
                        }
                        if (project.debugger.portBreakpoints) {
                            for (const pb of project.debugger.portBreakpoints) {
                                const pbType = pb.direction === 'in' ? 'port_in' : pb.direction === 'out' ? 'port_out' : 'port_io';
                                spectrum.addTrigger({
                                    type: pbType,
                                    start: pb.port,
                                    mask: pb.mask
                                });
                            }
                        }
                    }

                    // Restore port trace filters
                    if (project.debugger.portTraceFilters) {
                        spectrum.clearPortTraceFilters();
                        for (const f of project.debugger.portTraceFilters) {
                            spectrum.addPortTraceFilter(f);
                        }
                        updatePortFilterList();
                    }

                    // Restore labels
                    if (project.debugger.labels && project.debugger.labels.length > 0) {
                        labelManager.importJSON(JSON.stringify(project.debugger.labels), false);
                    }

                    // Clear and restore regions
                    regionManager.clear();
                    if (project.debugger.regions && project.debugger.regions.length > 0) {
                        regionManager.importJSON(JSON.stringify(project.debugger.regions), false);
                    }

                    // Clear and restore comments
                    commentManager.clear();
                    if (project.debugger.comments && project.debugger.comments.length > 0) {
                        commentManager.importJSON(JSON.stringify(project.debugger.comments), false);
                    }

                    // Clear and restore xrefs
                    xrefManager.clear();
                    if (project.debugger.xrefs && project.debugger.xrefs.length > 0) {
                        xrefManager.importJSON(JSON.stringify(project.debugger.xrefs), false);
                    }
                    updateXrefStats();

                    // Clear and restore subroutines
                    subroutineManager.clear();
                    if (project.debugger.subroutines && project.debugger.subroutines.length > 0) {
                        subroutineManager.importJSON(JSON.stringify(project.debugger.subroutines), false);
                    }

                    // Clear and restore folds
                    foldManager.clear();
                    if (project.debugger.folds) {
                        foldManager.importJSON(JSON.stringify(project.debugger.folds), false);
                    }

                    // Clear and restore operand formats
                    operandFormatManager.clear();
                    if (project.debugger.operandFormats && project.debugger.operandFormats.length > 0) {
                        for (const f of project.debugger.operandFormats) {
                            operandFormatManager.formats.set(f.address, f.format);
                        }
                    }

                    // Restore watches
                    if (project.debugger.watches && Array.isArray(project.debugger.watches)) {
                        watches = project.debugger.watches.map(item => {
                            // Support old format (number) and new format (object with addr/name/page)
                            if (typeof item === 'number') {
                                return { addr: item, name: '', page: null, prevBytes: new Uint8Array(WATCH_BYTES) };
                            }
                            return {
                                addr: item.addr,
                                name: item.name || '',
                                page: item.page !== undefined ? item.page : null,
                                prevBytes: new Uint8Array(WATCH_BYTES)
                            };
                        });
                        saveWatches();
                        renderWatches();
                    }
                }

                // Restore settings
                if (project.settings) {
                    if (project.settings.kempston !== undefined) {
                        chkKempston.checked = project.settings.kempston;
                        spectrum.kempstonEnabled = project.settings.kempston;
                    }
                    if (project.settings.kempstonExtended !== undefined) {
                        const extChk = document.getElementById('chkKempstonExtended');
                        if (extChk) {
                            extChk.checked = project.settings.kempstonExtended;
                            spectrum.kempstonExtendedEnabled = project.settings.kempstonExtended;
                        }
                    }
                    if (project.settings.gamepad !== undefined) {
                        const gpChk = document.getElementById('chkGamepad');
                        if (gpChk) {
                            gpChk.checked = project.settings.gamepad;
                            spectrum.gamepadEnabled = project.settings.gamepad;
                            setTimeout(() => {
                                if (typeof updateGamepadStatus === 'function') updateGamepadStatus();
                            }, 0);
                        }
                    }
                    if (project.settings.gamepadMapping !== undefined) {
                        spectrum.gamepadMapping = project.settings.gamepadMapping;
                    }
                    if (project.settings.kempstonMouse !== undefined) {
                        const mouseChk = document.getElementById('chkKempstonMouse');
                        if (mouseChk) {
                            mouseChk.checked = project.settings.kempstonMouse;
                            spectrum.kempstonMouseEnabled = project.settings.kempstonMouse;
                            // Update button visibility - defer to ensure function exists
                            setTimeout(() => {
                                if (typeof updateMouseStatus === 'function') updateMouseStatus();
                            }, 0);
                        }
                    }
                    if (project.settings.mouseWheel !== undefined) {
                        const wheelChk = document.getElementById('chkMouseWheel');
                        if (wheelChk) {
                            wheelChk.checked = project.settings.mouseWheel;
                            spectrum.kempstonMouseWheelEnabled = project.settings.mouseWheel;
                        }
                    }
                    if (project.settings.mouseSwap !== undefined) {
                        const swapChk = document.getElementById('chkMouseSwap');
                        if (swapChk) {
                            swapChk.checked = project.settings.mouseSwap;
                            spectrum.kempstonMouseSwapButtons = project.settings.mouseSwap;
                        }
                    }
                    if (project.settings.speed !== undefined) {
                        speedSelect.value = project.settings.speed;
                        spectrum.setSpeed(project.settings.speed);
                    }
                    if (project.settings.palette && loadedPalettes) {
                        paletteSelect.value = project.settings.palette;
                        applyPalette(project.settings.palette);
                    }
                    if (project.settings.labelDisplayMode) {
                        document.getElementById('labelDisplayMode').value = project.settings.labelDisplayMode;
                    }
                    if (project.settings.showRomLabels !== undefined) {
                        labelManager.showRomLabels = project.settings.showRomLabels;
                        document.getElementById('chkShowRomLabels').checked = project.settings.showRomLabels;
                    }
                    if (project.settings.darkTheme !== undefined) {
                        darkTheme = project.settings.darkTheme;
                        document.body.classList.toggle('light-theme', !darkTheme);
                        metaColorScheme.content = darkTheme ? 'dark' : 'light';
                        themeToggle.textContent = darkTheme ? '☀️' : '🌙';
                    }
                    if (project.settings.debuggerOpen !== undefined) {
                        tabContainer.classList.toggle('collapsed', !project.settings.debuggerOpen);
                    }
                    // Restore border preset FIRST (before zoom) so dimensions are correct
                    if (project.settings.borderPreset !== undefined) {
                        borderSizeSelect.value = project.settings.borderPreset;
                        spectrum.ula.setBorderPreset(project.settings.borderPreset);
                        spectrum.updateDisplayDimensions();
                    } else if (project.settings.fullBorder !== undefined) {
                        // Legacy: convert fullBorder boolean to preset
                        const preset = project.settings.fullBorder ? 'full' : 'normal';
                        borderSizeSelect.value = preset;
                        spectrum.ula.setBorderPreset(preset);
                        spectrum.updateDisplayDimensions();
                    }
                    if (project.settings.zoom) {
                        const zoomLevel = parseInt(project.settings.zoom);
                        if (zoomLevel >= 1 && zoomLevel <= 3) {
                            // Defer setZoom to ensure border preset is applied first
                            setTimeout(() => {
                                setZoom(zoomLevel);
                                // Force canvas update with correct dimensions
                                updateCanvasSize();
                            }, 0);
                        }
                    } else if (project.settings.borderPreset !== undefined || project.settings.fullBorder !== undefined) {
                        // No zoom setting but border changed - update canvas
                        setTimeout(() => updateCanvasSize(), 0);
                    }
                    // Load overlay mode (new) or grid (legacy)
                    if (project.settings.overlayMode !== undefined) {
                        overlaySelect.value = project.settings.overlayMode;
                        spectrum.setOverlayMode(project.settings.overlayMode);
                    } else if (project.settings.grid !== undefined) {
                        // Legacy: convert grid boolean to overlay mode
                        const mode = project.settings.grid ? 'grid' : 'normal';
                        overlaySelect.value = mode;
                        spectrum.setOverlayMode(mode);
                    }
                    if (project.settings.fullscreenMode !== undefined) {
                        fullscreenMode.value = project.settings.fullscreenMode;
                        localStorage.setItem('zx-fullscreen-mode', project.settings.fullscreenMode);
                    }
                    if (project.settings.invertDisplay !== undefined) {
                        chkInvertDisplay.checked = project.settings.invertDisplay;
                        applyInvertDisplay(project.settings.invertDisplay);
                    }
                    if (project.settings.lateTimings !== undefined) {
                        chkLateTimings.checked = project.settings.lateTimings;
                        spectrum.setLateTimings(project.settings.lateTimings);
                    }
                    if (project.settings.tapeFlashLoad !== undefined) {
                        document.getElementById('chkFlashLoad').checked = project.settings.tapeFlashLoad;
                        spectrum.setTapeFlashLoad(project.settings.tapeFlashLoad);
                    }
                    if (project.settings.tapeAudioEnabled !== undefined) {
                        document.getElementById('chkTapeAudio').checked = project.settings.tapeAudioEnabled;
                        spectrum.tapeAudioEnabled = project.settings.tapeAudioEnabled;
                    }
                    if (project.settings.autoLoad !== undefined) {
                        document.getElementById('chkAutoLoad').checked = project.settings.autoLoad;
                    }
                    if (project.settings.cfaSkipRom !== undefined) chkCfaSkipRom.checked = project.settings.cfaSkipRom;
                    if (project.settings.cfaISR !== undefined) chkCfaISR.checked = project.settings.cfaISR;
                    if (project.settings.cfaEntries !== undefined) cfaExtraEntries.value = project.settings.cfaEntries;
                }

                // Restore CPU timing state (tStates, halted, IFF)
                if (project.cpuTiming) {
                    if (project.cpuTiming.tStates !== undefined) {
                        spectrum.cpu.tStates = project.cpuTiming.tStates;
                    }
                    if (project.cpuTiming.halted !== undefined) {
                        spectrum.cpu.halted = project.cpuTiming.halted;
                    }
                    if (project.cpuTiming.iff1 !== undefined) {
                        spectrum.cpu.iff1 = project.cpuTiming.iff1;
                    }
                    if (project.cpuTiming.iff2 !== undefined) {
                        spectrum.cpu.iff2 = project.cpuTiming.iff2;
                    }
                    // Safety: if CPU is halted but interrupts disabled, enable them
                    // Otherwise the CPU will be stuck forever
                    if (spectrum.cpu.halted && !spectrum.cpu.iff1) {
                        console.warn('[loadProject] CPU was halted with IFF=0, enabling interrupts');
                        spectrum.cpu.iff1 = true;
                        spectrum.cpu.iff2 = true;
                    }
                }

                // Restore ULA state (border changes for rainbow graphics)
                if (project.ulaState) {
                    if (project.ulaState.borderColor !== undefined) {
                        spectrum.ula.borderColor = project.ulaState.borderColor;
                    }
                    if (project.ulaState.borderChanges && project.ulaState.borderChanges.length > 0) {
                        spectrum.ula.borderChanges = project.ulaState.borderChanges.slice();
                    }
                }

                // Restore AY-3-8910 sound chip state
                if (project.ayState && spectrum.ay) {
                    spectrum.ay.importState(project.ayState);
                }

                // Restore source file name and update status display
                if (project.sourceFile) {
                    labelManager.currentFile = project.sourceFile;
                    regionManager.currentFile = project.sourceFile;
                    commentManager.currentFile = project.sourceFile;
                    // Update media indicator in status bar
                    updateMediaIndicator(project.sourceFile);
                } else {
                    // No source file - hide media indicators
                    document.getElementById('tapeInfo').style.display = 'none';
                    document.getElementById('diskInfo').style.display = 'none';
                }

                // Restore RZX state if present
                if (project.rzx && project.rzx.data) {
                    try {
                        const rzxBinary = Uint8Array.from(atob(project.rzx.data), c => c.charCodeAt(0));
                        // Load RZX but skip embedded snapshot (we already loaded project snapshot)
                        await spectrum.loadRZX(rzxBinary, true);
                        // Restore frame position and instruction count
                        spectrum.setRZXFrame(project.rzx.frame || 0);
                        spectrum.setRZXInstructions(project.rzx.instructions || 0);
                        updateRZXStatus();
                    } catch (e) {
                        console.warn('Failed to restore RZX state:', e);
                    }
                }

                // Restore loaded media
                if (project.mediaVersion === 2 && project.media) {
                    // New multi-drive format (v2)
                    try {
                        const restoreMedia = {};
                        if (project.media.tape && project.media.tape.data) {
                            restoreMedia.tape = {
                                type: project.media.tape.type,
                                name: project.media.tape.name,
                                data: Uint8Array.from(atob(project.media.tape.data), c => c.charCodeAt(0))
                            };
                        } else {
                            restoreMedia.tape = null;
                        }
                        restoreMedia.betaDisks = [null, null, null, null];
                        if (project.media.betaDisks) {
                            for (const entry of project.media.betaDisks) {
                                restoreMedia.betaDisks[entry.drive] = {
                                    name: entry.name,
                                    data: Uint8Array.from(atob(entry.data), c => c.charCodeAt(0))
                                };
                            }
                        }
                        restoreMedia.fdcDisks = [null, null];
                        if (project.media.fdcDisks) {
                            for (const entry of project.media.fdcDisks) {
                                restoreMedia.fdcDisks[entry.drive] = {
                                    name: entry.name,
                                    data: Uint8Array.from(atob(entry.data), c => c.charCodeAt(0))
                                };
                            }
                        }
                        spectrum.setLoadedMedia(restoreMedia);
                        // Restore tape position
                        if (project.media.tape && project.media.tape.tapeBlock !== undefined) {
                            spectrum.setTapeBlock(project.media.tape.tapeBlock);
                        }
                        // Rebuild catalogs — show first drive that has a disk
                        let foundDisk = false;
                        for (let i = 0; i < 2 && !foundDisk; i++) {
                            if (spectrum.loadedFDCDisks[i]) { buildDiskCatalog(i, 'fdc'); foundDisk = true; }
                        }
                        for (let i = 0; i < 4 && !foundDisk; i++) {
                            if (spectrum.loadedBetaDisks[i]) { buildDiskCatalog(i, 'beta'); foundDisk = true; }
                        }
                        buildTapeCatalog();
                    } catch (e) {
                        console.warn('Failed to restore media (v2):', e);
                    }
                } else if (project.media && project.media.data) {
                    // Legacy single-media format (v1 backward compat)
                    try {
                        const mediaData = Uint8Array.from(atob(project.media.data), c => c.charCodeAt(0));
                        spectrum.setLoadedMedia({
                            type: project.media.type,
                            name: project.media.name,
                            data: mediaData
                        });
                        // Restore tape position
                        if (project.media.tapeBlock !== undefined) {
                            spectrum.setTapeBlock(project.media.tapeBlock);
                        }
                        // Rebuild disk catalog for TRD/SCL media
                        if (project.media.type === 'trd' || project.media.type === 'scl') {
                            buildDiskCatalog(0, 'beta');
                        } else if (project.media.type === 'dsk') {
                            buildDiskCatalog(0, 'fdc');
                        }
                        // Rebuild tape catalog
                        buildTapeCatalog();
                    } catch (e) {
                        console.warn('Failed to restore media:', e);
                    }
                }

                // Restore assembler state (VFS and editor content)
                if (project.assembler) {
                    try {
                        // Clear existing VFS
                        VFS.reset();

                        // Restore text files
                        if (project.assembler.files) {
                            for (const path in project.assembler.files) {
                                VFS.addFile(path, project.assembler.files[path]);
                            }
                        }

                        // Restore binary files
                        if (project.assembler.binaryFiles) {
                            for (const path in project.assembler.binaryFiles) {
                                const base64 = project.assembler.binaryFiles[path];
                                const binary = Uint8Array.from(atob(base64), c => c.charCodeAt(0));
                                VFS.addBinaryFile(path, binary);
                            }
                        }

                        // Restore main file reference
                        currentProjectMainFile = project.assembler.mainFile || null;

                        // Restore open tabs and current file
                        openTabs = project.assembler.openTabs || [];
                        currentOpenFile = project.assembler.currentOpenFile || null;
                        fileModified = {};

                        // If we have files but no tabs, open the main file
                        if (Object.keys(VFS.files).length > 0 && openTabs.length === 0) {
                            if (currentProjectMainFile) {
                                openTabs.push(currentProjectMainFile);
                                currentOpenFile = currentProjectMainFile;
                            }
                        }

                        // Restore editor content from current file or saved content
                        if (currentOpenFile && VFS.files[currentOpenFile]) {
                            asmEditor.value = VFS.files[currentOpenFile].content || '';
                        } else if (project.assembler.editorContent && asmEditor) {
                            asmEditor.value = project.assembler.editorContent;
                        }

                        updateLineNumbers();
                        updateHighlight();
                        updateFileTabs();
                        updateProjectButtons();
                        updateDefinesDropdown();
                    } catch (e) {
                        console.warn('Failed to restore assembler state:', e);
                    }
                }

                // Reset trace to live view and clear stale data
                traceManager.clear();
                traceManager.goToLive();
                traceViewAddress = null;

                // Update UI
                updateDebugger();
                updateMemoryView();
                updateBreakpointList();
                updateWatchpointList();
                updatePortBreakpointList();
                updateLabelsList();
                if (typeof updateGraphicsViewer === 'function') {
                    updateGraphicsViewer();
                }

                // Restore running state from project, or use previous state
                const shouldRun = project.settings?.running !== undefined ?
                    project.settings.running : wasRunning;

                if (shouldRun) {
                    // Force start to ensure loop begins even if state is inconsistent
                    spectrum.start(true);
                } else {
                    spectrum.stop();
                    // Render current state WITHOUT executing CPU (preserves tStates)
                    spectrum.renderToScreen();
                }

                // Update all status displays including RZX
                updateStatus();
                updateRZXStatus();

                showMessage(project.rzx ?
                    `Project loaded (RZX frame ${spectrum.getRZXFrame()}/${spectrum.getRZXTotalFrames()})` :
                    'Project loaded');
            } catch (e) {
                showMessage('Failed to load project: ' + e.message, 'error');
                console.error(e);
            }
        }

        projectFileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                loadProject(event.target.result);
            };
            reader.readAsText(file);
            projectFileInput.value = '';
        });
        
        machineSelect.addEventListener('change', () => {
            cancelAutoLoad();
            const type = machineSelect.value;

            // Check if we have the required ROM - open ROM dialog if not
            const profile = getMachineProfile(type);
            if (type !== '48k' && !romData[profile.romFile]) {
                showMessage(profile.name + ' ROM not loaded. Please select the ROM file.', 'error');
                machineSelect.value = spectrum.machineType;
                btnCloseRomModal.classList.remove('hidden');
                romModal.classList.remove('hidden');
                return;
            }

            const wasRunning = spectrum.isRunning();
            if (wasRunning) spectrum.stop();
            
            spectrum.setMachineType(type);
            localStorage.setItem('zx-machine-type', type);
            applyRomsToEmulator();
            // Re-apply border preset setting to new ULA
            spectrum.ula.setBorderPreset(borderSizeSelect.value);
            spectrum.updateDisplayDimensions();
            updateCanvasSize();
            // Re-apply palette to new ULA
            if (typeof applyPalette === 'function') {
                applyPalette(paletteSelect?.value || 'default');
            }
            // Update ULAplus status (palette was reset in setMachineType)
            if (typeof updateULAplusStatus === 'function') {
                updateULAplusStatus();
            }
            spectrum.reset();
            disasm = null; // Reset to use fresh memory reference

            // Update Beta Disk status (always on for Pentagon machines)
            if (profile.betaDiskDefault) {
                spectrum.betaDiskEnabled = true;
            }
            spectrum.updateBetaDiskPagingFlag();
            updateBetaDiskStatus();
            setupDiskActivityCallback();

            if (wasRunning) {
                spectrum.start();
            } else {
                spectrum.runFrame();
            }

            updateGraphicsViewer();
            showMessage(`Switched to ${type.toUpperCase()}`);
            updateStatus();
        });
        
        speedSelect.addEventListener('change', () => {
            const speed = parseInt(speedSelect.value, 10);
            spectrum.setSpeed(speed);
            const label = speed === 0 ? 'Max' : speed + '%';
            showMessage(`Speed: ${label}`);
        });
        
        chkKempston.addEventListener('change', () => {
            spectrum.kempstonEnabled = chkKempston.checked;
            showMessage(chkKempston.checked ? 'Kempston joystick enabled (Numpad)' : 'Kempston joystick disabled');
        });

        // Extended Kempston Joystick (C/A/Start buttons)
        const chkKempstonExtended = document.getElementById('chkKempstonExtended');
        chkKempstonExtended.addEventListener('change', () => {
            spectrum.kempstonExtendedEnabled = chkKempstonExtended.checked;
            showMessage(chkKempstonExtended.checked ?
                'Extended Kempston enabled ([ = C, ] = A, \\ = Start)' :
                'Extended Kempston disabled');
        });

        // Hardware Gamepad
        const chkGamepad = document.getElementById('chkGamepad');
        const gamepadStatus = document.getElementById('gamepadStatus');

        function updateGamepadStatus() {
            if (!chkGamepad.checked) {
                gamepadStatus.textContent = '';
                return;
            }
            const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
            let found = false;
            for (let gp of gamepads) {
                if (gp && gp.connected) {
                    gamepadStatus.textContent = `(${gp.id.substring(0, 30)})`;
                    gamepadStatus.style.color = 'var(--green)';
                    found = true;
                    break;
                }
            }
            if (!found) {
                gamepadStatus.textContent = '(No gamepad detected)';
                gamepadStatus.style.color = 'var(--text-dim)';
            }
        }

        chkGamepad.addEventListener('change', () => {
            spectrum.gamepadEnabled = chkGamepad.checked;
            if (chkGamepad.checked) {
                // Enable Kempston joystick automatically
                chkKempston.checked = true;
                spectrum.kempstonEnabled = true;
            }
            updateGamepadStatus();
            showMessage(chkGamepad.checked ?
                'Hardware gamepad enabled' :
                'Hardware gamepad disabled');
        });

        // Listen for gamepad connect/disconnect
        window.addEventListener('gamepadconnected', (e) => {
            updateGamepadStatus();
            if (chkGamepad.checked) {
                showMessage(`Gamepad connected: ${e.gamepad.id.substring(0, 40)}`);
            }
        });
        window.addEventListener('gamepaddisconnected', (e) => {
            updateGamepadStatus();
            if (chkGamepad.checked) {
                showMessage('Gamepad disconnected');
            }
        });

        // Gamepad Calibration
        const gamepadCalibDialog = document.getElementById('gamepadCalibDialog');
        const gamepadCalibInfo = document.getElementById('gamepadCalibInfo');
        const gamepadCalibStatus = document.getElementById('gamepadCalibStatus');
        const btnCalibrateGamepad = document.getElementById('btnCalibrateGamepad');
        let gamepadCalibrating = null; // Which direction we're calibrating
        let gamepadCalibPollId = null;
        let gamepadBaseline = null; // Baseline axis values when not pressed

        function updateGamepadCalibDisplay() {
            const m = spectrum.gamepadMapping || {};
            const fmt = (entry) => {
                if (!entry) return '-';
                if (entry.type === 'axis') {
                    return `Axis ${entry.index} ${entry.direction > 0 ? '+' : '-'}`;
                } else if (entry.type === 'button') {
                    return `Button ${entry.index}`;
                }
                return '-';
            };
            document.getElementById('gamepadMapUp').textContent = fmt(m.up);
            document.getElementById('gamepadMapDown').textContent = fmt(m.down);
            document.getElementById('gamepadMapLeft').textContent = fmt(m.left);
            document.getElementById('gamepadMapRight').textContent = fmt(m.right);
            document.getElementById('gamepadMapFire').textContent = fmt(m.fire);
            document.getElementById('gamepadMapC').textContent = fmt(m.c);
            document.getElementById('gamepadMapA').textContent = fmt(m.a);
            document.getElementById('gamepadMapStart').textContent = fmt(m.start);
        }

        function captureGamepadBaseline() {
            const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
            for (let gp of gamepads) {
                if (gp && gp.connected) {
                    gamepadBaseline = {
                        axes: [...gp.axes],
                        buttons: gp.buttons.map(b => b.pressed)
                    };
                    return;
                }
            }
            gamepadBaseline = null;
        }

        function pollGamepadForCalibration() {
            if (!gamepadCalibrating) return;

            const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
            let gp = null;
            for (let g of gamepads) {
                if (g && g.connected) { gp = g; break; }
            }
            if (!gp || !gamepadBaseline) {
                gamepadCalibPollId = requestAnimationFrame(pollGamepadForCalibration);
                return;
            }

            // Check for axis changes (threshold 0.4 difference from baseline)
            for (let i = 0; i < gp.axes.length; i++) {
                const diff = gp.axes[i] - (gamepadBaseline.axes[i] || 0);
                if (Math.abs(diff) > 0.4) {
                    // Found an axis movement
                    const mapping = {
                        type: 'axis',
                        index: i,
                        direction: diff > 0 ? 1 : -1,
                        threshold: 0.3
                    };
                    if (!spectrum.gamepadMapping) spectrum.gamepadMapping = {};
                    spectrum.gamepadMapping[gamepadCalibrating] = mapping;
                    gamepadCalibStatus.textContent = `Assigned: Axis ${i} ${diff > 0 ? '+' : '-'}`;
                    gamepadCalibrating = null;
                    updateGamepadCalibDisplay();
                    return;
                }
            }

            // Check for button presses
            for (let i = 0; i < gp.buttons.length; i++) {
                if (gp.buttons[i].pressed && !(gamepadBaseline.buttons[i])) {
                    const mapping = { type: 'button', index: i };
                    if (!spectrum.gamepadMapping) spectrum.gamepadMapping = {};
                    spectrum.gamepadMapping[gamepadCalibrating] = mapping;
                    gamepadCalibStatus.textContent = `Assigned: Button ${i}`;
                    gamepadCalibrating = null;
                    updateGamepadCalibDisplay();
                    return;
                }
            }

            gamepadCalibPollId = requestAnimationFrame(pollGamepadForCalibration);
        }

        btnCalibrateGamepad.addEventListener('click', () => {
            // Show gamepad info
            const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
            let found = false;
            for (let gp of gamepads) {
                if (gp && gp.connected) {
                    gamepadCalibInfo.textContent = gp.id;
                    gamepadCalibInfo.style.color = 'var(--green)';
                    found = true;
                    break;
                }
            }
            if (!found) {
                gamepadCalibInfo.textContent = 'No gamepad detected - connect one first';
                gamepadCalibInfo.style.color = 'var(--text-dim)';
            }
            gamepadCalibStatus.textContent = '';
            gamepadCalibrating = null;
            updateGamepadCalibDisplay();
            gamepadCalibDialog.classList.remove('hidden');
        });

        // Assign buttons
        document.querySelectorAll('.gamepad-assign-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const dir = btn.dataset.dir;
                gamepadCalibrating = dir;
                gamepadCalibStatus.textContent = `Move stick ${dir.toUpperCase()} or press button...`;
                captureGamepadBaseline();
                if (gamepadCalibPollId) cancelAnimationFrame(gamepadCalibPollId);
                gamepadCalibPollId = requestAnimationFrame(pollGamepadForCalibration);
            });
        });

        document.getElementById('btnGamepadCalibReset').addEventListener('click', () => {
            spectrum.gamepadMapping = null;
            localStorage.removeItem('gamepadMapping');
            updateGamepadCalibDisplay();
            gamepadCalibStatus.textContent = 'Mapping reset to default';
        });

        document.getElementById('btnGamepadCalibSave').addEventListener('click', () => {
            if (spectrum.gamepadMapping) {
                localStorage.setItem('gamepadMapping', JSON.stringify(spectrum.gamepadMapping));
                showMessage('Gamepad mapping saved');
            }
            gamepadCalibDialog.classList.add('hidden');
            if (gamepadCalibPollId) cancelAnimationFrame(gamepadCalibPollId);
            gamepadCalibrating = null;
        });

        document.getElementById('btnGamepadCalibClose').addEventListener('click', () => {
            gamepadCalibDialog.classList.add('hidden');
            if (gamepadCalibPollId) cancelAnimationFrame(gamepadCalibPollId);
            gamepadCalibrating = null;
        });

        // Load saved gamepad mapping
        try {
            const savedMapping = localStorage.getItem('gamepadMapping');
            if (savedMapping) {
                spectrum.gamepadMapping = JSON.parse(savedMapping);
            }
        } catch (e) {}

        // Mouse Wheel checkbox
        const chkMouseWheel = document.getElementById('chkMouseWheel');
        chkMouseWheel.addEventListener('change', () => {
            spectrum.kempstonMouseWheelEnabled = chkMouseWheel.checked;
            showMessage(chkMouseWheel.checked ?
                'Mouse wheel enabled (bits 7:4)' :
                'Mouse wheel disabled');
        });

        // Mouse Swap L/R checkbox
        const chkMouseSwap = document.getElementById('chkMouseSwap');
        chkMouseSwap.addEventListener('change', () => {
            spectrum.kempstonMouseSwapButtons = chkMouseSwap.checked;
            showMessage(chkMouseSwap.checked ?
                'Mouse buttons swapped (left↔right)' :
                'Mouse buttons normal');
        });

        // Kempston Mouse
        const chkKempstonMouse = document.getElementById('chkKempstonMouse');
        const mouseStatus = document.getElementById('mouseStatus');
        const btnMouse = document.getElementById('btnMouse');
        let mouseCaptured = false;

        function updateMouseStatus() {
            // Update settings panel status text
            if (!chkKempstonMouse.checked) {
                mouseStatus.textContent = '';
                btnMouse.style.display = 'none';
            } else if (mouseCaptured) {
                mouseStatus.textContent = '(Captured - Esc to release)';
                mouseStatus.style.color = 'var(--green)';
                btnMouse.style.display = '';
                btnMouse.textContent = '🖱️✓';
                btnMouse.title = 'Mouse captured (Esc to release)';
            } else {
                mouseStatus.textContent = '(Click 🖱️ to capture)';
                mouseStatus.style.color = 'var(--text-dim)';
                btnMouse.style.display = '';
                btnMouse.textContent = '🖱️';
                btnMouse.title = 'Capture mouse (Kempston Mouse)';
            }
        }

        chkKempstonMouse.addEventListener('change', () => {
            spectrum.kempstonMouseEnabled = chkKempstonMouse.checked;
            if (!chkKempstonMouse.checked && mouseCaptured) {
                document.exitPointerLock();
            }
            updateMouseStatus();
            showMessage(chkKempstonMouse.checked ?
                'Kempston Mouse enabled - click 🖱️ button to capture' :
                'Kempston Mouse disabled');
        });

        // Beta Disk (TR-DOS) interface toggle
        const chkBetaDisk = document.getElementById('chkBetaDisk');
        const betaDiskStatus = document.getElementById('betaDiskStatus');

        function updateBetaDiskStatus() {
            if (spectrum.profile.betaDiskDefault) {
                betaDiskStatus.textContent = '(always on for ' + spectrum.profile.name + ')';
                chkBetaDisk.checked = true;
                chkBetaDisk.disabled = true;
            } else {
                chkBetaDisk.disabled = false;
                if (!romData['trdos.rom']) {
                    betaDiskStatus.textContent = '(trdos.rom required)';
                } else if (chkBetaDisk.checked) {
                    betaDiskStatus.textContent = '';
                } else {
                    betaDiskStatus.textContent = '';
                }
            }
        }

        chkBetaDisk.addEventListener('change', () => {
            spectrum.betaDiskEnabled = chkBetaDisk.checked;
            localStorage.setItem('zx-beta-disk', chkBetaDisk.checked);
            // Load TR-DOS ROM into memory when enabling Beta Disk
            if (chkBetaDisk.checked && romData['trdos.rom'] && !spectrum.memory.hasTrdosRom()) {
                spectrum.memory.loadTrdosRom(romData['trdos.rom']);
                spectrum.trdosTrap.updateTrdosRomFlag();
            }
            spectrum.updateBetaDiskPagingFlag();
            updateBetaDiskStatus();
            showMessage(chkBetaDisk.checked ?
                'Beta Disk interface enabled' :
                'Beta Disk interface disabled');
        });

        // Restore Beta Disk setting from localStorage (but not for machines with built-in Beta Disk)
        const savedBetaDisk = localStorage.getItem('zx-beta-disk') === 'true';
        if (!spectrum.profile.betaDiskDefault) {
            chkBetaDisk.checked = savedBetaDisk;
            spectrum.betaDiskEnabled = savedBetaDisk;
            // Load TR-DOS ROM if Beta Disk enabled and ROM available
            if (savedBetaDisk && romData['trdos.rom'] && !spectrum.memory.hasTrdosRom()) {
                spectrum.memory.loadTrdosRom(romData['trdos.rom']);
                spectrum.trdosTrap.updateTrdosRomFlag();
            }
        }
        spectrum.updateBetaDiskPagingFlag();
        updateBetaDiskStatus();

        // Load boot TRD settings from localStorage
        loadBootTrdSettings();

        // Media controls - Tape
        const chkFlashLoad = document.getElementById('chkFlashLoad');
        const tapeLoadModeEl = document.getElementById('tapeLoadMode');
        const tapePositionEl = document.getElementById('tapePosition');
        const tapeProgressEl = document.getElementById('tapeProgress');
        const tapeCatalogEl = document.getElementById('tapeCatalog');
        const diskCatalogEl = document.getElementById('diskCatalog');
        const mediaCatalogContainer = document.getElementById('mediaCatalogContainer');
        const mediaCatalogTapeBtn = document.getElementById('mediaCatalogTapeBtn');
        const mediaCatalogDiskBtn = document.getElementById('mediaCatalogDiskBtn');

        function selectCatalogTab(which) {
            const isTape = which === 'tape';
            mediaCatalogTapeBtn.classList.toggle('active', isTape);
            mediaCatalogDiskBtn.classList.toggle('active', !isTape);
            tapeCatalogEl.style.display = isTape ? 'block' : 'none';
            diskCatalogEl.style.display = !isTape ? 'block' : 'none';
        }

        function updateCatalogTabs(activate) {
            const hasTape = tapeCatalogEl.children.length > 0;
            const hasDisk = diskCatalogEl.children.length > 0 ||
                (spectrum.loadedBetaDiskFiles && spectrum.loadedBetaDiskFiles.some(f => f && f.length > 0)) ||
                (spectrum.loadedFDCDiskFiles && spectrum.loadedFDCDiskFiles.some(f => f && f.length > 0)) ||
                [0, 1, 2, 3].some(i => hasDiskInDrive(i));
            mediaCatalogTapeBtn.style.display = hasTape ? '' : 'none';
            mediaCatalogDiskBtn.style.display = hasDisk ? '' : 'none';
            if (!hasTape && !hasDisk) {
                mediaCatalogContainer.style.display = 'none';
                return;
            }
            mediaCatalogContainer.style.display = 'block';
            if (activate === 'tape' && hasTape) selectCatalogTab('tape');
            else if (activate === 'disk' && hasDisk) selectCatalogTab('disk');
            else if (hasTape && !hasDisk) selectCatalogTab('tape');
            else if (hasDisk && !hasTape) selectCatalogTab('disk');
        }

        mediaCatalogTapeBtn.addEventListener('click', () => selectCatalogTab('tape'));
        mediaCatalogDiskBtn.addEventListener('click', () => selectCatalogTab('disk'));

        // Drive sub-tab click handlers
        document.getElementById('diskDriveTabs').addEventListener('click', (e) => {
            const btn = e.target.closest('.drive-tab');
            if (!btn) return;
            const drv = parseInt(btn.dataset.drive, 10);
            const ctrl = btn.dataset.controller || null;
            buildDiskCatalog(drv, ctrl);
        });

        function describeTapeBlock(block, index) {
            if (!block) return `${index}: ?`;
            const num = String(index + 1).padStart(2, ' ');
            if (block.type === 'pause') return `${num}  Pause ${block.pauseMs || 0}ms`;
            if (block.type === 'stop') return `${num}  Stop Tape`;
            if (block.type !== 'data') return `${num}  ${block.type}`;
            const isTurbo = block.pilotPulse && Math.abs(block.pilotPulse - TAPE_STD_PILOT_PULSE) >= TAPE_TURBO_TOLERANCE;
            const prefix = isTurbo ? 'Turbo' : 'Std';
            const size = block.data ? block.data.length : block.length || 0;
            // Decode standard header
            if (!isTurbo && block.flag === TAPE_STD_FLAG && block.data && block.data.length >= TAPE_HDR_MIN_LENGTH) {
                const d = block.data;
                const hdrType = d[1];
                let name = '';
                for (let i = 2; i < 12; i++) name += String.fromCharCode(d[i] & 0x7f);
                name = name.trimEnd();
                if (hdrType === TAPE_HDR_TYPE_PROGRAM) return `${num}  Header: Program "${name}"`;
                if (hdrType === TAPE_HDR_TYPE_BYTES) return `${num}  Header: Bytes "${name}"`;
                if (hdrType === TAPE_HDR_TYPE_NUM_ARR) return `${num}  Header: Num Array "${name}"`;
                if (hdrType === TAPE_HDR_TYPE_CHR_ARR) return `${num}  Header: Char Array "${name}"`;
                return `${num}  Header: "${name}"`;
            }
            return `${num}  ${prefix} Data (${size} bytes)`;
        }

        function buildTapeCatalog() {
            const blocks = spectrum.tapePlayer.blocks;
            tapeCatalogEl.innerHTML = '';
            if (!blocks || blocks.length === 0) {
                updateCatalogTabs(null);
                return;
            }
            for (let i = 0; i < blocks.length; i++) {
                const row = document.createElement('div');
                row.className = 'tape-catalog-row';
                row.dataset.index = i;
                row.textContent = describeTapeBlock(blocks[i], i);
                row.style.cssText = 'padding: 1px 6px; cursor: pointer; white-space: nowrap;';
                row.addEventListener('click', () => {
                    spectrum.tapePlayer.setBlock(i);
                    updateTapePosition();
                    updateTapeCatalogHighlight();
                });
                tapeCatalogEl.appendChild(row);
            }
            updateTapeCatalogHighlight();
            updateCatalogTabs('tape');
        }

        function updateTapeCatalogHighlight() {
            const rows = tapeCatalogEl.children;
            const current = spectrum.tapePlayer.currentBlock;
            const playing = spectrum.tapePlayer.isPlaying();
            for (let i = 0; i < rows.length; i++) {
                if (i === current) {
                    rows[i].style.background = 'var(--accent)';
                    rows[i].style.color = 'var(--bg-primary)';
                } else if (i < current) {
                    rows[i].style.background = '';
                    rows[i].style.color = 'var(--text-dim)';
                } else {
                    rows[i].style.background = '';
                    rows[i].style.color = 'var(--text-primary)';
                }
            }
        }

        // Track which drive + controller is displayed in the disk catalog
        let diskCatalogDrive = 0;
        let diskCatalogController = null;  // 'fdc'|'beta'|null

        // Check if a disk is present in the specified drive (regardless of file listing)
        // On +3 with Beta Disk, both controllers can have disks simultaneously
        function hasDiskInDrive(driveIndex) {
            const hasFDC = driveIndex < 2 && spectrum.loadedFDCDisks[driveIndex];
            const hasBeta = driveIndex < 4 && spectrum.loadedBetaDisks[driveIndex];
            return !!(hasFDC || hasBeta);
        }

        function buildDiskCatalogSection(driveIndex, isDSK, media, files) {
            const driveLetter = String.fromCharCode(65 + driveIndex);
            const hasFiles = files && files.length > 0;

            // Header row with disk info
            const header = document.createElement('div');
            header.style.cssText = 'padding: 1px 6px; white-space: nowrap; color: var(--cyan); border-bottom: 1px solid var(--bg-secondary); margin-bottom: 2px;';
            let headerText = '';
            if (isDSK) {
                if (hasFiles) {
                    headerText = '\u{1F4BE} ' + driveLetter + ': ' + ((media && media.name) || 'DSK') + ' \u2014 ' + files.length + ' files';
                } else {
                    headerText = '\u{1F4BE} ' + driveLetter + ': ' + ((media && media.name) || 'DSK');
                }
            } else if (media && media.data && media.data.length > TRD_MIN_IMAGE_SIZE) {
                const d = media.data;
                const freeSectors = d[TRD_SECTOR9_OFFSET + TRD_FREE_SECS_LO] | (d[TRD_SECTOR9_OFFSET + TRD_FREE_SECS_HI] << 8);
                const freeKB = Math.floor(freeSectors * TRD_SECTOR_SIZE / 1024);
                let label = '';
                for (let i = 0; i < TRD_LABEL_LENGTH; i++) {
                    const ch = d[TRD_SECTOR9_OFFSET + TRD_LABEL_OFFSET + i];
                    if (ch >= 0x20 && ch < 0x80) label += String.fromCharCode(ch);
                }
                label = label.trim();
                headerText = '\u{1F4BE} ' + driveLetter + ': ' + ((media && media.name) || 'TRD');
                if (label) headerText += ' [' + label + ']';
                headerText += ' \u2014 ' + (hasFiles ? files.length + ' files, ' : '') + freeKB + 'K free';
            } else {
                headerText = '\u{1F4BE} ' + driveLetter + ': ' + ((media && media.name) || 'Disk');
                if (hasFiles) headerText += ' \u2014 ' + files.length + ' files';
            }
            header.textContent = headerText;
            diskCatalogEl.appendChild(header);

            // File rows — DSK files use CP/M format (name.ext + size)
            if (hasFiles) {
                for (let i = 0; i < files.length; i++) {
                    const f = files[i];
                    const row = document.createElement('div');
                    row.style.cssText = 'padding: 1px 6px; white-space: nowrap;';
                    const num = String(i + 1).padStart(2, ' ');
                    const name = f.name.padEnd(8, ' ');
                    if (isDSK) {
                        // CP/M style: name.ext  size
                        const ext = (f.ext || '').padEnd(3, ' ');
                        const size = String(f.size).padStart(6, ' ');
                        row.textContent = num + '  ' + name + '.' + ext + '  ' + size + 'b';
                    } else {
                        // TRD style: name.ext  start  size  sectors
                        const startHex = f.start.toString(16).toUpperCase().padStart(4, '0');
                        const size = String(f.length).padStart(5, ' ');
                        const secs = String(f.sectors).padStart(3, ' ');
                        row.textContent = num + '  ' + name + '.' + f.ext + '  ' + startHex + 'h ' + size + 'b ' + secs + 's';
                        const isBoot = f.name.trim().toLowerCase() === 'boot';
                        if (isBoot) {
                            row.style.color = 'var(--cyan)';
                            row.title = 'Boot file (auto-run on TR-DOS startup)';
                        }
                    }
                    diskCatalogEl.appendChild(row);
                }
            }
        }

        function buildDiskCatalog(driveIndex, controller) {
            if (driveIndex === undefined) driveIndex = diskCatalogDrive;
            if (controller === undefined) controller = diskCatalogController;
            diskCatalogDrive = driveIndex;
            diskCatalogController = controller;
            diskCatalogEl.innerHTML = '';

            // Get media for the specified controller, or both if null
            const showFdc = (!controller || controller === 'fdc') && driveIndex < 2;
            const showBeta = (!controller || controller === 'beta') && driveIndex < 4;
            const fdcMedia = showFdc ? spectrum.loadedFDCDisks[driveIndex] : null;
            const betaMedia = showBeta ? spectrum.loadedBetaDisks[driveIndex] : null;
            const fdcFiles = showFdc ? spectrum.loadedFDCDiskFiles[driveIndex] : null;
            const betaFiles = showBeta ? spectrum.loadedBetaDiskFiles[driveIndex] : null;
            const hasFdcContent = fdcMedia || (fdcFiles && fdcFiles.length > 0);
            const hasBetaContent = betaMedia || (betaFiles && betaFiles.length > 0);

            if (!hasFdcContent && !hasBetaContent) {
                // No disk in this drive — check if any other drive has a disk
                let anyDisk = false;
                for (let i = 0; i < 4; i++) {
                    if (hasDiskInDrive(i)) { anyDisk = true; break; }
                }
                updateDiskDriveTabs();
                updateCatalogTabs(anyDisk ? 'disk' : null);
                return;
            }

            // Show FDC section if present
            if (hasFdcContent) {
                buildDiskCatalogSection(driveIndex, true, fdcMedia, fdcFiles);
            }
            // Show Beta Disk section if present
            if (hasBetaContent) {
                buildDiskCatalogSection(driveIndex, false, betaMedia, betaFiles);
            }

            updateDiskDriveTabs();
            updateCatalogTabs('disk');
        }

        function clearDiskCatalog(driveIndex) {
            if (driveIndex !== undefined) {
                // Clear specific drive file listings
                if (driveIndex < 4) spectrum.loadedBetaDiskFiles[driveIndex] = null;
                if (driveIndex < 2) spectrum.loadedFDCDiskFiles[driveIndex] = null;
                if (diskCatalogDrive === driveIndex) {
                    diskCatalogEl.innerHTML = '';
                }
            } else {
                // Clear all
                diskCatalogEl.innerHTML = '';
            }
            updateDiskDriveTabs();
            // Check if any drive still has a disk
            const maxDrives = 4;
            let anyDisk = false;
            for (let i = 0; i < maxDrives; i++) {
                if (hasDiskInDrive(i)) { anyDisk = true; break; }
            }
            if (!anyDisk) {
                updateCatalogTabs(null);
            }
        }

        // Update disk drive sub-tabs — dynamically generated based on loaded disks
        function updateDiskDriveTabs() {
            const tabsEl = document.getElementById('diskDriveTabs');
            // Collect which drives have disks on each controller
            const fdcDrives = [];
            const betaDrives = [];
            for (let i = 0; i < 2; i++) {
                if (spectrum.loadedFDCDisks[i] || (spectrum.loadedFDCDiskFiles[i] && spectrum.loadedFDCDiskFiles[i].length > 0)) {
                    fdcDrives.push(i);
                }
            }
            for (let i = 0; i < 4; i++) {
                if (spectrum.loadedBetaDisks[i] || (spectrum.loadedBetaDiskFiles[i] && spectrum.loadedBetaDiskFiles[i].length > 0)) {
                    betaDrives.push(i);
                }
            }
            const bothActive = fdcDrives.length > 0 && betaDrives.length > 0;

            // Build tab entries: [{drive, controller, label}]
            const tabs = [];
            if (fdcDrives.length > 0) {
                for (const drv of fdcDrives) {
                    const letter = String.fromCharCode(65 + drv);
                    tabs.push({ drive: drv, controller: 'fdc', label: bothActive ? '3DOS:' + letter : letter + ':' });
                }
            }
            if (betaDrives.length > 0) {
                for (const drv of betaDrives) {
                    const letter = String.fromCharCode(65 + drv);
                    tabs.push({ drive: drv, controller: 'beta', label: bothActive ? 'TRD:' + letter : letter + ':' });
                }
            }

            // Rebuild tab buttons
            tabsEl.innerHTML = '';
            for (const tab of tabs) {
                const btn = document.createElement('button');
                btn.className = 'media-catalog-btn drive-tab';
                btn.style.cssText = 'min-width: 24px; padding: 1px 4px;';
                btn.dataset.drive = tab.drive;
                btn.dataset.controller = tab.controller;
                btn.textContent = tab.label;
                btn.classList.toggle('active', tab.drive === diskCatalogDrive && tab.controller === diskCatalogController);
                tabsEl.appendChild(btn);
            }
            tabsEl.style.display = tabs.length > 0 ? 'inline' : 'none';

            // Also show/hide drive selector
            const drvSelEl = document.getElementById('driveSelector');
            const hasBetaDisk = spectrum.betaDisk && spectrum.betaDisk.hasAnyDisk();
            const hasFDCDisk = spectrum.fdc && spectrum.fdc.hasDisk();
            drvSelEl.style.display = (hasBetaDisk || hasFDCDisk) ? '' : 'none';
            if (drvSelEl.style.display !== 'none') updateDriveSelector();
        }

        function updateTapePosition() {
            const pos = spectrum.getTapePosition();
            if (pos.totalBlocks > 0) {
                const status = pos.playing ? (pos.phase === 'pilot' ? 'PILOT' : pos.phase === 'data' ? 'DATA' : pos.phase.toUpperCase()) : 'STOPPED';
                tapePositionEl.textContent = `Block ${pos.block + 1}/${pos.totalBlocks} ${status}`;
                // Update progress in status bar - show current block progress
                if (tapeProgressEl) {
                    if (pos.playing && pos.phase === 'data') {
                        tapeProgressEl.textContent = `${pos.blockProgress}%`;
                    } else if (pos.playing) {
                        tapeProgressEl.textContent = 'SYNC';
                    } else {
                        tapeProgressEl.textContent = '';
                    }
                }
            } else {
                tapePositionEl.textContent = '';
                if (tapeProgressEl) {
                    tapeProgressEl.textContent = '';
                }
            }
            updateTapeCatalogHighlight();
        }

        // Set up TapePlayer callbacks
        spectrum.tapePlayer.onBlockStart = (blockIndex, block) => {
            const type = block.flag === 0x00 ? 'Header' : 'Data';
            showMessage(`Loading block ${blockIndex + 1}: ${type}`);
            updateTapePosition();
        };
        spectrum.tapePlayer.onBlockEnd = (blockIndex) => {
            updateTapePosition();
        };
        spectrum.tapePlayer.onTapeEnd = () => {
            showMessage('Tape finished');
            updateTapePosition();
        };

        chkFlashLoad.addEventListener('change', () => {
            const flash = chkFlashLoad.checked;
            spectrum.setTapeFlashLoad(flash);
            tapeLoadModeEl.textContent = flash ? '(instant)' : '(real-time)';
            if (flash) {
                spectrum.stopTape();
            }
            updateTapePosition();
        });

        // Initialize flash load state from checkbox on page load
        spectrum.setTapeFlashLoad(chkFlashLoad.checked);
        tapeLoadModeEl.textContent = chkFlashLoad.checked ? '(instant)' : '(real-time)';

        // Auto Load engine
        const chkAutoLoad = document.getElementById('chkAutoLoad');
        let autoLoadTimers = [];
        let autoLoadActive = false;

        function cancelAutoLoad() {
            for (const id of autoLoadTimers) clearTimeout(id);
            autoLoadTimers = [];
            if (autoLoadActive) {
                spectrum.ula.keyboardState.fill(0xFF);
                autoLoadActive = false;
            }
        }

        function autoLoadTimeout(fn, delay) {
            const id = setTimeout(() => {
                const idx = autoLoadTimers.indexOf(id);
                if (idx >= 0) autoLoadTimers.splice(idx, 1);
                fn();
            }, delay);
            autoLoadTimers.push(id);
        }

        function startAutoLoadTape(isTzx) {
            cancelAutoLoad();
            autoLoadActive = true;
            const machType = spectrum.machineType;
            const isAmsMenu = machType === '+2' || machType === '+2a' || machType === '+3';
            const is128K = machType !== '48k';
            const ula = spectrum.ula;

            // Reset (tape data survives reset - only rewinds)
            spectrum.stop();
            spectrum.reset();
            spectrum.start();

            let t = 0;

            // For TZX + flash load: no wrapper needed. The loadTZX callback in
            // spectrum.js sets _turboBlockPending after the last standard block before
            // a turbo gap. The auto-start mechanism (portRead, line ~911) starts the
            // tapePlayer when the custom loader first reads port 0xFE. This is the
            // correct timing — the pilot starts exactly when the loader is ready.
            //
            // For pure turbo TZX (no standard blocks at all): disable flash load
            // so the ROM's real tape routine reads via port 0xFE from the start.
            if (isTzx && spectrum.getTapeFlashLoad() &&
                spectrum.tapeLoader.getBlockCount() === 0 &&
                spectrum.tapePlayer.hasMoreBlocks()) {
                spectrum.setTapeFlashLoad(false);
                chkFlashLoad.checked = false;
                tapeLoadModeEl.textContent = '(real-time)';
            }

            if (isAmsMenu) {
                // +2/+2A: Amstrad menu — press Enter to select "Tape Loader" (default option)
                // which runs LOAD "" automatically, no typing needed
                t += AUTO_LOAD_ROM_WAIT;
                autoLoadTimeout(() => { if (!autoLoadActive) return; ula.keyDown('Enter'); }, t);
                t += AUTO_LOAD_KEY_HOLD;
                autoLoadTimeout(() => {
                    if (!autoLoadActive) return;
                    ula.keyUp('Enter');
                    ula.keyboardState.fill(0xFF);
                    if (!spectrum.getTapeFlashLoad()) {
                        if (!spectrum.tapePlayer.isPlaying()) {
                            spectrum.playTape();
                        }
                    }
                    autoLoadActive = false;
                }, t);
                return;
            }

            if (is128K) {
                // Sinclair 128K/Pentagon menu: press "1" for BASIC
                t += AUTO_LOAD_ROM_WAIT;
                autoLoadTimeout(() => { if (!autoLoadActive) return; ula.keyDown('1'); }, t);
                t += AUTO_LOAD_KEY_HOLD;
                autoLoadTimeout(() => { if (!autoLoadActive) return; ula.keyUp('1'); ula.keyboardState.fill(0xFF); }, t);
                t += AUTO_LOAD_128K_WAIT;
            } else {
                t += AUTO_LOAD_ROM_WAIT;
            }

            // J = LOAD
            autoLoadTimeout(() => { if (!autoLoadActive) return; ula.keyDown('j'); }, t);
            t += AUTO_LOAD_KEY_HOLD;
            autoLoadTimeout(() => { if (!autoLoadActive) return; ula.keyUp('j'); ula.keyboardState.fill(0xFF); }, t);
            t += AUTO_LOAD_KEY_GAP;

            // Symbol+P = first "
            autoLoadTimeout(() => { if (!autoLoadActive) return; ula.keyDown('Alt'); ula.keyDown('p'); }, t);
            t += AUTO_LOAD_KEY_HOLD;
            autoLoadTimeout(() => { if (!autoLoadActive) return; ula.keyUp('p'); ula.keyUp('Alt'); ula.keyboardState.fill(0xFF); }, t);
            t += AUTO_LOAD_KEY_GAP;

            // Symbol+P = second "
            autoLoadTimeout(() => { if (!autoLoadActive) return; ula.keyDown('Alt'); ula.keyDown('p'); }, t);
            t += AUTO_LOAD_KEY_HOLD;
            autoLoadTimeout(() => { if (!autoLoadActive) return; ula.keyUp('p'); ula.keyUp('Alt'); ula.keyboardState.fill(0xFF); }, t);
            t += AUTO_LOAD_KEY_GAP;

            // Enter
            autoLoadTimeout(() => { if (!autoLoadActive) return; ula.keyDown('Enter'); }, t);
            t += AUTO_LOAD_KEY_HOLD;
            autoLoadTimeout(() => {
                if (!autoLoadActive) return;
                ula.keyUp('Enter');
                ula.keyboardState.fill(0xFF);
                if (!spectrum.getTapeFlashLoad()) {
                    // Flash load off: start real-time tape playback
                    if (!spectrum.tapePlayer.isPlaying()) {
                        spectrum.playTape();
                    }
                }
                // For TZX + flash load on: standard blocks load via trap,
                // turbo blocks auto-start via _turboBlockPending in spectrum.js
                autoLoadActive = false;
            }, t);
        }

        function startAutoLoadDisk() {
            cancelAutoLoad();
            if (spectrum.bootTrdos()) {
                spectrum.start();
            }
        }

        function startAutoLoadPlus3Disk() {
            cancelAutoLoad();
            autoLoadActive = true;
            const ula = spectrum.ula;

            // Save all FDC drive disks before reset
            const savedDisks = spectrum.fdc ? spectrum.fdc.drives.map(d => d.disk) : [];

            // Reset machine (disk data survives via restore below)
            spectrum.stop();
            spectrum.reset();

            // Restore all drive disks after reset
            if (spectrum.fdc) {
                for (let i = 0; i < savedDisks.length; i++) {
                    if (savedDisks[i]) spectrum.fdc.drives[i].disk = savedDisks[i];
                }
            }

            spectrum.start();

            // +3 Amstrad menu: press Enter to select "Loader" (default option)
            // The +3 ROM's Loader routine auto-detects disk and boots from it
            let t = AUTO_LOAD_ROM_WAIT;
            autoLoadTimeout(() => { if (!autoLoadActive) return; ula.keyDown('Enter'); }, t);
            t += AUTO_LOAD_KEY_HOLD;
            autoLoadTimeout(() => {
                if (!autoLoadActive) return;
                ula.keyUp('Enter');
                ula.keyboardState.fill(0xFF);
                autoLoadActive = false;
            }, t);
        }

        // Tape audio toggle
        const chkTapeAudio = document.getElementById('chkTapeAudio');
        chkTapeAudio.addEventListener('change', () => {
            spectrum.tapeAudioEnabled = chkTapeAudio.checked;
        });

        document.getElementById('btnTapePlay').addEventListener('click', () => {
            if (spectrum.getTapeFlashLoad()) {
                showMessage('Switch to real-time mode to use Play', 'warning');
                return;
            }
            if (spectrum.playTape()) {
                showMessage('Tape playing - type LOAD "" and press Enter');
                updateTapePosition();
            } else {
                showMessage('No tape loaded', 'error');
            }
        });

        document.getElementById('btnTapeStop').addEventListener('click', () => {
            spectrum.stopTape();
            showMessage('Tape stopped');
            updateTapePosition();
        });

        document.getElementById('btnTapeRewind').addEventListener('click', () => {
            spectrum.rewindTape();
            showMessage('Tape rewound to beginning');
            updateTapePosition();
        });

        // Update tape position periodically when playing
        setInterval(() => {
            if (spectrum.isTapePlaying()) {
                updateTapePosition();
            }
        }, 200);

        document.getElementById('btnBlankDisk').addEventListener('click', () => {
            if (!spectrum.betaDisk) {
                showMessage('Beta Disk not available', 'error');
                return;
            }
            const driveIndex = getSelectedDriveIndex();
            spectrum.betaDisk.createBlankDisk('BLANK', driveIndex);
            // Update per-drive media state
            spectrum.loadedBetaDisks[driveIndex] = { data: spectrum.betaDisk.drives[driveIndex].diskData, name: '[blank]' };
            spectrum.loadedBetaDiskFiles[driveIndex] = [];
            const driveLetter = String.fromCharCode(65 + driveIndex);
            // Show disk name and activity indicators
            updateMediaIndicator('[blank]', 'disk', driveIndex);
            diskActivityEl.style.display = 'inline-block';
            diskStatusEl.textContent = 'ready';
            diskLedEl.style.color = '';
            showMessage(`Blank formatted disk inserted in drive ${driveLetter}:`);
            clearDiskCatalog(driveIndex);
        });


        document.getElementById('btnSettingsLoadRoms').addEventListener('click', () => {
            updateRomStatus();
            btnCloseRomModal.classList.remove('hidden');
            romModal.classList.remove('hidden');
        });

        // Boot TRD file selection
        document.getElementById('btnSelectBootTrd').addEventListener('click', () => {
            document.getElementById('bootTrdFile').click();
        });

        document.getElementById('bootTrdFile').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            try {
                const data = new Uint8Array(await file.arrayBuffer());

                // Detect file type: TRD by size, Hobeta by extension/CRC
                let detectedType = null;
                let hasBootFile = false;

                // Check if it's a TRD file (by size)
                if (data.length === 655360 || data.length === 655360 - 256) {
                    detectedType = 'trd';
                    hasBootFile = trdHasBootFile(data);
                }
                // Check if it's a Hobeta file
                else if (isHobetaFile(data, file.name)) {
                    detectedType = 'hobeta';
                    hasBootFile = hobetaHasBootFile(data);
                }

                if (!detectedType) {
                    showMessage('Invalid file: not a TRD or Hobeta file', 'error');
                    return;
                }

                if (!hasBootFile) {
                    showMessage(`Selected ${detectedType.toUpperCase()} has no boot file`, 'error');
                    return;
                }

                bootTrdData = data;
                bootTrdName = file.name;
                bootFileType = detectedType;

                // Display with type label
                const typeLabel = detectedType === 'hobeta' ? '(Hobeta)' : '(TRD)';
                document.getElementById('bootTrdName').textContent = `${file.name} ${typeLabel}`;

                // Save to localStorage
                localStorage.setItem('bootTrdName', file.name);
                localStorage.setItem('bootTrdData', arrayBufferToBase64(data));
                localStorage.setItem('bootFileType', detectedType);

                showMessage(`Boot file set: ${file.name} ${typeLabel}`);
            } catch (err) {
                showMessage('Failed to load boot file: ' + err.message, 'error');
            }
            // Clear input so same file can be selected again
            e.target.value = '';
        });

        // Boot TRD mode change
        document.getElementById('bootTrdMode').addEventListener('change', (e) => {
            localStorage.setItem('bootTrdMode', e.target.value);
        });

        // Helper: Check if TRD has a boot file (filename "boot" in directory)
        function trdHasBootFile(data) {
            // Ensure we have a Uint8Array (data might be ArrayBuffer)
            const bytes = data instanceof Uint8Array ? data : new Uint8Array(data);
            // Scan directory entries (first 8 sectors = 2048 bytes, 128 entries max)
            for (let i = 0; i < 128; i++) {
                const offset = i * 16;
                const firstByte = bytes[offset];
                if (firstByte === 0x00) break; // End of directory
                if (firstByte === 0x01) continue; // Deleted file
                // Get filename (8 bytes, space-padded)
                let filename = '';
                for (let j = 0; j < 8; j++) {
                    filename += String.fromCharCode(bytes[offset + j]);
                }
                filename = filename.trimEnd().toLowerCase();
                if (filename === 'boot') return true;
            }
            return false;
        }

        // Helper: Extract boot file from TRD
        function extractBootFile(data) {
            // Ensure we have a Uint8Array (data might be ArrayBuffer)
            const bytes = data instanceof Uint8Array ? data : new Uint8Array(data);
            // Scan directory entries to find boot file
            for (let i = 0; i < 128; i++) {
                const offset = i * 16;
                const firstByte = bytes[offset];
                if (firstByte === 0x00) break; // End of directory
                if (firstByte === 0x01) continue; // Deleted file
                // Get filename (8 bytes, space-padded)
                let filename = '';
                for (let j = 0; j < 8; j++) {
                    filename += String.fromCharCode(bytes[offset + j]);
                }
                filename = filename.trimEnd().toLowerCase();
                if (filename === 'boot') {
                    // Found boot file - extract its data
                    const fileType = bytes[offset + 8];
                    const startAddr = bytes[offset + 9] | (bytes[offset + 10] << 8);
                    const length = bytes[offset + 11] | (bytes[offset + 12] << 8);
                    const sectorCount = bytes[offset + 13];
                    const firstSector = bytes[offset + 14];
                    const firstTrack = bytes[offset + 15];

                    // Copy directory entry
                    const dirEntry = bytes.slice(offset, offset + 16);

                    // Calculate data offset and extract file data
                    const trackOffset = firstTrack * 16 * 256; // 16 sectors per track, 256 bytes per sector
                    const sectorOffset = firstSector * 256;
                    const dataOffset = trackOffset + sectorOffset;
                    const fileData = bytes.slice(dataOffset, dataOffset + sectorCount * 256);

                    return { dirEntry, fileData, sectorCount, length, startAddr, fileType };
                }
            }
            return null;
        }

        // Helper: Detect if file is Hobeta format
        function isHobetaFile(data, filename) {
            // Check by extension first
            const lowerName = filename.toLowerCase();
            const hobetaExtensions = ['.$c', '.$b', '.$d', '.$#', '.hobeta'];
            const hasHobetaExt = hobetaExtensions.some(ext => lowerName.endsWith(ext));

            if (!hasHobetaExt) return false;

            // Validate Hobeta header (17 bytes minimum + at least 1 byte of data)
            if (data.length <= 17) return false;

            // If extension matches and file has header + data, accept it
            // Calculate actual sector count from file size (more reliable than header byte)
            const dataSize = data.length - 17;
            const actualSectors = Math.ceil(dataSize / 256);
            if (actualSectors === 0 || actualSectors > 255) return false;

            return true;
        }

        // Helper: Check if Hobeta file has "boot" filename
        function hobetaHasBootFile(data) {
            if (data.length < 17) return false;

            // Get filename (bytes 0-7, space-padded)
            let filename = '';
            for (let i = 0; i < 8; i++) {
                filename += String.fromCharCode(data[i]);
            }
            filename = filename.trimEnd().toLowerCase();
            return filename === 'boot';
        }

        // Helper: Extract boot file from Hobeta
        function extractBootFromHobeta(data) {
            if (data.length <= 17) return null;

            // Parse Hobeta header (17 bytes)
            // Bytes 0-7: Filename
            // Byte 8: Type (B/C/D/#)
            // Bytes 9-10: Start address
            // Bytes 11-12: Length
            // Byte 13: Sector count (may be 0 in some files, so calculate from size)
            // Bytes 14-16: CRC
            // Bytes 17+: File data

            const fileType = data[8];
            const startAddr = data[9] | (data[10] << 8);
            const length = data[11] | (data[12] << 8);
            // Calculate sector count from actual data size (more reliable)
            const dataSize = data.length - 17;
            const sectorCount = Math.ceil(dataSize / 256);

            // Create directory entry (16 bytes) in TRD format
            const dirEntry = new Uint8Array(16);
            // Copy filename (8 bytes)
            for (let i = 0; i < 8; i++) {
                dirEntry[i] = data[i];
            }
            dirEntry[8] = fileType;
            dirEntry[9] = startAddr & 0xFF;
            dirEntry[10] = (startAddr >> 8) & 0xFF;
            dirEntry[11] = length & 0xFF;
            dirEntry[12] = (length >> 8) & 0xFF;
            dirEntry[13] = sectorCount;
            // Bytes 14-15 (first sector/track) will be set by injection
            dirEntry[14] = 0;
            dirEntry[15] = 0;

            // Extract file data (after 17-byte header, pad to full sectors)
            const fileData = new Uint8Array(sectorCount * 256);
            fileData.set(data.slice(17));

            return { dirEntry, fileData, sectorCount, length, startAddr, fileType };
        }

        // Helper: Inject boot file into TRD data
        function injectBootIntoTrd(trdData, bootInfo, reuseLocation) {
            const result = new Uint8Array(trdData);

            // Find first free directory slot
            let dirSlot = -1;
            let wasEndMarker = false; // true if we're inserting at 0x00 (end), false if at 0x01 (deleted)
            for (let i = 0; i < 128; i++) {
                const offset = i * 16;
                const firstByte = result[offset];
                if (firstByte === 0x00) {
                    dirSlot = i;
                    wasEndMarker = true;
                    break;
                }
                if (firstByte === 0x01) {
                    dirSlot = i;
                    wasEndMarker = false;
                    break;
                }
            }
            if (dirSlot === -1) {
                alert('Cannot add boot: disk directory is full (128 files max)');
                return result;
            }

            // Get disk info from sector 8 (offset 0x800)
            const sector8Offset = 8 * 256;
            let firstFreeSector = result[sector8Offset + 0xE1];
            let firstFreeTrack = result[sector8Offset + 0xE2];
            const fileCount = result[sector8Offset + 0xE4];
            let freeSectors = result[sector8Offset + 0xE5] | (result[sector8Offset + 0xE6] << 8);

            // Check if there's enough space
            if (freeSectors < bootInfo.sectorCount) {
                alert('Cannot add boot: not enough free space on disk');
                return result;
            }

            // Write directory entry at the slot
            const dirOffset = dirSlot * 16;
            // Copy filename "boot    " (8 chars padded)
            const bootName = 'boot    ';
            for (let i = 0; i < 8; i++) {
                result[dirOffset + i] = bootName.charCodeAt(i);
            }
            result[dirOffset + 8] = bootInfo.fileType;
            result[dirOffset + 9] = bootInfo.startAddr & 0xFF;
            result[dirOffset + 10] = (bootInfo.startAddr >> 8) & 0xFF;
            result[dirOffset + 11] = bootInfo.length & 0xFF;
            result[dirOffset + 12] = (bootInfo.length >> 8) & 0xFF;
            result[dirOffset + 13] = bootInfo.sectorCount;
            result[dirOffset + 14] = firstFreeSector;
            result[dirOffset + 15] = firstFreeTrack;

            // Write file data at the free location
            const trackOffset = firstFreeTrack * 16 * 256;
            const sectorOffset = firstFreeSector * 256;
            const dataOffset = trackOffset + sectorOffset;
            result.set(bootInfo.fileData.slice(0, bootInfo.sectorCount * 256), dataOffset);

            // Update disk info
            // Calculate new free position
            let newSector = firstFreeSector + bootInfo.sectorCount;
            let newTrack = firstFreeTrack;
            while (newSector >= 16) {
                newSector -= 16;
                newTrack++;
            }
            result[sector8Offset + 0xE1] = newSector;
            result[sector8Offset + 0xE2] = newTrack;
            result[sector8Offset + 0xE4] = fileCount + 1;
            freeSectors -= bootInfo.sectorCount;
            result[sector8Offset + 0xE5] = freeSectors & 0xFF;
            result[sector8Offset + 0xE6] = (freeSectors >> 8) & 0xFF;

            // Mark end of directory if we inserted at the end marker
            if (wasEndMarker && dirSlot + 1 < 128) {
                // We inserted at the previous end-of-directory position
                // ALWAYS mark the next slot as end-of-directory
                const nextOffset = (dirSlot + 1) * 16;
                result[nextOffset] = 0x00;
            }

            return result;
        }

        // Helper: Convert ArrayBuffer to base64 for localStorage
        function arrayBufferToBase64(buffer) {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            const chunkSize = 8192;
            for (let i = 0; i < bytes.length; i += chunkSize) {
                const chunk = bytes.slice(i, i + chunkSize);
                binary += String.fromCharCode.apply(null, chunk);
            }
            return btoa(binary);
        }

        // Helper: Convert base64 to Uint8Array
        function base64ToArrayBuffer(base64) {
            const binary = atob(base64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            return bytes;
        }

        // Load boot TRD settings from localStorage
        function loadBootTrdSettings() {
            const mode = localStorage.getItem('bootTrdMode') || 'none';
            document.getElementById('bootTrdMode').value = mode;

            const name = localStorage.getItem('bootTrdName');
            const dataBase64 = localStorage.getItem('bootTrdData');
            const storedType = localStorage.getItem('bootFileType');
            if (name && dataBase64) {
                try {
                    bootTrdData = base64ToArrayBuffer(dataBase64);
                    bootTrdName = name;
                    // Default to 'trd' for backwards compatibility
                    bootFileType = storedType || 'trd';
                    // Display with type label
                    const typeLabel = bootFileType === 'hobeta' ? '(Hobeta)' : '(TRD)';
                    document.getElementById('bootTrdName').textContent = `${name} ${typeLabel}`;
                } catch (e) {
                    console.warn('Failed to load boot file from localStorage:', e);
                }
            }
        }

        // Process TRD with boot injection if configured
        function processTrdWithBoot(data, filename) {
            const mode = document.getElementById('bootTrdMode').value;
            if (mode === 'none' || !bootTrdData) {
                return data;
            }

            // Extract boot from boot source (TRD or Hobeta)
            let bootInfo;
            if (bootFileType === 'hobeta') {
                bootInfo = extractBootFromHobeta(bootTrdData);
            } else {
                bootInfo = extractBootFile(bootTrdData);
            }
            if (!bootInfo) {
                alert('Cannot add boot: no boot file found in selected boot source');
                return data;
            }

            const existingBoot = getBootFileInfo(data);

            if (mode === 'add') {
                if (existingBoot) {
                    // Already has boot, don't add
                    return data;
                }
                // No boot exists, add new one
                return injectBootIntoTrd(data, bootInfo, null);
            }

            if (mode === 'replace') {
                if (existingBoot) {
                    // Replace existing boot - reuse its location if new boot fits
                    if (bootInfo.sectorCount <= existingBoot.sectorCount) {
                        // New boot fits in old boot's space - reuse location
                        return replaceBootInPlace(data, bootInfo, existingBoot);
                    } else {
                        // New boot is larger - remove old and add at first free
                        data = removeBootFromTrd(data);
                        return injectBootIntoTrd(data, bootInfo, null);
                    }
                } else {
                    // No boot exists, just add
                    return injectBootIntoTrd(data, bootInfo, null);
                }
            }

            return data;
        }

        // Helper: Get info about existing boot file on disk
        function getBootFileInfo(data) {
            const bytes = data instanceof Uint8Array ? data : new Uint8Array(data);
            for (let i = 0; i < 128; i++) {
                const offset = i * 16;
                const firstByte = bytes[offset];
                if (firstByte === 0x00) break;
                if (firstByte === 0x01) continue;
                let filename = '';
                for (let j = 0; j < 8; j++) {
                    filename += String.fromCharCode(bytes[offset + j]);
                }
                if (filename.trimEnd().toLowerCase() === 'boot') {
                    return {
                        dirSlot: i,
                        sectorCount: bytes[offset + 13],
                        firstSector: bytes[offset + 14],
                        firstTrack: bytes[offset + 15]
                    };
                }
            }
            return null;
        }

        // Helper: Replace boot file in place (reuse old boot's disk location)
        function replaceBootInPlace(trdData, bootInfo, existingBoot) {
            const result = new Uint8Array(trdData);
            const dirOffset = existingBoot.dirSlot * 16;

            // Update directory entry with new boot info (keep same disk location)
            const bootName = 'boot    ';
            for (let i = 0; i < 8; i++) {
                result[dirOffset + i] = bootName.charCodeAt(i);
            }
            result[dirOffset + 8] = bootInfo.fileType;
            result[dirOffset + 9] = bootInfo.startAddr & 0xFF;
            result[dirOffset + 10] = (bootInfo.startAddr >> 8) & 0xFF;
            result[dirOffset + 11] = bootInfo.length & 0xFF;
            result[dirOffset + 12] = (bootInfo.length >> 8) & 0xFF;
            result[dirOffset + 13] = bootInfo.sectorCount;
            // Keep same location as old boot
            result[dirOffset + 14] = existingBoot.firstSector;
            result[dirOffset + 15] = existingBoot.firstTrack;

            // Write new boot data at old boot's location
            const trackOffset = existingBoot.firstTrack * 16 * 256;
            const sectorOffset = existingBoot.firstSector * 256;
            const dataOffset = trackOffset + sectorOffset;
            result.set(bootInfo.fileData.slice(0, bootInfo.sectorCount * 256), dataOffset);

            // If new boot is smaller, we waste some sectors (acceptable)
            // File count stays the same (replacing, not adding)

            return result;
        }

        // Helper: Remove boot file from TRD
        function removeBootFromTrd(data) {
            const result = new Uint8Array(data);
            // Find and mark boot file as deleted in directory
            for (let i = 0; i < 128; i++) {
                const offset = i * 16;
                const firstByte = result[offset];
                if (firstByte === 0x00) break;
                if (firstByte === 0x01) continue;
                let filename = '';
                for (let j = 0; j < 8; j++) {
                    filename += String.fromCharCode(result[offset + j]);
                }
                filename = filename.trimEnd().toLowerCase();
                if (filename === 'boot') {
                    // Mark as deleted
                    result[offset] = 0x01;
                    // Note: We don't reclaim the disk space, just mark deleted
                    // Update file count
                    const sector8Offset = 8 * 256;
                    const fileCount = result[sector8Offset + 0xE4];
                    if (fileCount > 0) {
                        result[sector8Offset + 0xE4] = fileCount - 1;
                    }
                    break;
                }
            }
            return result;
        }

        // Mouse button click to capture
        btnMouse.addEventListener('click', () => {
            if (!mouseCaptured) {
                canvas.requestPointerLock();
            }
        });

        // Pointer Lock for mouse capture (also works by clicking canvas)
        canvas.addEventListener('click', () => {
            if (chkKempstonMouse.checked && !mouseCaptured) {
                canvas.requestPointerLock();
            }
        });

        document.addEventListener('pointerlockchange', () => {
            mouseCaptured = document.pointerLockElement === canvas;
            updateMouseStatus();
            if (mouseCaptured) {
                showMessage('Mouse captured - press Escape to release');
            }
        });

        document.addEventListener('pointerlockerror', () => {
            showMessage('Failed to capture mouse', 'error');
        });

        // Mouse movement when captured
        document.addEventListener('mousemove', (e) => {
            if (mouseCaptured && spectrum.kempstonMouseEnabled) {
                // movementX/Y give relative movement
                spectrum.updateMousePosition(e.movementX, e.movementY);
            }
        });

        // Mouse buttons when captured
        canvas.addEventListener('mousedown', (e) => {
            if (mouseCaptured && spectrum.kempstonMouseEnabled) {
                spectrum.setMouseButton(e.button, true);
                e.preventDefault();
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (mouseCaptured && spectrum.kempstonMouseEnabled) {
                spectrum.setMouseButton(e.button, false);
                e.preventDefault();
            }
        });

        // Prevent context menu when mouse captured
        canvas.addEventListener('contextmenu', (e) => {
            if (mouseCaptured) {
                e.preventDefault();
            }
        });

        // Mouse wheel when captured
        document.addEventListener('wheel', (e) => {
            if (mouseCaptured && spectrum.kempstonMouseEnabled && spectrum.kempstonMouseWheelEnabled) {
                spectrum.updateMouseWheel(e.deltaY);
                e.preventDefault();
            }
        }, { passive: false });

        // Audio controls
        async function initAudioOnUserGesture() {
            if (!spectrum.audio) {
                const audio = spectrum.initAudio();
                await audio.start();
                // Restore settings
                audio.setVolume(volumeSlider.value / 100);
                audio.setMuted(!chkSound.checked);
                spectrum.ay.stereoMode = stereoMode.value;
                spectrum.ay.updateStereoPanning();
            }
            // Ensure context is resumed (browser autoplay policy)
            if (spectrum.audio && spectrum.audio.context) {
                if (spectrum.audio.context.state === 'suspended') {
                    try {
                        await spectrum.audio.context.resume();
                    } catch (e) { /* ignore */ }
                }
            }
        }

        function updateSoundButtons(enabled) {
            const icon = enabled ? '🔊' : '🔇';
            btnSound.textContent = icon;
            btnMute.textContent = icon;
        }

        async function toggleSound(enable) {
            if (enable) {
                await initAudioOnUserGesture();
                if (spectrum.audio) {
                    spectrum.audio.setMuted(false);
                }
                showMessage('Sound enabled');
            } else {
                if (spectrum.audio) {
                    spectrum.audio.setMuted(true);
                }
                showMessage('Sound disabled');
            }
            chkSound.checked = enable;
            updateSoundButtons(enable);
            localStorage.setItem('zx-sound-enabled', enable);
        }

        // Main sound button (in controls area)
        btnSound.addEventListener('click', async () => {
            await toggleSound(!chkSound.checked);
        });

        // Settings checkbox
        chkSound.addEventListener('change', async () => {
            await toggleSound(chkSound.checked);
        });

        chkAY48k.addEventListener('change', () => {
            spectrum.ay48kEnabled = chkAY48k.checked;
            showMessage(chkAY48k.checked ? 'AY enabled in 48K mode' : 'AY disabled in 48K mode');
            localStorage.setItem('zx-ay-48k', chkAY48k.checked);
        });

        btnMute.addEventListener('click', async () => {
            await toggleSound(!chkSound.checked);
        });

        volumeSlider.addEventListener('input', () => {
            const vol = volumeSlider.value;
            volumeValue.textContent = vol + '%';
            if (spectrum.audio) {
                spectrum.audio.setVolume(vol / 100);
            }
            localStorage.setItem('zx-volume', vol);
        });

        stereoMode.addEventListener('change', () => {
            spectrum.ay.stereoMode = stereoMode.value;
            spectrum.ay.updateStereoPanning();
            localStorage.setItem('zx-stereo-mode', stereoMode.value);
            showMessage(`Stereo mode: ${stereoMode.value.toUpperCase()}`);
        });

        // Fullscreen functionality
        const screenCanvas = document.getElementById('screen');
        let originalCanvasStyle = null;
        let originalOverlayStyle = null;

        function applyFullscreenScale() {
            // Wait a frame for fullscreen to be fully applied
            requestAnimationFrame(() => {
                const mode = fullscreenMode.value;
                const canvasWidth = screenCanvas.width;
                const canvasHeight = screenCanvas.height;
                // Get fullscreen element dimensions (more reliable than window.inner*)
                const fsElement = document.fullscreenElement || document.webkitFullscreenElement;
                const fsWidth = fsElement ? fsElement.clientWidth : screen.width;
                const fsHeight = fsElement ? fsElement.clientHeight : screen.height;

                let newWidth, newHeight, left, top;

                if (mode === 'stretch') {
                    // Stretch to fill screen (known issue: may not fill full width)
                    newWidth = fsWidth;
                    newHeight = fsHeight;
                    left = 0;
                    top = 0;
                } else if (mode === 'crisp') {
                    // Crisp: use integer scaling for sharp pixels
                    const maxScaleX = Math.floor(fsWidth / canvasWidth);
                    const maxScaleY = Math.floor(fsHeight / canvasHeight);
                    const scale = Math.max(1, Math.min(maxScaleX, maxScaleY));
                    newWidth = canvasWidth * scale;
                    newHeight = canvasHeight * scale;
                    left = Math.round((fsWidth - newWidth) / 2);
                    top = Math.round((fsHeight - newHeight) / 2);
                } else {
                    // Fit: maintain aspect ratio, scale to maximum that fits
                    const scaleX = fsWidth / canvasWidth;
                    const scaleY = fsHeight / canvasHeight;
                    const scale = Math.min(scaleX, scaleY);
                    newWidth = Math.round(canvasWidth * scale);
                    newHeight = Math.round(canvasHeight * scale);
                    left = Math.round((fsWidth - newWidth) / 2);
                    top = Math.round((fsHeight - newHeight) / 2);
                }

                // Apply to main canvas with absolute positioning
                screenCanvas.style.position = 'absolute';
                screenCanvas.style.left = left + 'px';
                screenCanvas.style.top = top + 'px';
                screenCanvas.style.width = newWidth + 'px';
                screenCanvas.style.height = newHeight + 'px';

                // Apply same to overlay canvas
                overlayCanvas.style.position = 'absolute';
                overlayCanvas.style.left = left + 'px';
                overlayCanvas.style.top = top + 'px';
                overlayCanvas.style.width = newWidth + 'px';
                overlayCanvas.style.height = newHeight + 'px';
            });
        }

        function restoreCanvasSize() {
            if (originalCanvasStyle) {
                screenCanvas.style.position = originalCanvasStyle.position;
                screenCanvas.style.left = originalCanvasStyle.left;
                screenCanvas.style.top = originalCanvasStyle.top;
                screenCanvas.style.width = originalCanvasStyle.width;
                screenCanvas.style.height = originalCanvasStyle.height;
            }
            if (originalOverlayStyle) {
                overlayCanvas.style.position = originalOverlayStyle.position;
                overlayCanvas.style.left = originalOverlayStyle.left;
                overlayCanvas.style.top = originalOverlayStyle.top;
                overlayCanvas.style.width = originalOverlayStyle.width;
                overlayCanvas.style.height = originalOverlayStyle.height;
            }
        }

        function toggleFullscreen() {
            if (document.fullscreenElement || document.webkitFullscreenElement) {
                // Exit fullscreen
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                }
            } else {
                // Save original canvas styles
                originalCanvasStyle = {
                    position: screenCanvas.style.position,
                    left: screenCanvas.style.left,
                    top: screenCanvas.style.top,
                    width: screenCanvas.style.width,
                    height: screenCanvas.style.height
                };
                originalOverlayStyle = {
                    position: overlayCanvas.style.position,
                    left: overlayCanvas.style.left,
                    top: overlayCanvas.style.top,
                    width: overlayCanvas.style.width,
                    height: overlayCanvas.style.height
                };
                // Enter fullscreen
                if (screenWrapper.requestFullscreen) {
                    screenWrapper.requestFullscreen();
                } else if (screenWrapper.webkitRequestFullscreen) {
                    screenWrapper.webkitRequestFullscreen();
                }
            }
        }

        btnFullscreen.addEventListener('click', toggleFullscreen);

        fullscreenMode.addEventListener('change', () => {
            localStorage.setItem('zx-fullscreen-mode', fullscreenMode.value);
            // Update scale if currently in fullscreen
            if (document.fullscreenElement || document.webkitFullscreenElement) {
                applyFullscreenScale();
            }
        });

        // Handle fullscreen change events
        document.addEventListener('fullscreenchange', () => {
            if (document.fullscreenElement) {
                applyFullscreenScale();
            } else {
                restoreCanvasSize();
            }
        });
        document.addEventListener('webkitfullscreenchange', () => {
            if (document.webkitFullscreenElement) {
                applyFullscreenScale();
            } else {
                restoreCanvasSize();
            }
        });

        // F11 key for fullscreen toggle
        document.addEventListener('keydown', (e) => {
            if (e.key === 'F11') {
                e.preventDefault();
                toggleFullscreen();
            }
        });

        // Quicksave/Quickload (F5/F9)
        const QUICKSAVE_KEY = 'zx-quicksave';

        function quicksave() {
            try {
                const data = spectrum.saveSnapshot('szx');
                // Convert to base64 for localStorage
                let binary = '';
                const bytes = new Uint8Array(data);
                for (let i = 0; i < bytes.length; i++) {
                    binary += String.fromCharCode(bytes[i]);
                }
                const base64 = btoa(binary);
                localStorage.setItem(QUICKSAVE_KEY, base64);
                localStorage.setItem(QUICKSAVE_KEY + '-machine', spectrum.machineType);
                localStorage.setItem(QUICKSAVE_KEY + '-time', new Date().toLocaleString());
                showMessage('Quicksave (F5 to load)', 'success');
            } catch (err) {
                showMessage('Quicksave failed: ' + err.message, 'error');
            }
        }

        async function quickload() {
            try {
                const base64 = localStorage.getItem(QUICKSAVE_KEY);
                if (!base64) {
                    showMessage('No quicksave found (F2 to save)', 'warning');
                    return;
                }
                // Convert from base64
                const binary = atob(base64);
                const bytes = new Uint8Array(binary.length);
                for (let i = 0; i < binary.length; i++) {
                    bytes[i] = binary.charCodeAt(i);
                }
                const blob = new Blob([bytes], { type: 'application/octet-stream' });
                const file = new File([blob], 'quicksave.szx');
                const result = await spectrum.loadFile(file);
                handleLoadResult(result, 'Quicksave');
                updateCanvasSize();
                showMessage('Quickload successful');
            } catch (err) {
                showMessage('Quickload failed: ' + err.message, 'error');
            }
        }

        document.addEventListener('keydown', (e) => {
            // F2 = Quicksave, F5 = Quickload (spaced apart to avoid mistakes)
            // Ctrl+F5 is allowed through for hard refresh
            if (e.key === 'F2' && !e.ctrlKey) {
                e.preventDefault();
                quicksave();
            } else if (e.key === 'F5' && !e.ctrlKey) {
                e.preventDefault(); // Prevent browser refresh
                quickload();
            }
        });

        // Restore fullscreen setting
        const savedFullscreenMode = localStorage.getItem('zx-fullscreen-mode');
        if (savedFullscreenMode) {
            fullscreenMode.value = savedFullscreenMode;
        }

        // Restore audio settings from localStorage
        const savedSoundEnabled = localStorage.getItem('zx-sound-enabled') === 'true';
        const savedAY48k = localStorage.getItem('zx-ay-48k') === 'true';
        const savedVolume = localStorage.getItem('zx-volume');
        const savedStereoMode = localStorage.getItem('zx-stereo-mode');

        chkSound.checked = savedSoundEnabled;
        chkAY48k.checked = savedAY48k;
        spectrum.ay48kEnabled = savedAY48k;
        updateSoundButtons(savedSoundEnabled);

        if (savedVolume !== null) {
            volumeSlider.value = savedVolume;
            volumeValue.textContent = savedVolume + '%';
        }
        if (savedStereoMode) {
            stereoMode.value = savedStereoMode;
            spectrum.ay.stereoMode = savedStereoMode;
            spectrum.ay.updateStereoPanning();
        }

        // Auto-initialize audio on first user interaction if sound is enabled
        if (savedSoundEnabled) {
            const initAudioOnce = async () => {
                await initAudioOnUserGesture();
                document.removeEventListener('click', initAudioOnce);
                document.removeEventListener('keydown', initAudioOnce);
            };
            document.addEventListener('click', initAudioOnce, { once: true });
            document.addEventListener('keydown', initAudioOnce, { once: true });
        }

        // Ensure audio context resumes on any user interaction (some browsers are strict)
        const resumeAudioContext = async () => {
            if (spectrum.audio && spectrum.audio.context &&
                spectrum.audio.context.state === 'suspended' && chkSound.checked) {
                try {
                    await spectrum.audio.context.resume();
                } catch (e) {
                    // Ignore errors
                }
            }
        };
        document.addEventListener('click', resumeAudioContext);
        document.addEventListener('keydown', resumeAudioContext);

        // Overlay mode dropdown
        const overlaySelect = document.getElementById('overlaySelect');
        spectrum.setOverlayMode(overlaySelect.value);  // Initialize from select default
        overlaySelect.addEventListener('change', () => {
            spectrum.setOverlayMode(overlaySelect.value);
            spectrum.redraw();
        });

        // Border size preset
        borderSizeSelect.addEventListener('change', () => {
            if (spectrum.ula.setBorderPreset(borderSizeSelect.value)) {
                spectrum.updateDisplayDimensions();
                updateCanvasSize();
                spectrum.redraw();
            }
            const option = borderSizeSelect.options[borderSizeSelect.selectedIndex];
            showMessage('Border: ' + option.text);
        });

        // Invert display handling
        const chkInvertDisplay = document.getElementById('chkInvertDisplay');

        function applyInvertDisplay(invert) {
            canvas.style.filter = invert ? 'invert(1)' : '';
            if (overlayCanvas) overlayCanvas.style.filter = invert ? 'invert(1)' : '';
        }

        // Restore saved invert setting
        const savedInvert = localStorage.getItem('zxm8_invert') === 'true';
        chkInvertDisplay.checked = savedInvert;
        applyInvertDisplay(savedInvert);

        chkInvertDisplay.addEventListener('change', () => {
            applyInvertDisplay(chkInvertDisplay.checked);
            localStorage.setItem('zxm8_invert', chkInvertDisplay.checked);
            showMessage(chkInvertDisplay.checked ? 'Display inverted' : 'Display normal');
        });

        // Late timing checkbox (default: false - early ULA behavior)
        const chkLateTimings = document.getElementById('chkLateTimings');
        const savedLateTimings = localStorage.getItem('zxm8_lateTiming') === 'true';  // Default false
        chkLateTimings.checked = savedLateTimings;
        spectrum.setLateTimings(savedLateTimings);

        chkLateTimings.addEventListener('change', () => {
            spectrum.setLateTimings(chkLateTimings.checked);
            localStorage.setItem('zxm8_lateTiming', chkLateTimings.checked);
            showMessage(chkLateTimings.checked ? 'Late timings enabled' : 'Early timings enabled');
        });

        // ULAplus handling
        const chkULAplus = document.getElementById('chkULAplus');
        const ulaplusStatus = document.getElementById('ulaplusStatus');
        const ulaplusPalettePreview = document.getElementById('ulaplusPalettePreview');
        const ulaplusPaletteGrid = document.getElementById('ulaplusPaletteGrid');

        // Initialize ULAplus palette grid (4 rows x 16 colors)
        for (let i = 0; i < 64; i++) {
            const cell = document.createElement('div');
            cell.className = 'ulaplus-palette-cell';
            cell.dataset.index = i;
            ulaplusPaletteGrid.appendChild(cell);
        }

        function updateULAplusStatus() {
            const ula = spectrum.ula;
            if (!ula.ulaplus.enabled) {
                ulaplusStatus.textContent = '';
                ulaplusPalettePreview.classList.add('hidden');
            } else if (ula.ulaplus.paletteEnabled) {
                ulaplusStatus.textContent = '(palette active)';
                ulaplusPalettePreview.classList.remove('hidden');
                updateULAplusPalettePreview();
            } else {
                ulaplusStatus.textContent = '(hardware present)';
                ulaplusPalettePreview.classList.add('hidden');
            }
        }

        function updateULAplusPalettePreview() {
            const palette = spectrum.ula.ulaplus.palette;
            const cells = ulaplusPaletteGrid.children;
            for (let i = 0; i < 64; i++) {
                const grb = palette[i];
                // Convert GRB 332 to RGB
                const g3 = (grb >> 5) & 0x07;
                const r3 = (grb >> 2) & 0x07;
                const b2 = grb & 0x03;
                const r = (r3 << 5) | (r3 << 2) | (r3 >> 1);
                const g = (g3 << 5) | (g3 << 2) | (g3 >> 1);
                const b = (b2 << 6) | (b2 << 4) | (b2 << 2) | b2;
                cells[i].style.backgroundColor = `rgb(${r},${g},${b})`;
            }
        }

        const savedULAplus = localStorage.getItem('zxm8_ulaplus') === 'true';
        chkULAplus.checked = savedULAplus;
        spectrum.ula.ulaplus.enabled = savedULAplus;
        updateULAplusStatus();

        chkULAplus.addEventListener('change', () => {
            spectrum.ula.ulaplus.enabled = chkULAplus.checked;
            localStorage.setItem('zxm8_ulaplus', chkULAplus.checked);
            // Don't reset palette when toggling - preserve game's palette data
            updateULAplusStatus();
            spectrum.redraw(); // Immediately apply palette change
            showMessage(chkULAplus.checked ? 'ULA+ enabled' : 'ULA+ disabled');
        });

        // Reset ULAplus palette to defaults
        document.getElementById('btnResetULAplus').addEventListener('click', () => {
            spectrum.ula.resetULAplus();
            updateULAplusStatus();
            spectrum.redraw();
            showMessage('ULAplus palette reset');
        });

        // Update ULAplus status periodically when palette is active
        setInterval(() => {
            if (spectrum.ula.ulaplus.enabled && spectrum.ula.ulaplus.paletteEnabled) {
                updateULAplusStatus();
            }
        }, 500);

        // Palette handling
        const paletteSelect = document.getElementById('paletteSelect');
        const palettePreview = document.getElementById('palettePreview');
        let loadedPalettes = null;

        async function loadPalettes() {
            try {
                const response = await fetch('palettes.json');
                const data = await response.json();
                loadedPalettes = data.palettes;

                // Populate dropdown
                paletteSelect.innerHTML = '';
                loadedPalettes.forEach(palette => {
                    const option = document.createElement('option');
                    option.value = palette.id;
                    option.textContent = palette.name;
                    paletteSelect.appendChild(option);
                });

                // Apply saved palette or default
                const savedPalette = localStorage.getItem('zxm8_palette') || 'default';
                paletteSelect.value = savedPalette;
                applyPalette(savedPalette);
            } catch (e) {
                console.error('Failed to load palettes:', e);
            }
        }

        function applyPalette(paletteId) {
            if (!loadedPalettes) return;

            const palette = loadedPalettes.find(p => p.id === paletteId);
            if (!palette) return;

            // Update ULA palette
            if (spectrum.ula) {
                spectrum.ula.palette = palette.colors.map(hex => {
                    const r = parseInt(hex.slice(1, 3), 16);
                    const g = parseInt(hex.slice(3, 5), 16);
                    const b = parseInt(hex.slice(5, 7), 16);
                    return [r, g, b, 255]; // [R, G, B, A] array format
                });
                spectrum.ula.updatePalette32(); // Recalculate 32-bit palette for rendering
                spectrum.redraw();
            }

            // Update preview
            updatePalettePreview(palette.colors);
        }

        function updatePalettePreview(colors) {
            const colorElements = palettePreview.querySelectorAll('.palette-color');
            colorElements.forEach(el => {
                const index = parseInt(el.dataset.index);
                const isBright = el.dataset.bright === 'true';
                const colorIndex = isBright ? index + 8 : index;
                if (colors[colorIndex]) {
                    el.style.backgroundColor = colors[colorIndex];
                    el.title = `${index}: ${colors[colorIndex]}`;
                }
            });
        }

        paletteSelect.addEventListener('change', () => {
            applyPalette(paletteSelect.value);
            localStorage.setItem('zxm8_palette', paletteSelect.value);
            showMessage(`Palette: ${paletteSelect.options[paletteSelect.selectedIndex].text}`);
        });

        // Load palettes on startup
        loadPalettes();

        // ========== Frame Export ==========
        const frameGrabState = {
            active: false,
            frames: [],
            wasRunning: false,
            startTime: 0
        };
        const frameGrabStatus = document.getElementById('frameGrabStatus');
        const btnFrameGrabStart = document.getElementById('btnFrameGrabStart');
        const btnFrameGrabStop = document.getElementById('btnFrameGrabStop');
        const btnFrameGrabCancel = document.getElementById('btnFrameGrabCancel');
        const frameExportFormat = document.getElementById('frameExportFormat');
        const frameExportSize = document.getElementById('frameExportSize');
        const spriteRegionRow = document.getElementById('spriteRegionRow');
        const sizeRow = document.getElementById('sizeRow');

        // Track last sprite mode for value conversion
        let lastSpriteMode = null;

        // Show/hide size row based on format selection (SCR/BSC/SCA have fixed sizes)
        function updateSizeRowVisibility() {
            const format = frameExportFormat.value;
            const scaOptionsRow = document.getElementById('scaOptionsRow');
            const scaCustomPatternRow = document.getElementById('scaCustomPatternRow');

            if (format === 'scr' || format === 'sca') {
                // SCR/SCA requires screen only (256x192)
                sizeRow.style.display = 'none';
                frameExportSize.value = 'screen';
                spriteRegionRow.style.display = 'none';
                clearSpriteRegionPreview();
                // Show SCA options only for SCA format
                scaOptionsRow.style.display = format === 'sca' ? 'flex' : 'none';
                if (format !== 'sca') {
                    scaCustomPatternRow.style.display = 'none';
                }
            } else if (format === 'bsc') {
                // BSC requires full border
                sizeRow.style.display = 'none';
                frameExportSize.value = 'full';
                spriteRegionRow.style.display = 'none';
                clearSpriteRegionPreview();
                scaOptionsRow.style.display = 'none';
                scaCustomPatternRow.style.display = 'none';
            } else {
                sizeRow.style.display = 'flex';
                scaOptionsRow.style.display = 'none';
                scaCustomPatternRow.style.display = 'none';
            }
            updateScaOptionsVisibility();
        }

        // Show/hide SCA payload-specific options
        function updateScaOptionsVisibility() {
            const scaOptionsRow = document.getElementById('scaOptionsRow');
            const scaCustomPatternRow = document.getElementById('scaCustomPatternRow');
            const scaPayloadType = document.getElementById('scaPayloadType');
            const scaFillPattern = document.getElementById('scaFillPattern');

            if (scaOptionsRow.style.display === 'none') return;

            const isType1 = scaPayloadType.value === '1';
            // Show fill pattern options only for type 1
            scaFillPattern.disabled = !isType1;
            scaCustomPatternRow.style.display = (isType1 && scaFillPattern.value === 'custom') ? 'flex' : 'none';
        }

        frameExportFormat.addEventListener('change', updateSizeRowVisibility);
        document.getElementById('scaPayloadType').addEventListener('change', updateScaOptionsVisibility);
        document.getElementById('scaFillPattern').addEventListener('change', updateScaOptionsVisibility);

        // Show/hide sprite region inputs and update labels based on size selection
        frameExportSize.addEventListener('change', () => {
            const sizeMode = frameExportSize.value;
            const isSprite = sizeMode.startsWith('sprite-');
            const isPixels = sizeMode === 'sprite-pixels';

            spriteRegionRow.style.display = isSprite ? 'flex' : 'none';

            if (isSprite) {
                const spriteXEl = document.getElementById('spriteX');
                const spriteYEl = document.getElementById('spriteY');
                const spriteWEl = document.getElementById('spriteW');
                const spriteHEl = document.getElementById('spriteH');

                // Update labels
                document.getElementById('spriteLabelX').textContent = isPixels ? 'X:' : 'Col:';
                document.getElementById('spriteLabelY').textContent = isPixels ? 'Y:' : 'Row:';

                // Convert values if switching between pixel and cell modes
                if (lastSpriteMode !== sizeMode) {
                    if (isPixels) {
                        if (lastSpriteMode) {
                            // Converting from cells to pixels
                            spriteXEl.value = Math.min(255, parseInt(spriteXEl.value) * 8);
                            spriteYEl.value = Math.min(191, parseInt(spriteYEl.value) * 8);
                            spriteWEl.value = Math.min(256, parseInt(spriteWEl.value) * 8);
                            spriteHEl.value = Math.min(192, parseInt(spriteHEl.value) * 8);
                        }
                        // else: first time pixels - keep HTML defaults (0, 0, 16, 16)
                    } else {
                        // Converting to cells (from pixels or first time)
                        spriteXEl.value = Math.min(31, Math.floor(parseInt(spriteXEl.value) / 8));
                        spriteYEl.value = Math.min(23, Math.floor(parseInt(spriteYEl.value) / 8));
                        spriteWEl.value = Math.max(1, Math.min(32, Math.ceil(parseInt(spriteWEl.value) / 8)));
                        spriteHEl.value = Math.max(1, Math.min(24, Math.ceil(parseInt(spriteHEl.value) / 8)));
                    }
                }

                // Update max values
                if (isPixels) {
                    spriteXEl.max = 255; spriteYEl.max = 191; spriteWEl.max = 256; spriteHEl.max = 192;
                } else {
                    spriteXEl.max = 31; spriteYEl.max = 23; spriteWEl.max = 32; spriteHEl.max = 24;
                }

                lastSpriteMode = sizeMode;
                updateSpriteRegionPreview();
            } else {
                clearSpriteRegionPreview();
            }
        });

        // Sprite region preview using CSS-positioned div (not canvas, which gets cleared by spectrum)
        const spriteOverlay = document.getElementById('spriteRegionOverlay');

        function updateSpriteRegionPreview() {
            if (frameGrabState.active) {
                spriteOverlay.style.display = 'none';
                return;
            }

            const sizeMode = frameExportSize.value;
            if (!sizeMode.startsWith('sprite-')) {
                spriteOverlay.style.display = 'none';
                return;
            }

            const isPixels = sizeMode === 'sprite-pixels';
            const multiplier = isPixels ? 1 : 8;

            let spriteX = (parseInt(document.getElementById('spriteX').value) || 0) * multiplier;
            let spriteY = (parseInt(document.getElementById('spriteY').value) || 0) * multiplier;
            let spriteW = (parseInt(document.getElementById('spriteW').value) || (isPixels ? 16 : 2)) * multiplier;
            let spriteH = (parseInt(document.getElementById('spriteH').value) || (isPixels ? 16 : 2)) * multiplier;

            // Clamp to screen bounds
            spriteX = Math.max(0, Math.min(255, spriteX));
            spriteY = Math.max(0, Math.min(191, spriteY));
            spriteW = Math.max(1, spriteW);
            spriteH = Math.max(1, spriteH);
            if (spriteX + spriteW > 256) spriteW = 256 - spriteX;
            if (spriteY + spriteH > 192) spriteH = 192 - spriteY;

            // Get screen dimensions - use defaults if ULA not ready
            let borderLeft = 32, borderTop = 24, screenWidth = 320;
            if (spectrum && spectrum.ula) {
                const dims = spectrum.ula.getDimensions();
                borderLeft = dims.borderLeft;
                borderTop = dims.borderTop;
                screenWidth = dims.width;
            }

            // Get zoom from screen canvas style
            const screenCanvas = document.getElementById('screen');
            const styleWidth = parseFloat(screenCanvas.style.width) || screenCanvas.width;
            const zoom = styleWidth / screenCanvas.width || 1;

            // Calculate pixel position (accounting for border and zoom)
            const x = (borderLeft + spriteX) * zoom;
            const y = (borderTop + spriteY) * zoom;
            const w = spriteW * zoom;
            const h = spriteH * zoom;

            // Position the overlay div
            spriteOverlay.style.left = x + 'px';
            spriteOverlay.style.top = y + 'px';
            spriteOverlay.style.width = w + 'px';
            spriteOverlay.style.height = h + 'px';
            spriteOverlay.style.display = 'block';
        }

        function clearSpriteRegionPreview() {
            spriteOverlay.style.display = 'none';
        }

        // Update preview when sprite inputs change
        ['spriteX', 'spriteY', 'spriteW', 'spriteH'].forEach(id => {
            document.getElementById(id).addEventListener('input', updateSpriteRegionPreview);
        });

        function updateFrameGrabStatus() {
            if (!frameGrabState.active) {
                frameGrabStatus.textContent = '';
                frameGrabStatus.classList.remove('recording');
                return;
            }
            const frameCount = frameGrabState.frames.length;
            const duration = (frameCount / 50).toFixed(2);
            frameGrabStatus.textContent = `Recording: ${frameCount} frames (${duration}s)`;
            frameGrabStatus.classList.add('recording');
        }

        function captureFrame() {
            if (!frameGrabState.active) return;

            const sizeMode = frameExportSize.value;
            const dims = spectrum.ula.getDimensions();

            let sx, sy, sw, sh;
            if (sizeMode === 'screen') {
                // Screen only: 256x192, centered
                sx = dims.borderLeft;
                sy = dims.borderTop;
                sw = 256;
                sh = 192;
            } else if (sizeMode === 'normal') {
                // Normal border (32px each side)
                sx = Math.max(0, dims.borderLeft - 32);
                sy = Math.max(0, dims.borderTop - 32);
                sw = 256 + 64;
                sh = 192 + 64;
            } else if (sizeMode.startsWith('sprite-')) {
                // Custom sprite region (relative to screen area)
                const isPixels = sizeMode === 'sprite-pixels';
                const multiplier = isPixels ? 1 : 8;

                // Get input values, default to valid ranges
                let spriteX = parseInt(document.getElementById('spriteX').value) || 0;
                let spriteY = parseInt(document.getElementById('spriteY').value) || 0;
                let spriteW = parseInt(document.getElementById('spriteW').value) || (isPixels ? 16 : 2);
                let spriteH = parseInt(document.getElementById('spriteH').value) || (isPixels ? 16 : 2);

                // Convert to pixels
                spriteX *= multiplier;
                spriteY *= multiplier;
                spriteW *= multiplier;
                spriteH *= multiplier;

                // Clamp position to screen bounds (0-255, 0-191)
                spriteX = Math.max(0, Math.min(255, spriteX));
                spriteY = Math.max(0, Math.min(191, spriteY));

                // Ensure width/height are at least 1 pixel
                spriteW = Math.max(1, spriteW);
                spriteH = Math.max(1, spriteH);

                // Clamp width/height to not exceed screen bounds
                if (spriteX + spriteW > 256) spriteW = 256 - spriteX;
                if (spriteY + spriteH > 192) spriteH = 192 - spriteY;

                sx = dims.borderLeft + spriteX;
                sy = dims.borderTop + spriteY;
                sw = spriteW;
                sh = spriteH;
            } else {
                // Full border
                sx = 0;
                sy = 0;
                sw = dims.width;
                sh = dims.height;
            }

            // Create a temporary canvas to capture the frame region
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = sw;
            tempCanvas.height = sh;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(canvas, sx, sy, sw, sh, 0, 0, sw, sh);

            // Store as data URL (PNG) + memory snapshots for SCA export
            const attrs = spectrum ? spectrum.memory.getBlock(0x5800, 768) : new Uint8Array(768);
            const bitmap = spectrum ? spectrum.memory.getBlock(0x4000, 6144) : new Uint8Array(6144);
            frameGrabState.frames.push({
                dataUrl: tempCanvas.toDataURL('image/png'),
                width: sw,
                height: sh,
                attrs: new Uint8Array(attrs),
                bitmap: new Uint8Array(bitmap)
            });

            updateFrameGrabStatus();

            // Check max frames limit
            const maxFrames = parseInt(document.getElementById('maxFrames').value) || 0;
            if (maxFrames > 0 && frameGrabState.frames.length >= maxFrames) {
                stopFrameGrab(false);
            }
        }

        function startFrameGrab() {
            frameGrabState.wasRunning = spectrum.isRunning();
            frameGrabState.active = true;
            frameGrabState.frames = [];
            frameGrabState.startTime = Date.now();

            // Clear sprite region preview during recording
            clearSpriteRegionPreview();

            // Set up frame callback
            spectrum.onFrame = () => {
                captureFrame();
            };

            // Start emulator if not running
            if (!frameGrabState.wasRunning) {
                spectrum.start();
            }

            // Update UI
            btnFrameGrabStart.disabled = true;
            btnFrameGrabStop.disabled = false;
            btnFrameGrabCancel.disabled = false;
            frameExportFormat.disabled = true;
            frameExportSize.disabled = true;
            document.getElementById('spriteX').disabled = true;
            document.getElementById('spriteY').disabled = true;
            document.getElementById('spriteW').disabled = true;
            document.getElementById('spriteH').disabled = true;
            document.getElementById('maxFrames').disabled = true;

            updateFrameGrabStatus();
            showMessage('Recording frames...');
        }

        function stopFrameGrab(cancel = false) {
            frameGrabState.active = false;
            spectrum.onFrame = null;

            // Stop emulator if it was paused before
            if (!frameGrabState.wasRunning) {
                spectrum.stop();
            }

            // Update UI
            btnFrameGrabStart.disabled = false;
            btnFrameGrabStop.disabled = true;
            btnFrameGrabCancel.disabled = true;
            frameExportFormat.disabled = false;
            frameExportSize.disabled = false;
            document.getElementById('spriteX').disabled = false;
            document.getElementById('spriteY').disabled = false;
            document.getElementById('spriteW').disabled = false;
            document.getElementById('spriteH').disabled = false;
            document.getElementById('maxFrames').disabled = false;

            // Restore sprite region preview if in sprite mode
            updateSpriteRegionPreview();

            if (cancel) {
                frameGrabState.frames = [];
                frameGrabStatus.textContent = 'Recording cancelled';
                frameGrabStatus.classList.remove('recording');
                showMessage('Frame recording cancelled');
                return;
            }

            // Export frames
            const frameCount = frameGrabState.frames.length;
            if (frameCount === 0) {
                frameGrabStatus.textContent = 'No frames captured';
                showMessage('No frames captured', 'error');
                return;
            }

            const format = frameExportFormat.value;
            const duration = (frameCount / 50).toFixed(2);
            frameGrabStatus.textContent = `Exporting ${frameCount} frames...`;

            if (format === 'zip') {
                exportFramesAsZip();
            } else if (format === 'scr') {
                exportFramesAsScr('scr');
            } else if (format === 'bsc') {
                exportFramesAsScr('bsc');
            } else if (format === 'sca') {
                exportFramesAsSca();
            } else {
                exportFramesAsGif();
            }
        }

        // Get base name for exports from loaded filename (prefer disk, fallback to tape)
        function getExportBaseName() {
            const diskInfoLed = document.getElementById('diskInfoLed');
            const tapeLed = document.getElementById('tapeLed');
            const diskName = diskInfoLed ? diskInfoLed.title.trim() : '';
            const tapeName = tapeLed ? tapeLed.title.trim() : '';
            // Use disk name if available, then tape name, otherwise 'frame'
            return diskName || tapeName || 'frame';
        }

        async function exportFramesAsZip() {
            const frames = frameGrabState.frames;
            const baseName = getExportBaseName();

            // Single frame - save as single PNG file, not ZIP
            if (frames.length === 1) {
                const frame = frames[0];
                const base64 = frame.dataUrl.split(',')[1];
                const binary = atob(base64);
                const bytes = new Uint8Array(binary.length);
                for (let j = 0; j < binary.length; j++) {
                    bytes[j] = binary.charCodeAt(j);
                }
                const blob = new Blob([bytes], { type: 'image/png' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${baseName}_0000.png`;
                a.click();
                URL.revokeObjectURL(url);
                frameGrabStatus.textContent = `Exported 1 frame as PNG`;
                frameGrabStatus.classList.remove('recording');
                showMessage(`Exported ${baseName}_0000.png`);
                frameGrabState.frames = [];
                return;
            }

            // Multiple frames - create ZIP
            const files = [];
            for (let i = 0; i < frames.length; i++) {
                const frame = frames[i];
                const filename = `${baseName}_${String(i).padStart(4, '0')}.png`;

                // Convert data URL to binary
                const base64 = frame.dataUrl.split(',')[1];
                const binary = atob(base64);
                const bytes = new Uint8Array(binary.length);
                for (let j = 0; j < binary.length; j++) {
                    bytes[j] = binary.charCodeAt(j);
                }

                files.push({ name: filename, data: bytes });
            }

            // Create ZIP using simple store method (no compression for PNGs - already compressed)
            const zipData = createZip(files);

            // Download
            const blob = new Blob([zipData], { type: 'application/zip' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${baseName}.zip`;
            a.click();
            URL.revokeObjectURL(url);

            frameGrabStatus.textContent = `Exported ${frames.length} frames to ZIP`;
            frameGrabStatus.classList.remove('recording');
            showMessage(`Exported ${frames.length} frames to ${baseName}.zip`);
            frameGrabState.frames = [];
        }

        function createZip(files) {
            // Simple ZIP file creator (store method, no compression)
            const localHeaders = [];
            const centralHeaders = [];
            let offset = 0;

            for (const file of files) {
                const nameBytes = new TextEncoder().encode(file.name);
                const data = file.data;

                // CRC32
                const crc = crc32(data);

                // Local file header
                const localHeader = new Uint8Array(30 + nameBytes.length);
                const lv = new DataView(localHeader.buffer);
                lv.setUint32(0, 0x04034b50, true);  // Local file header signature
                lv.setUint16(4, 20, true);          // Version needed
                lv.setUint16(6, 0, true);           // General purpose flag
                lv.setUint16(8, 0, true);           // Compression: store
                lv.setUint16(10, 0, true);          // Mod time
                lv.setUint16(12, 0, true);          // Mod date
                lv.setUint32(14, crc, true);        // CRC32
                lv.setUint32(18, data.length, true);// Compressed size
                lv.setUint32(22, data.length, true);// Uncompressed size
                lv.setUint16(26, nameBytes.length, true); // Filename length
                lv.setUint16(28, 0, true);          // Extra field length
                localHeader.set(nameBytes, 30);

                // Central directory header
                const centralHeader = new Uint8Array(46 + nameBytes.length);
                const cv = new DataView(centralHeader.buffer);
                cv.setUint32(0, 0x02014b50, true);  // Central file header signature
                cv.setUint16(4, 20, true);          // Version made by
                cv.setUint16(6, 20, true);          // Version needed
                cv.setUint16(8, 0, true);           // General purpose flag
                cv.setUint16(10, 0, true);          // Compression: store
                cv.setUint16(12, 0, true);          // Mod time
                cv.setUint16(14, 0, true);          // Mod date
                cv.setUint32(16, crc, true);        // CRC32
                cv.setUint32(20, data.length, true);// Compressed size
                cv.setUint32(24, data.length, true);// Uncompressed size
                cv.setUint16(28, nameBytes.length, true); // Filename length
                cv.setUint16(30, 0, true);          // Extra field length
                cv.setUint16(32, 0, true);          // Comment length
                cv.setUint16(34, 0, true);          // Disk number start
                cv.setUint16(36, 0, true);          // Internal attributes
                cv.setUint32(38, 0, true);          // External attributes
                cv.setUint32(42, offset, true);     // Relative offset
                centralHeader.set(nameBytes, 46);

                localHeaders.push({ header: localHeader, data: data });
                centralHeaders.push(centralHeader);
                offset += localHeader.length + data.length;
            }

            // End of central directory record
            const centralDirOffset = offset;
            let centralDirSize = 0;
            for (const ch of centralHeaders) {
                centralDirSize += ch.length;
            }

            const endRecord = new Uint8Array(22);
            const ev = new DataView(endRecord.buffer);
            ev.setUint32(0, 0x06054b50, true);      // End signature
            ev.setUint16(4, 0, true);               // Disk number
            ev.setUint16(6, 0, true);               // Start disk
            ev.setUint16(8, files.length, true);    // Entries on disk
            ev.setUint16(10, files.length, true);   // Total entries
            ev.setUint32(12, centralDirSize, true); // Central dir size
            ev.setUint32(16, centralDirOffset, true); // Central dir offset
            ev.setUint16(20, 0, true);              // Comment length

            // Combine all parts
            const totalSize = offset + centralDirSize + 22;
            const result = new Uint8Array(totalSize);
            let pos = 0;

            for (const lh of localHeaders) {
                result.set(lh.header, pos);
                pos += lh.header.length;
                result.set(lh.data, pos);
                pos += lh.data.length;
            }
            for (const ch of centralHeaders) {
                result.set(ch, pos);
                pos += ch.length;
            }
            result.set(endRecord, pos);

            return result;
        }

        function crc32(data) {
            let crc = 0xFFFFFFFF;
            const table = crc32.table || (crc32.table = (() => {
                const t = new Uint32Array(256);
                for (let i = 0; i < 256; i++) {
                    let c = i;
                    for (let j = 0; j < 8; j++) {
                        c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
                    }
                    t[i] = c;
                }
                return t;
            })());

            for (let i = 0; i < data.length; i++) {
                crc = table[(crc ^ data[i]) & 0xFF] ^ (crc >>> 8);
            }
            return (crc ^ 0xFFFFFFFF) >>> 0;
        }

        // ZX Spectrum standard palette (RGB values)
        const zxPalette = [
            [0, 0, 0],       // 0: black
            [0, 0, 215],     // 1: blue
            [215, 0, 0],     // 2: red
            [215, 0, 215],   // 3: magenta
            [0, 215, 0],     // 4: green
            [0, 215, 215],   // 5: cyan
            [215, 215, 0],   // 6: yellow
            [215, 215, 215], // 7: white
            [0, 0, 0],       // 8: black (bright)
            [0, 0, 255],     // 9: blue (bright)
            [255, 0, 0],     // 10: red (bright)
            [255, 0, 255],   // 11: magenta (bright)
            [0, 255, 0],     // 12: green (bright)
            [0, 255, 255],   // 13: cyan (bright)
            [255, 255, 0],   // 14: yellow (bright)
            [255, 255, 255]  // 15: white (bright)
        ];

        function rgbToZxColor(r, g, b) {
            // Find closest ZX Spectrum color
            let bestIdx = 0;
            let bestDist = Infinity;
            for (let i = 0; i < 16; i++) {
                const dr = r - zxPalette[i][0];
                const dg = g - zxPalette[i][1];
                const db = b - zxPalette[i][2];
                const dist = dr*dr + dg*dg + db*db;
                if (dist < bestDist) {
                    bestDist = dist;
                    bestIdx = i;
                }
            }
            return bestIdx;
        }

        function imageDataToScr(pixels, srcWidth, screenLeft, screenTop) {
            // Convert image to SCR format (6912 bytes)
            // SCR = 6144 bytes bitmap + 768 bytes attributes
            const scr = new Uint8Array(6912);

            // Process each 8x8 character cell
            for (let charY = 0; charY < 24; charY++) {
                for (let charX = 0; charX < 32; charX++) {
                    // Count colors in this cell
                    const colorCounts = new Map();

                    for (let py = 0; py < 8; py++) {
                        for (let px = 0; px < 8; px++) {
                            const sx = screenLeft + charX * 8 + px;
                            const sy = screenTop + charY * 8 + py;
                            const idx = (sy * srcWidth + sx) * 4;
                            const zxColor = rgbToZxColor(pixels[idx], pixels[idx+1], pixels[idx+2]);
                            colorCounts.set(zxColor, (colorCounts.get(zxColor) || 0) + 1);
                        }
                    }

                    // Find two most common colors
                    const sorted = [...colorCounts.entries()].sort((a, b) => b[1] - a[1]);
                    let ink = sorted[0] ? sorted[0][0] : 0;
                    let paper = sorted[1] ? sorted[1][0] : 7;

                    // Determine brightness (both colors should match)
                    const inkBright = ink >= 8;
                    const paperBright = paper >= 8;
                    const bright = inkBright || paperBright;

                    // Convert to base color (0-7)
                    ink = ink % 8;
                    paper = paper % 8;

                    // Make sure paper is different from ink
                    if (paper === ink) {
                        paper = (ink === 7) ? 0 : 7;
                    }

                    // Build attribute byte
                    const attr = (bright ? 0x40 : 0) | (paper << 3) | ink;
                    scr[6144 + charY * 32 + charX] = attr;

                    // Build bitmap for this cell
                    for (let py = 0; py < 8; py++) {
                        let byte = 0;
                        for (let px = 0; px < 8; px++) {
                            const sx = screenLeft + charX * 8 + px;
                            const sy = screenTop + charY * 8 + py;
                            const idx = (sy * srcWidth + sx) * 4;
                            const zxColor = rgbToZxColor(pixels[idx], pixels[idx+1], pixels[idx+2]) % 8;

                            // Pixel is set if closer to ink than paper
                            const inkDist = Math.abs(zxColor - ink);
                            const paperDist = Math.abs(zxColor - paper);
                            if (inkDist <= paperDist) {
                                byte |= (0x80 >> px);
                            }
                        }

                        // Calculate screen address (ZX Spectrum weird layout)
                        const third = Math.floor(charY / 8);
                        const charRow = charY % 8;
                        const addr = third * 2048 + py * 256 + charRow * 32 + charX;
                        scr[addr] = byte;
                    }
                }
            }

            return scr;
        }

        // BSC format constants
        const BSC_FORMAT = {
            TOTAL_SIZE: 11136,        // 6912 + 4224
            BORDER_OFFSET: 6912,
            BORDER_SIZE: 4224,
            BYTES_PER_FULL_LINE: 24,  // Top/bottom: 24 bytes per line (384px / 16px per byte)
            BYTES_PER_SIDE_LINE: 8,   // Side: 8 bytes per line (4 left + 4 right)
            FRAME_WIDTH: 384,
            FRAME_HEIGHT: 304,
            BORDER_LEFT_PX: 64,
            BORDER_TOP_LINES: 64,
            BORDER_BOTTOM_LINES: 48,
            SCREEN_LINES: 192
        };

        function extractBscBorder(pixels, srcWidth, srcHeight, screenLeft, screenTop) {
            // BSC border format:
            // - Top border: 64 lines × 24 bytes = 1536 bytes
            // - Side borders: 192 lines × 8 bytes = 1536 bytes (4 left + 4 right)
            // - Bottom border: 48 lines × 24 bytes = 1152 bytes
            // Each byte: bits 2-0 = first color (8px), bits 5-3 = second color (8px)
            const borderData = new Uint8Array(BSC_FORMAT.BORDER_SIZE);
            let offset = 0;

            // Helper: sample color at pixel position (clamped to frame bounds)
            const getColor = (x, y) => {
                x = Math.max(0, Math.min(srcWidth - 1, Math.floor(x)));
                y = Math.max(0, Math.min(srcHeight - 1, Math.floor(y)));
                const idx = (y * srcWidth + x) * 4;
                return rgbToZxColor(pixels[idx], pixels[idx+1], pixels[idx+2]) % 8;
            };

            // Helper: pack two 3-bit colors into one byte
            const packColors = (c1, c2) => (c1 & 7) | ((c2 & 7) << 3);

            // Calculate border sizes in captured frame
            const srcScreenRight = screenLeft + 256;
            const srcScreenBottom = screenTop + 192;
            const srcRightBorder = srcWidth - srcScreenRight;
            const srcBottomBorder = srcHeight - srcScreenBottom;

            // Top border: 64 lines × 24 bytes (384px width)
            // Map 64 BSC lines to srcTop lines of captured frame
            for (let line = 0; line < BSC_FORMAT.BORDER_TOP_LINES; line++) {
                const srcY = screenTop > 0 ? (line * screenTop / BSC_FORMAT.BORDER_TOP_LINES) : 0;
                for (let col = 0; col < BSC_FORMAT.BYTES_PER_FULL_LINE; col++) {
                    // Each byte covers 16 pixels (2 colors × 8 pixels)
                    // Map 384px BSC width to srcWidth
                    const bscX1 = col * 16;
                    const bscX2 = col * 16 + 8;
                    const srcX1 = bscX1 * srcWidth / BSC_FORMAT.FRAME_WIDTH;
                    const srcX2 = bscX2 * srcWidth / BSC_FORMAT.FRAME_WIDTH;
                    const c1 = getColor(srcX1, srcY);
                    const c2 = getColor(srcX2, srcY);
                    borderData[offset++] = packColors(c1, c2);
                }
            }

            // Side borders: 192 lines × 8 bytes (4 left + 4 right)
            for (let line = 0; line < BSC_FORMAT.SCREEN_LINES; line++) {
                const srcY = screenTop + line;

                // Left side: 4 bytes = 64 BSC pixels
                for (let col = 0; col < 4; col++) {
                    const bscX1 = col * 16;
                    const bscX2 = col * 16 + 8;
                    // Map 64px BSC left border to screenLeft pixels
                    const srcX1 = screenLeft > 0 ? (bscX1 * screenLeft / 64) : 0;
                    const srcX2 = screenLeft > 0 ? (bscX2 * screenLeft / 64) : 0;
                    const c1 = getColor(srcX1, srcY);
                    const c2 = getColor(srcX2, srcY);
                    borderData[offset++] = packColors(c1, c2);
                }

                // Right side: 4 bytes = 64 BSC pixels
                for (let col = 0; col < 4; col++) {
                    const bscX1 = col * 16;
                    const bscX2 = col * 16 + 8;
                    // Map 64px BSC right border to srcRightBorder pixels
                    const srcX1 = srcScreenRight + (srcRightBorder > 0 ? (bscX1 * srcRightBorder / 64) : 0);
                    const srcX2 = srcScreenRight + (srcRightBorder > 0 ? (bscX2 * srcRightBorder / 64) : 0);
                    const c1 = getColor(srcX1, srcY);
                    const c2 = getColor(srcX2, srcY);
                    borderData[offset++] = packColors(c1, c2);
                }
            }

            // Bottom border: 48 lines × 24 bytes (384px width)
            for (let line = 0; line < BSC_FORMAT.BORDER_BOTTOM_LINES; line++) {
                const srcY = srcScreenBottom + (srcBottomBorder > 0 ? (line * srcBottomBorder / BSC_FORMAT.BORDER_BOTTOM_LINES) : 0);
                for (let col = 0; col < BSC_FORMAT.BYTES_PER_FULL_LINE; col++) {
                    const bscX1 = col * 16;
                    const bscX2 = col * 16 + 8;
                    const srcX1 = bscX1 * srcWidth / BSC_FORMAT.FRAME_WIDTH;
                    const srcX2 = bscX2 * srcWidth / BSC_FORMAT.FRAME_WIDTH;
                    const c1 = getColor(srcX1, srcY);
                    const c2 = getColor(srcX2, srcY);
                    borderData[offset++] = packColors(c1, c2);
                }
            }

            return borderData;
        }

        async function exportFramesAsScr(ext) {
            const frames = frameGrabState.frames;
            const baseName = getExportBaseName();
            const files = [];
            const isBsc = ext === 'bsc';

            // Get border dimensions for proper extraction
            let borderLeft = 0, borderTop = 0;
            if (spectrum && spectrum.ula) {
                const dims = spectrum.ula.getDimensions();
                borderLeft = dims.borderLeft;
                borderTop = dims.borderTop;
            }

            for (let i = 0; i < frames.length; i++) {
                const frame = frames[i];
                const filename = `${baseName}_${String(i).padStart(4, '0')}.${ext}`;

                // Convert data URL to image
                const img = new Image();
                img.src = frame.dataUrl;
                await new Promise(resolve => img.onload = resolve);

                // Get image data
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = frame.width;
                tempCanvas.height = frame.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(img, 0, 0);
                const imageData = tempCtx.getImageData(0, 0, frame.width, frame.height);
                const pixels = imageData.data;

                // Determine screen position within captured frame
                let scrLeft = 0, scrTop = 0;
                if (frame.width > 256) {
                    // Frame includes border - calculate screen position
                    // For full capture (dims.width × dims.height): screen at (borderLeft, borderTop)
                    // For normal capture (320 × 256): screen at (32, 32)
                    // For other sizes: calculate based on the border we have
                    const dims = spectrum && spectrum.ula ? spectrum.ula.getDimensions() : null;
                    if (dims && frame.width >= dims.width && frame.height >= dims.height) {
                        // Full or larger capture
                        scrLeft = borderLeft;
                        scrTop = borderTop;
                    } else if (frame.width === 320 && frame.height === 256) {
                        // Normal capture mode (32px borders)
                        scrLeft = 32;
                        scrTop = 32;
                    } else {
                        // Calculate proportionally from what we have
                        scrLeft = (frame.width - 256) / 2;
                        scrTop = (frame.height - 192) / 2;
                    }
                }

                // Convert to SCR format
                const scrData = imageDataToScr(pixels, frame.width, scrLeft, scrTop);

                if (isBsc) {
                    // BSC format: SCR (6912) + border data (4224 bytes)
                    // Full frame: 384x304, border color packed 2 per byte
                    const borderData = extractBscBorder(pixels, frame.width, frame.height, scrLeft, scrTop);
                    const bscData = new Uint8Array(BSC_FORMAT.TOTAL_SIZE);
                    bscData.set(scrData, 0);
                    bscData.set(borderData, BSC_FORMAT.BORDER_OFFSET);
                    files.push({ name: filename, data: bscData });
                } else {
                    files.push({ name: filename, data: scrData });
                }
            }

            const frameCount = frames.length;
            const duration = (frameCount / 50).toFixed(2);

            // Single frame - save as single file, not ZIP
            if (files.length === 1) {
                let fileData = files[0].data;
                let statusMsg = `Exported 1 ${ext.toUpperCase()} frame`;

                // For SCR format with ULAplus active and palette modified, use raw memory + palette
                if (!isBsc && spectrum.ula.ulaplus.enabled && spectrum.ula.ulaplus.paletteEnabled && spectrum.ula.ulaplus.paletteModified) {
                    const scrData = new Uint8Array(6912 + 64);
                    for (let i = 0; i < 6912; i++) {
                        scrData[i] = spectrum.memory.read(0x4000 + i);
                    }
                    scrData.set(spectrum.ula.ulaplus.palette, 6912);
                    fileData = scrData;
                    statusMsg = 'Exported SCR with ULAplus palette (6976 bytes)';
                }

                const blob = new Blob([fileData], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${baseName}_0000.${ext}`;
                a.click();
                URL.revokeObjectURL(url);
                frameGrabStatus.textContent = statusMsg;
                frameGrabStatus.classList.remove('recording');
                showMessage(statusMsg);
                return;
            }

            // Multiple frames - create ZIP
            const zipData = createZip(files);
            const blob = new Blob([zipData], { type: 'application/zip' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = `${baseName}_${ext}.zip`;
            a.click();

            URL.revokeObjectURL(url);

            frameGrabStatus.textContent = `Exported ${frameCount} ${ext.toUpperCase()} frames (${duration}s)`;
            frameGrabStatus.classList.remove('recording');
            showMessage(`Exported ${frameCount} frames to ${baseName}_${ext}.zip`);
        }

        // Detect if bitmap has a consistent 8-byte repeating pattern
        // Returns the pattern if found, null otherwise
        function detectBitmapPattern(bitmap) {
            if (!bitmap || bitmap.length < 6144) return null;

            // ZX Spectrum screen layout: 3 thirds, each 8 char rows
            // Within each third: interleaved by pixel row
            // For pattern detection, check if each 8x8 cell uses the same 8-byte pattern

            // Extract the pattern from first cell (top-left)
            const pattern = new Uint8Array(8);
            for (let row = 0; row < 8; row++) {
                // Address for pixel row 'row' of char cell (0,0)
                const addr = row * 256; // third 0, char row 0, pixel row 'row'
                pattern[row] = bitmap[addr];
            }

            // Check if this pattern repeats across all 32x24 cells
            let matches = 0;
            let mismatches = 0;
            for (let charY = 0; charY < 24; charY++) {
                const third = Math.floor(charY / 8);
                const charRow = charY % 8;
                for (let charX = 0; charX < 32; charX++) {
                    for (let row = 0; row < 8; row++) {
                        const addr = third * 2048 + row * 256 + charRow * 32 + charX;
                        if (bitmap[addr] === pattern[row]) {
                            matches++;
                        } else {
                            mismatches++;
                        }
                    }
                }
            }

            // Allow some tolerance (95% match)
            const total = matches + mismatches;
            if (matches / total >= 0.95) {
                return pattern;
            }
            return null;
        }

        // Show dialog to let user choose between 53c and 127c patterns
        function showPatternChoiceDialog() {
            return new Promise((resolve) => {
                const dialog = document.createElement('div');
                dialog.className = 'modal-overlay';
                dialog.innerHTML = `
                    <div class="modal-dialog" style="max-width: 320px;">
                        <div class="modal-header">
                            <span>Select Fill Pattern</span>
                            <button class="modal-close">&times;</button>
                        </div>
                        <div class="modal-body">
                            <p style="margin-bottom: 12px;">Could not detect a consistent bitmap pattern. Please select the fill pattern to use:</p>
                            <div style="display: flex; gap: 10px; justify-content: center;">
                                <button id="patternChoice53c" class="primary" style="padding: 8px 16px;">53c (AA 55)</button>
                                <button id="patternChoice127c" style="padding: 8px 16px;">127c (DD 77)</button>
                            </div>
                        </div>
                    </div>
                `;
                document.body.appendChild(dialog);

                const close = (result) => {
                    dialog.remove();
                    resolve(result);
                };

                dialog.querySelector('.modal-close').onclick = () => close(null);
                dialog.querySelector('#patternChoice53c').onclick = () => close('53c');
                dialog.querySelector('#patternChoice127c').onclick = () => close('127c');
                dialog.onclick = (e) => { if (e.target === dialog) close(null); };
            });
        }

        // SCA format: animation file with header + delay table + SCR frames
        // https://github.com/moroz1999/sca
        // Type 0: full 6912-byte SCR frames
        // Type 1: 8-byte fill pattern + 768-byte attributes per frame
        async function exportFramesAsSca() {
            const frames = frameGrabState.frames;
            const baseName = getExportBaseName();
            const frameCount = frames.length;

            // Get payload type and fill pattern from UI
            const payloadType = parseInt(document.getElementById('scaPayloadType').value);

            // Warning for Type 1 - feature under development
            if (payloadType === 1) {
                if (!confirm('SCA Type 1 export is experimental and under development.\nFormat may change in future versions.\n\nContinue with export?')) {
                    frameGrabStatus.textContent = 'Export cancelled';
                    frameGrabStatus.classList.remove('recording');
                    return;
                }
            }

            let fillPattern = new Uint8Array(8);
            if (payloadType === 1) {
                const patternSelect = document.getElementById('scaFillPattern').value;
                if (patternSelect === 'auto') {
                    // Try to detect pattern from first frame's bitmap
                    const detected = detectBitmapPattern(frames[0].bitmap);
                    if (detected) {
                        fillPattern = detected;
                        showMessage(`Detected pattern: ${Array.from(detected).map(b => b.toString(16).toUpperCase().padStart(2, '0')).join(' ')}`);
                    } else {
                        // Pattern not consistent - ask user
                        const choice = await showPatternChoiceDialog();
                        if (choice === null) {
                            frameGrabStatus.textContent = 'Export cancelled';
                            frameGrabStatus.classList.remove('recording');
                            return;
                        }
                        fillPattern = choice === '53c'
                            ? new Uint8Array([0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55])
                            : new Uint8Array([0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77]);
                    }
                } else if (patternSelect === '53c') {
                    fillPattern = new Uint8Array([0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55]);
                } else if (patternSelect === '127c') {
                    fillPattern = new Uint8Array([0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77]);
                } else if (patternSelect === 'v4x8') {
                    // Vertical 4x8+4x8: 4 columns ink, 4 columns paper
                    fillPattern = new Uint8Array([0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0]);
                } else if (patternSelect === 'h8x4') {
                    // Horizontal 8x4+8x4: 4 rows ink, 4 rows paper
                    fillPattern = new Uint8Array([0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00]);
                } else {
                    // Custom pattern - parse hex string
                    const customStr = document.getElementById('scaCustomPattern').value.trim();
                    const hexBytes = customStr.split(/[\s,]+/).map(h => parseInt(h, 16) || 0);
                    for (let i = 0; i < 8; i++) {
                        fillPattern[i] = hexBytes[i % hexBytes.length] || 0;
                    }
                }
            }

            // Get border dimensions for proper extraction
            let borderLeft = 0, borderTop = 0;
            if (spectrum && spectrum.ula) {
                const dims = spectrum.ula.getDimensions();
                borderLeft = dims.borderLeft;
                borderTop = dims.borderTop;
            }

            // SCA header: 14 bytes
            // 0-2: "SCA" marker
            // 3: version (1)
            // 4-5: width (256, little-endian)
            // 6-7: height (192, little-endian)
            // 8: border color (0)
            // 9-10: frame count (little-endian)
            // 11: payload type (0 = full SCR, 1 = attrs only)
            // 12-13: payload position (14 = after header)
            const headerSize = 14;
            const delayTableSize = frameCount;
            const fillPatternSize = payloadType === 1 ? 8 : 0;
            const frameDataSize = payloadType === 1 ? frameCount * 768 : frameCount * 6912;
            const totalSize = headerSize + delayTableSize + fillPatternSize + frameDataSize;

            const scaData = new Uint8Array(totalSize);

            // Write header
            scaData[0] = 0x53; // 'S'
            scaData[1] = 0x43; // 'C'
            scaData[2] = 0x41; // 'A'
            scaData[3] = 1;    // version
            scaData[4] = 256 & 0xFF;  // width low
            scaData[5] = (256 >> 8) & 0xFF; // width high
            scaData[6] = 192 & 0xFF;  // height low
            scaData[7] = (192 >> 8) & 0xFF; // height high
            scaData[8] = 0;    // border color
            scaData[9] = frameCount & 0xFF;  // frame count low
            scaData[10] = (frameCount >> 8) & 0xFF; // frame count high
            scaData[11] = payloadType;  // payload type
            scaData[12] = headerSize & 0xFF;  // payload position low
            scaData[13] = (headerSize >> 8) & 0xFF; // payload position high

            // Write delay table (1 byte per frame, all set to 1 = 1/50s = 50fps)
            for (let i = 0; i < frameCount; i++) {
                scaData[headerSize + i] = 1;
            }

            // Write fill pattern for type 1
            let frameDataOffset = headerSize + delayTableSize;
            if (payloadType === 1) {
                scaData.set(fillPattern, frameDataOffset);
                frameDataOffset += 8;
            }

            // Convert and write each frame
            for (let i = 0; i < frames.length; i++) {
                const frame = frames[i];

                // Convert data URL to image
                const img = new Image();
                img.src = frame.dataUrl;
                await new Promise(resolve => img.onload = resolve);

                // Get image data
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = frame.width;
                tempCanvas.height = frame.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(img, 0, 0);
                const imageData = tempCtx.getImageData(0, 0, frame.width, frame.height);
                const pixels = imageData.data;

                // Determine screen position within captured frame
                let scrLeft = 0, scrTop = 0;
                if (frame.width > 256) {
                    const dims = spectrum && spectrum.ula ? spectrum.ula.getDimensions() : null;
                    if (dims && frame.width >= dims.width && frame.height >= dims.height) {
                        scrLeft = borderLeft;
                        scrTop = borderTop;
                    } else if (frame.width === 320 && frame.height === 256) {
                        scrLeft = 32;
                        scrTop = 32;
                    } else {
                        scrLeft = (frame.width - 256) / 2;
                        scrTop = (frame.height - 192) / 2;
                    }
                }

                if (payloadType === 1) {
                    // Type 1: copy attributes directly from frame's memory snapshot
                    scaData.set(frame.attrs, frameDataOffset + i * 768);
                } else {
                    // Type 0: full SCR (6912 bytes)
                    const scrData = imageDataToScr(pixels, frame.width, scrLeft, scrTop);
                    scaData.set(scrData, frameDataOffset + i * 6912);
                }

                if (i % 10 === 0) {
                    frameGrabStatus.textContent = `Encoding SCA: ${Math.round(i / frames.length * 100)}%`;
                    await new Promise(r => setTimeout(r, 0));
                }
            }

            // Download
            const blob = new Blob([scaData], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${baseName}.sca`;
            a.click();
            URL.revokeObjectURL(url);

            const duration = (frameCount / 50).toFixed(2);
            const typeStr = payloadType === 1 ? 'Type 1' : 'Type 0';
            frameGrabStatus.textContent = `Exported ${frameCount} frames to SCA ${typeStr} (${duration}s)`;
            frameGrabStatus.classList.remove('recording');
            showMessage(`Exported ${frameCount} frames to ${baseName}.sca (${typeStr})`);
            frameGrabState.frames = [];
        }

        async function exportFramesAsGif() {
            const frames = frameGrabState.frames;
            if (frames.length === 0) return;

            const width = frames[0].width;
            const height = frames[0].height;

            // Simple GIF encoder
            const gif = new GifEncoder(width, height);

            for (let i = 0; i < frames.length; i++) {
                // Convert data URL to image data
                const img = new Image();
                img.src = frames[i].dataUrl;
                await new Promise(resolve => img.onload = resolve);

                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = width;
                tempCanvas.height = height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(img, 0, 0);
                const imageData = tempCtx.getImageData(0, 0, width, height);

                gif.addFrame(imageData.data, 2); // 2 = 20ms delay (50fps)

                if (i % 10 === 0) {
                    frameGrabStatus.textContent = `Encoding GIF: ${Math.round(i / frames.length * 100)}%`;
                    await new Promise(r => setTimeout(r, 0)); // Allow UI update
                }
            }

            const gifData = gif.finish();
            const baseName = getExportBaseName();

            // Download
            const blob = new Blob([gifData], { type: 'image/gif' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${baseName}.gif`;
            a.click();
            URL.revokeObjectURL(url);

            frameGrabStatus.textContent = `Exported ${frames.length} frames to GIF`;
            frameGrabStatus.classList.remove('recording');
            showMessage(`Exported ${frames.length} frames to ${baseName}.gif`);
            frameGrabState.frames = [];
        }

        // Simple GIF Encoder (256-color, LZW compression)
        class GifEncoder {
            constructor(width, height) {
                this.width = width;
                this.height = height;
                this.frames = [];
                this.data = [];
            }

            addFrame(rgba, delay) {
                // Quantize to 256 colors and create indexed frame
                const { palette, indexed } = this.quantize(rgba);
                this.frames.push({ palette, indexed, delay });
            }

            quantize(rgba) {
                // Simple color quantization using a fixed palette
                // Use median-cut or popularity algorithm for better results
                const colorCounts = new Map();
                const pixels = [];

                for (let i = 0; i < rgba.length; i += 4) {
                    const r = rgba[i] & 0xF8;     // 5 bits
                    const g = rgba[i + 1] & 0xFC; // 6 bits
                    const b = rgba[i + 2] & 0xF8; // 5 bits
                    const key = (r << 16) | (g << 8) | b;
                    pixels.push(key);
                    colorCounts.set(key, (colorCounts.get(key) || 0) + 1);
                }

                // Get top 256 colors
                const sorted = [...colorCounts.entries()]
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 256);

                const palette = new Uint8Array(256 * 3);
                const colorToIndex = new Map();

                for (let i = 0; i < sorted.length; i++) {
                    const [color] = sorted[i];
                    const r = (color >> 16) & 0xFF;
                    const g = (color >> 8) & 0xFF;
                    const b = color & 0xFF;
                    palette[i * 3] = r;
                    palette[i * 3 + 1] = g;
                    palette[i * 3 + 2] = b;
                    colorToIndex.set(color, i);
                }

                // Map pixels to palette indices
                const indexed = new Uint8Array(pixels.length);
                for (let i = 0; i < pixels.length; i++) {
                    indexed[i] = colorToIndex.get(pixels[i]) || 0;
                }

                return { palette, indexed };
            }

            finish() {
                const out = [];

                // GIF Header
                out.push(...[0x47, 0x49, 0x46, 0x38, 0x39, 0x61]); // GIF89a

                // Logical Screen Descriptor
                out.push(this.width & 0xFF, (this.width >> 8) & 0xFF);
                out.push(this.height & 0xFF, (this.height >> 8) & 0xFF);
                out.push(0xF7); // Global color table, 256 colors (2^(7+1))
                out.push(0);    // Background color index
                out.push(0);    // Pixel aspect ratio

                // Global Color Table (use first frame's palette)
                if (this.frames.length > 0) {
                    for (let i = 0; i < 256 * 3; i++) {
                        out.push(this.frames[0].palette[i] || 0);
                    }
                }

                // Netscape Extension for looping
                out.push(0x21, 0xFF, 0x0B);
                out.push(...[0x4E, 0x45, 0x54, 0x53, 0x43, 0x41, 0x50, 0x45, 0x32, 0x2E, 0x30]); // NETSCAPE2.0
                out.push(0x03, 0x01, 0x00, 0x00, 0x00); // Loop forever

                // Frames
                for (const frame of this.frames) {
                    // Graphics Control Extension
                    out.push(0x21, 0xF9, 0x04);
                    out.push(0x00); // Disposal method
                    out.push(frame.delay & 0xFF, (frame.delay >> 8) & 0xFF); // Delay
                    out.push(0x00); // Transparent color index
                    out.push(0x00); // Block terminator

                    // Image Descriptor
                    out.push(0x2C);
                    out.push(0, 0, 0, 0); // Left, Top
                    out.push(this.width & 0xFF, (this.width >> 8) & 0xFF);
                    out.push(this.height & 0xFF, (this.height >> 8) & 0xFF);
                    out.push(0x00); // No local color table

                    // LZW Compressed Image Data
                    const lzw = this.lzwEncode(frame.indexed, 8);
                    out.push(8); // LZW minimum code size

                    // Output in sub-blocks
                    let pos = 0;
                    while (pos < lzw.length) {
                        const blockSize = Math.min(255, lzw.length - pos);
                        out.push(blockSize);
                        for (let i = 0; i < blockSize; i++) {
                            out.push(lzw[pos++]);
                        }
                    }
                    out.push(0x00); // Block terminator
                }

                // GIF Trailer
                out.push(0x3B);

                return new Uint8Array(out);
            }

            lzwEncode(data, minCodeSize) {
                const clearCode = 1 << minCodeSize;
                const eoiCode = clearCode + 1;
                let codeSize = minCodeSize + 1;
                let nextCode = eoiCode + 1;
                const maxCode = 4096;

                const table = new Map();
                for (let i = 0; i < clearCode; i++) {
                    table.set(String.fromCharCode(i), i);
                }

                const output = [];
                let bitBuffer = 0;
                let bitCount = 0;

                const writeBits = (code, size) => {
                    bitBuffer |= code << bitCount;
                    bitCount += size;
                    while (bitCount >= 8) {
                        output.push(bitBuffer & 0xFF);
                        bitBuffer >>= 8;
                        bitCount -= 8;
                    }
                };

                writeBits(clearCode, codeSize);

                let current = '';
                for (let i = 0; i < data.length; i++) {
                    const char = String.fromCharCode(data[i]);
                    const next = current + char;

                    if (table.has(next)) {
                        current = next;
                    } else {
                        writeBits(table.get(current), codeSize);

                        if (nextCode < maxCode) {
                            table.set(next, nextCode++);
                            if (nextCode > (1 << codeSize) && codeSize < 12) {
                                codeSize++;
                            }
                        } else {
                            // Reset table
                            writeBits(clearCode, codeSize);
                            table.clear();
                            for (let j = 0; j < clearCode; j++) {
                                table.set(String.fromCharCode(j), j);
                            }
                            codeSize = minCodeSize + 1;
                            nextCode = eoiCode + 1;
                        }

                        current = char;
                    }
                }

                if (current.length > 0) {
                    writeBits(table.get(current), codeSize);
                }

                writeBits(eoiCode, codeSize);

                if (bitCount > 0) {
                    output.push(bitBuffer & 0xFF);
                }

                return output;
            }
        }

        btnFrameGrabStart.addEventListener('click', startFrameGrab);
        btnFrameGrabStop.addEventListener('click', () => stopFrameGrab(false));
        btnFrameGrabCancel.addEventListener('click', () => stopFrameGrab(true));

        // PSG Recording controls
        const btnPsgStart = document.getElementById('btnPsgStart');
        const btnPsgStop = document.getElementById('btnPsgStop');
        const btnPsgCancel = document.getElementById('btnPsgCancel');
        const chkPsgChangedOnly = document.getElementById('chkPsgChangedOnly');
        const psgStatus = document.getElementById('psgStatus');
        let psgRecording = false;
        let psgFrameCount = 0;
        let psgWriteCount = 0;
        let psgUpdateInterval = null;

        function startPsgRecording() {
            spectrum.ay.startLogging();
            psgRecording = true;
            psgFrameCount = 0;
            psgWriteCount = 0;
            btnPsgStart.disabled = true;
            btnPsgStop.disabled = false;
            btnPsgCancel.disabled = false;
            psgStatus.textContent = 'Recording: 0 frames';
            showMessage('PSG recording started');

            // Update status periodically by reading AY properties directly
            psgUpdateInterval = setInterval(() => {
                if (psgRecording && spectrum.ay.loggingEnabled) {
                    psgFrameCount = spectrum.ay.logFrameNumber;
                    psgWriteCount = spectrum.ay.registerLog.length;
                    const duration = (psgFrameCount / 50).toFixed(1);
                    psgStatus.textContent = `Recording: ${psgFrameCount} frames, ${psgWriteCount} writes (${duration}s)`;
                }
            }, 200);
        }

        function stopPsgRecording(cancel) {
            spectrum.ay.stopLogging();
            psgRecording = false;
            btnPsgStart.disabled = false;
            btnPsgStop.disabled = true;
            btnPsgCancel.disabled = true;

            if (psgUpdateInterval) {
                clearInterval(psgUpdateInterval);
                psgUpdateInterval = null;
            }

            if (cancel) {
                spectrum.ay.clearLog();
                psgStatus.textContent = 'Cancelled';
                showMessage('PSG recording cancelled');
                return;
            }

            // Export PSG file
            const changedOnly = chkPsgChangedOnly.checked;
            const psgData = spectrum.ay.exportPSG(changedOnly);

            if (!psgData || psgData.length <= 16) {
                psgStatus.textContent = 'No AY data recorded';
                showMessage('No AY data to export');
                spectrum.ay.clearLog();
                return;
            }

            const frames = psgFrameCount;
            const duration = (frames / 50).toFixed(1);
            const blob = new Blob([psgData], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `music_${frames}f.psg`;
            a.click();
            URL.revokeObjectURL(url);

            psgStatus.textContent = `Exported: ${psgData.length} bytes, ${frames} frames (${duration}s)`;
            showMessage(`Exported PSG: ${psgData.length} bytes`);
            spectrum.ay.clearLog();
        }

        btnPsgStart.addEventListener('click', startPsgRecording);
        btnPsgStop.addEventListener('click', () => stopPsgRecording(false));
        btnPsgCancel.addEventListener('click', () => stopPsgRecording(true));

        // ========== RZX Recording ==========
        const btnRzxRecStart = document.getElementById('btnRzxRecStart');
        const btnRzxRecExport = document.getElementById('btnRzxRecExport');
        const btnRzxRecCancel = document.getElementById('btnRzxRecCancel');
        const rzxRecStatus = document.getElementById('rzxRecStatus');

        btnRzxRecStart.addEventListener('click', () => {
            if (spectrum.rzxStartRecording()) {
                btnRzxRecStart.disabled = true;
                btnRzxRecExport.disabled = false;
                btnRzxRecCancel.disabled = false;
                if (spectrum.running) {
                    rzxRecStatus.textContent = 'Recording...';
                } else {
                    rzxRecStatus.textContent = 'Recording (paused - press Start to run)';
                }
            } else {
                showMessage('Cannot start RZX recording (playback active?)', 'error');
            }
        });

        btnRzxRecExport.addEventListener('click', () => {
            const result = spectrum.rzxStopRecording();
            btnRzxRecStart.disabled = false;
            btnRzxRecExport.disabled = true;
            btnRzxRecCancel.disabled = true;
            if (result && result.frames > 0) {
                const baseName = getExportBaseName() || 'recording';
                spectrum.rzxDownloadRecording(`${baseName}.rzx`);
                rzxRecStatus.textContent = `Exported: ${result.frames} frames`;
            } else {
                rzxRecStatus.textContent = 'No frames recorded';
            }
        });

        btnRzxRecCancel.addEventListener('click', () => {
            spectrum.rzxCancelRecording();
            btnRzxRecStart.disabled = false;
            btnRzxRecExport.disabled = true;
            btnRzxRecCancel.disabled = true;
            rzxRecStatus.textContent = 'Recording cancelled';
        });

        // Update RZX recording status during recording
        setInterval(() => {
            if (spectrum.isRZXRecording()) {
                const frames = spectrum.getRZXRecordedFrameCount();
                if (spectrum.rzxRecordPending) {
                    // Waiting for frame boundary
                    if (spectrum.running) {
                        rzxRecStatus.textContent = 'Starting...';
                    } else {
                        rzxRecStatus.textContent = 'Pending (press Start to begin)';
                    }
                    btnRzxRecExport.disabled = true;
                } else if (spectrum.running) {
                    rzxRecStatus.textContent = `Recording... ${frames} frames`;
                    btnRzxRecExport.disabled = frames === 0;
                } else {
                    rzxRecStatus.textContent = `Recording (paused) ${frames} frames`;
                    btnRzxRecExport.disabled = frames === 0;
                }
                btnRzxRecCancel.disabled = false;
            }
        }, 500);

        // PSG Player source code download
        const btnPsgPlayer = document.getElementById('btnPsgPlayer');
        btnPsgPlayer.addEventListener('click', () => {
            const playerSource = `; PSG Player for ZX Spectrum
; Simple player for PSG files exported from ZX-M8XXX
; Assemble with sjasmplus
;
; Usage:
;   1. Include your PSG data at PSG_DATA label (INCBIN "music.psg")
;   2. Assemble: sjasmplus psg_player.asm
;   3. Load music.sna and run
;   4. Press Space to stop

        DEVICE ZXSPECTRUM128

        ORG #8000

AY_REG  EQU #FFFD       ; AY register select port
AY_DATA EQU #BFFD       ; AY data port

START:
        DI
        LD HL,PSG_DATA+16   ; Skip 16-byte header
        EI

PLAY_LOOP:
        LD A,(HL)
        INC HL

        CP #FD              ; End of music?
        JR Z,MUSIC_END

        CP #FF              ; End of frame?
        JR Z,WAIT_FRAME

        CP #FE              ; Multiple empty frames?
        JR Z,SKIP_FRAMES

        ; Register write: A = register, next byte = value
        LD BC,AY_REG
        OUT (C),A           ; Select register
        LD A,(HL)
        INC HL
        LD BC,AY_DATA
        OUT (C),A           ; Write value
        JR PLAY_LOOP

SKIP_FRAMES:
        ; 0xFE followed by count (frames = count * 4)
        LD A,(HL)
        INC HL
        LD B,A
        SLA B
        SLA B               ; B = count * 4
SKIP_LOOP:
        CALL WAIT_INT
        DJNZ SKIP_LOOP
        JR PLAY_LOOP

WAIT_FRAME:
        CALL WAIT_INT
        JR PLAY_LOOP

WAIT_INT:
        ; Wait for interrupt (50Hz frame sync)
        LD A,#7F
        IN A,(#FE)          ; Check keyboard
        RRA
        JR NC,KEY_PRESSED   ; Space pressed - exit

        HALT                ; Wait for next interrupt
        RET

KEY_PRESSED:
        POP AF              ; Remove return address

MUSIC_END:
        ; Silence AY
        XOR A
        LD BC,AY_REG
        LD E,13             ; 14 registers (0-13)
SILENCE:
        OUT (C),A
        LD D,A
        LD BC,AY_DATA
        OUT (C),D
        LD BC,AY_REG
        INC A
        DEC E
        JP P,SILENCE

        RET

; Include your PSG data here
PSG_DATA:
        INCBIN "music.psg"

        SAVESNA "music.sna", START
`;
            const blob = new Blob([playerSource], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'psg_player.asm';
            a.click();
            URL.revokeObjectURL(url);
            showMessage('Downloaded psg_player.asm');
        });

        // Zoom controls (canvas already declared above)
        const zoomButtons = [
            document.getElementById('zoom1'),
            document.getElementById('zoom2'),
            document.getElementById('zoom3')
        ];

        let currentZoom = 1;  // Default zoom x1

        function updateCanvasSize() {
            // Skip size updates when in fullscreen mode
            if (document.fullscreenElement || document.webkitFullscreenElement) {
                return;
            }
            // Get current dimensions from ULA
            const dims = spectrum.ula.getDimensions();
            canvas.width = dims.width;
            canvas.height = dims.height;
            // Apply current zoom level to style
            canvas.style.width = (dims.width * currentZoom) + 'px';
            canvas.style.height = (dims.height * currentZoom) + 'px';
            // Overlay canvas: internal resolution = screen resolution (zoomed)
            // So 1px line = 1 screen pixel regardless of zoom
            overlayCanvas.width = dims.width * currentZoom;
            overlayCanvas.height = dims.height * currentZoom;
            overlayCanvas.style.width = (dims.width * currentZoom) + 'px';
            overlayCanvas.style.height = (dims.height * currentZoom) + 'px';
            // Tell spectrum about zoom for overlay drawing
            spectrum.setZoom(currentZoom);
        }

        function setZoom(level) {
            currentZoom = level;
            updateCanvasSize();

            // Update active button
            zoomButtons.forEach((btn, i) => {
                btn.classList.toggle('active', i + 1 === level);
            });

            // Shift tabs left in landscape mode at higher zoom levels
            document.getElementById('tabContainer').classList.toggle('zoom-shifted', level >= 2);

            // Re-render current frame after zoom change
            spectrum.renderToScreen();

            // Update sprite region preview if visible
            if (typeof updateSpriteRegionPreview === 'function') {
                updateSpriteRegionPreview();
            }
        }

        zoomButtons[0].addEventListener('click', () => setZoom(1));
        zoomButtons[1].addEventListener('click', () => setZoom(2));
        zoomButtons[2].addEventListener('click', () => setZoom(3));

        // Set initial zoom to x1
        setZoom(1);
        
        // Theme toggle
        const themeToggle = document.getElementById('themeToggle');
        const metaColorScheme = document.getElementById('metaColorScheme');
        let darkTheme = localStorage.getItem('zx-theme') !== 'light';
        document.body.classList.toggle('light-theme', !darkTheme);
        metaColorScheme.content = darkTheme ? 'dark' : 'light';
        themeToggle.textContent = darkTheme ? '☀️' : '🌙';

        themeToggle.addEventListener('click', () => {
            darkTheme = !darkTheme;
            document.body.classList.toggle('light-theme', !darkTheme);
            metaColorScheme.content = darkTheme ? 'dark' : 'light';
            themeToggle.textContent = darkTheme ? '☀️' : '🌙';
            localStorage.setItem('zx-theme', darkTheme ? 'dark' : 'light');
        });
        
        // Handle disk image insertion - requires Beta Disk to be available
        function handleDiskInserted(result, fileName) {
            if (result.needsMachineSwitch) {
                // Beta Disk not available on current machine - don't force machine switch
                if (!romData['trdos.rom']) {
                    showMessage('TR-DOS ROM required for disk images. Load trdos.rom first.', 'error');
                } else {
                    showMessage('Enable Beta Disk in Settings, or switch to Pentagon/Scorpion mode for disk images.', 'error');
                }
                return;
            }

            handleLoadResult(result, fileName);
        }

        // Update media indicators (tape/disk filenames)
        function updateMediaIndicator(fileName, type, driveIndex) {
            const ext = fileName.split('.').pop().toLowerCase();
            if (type === 'tape' || ext === 'tap' || ext === 'tzx') {
                document.getElementById('tapeLed').title = fileName;
                document.getElementById('tapeInfo').style.display = 'inline-block';
            } else if (type === 'disk' || ext === 'trd' || ext === 'scl' || ext === 'dsk') {
                // Build tooltip listing all loaded drives
                const driveNames = [];
                const betaDisks = spectrum.loadedBetaDisks;
                const fdcDisks = spectrum.loadedFDCDisks;
                if (spectrum.machineType === '+3') {
                    for (let i = 0; i < 2; i++) {
                        if (fdcDisks[i]) driveNames.push(`${String.fromCharCode(65 + i)}: ${fdcDisks[i].name}`);
                    }
                } else {
                    for (let i = 0; i < 4; i++) {
                        if (betaDisks[i]) driveNames.push(`${String.fromCharCode(65 + i)}: ${betaDisks[i].name}`);
                    }
                }
                document.getElementById('diskInfoLed').title = driveNames.join('\n') || fileName;
                document.getElementById('diskInfo').style.display = 'inline-block';
            }
        }

        // Show/hide drive selector based on current machine type
        function updateDriveSelector() {
            const sel = document.getElementById('driveSelectorSelect');
            if (spectrum.machineType === '+3') {
                // FDC: only 2 drives
                sel.options[2].style.display = 'none';
                sel.options[3].style.display = 'none';
                if (sel.selectedIndex > 1) sel.selectedIndex = 0;
            } else {
                sel.options[2].style.display = '';
                sel.options[3].style.display = '';
            }
        }

        // Get currently selected drive index from the UI drive selector
        function getSelectedDriveIndex() {
            const sel = document.getElementById('driveSelectorSelect');
            return parseInt(sel.value, 10) || 0;
        }

        // Handle loaded result (shared between file input and ZIP selection)
        function handleLoadResult(result, fileName) {
            // Cancel any in-progress auto load sequence
            cancelAutoLoad();

            // Stop any running RZX playback when loading new file (unless this IS an RZX)
            if (result.frames === undefined && spectrum.isRZXPlaying()) {
                spectrum.rzxStop();
                updateRZXStatus();
            }

            // Update last loaded file label
            const lastFileEl = document.getElementById('lastLoadedFile');
            if (lastFileEl) lastFileEl.textContent = fileName;

            // Update media indicators based on result type
            if (result.diskInserted || result.diskFile) {
                const drv = result._driveIndex || 0;
                const ctrl = result.isDSK ? 'fdc' : 'beta';
                updateMediaIndicator(fileName, 'disk', drv);
                if (typeof buildDiskCatalog === 'function') {
                    buildDiskCatalog(drv, ctrl);
                }
            } else if (result.blocks !== undefined) {
                updateMediaIndicator(fileName, 'tape');
                // Update tape position display and catalog
                if (typeof updateTapePosition === 'function') {
                    updateTapePosition();
                }
                if (typeof buildTapeCatalog === 'function') {
                    buildTapeCatalog();
                }
            }

            // Load labels, regions, comments, and xrefs for this file
            labelManager.setCurrentFile(fileName);
            regionManager.setCurrentFile(fileName);
            commentManager.setCurrentFile(fileName);
            xrefManager.setCurrentFile(fileName);
            operandFormatManager.setCurrentFile(fileName);
            subroutineManager.setCurrentFile(fileName);
            updateXrefStats();

            // Check result type by properties
            if (result.isDSK && result.diskInserted) {
                // DSK disk inserted into µPD765 FDC (+3)
                const dskDrive = result._driveIndex || 0;
                const dskLetter = String.fromCharCode(65 + dskDrive);
                // Auto-boot only when loading into drive A (drive 0)
                if (chkAutoLoad.checked && spectrum.machineType === '+3' && dskDrive === 0) {
                    showMessage(`DSK disk inserted in ${dskLetter}: ${result.diskName} (${result.fileCount} files). Auto booting +3...`);
                    startAutoLoadPlus3Disk();
                } else {
                    if (!spectrum.isRunning()) spectrum.start();
                    showMessage(`DSK disk inserted in ${dskLetter}: ${result.diskName} (${result.fileCount} files).`);
                }
            } else if (result.diskInserted) {
                // TRD/SCL disk inserted into Beta Disk interface
                const trdDrive = result._driveIndex || 0;
                const trdLetter = String.fromCharCode(65 + trdDrive);
                // Auto-load only when loading into drive A (drive 0) and Beta Disk available
                const canBootTrdos = spectrum.profile.betaDiskDefault ||
                    (spectrum.betaDiskEnabled && spectrum.memory.hasTrdosRom());
                if (chkAutoLoad.checked && canBootTrdos && trdDrive === 0) {
                    const typeStr = result.diskType.toUpperCase();
                    showMessage(`${typeStr} disk inserted in ${trdLetter}: ${result.diskName} (${result.fileCount} files). Auto booting TR-DOS...`);
                    startAutoLoadDisk();
                } else {
                    if (!spectrum.isRunning()) spectrum.start();
                    const typeStr = result.diskType.toUpperCase();
                    showMessage(`${typeStr} disk inserted in ${trdLetter}: ${result.diskName} (${result.fileCount} files).`);
                }
            } else if (result.diskFile) {
                // TRD/SCL disk file - ensure emulator is running
                if (!spectrum.isRunning()) spectrum.start();

                if (result.useTrdos) {
                    // TR-DOS mode - show instructions
                    if (result.manualBoot) {
                        showMessage(`Disk loaded. Select TR-DOS from Pentagon menu, then type ${result.trdosCommand}`);
                    } else {
                        showMessage(`TR-DOS: Type ${result.trdosCommand} to run ${result.fileName}`);
                    }
                } else {
                    const addrHex = result.start.toString(16).toUpperCase().padStart(4, '0');
                    if (result.fileType === 'code') {
                        showMessage(`${result.diskType.toUpperCase()}: ${result.fileName} loaded at ${addrHex}h (${result.length} bytes) - RANDOMIZE USR ${result.start} to run`);
                    } else if (result.fileType === 'basic') {
                        // BASIC program - auto-loading via injected LOAD ""
                        if (result.autoload) {
                            showMessage(`${result.diskType.toUpperCase()}: ${result.fileName} - Loading...`);
                        } else {
                            showMessage(`${result.diskType.toUpperCase()}: ${result.fileName} loaded - Type LOAD "" to load`);
                        }
                    } else {
                        showMessage(`${result.diskType.toUpperCase()}: Loaded ${result.fileName}`);
                    }
                }
            } else if (result.blocks !== undefined) {
                // TAP/TZX file
                const isTzx = /\.tzx/i.test(fileName);
                if (chkAutoLoad.checked) {
                    showMessage(`${isTzx ? 'TZX' : 'TAP'} loaded: ${result.blocks} blocks. Auto loading...`);
                    startAutoLoadTape(isTzx);
                } else {
                    showMessage(`${isTzx ? 'TZX' : 'TAP'} loaded: ${result.blocks} blocks. Type LOAD "" to load.`);
                }
            } else if (result.frames !== undefined) {
                // RZX file - stop immediately and show debugger
                spectrum.stop();
                disasm = null;

                // Reload ROM if needed (machine type changed or ROM incompatible)
                if (result.needsRomReload || !spectrum.romLoaded) {
                    loadRomsForMachineType(spectrum, result.machineType);
                }

                const creatorInfo = result.creator ? ` (${result.creator.name})` : '';
                const pc = spectrum.cpu ? spectrum.cpu.pc : 0;
                const pcHex = pc.toString(16).toUpperCase().padStart(4, '0');
                showMessage(`RZX loaded: ${result.frames} frames${creatorInfo} - PC: ${pcHex} (paused, press Resume to play)`);

                openDebuggerPanel();
                updateRZXStatus();
                updateStatus();
                updateDebugger();

                // Render the snapshot screen (updateCanvasSize() clears the canvas)
                spectrum.renderToScreen();
            } else {
                // SNA/Z80/SZX snapshot - machine type may have changed
                showMessage(`Snapshot loaded (${result.machineType.toUpperCase()}): ${fileName}`);

                // Re-apply appropriate ROM after machine switch (and set romLoaded flag)
                const romReloaded = loadRomsForMachineType(spectrum, result.machineType);

                // If ROM was reloaded after machine type change, start emulation
                // (snapshot loaders try to start but fail if romLoaded was false)
                if (romReloaded && !spectrum.running) {
                    spectrum.start();
                }

                // Reset disassembler to use fresh memory reference
                disasm = null;

                updateStatus();
                updateDebugger();
            }
        }
        
        // Show file selection modal (ZIP or disk image)
        async function showZipSelection(result, fileName) {
            pendingZipResult = { result, fileName };
            zipFileList.innerHTML = '';

            const isDisk = result.diskType;
            const modalTitle = zipModal.querySelector('h2');
            const modalDesc = zipModal.querySelector('p');

            // Check Beta Disk availability for disk images
            if (isDisk && result.needsMachineSwitch) {
                // Beta Disk not available - warn user and don't force machine switch
                if (!romData['trdos.rom']) {
                    showMessage('TR-DOS ROM required for disk images. Load trdos.rom first.', 'error');
                } else {
                    showMessage('Enable Beta Disk in Settings, or switch to Pentagon/Scorpion mode for disk images.', 'error');
                }
                return;
            } else if (isDisk && romData['trdos.rom'] && !spectrum.memory.hasTrdosRom()) {
                // TR-DOS ROM available but not loaded into memory - load it now
                spectrum.memory.loadTrdosRom(romData['trdos.rom']);
                spectrum.trdosTrap.updateTrdosRomFlag();
            }

            if (isDisk) {
                modalTitle.textContent = `Select File from ${result.diskType.toUpperCase()}`;
                modalDesc.textContent = 'Select file to load, or boot TR-DOS for command prompt:';
                // Show Boot TR-DOS button if Beta Disk available (Pentagon OR enabled with TR-DOS ROM)
                const hasTrdosRom = spectrum.memory.hasTrdosRom && spectrum.memory.hasTrdosRom();
                const betaDiskAvailable = spectrum.profile.betaDiskDefault || spectrum.betaDiskEnabled;
                btnBootTrdos.style.display = (betaDiskAvailable && hasTrdosRom) ? 'inline-block' : 'none';
            } else {
                modalTitle.textContent = 'Select File to Load';
                modalDesc.textContent = 'The archive contains multiple files. Select one to load:';
                btnBootTrdos.style.display = 'none';
            }

            // Create sorted list with original indices
            const sortedFiles = result.files
                .map((file, index) => ({ file, index: isDisk ? file.index : index }))
                .sort((a, b) => a.file.name.localeCompare(b.file.name));

            sortedFiles.forEach(({ file, index }) => {
                const item = document.createElement('div');
                item.className = 'zip-file-item';

                // For disk files, show more details
                if (isDisk) {
                    const isBoot = file.name.toLowerCase().startsWith('boot');
                    const typeLabel = file.type === 'basic' ? 'BASIC' :
                                     file.type === 'code' ? 'CODE' :
                                     file.type === 'data' ? 'DATA' : file.type.toUpperCase();
                    const startHex = file.start.toString(16).toUpperCase().padStart(4, '0');
                    const bootBadge = isBoot ? ' <span style="color: var(--success-color); font-weight: bold;">[BOOT]</span>' : '';
                    item.innerHTML = `
                        <span class="zip-file-name">${file.name}${bootBadge}</span>
                        <span class="zip-file-type">${typeLabel}</span>
                        <span class="zip-file-info">${startHex}h, ${file.length} bytes</span>
                    `;
                    if (isBoot) {
                        item.style.borderLeft = '3px solid var(--success-color)';
                    }
                } else {
                    item.innerHTML = `
                        <span class="zip-file-name">${file.name}</span>
                        <span class="zip-file-type">${file.type}</span>
                    `;
                }

                item.addEventListener('click', async () => {
                    zipModal.classList.add('hidden');

                    // Save current settings before loading (may trigger machine type change)
                    const savedPaletteId = paletteSelect?.value || 'default';
                    const savedFullBorder = spectrum.ula.fullBorderMode;

                    try {
                        let loadResult;
                        if (isDisk) {
                            // Load from disk image
                            loadResult = spectrum.loadFromDiskSelection(result, index);
                        } else if (file.type === 'rzx') {
                            // Handle RZX files specially (async loading)
                            const rzxData = result._zipFiles[index].data;
                            loadResult = await spectrum.loadRZX(rzxData);
                            // Reload ROM if needed (machine type changed or ROM incompatible)
                            if (loadResult.needsRomReload || !spectrum.romLoaded) {
                                loadRomsForMachineType(spectrum, loadResult.machineType);
                            }
                        } else if (file.type === 'trd' || file.type === 'scl') {
                            // Disk image inside ZIP - handle disk insertion
                            loadResult = spectrum.loadFromZipSelection(result, index);
                            if (loadResult.diskInserted) {
                                handleDiskInserted(loadResult, file.name, { fullBorder: savedFullBorder, paletteId: savedPaletteId });
                                pendingZipResult = null;
                                return;
                            }
                        } else {
                            loadResult = spectrum.loadFromZipSelection(result, index);
                        }

                        // Restore full border setting (machine type change creates new ULA)
                        if (spectrum.ula.setFullBorder(savedFullBorder)) {
                            spectrum.updateDisplayDimensions();
                        }

                        // Update canvas sizes after loading (machine type change may affect dimensions)
                        updateCanvasSize();

                        // Restore palette after loading (machine type change creates new ULA)
                        if (typeof applyPalette === 'function') {
                            applyPalette(savedPaletteId);
                        }

                        handleLoadResult(loadResult, file.name);
                    } catch (e) {
                        showMessage('Failed to load: ' + e.message, 'error');
                    }
                    pendingZipResult = null;
                });
                zipFileList.appendChild(item);
            });

            zipModal.classList.remove('hidden');
        }
        
        btnZipCancel.addEventListener('click', () => {
            zipModal.classList.add('hidden');
            pendingZipResult = null;
            btnBootTrdos.style.display = 'none';
            // Make sure emulator is running after dialog closes
            if (!spectrum.isRunning()) spectrum.start();
        });

        btnBootTrdos.addEventListener('click', () => {
            zipModal.classList.add('hidden');
            pendingZipResult = null;
            btnBootTrdos.style.display = 'none';

            // Boot into TR-DOS
            if (spectrum.bootTrdos()) {
                spectrum.start();
                showMessage('TR-DOS started. Type RUN or LOAD "filename" to run programs.');
            } else {
                // Determine what's missing
                if (!spectrum.memory.hasTrdosRom()) {
                    showMessage('Cannot boot TR-DOS: trdos.rom not loaded', 'error');
                } else if (!spectrum.profile.betaDiskDefault && !spectrum.betaDiskEnabled) {
                    showMessage('Cannot boot TR-DOS: Enable Beta Disk in Settings', 'error');
                } else {
                    showMessage('Cannot boot TR-DOS', 'error');
                }
            }
        });
        
        fileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            // Check if ROM loaded
            if (!spectrum.romLoaded) {
                showMessage('Please load ROM files first', 'error');
                romModal.classList.remove('hidden');
                fileInput.value = '';
                return;
            }

            try {
                const driveIndex = getSelectedDriveIndex();
                const result = await spectrum.loadFile(file, driveIndex);

                // Update canvas sizes after loading (machine type change may affect dimensions)
                updateCanvasSize();

                // Check if ZIP needs file selection
                if (result.needsSelection) {
                    showZipSelection(result, file.name);
                } else if (result.diskInserted) {
                    // Handle disk image with machine switch if needed
                    handleDiskInserted(result, file.name);
                } else {
                    handleLoadResult(result, file.name);
                }
            } catch (e) {
                showMessage('Failed to load: ' + e.message, 'error');
            }
            fileInput.value = '';
        });
        
        // Check if assembler tab is active
        function isAssemblerTabActive() {
            const asmTab = document.getElementById('tab-assembler');
            return asmTab && asmTab.classList.contains('active');
        }

        document.addEventListener('dragover', (e) => {
            e.preventDefault();
            if (!romModal.classList.contains('hidden')) return;
            // Don't show drop zone overlay when assembler tab is active
            // (assembler has its own drop handling with visual feedback)
            if (isAssemblerTabActive()) return;
            dropZone.classList.add('active');
        });

        document.addEventListener('dragleave', (e) => {
            if (e.target === dropZone) dropZone.classList.remove('active');
        });

        document.addEventListener('drop', async (e) => {
            e.preventDefault();
            dropZone.classList.remove('active');
            if (!romModal.classList.contains('hidden')) return;
            // Skip if assembler tab is active (handled by assembler's own drop handler)
            if (isAssemblerTabActive()) return;
            
            const file = e.dataTransfer.files[0];
            if (!file) return;
            const ext = file.name.toLowerCase().split('.').pop();
            
            try {
                if (ext === 'rom' || ext === 'bin') {
                    const data = await file.arrayBuffer();
                    if (data.byteLength >= 32768) {
                        romData['128.rom'] = data;
                        if (spectrum.machineType !== '48k') {
                            spectrum.memory.loadRom(data.slice(0, 16384), 0);
                            spectrum.memory.loadRom(data.slice(16384, 32768), 1);
                        }
                    } else {
                        romData['48.rom'] = data;
                        spectrum.memory.loadRom(data, 0);
                    }
                    spectrum.romLoaded = true;
                    showMessage('ROM loaded: ' + file.name);
                } else if (ext === 'sna' || ext === 'tap' || ext === 'z80' || ext === 'szx' || ext === 'zip' || ext === 'trd' || ext === 'scl' || ext === 'rzx') {
                    if (!spectrum.romLoaded) {
                        showMessage('Please load ROM files first', 'error');
                        romModal.classList.remove('hidden');
                        return;
                    }

                    const driveIndex = getSelectedDriveIndex();
                    const result = await spectrum.loadFile(file, driveIndex);

                    // Update canvas sizes after loading (machine type change may affect dimensions)
                    updateCanvasSize();

                    // Check if ZIP needs file selection
                    if (result.needsSelection) {
                        showZipSelection(result, file.name);
                    } else if (result.diskInserted) {
                        // Handle disk image with machine switch if needed
                        handleDiskInserted(result, file.name);
                    } else {
                        handleLoadResult(result, file.name);
                    }
                }
            } catch (e) {
                showMessage('Failed to load: ' + e.message, 'error');
            }
        });

        canvas.tabIndex = 0;
        
        const screenInfoPopup = document.getElementById('screenInfoPopup');
        
        canvas.addEventListener('click', (e) => {
            canvas.focus();
            
            // Only show popup when paused
            if (spectrum.isRunning()) return;
            
            // Get click position relative to canvas
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const canvasX = Math.floor((e.clientX - rect.left) * scaleX);
            const canvasY = Math.floor((e.clientY - rect.top) * scaleY);
            
            // Get ULA dimensions
            const dims = spectrum.ula.getDimensions();
            const borderLeft = dims.borderLeft;
            const borderTop = dims.borderTop;
            const screenWidth = dims.screenWidth;
            const screenHeight = dims.screenHeight;
            
            // Calculate position relative to screen area
            const screenX = canvasX - borderLeft;
            const screenY = canvasY - borderTop;
            
            // Check if in screen area
            const inScreen = screenX >= 0 && screenX < screenWidth && 
                             screenY >= 0 && screenY < screenHeight;
            
            let infoHtml = '';
            
            if (inScreen) {
                const col = Math.floor(screenX / 8);
                const row = Math.floor(screenY / 8);
                const pixelX = screenX;
                const pixelY = screenY;
                
                // Calculate base Y for this character row (top of char cell)
                const charBaseY = row * 8;
                
                // Read 8 bitmap bytes (one per scanline in char cell)
                const bitmapBytes = [];
                const bitmapAddrs = [];
                for (let line = 0; line < 8; line++) {
                    const y = charBaseY + line;
                    const addr = 0x4000 + 
                        ((y & 0xC0) << 5) + 
                        ((y & 0x07) << 8) + 
                        ((y & 0x38) << 2) + 
                        col;
                    bitmapAddrs.push(addr);
                    bitmapBytes.push(spectrum.memory.read(addr));
                }
                
                // Calculate attribute address
                const attrAddr = 0x5800 + row * 32 + col;
                
                // Read 8 attribute bytes for 8 consecutive rows (multicolor check)
                const attrBytes = [];
                const attrAddrs = [];
                for (let r = 0; r < 8; r++) {
                    const checkRow = row + r;
                    if (checkRow < 24) {
                        const addr = 0x5800 + checkRow * 32 + col;
                        attrAddrs.push(addr);
                        attrBytes.push(spectrum.memory.read(addr));
                    }
                }
                
                // Check if all attributes are the same
                const allSame = attrBytes.every(b => b === attrBytes[0]);
                
                // Format attribute byte as f_b_ppp_iii
                function formatAttr(b) {
                    const flash = (b >> 7) & 1;
                    const bright = (b >> 6) & 1;
                    const paper = (b >> 3) & 7;
                    const ink = b & 7;
                    return `${flash}_${bright}_${paper.toString(2).padStart(3,'0')}_${ink.toString(2).padStart(3,'0')}`;
                }
                
                infoHtml = `
                    <div><span class="info-label">X:</span> <span class="info-value">${hex8(pixelX)}</span> <span class="info-dec">(${pixelX})</span> &nbsp; <span class="info-label">Y:</span> <span class="info-value">${hex8(pixelY)}</span> <span class="info-dec">(${pixelY})</span></div>
                    <div><span class="info-label">Col:</span> <span class="info-value">${hex8(col)}</span> <span class="info-dec">(${col})</span> &nbsp; <span class="info-label">Row:</span> <span class="info-value">${hex8(row)}</span> <span class="info-dec">(${row})</span></div>
                    <div><span class="info-label">Bitmap:</span> <span class="info-value">${hex16(bitmapAddrs[0])}</span></div>
                `;
                
                // Format bitmap bytes as binary with hex/dec
                for (let i = 0; i < bitmapBytes.length; i++) {
                    const b = bitmapBytes[i];
                    const bin = b.toString(2).padStart(8, '0');
                    infoHtml += `<div><span class="info-value">${bin}</span> <span class="info-dec">(${hex8(b)}/${b})</span></div>`;
                }
                
                infoHtml += `<div><span class="info-label">Attr:</span> <span class="info-value">${hex16(attrAddr)}</span></div>`;
                
                if (allSame) {
                    // Single attribute
                    infoHtml += `<div><span class="info-value">${hex8(attrBytes[0])}</span> <span class="info-dec">${formatAttr(attrBytes[0])}</span></div>`;
                } else {
                    // Multicolor - show all 8
                    infoHtml += `<div class="info-dec">(multicolor)</div>`;
                    for (let i = 0; i < attrBytes.length; i++) {
                        infoHtml += `<div><span class="info-value">${hex8(attrBytes[i])}</span> <span class="info-dec">${formatAttr(attrBytes[i])}</span></div>`;
                    }
                }
            } else {
                // In border area - show position and border color at this scanline
                const borderColor = spectrum.ula.getBorderColorAtLine(canvasY);
                const colorNames = ['black', 'blue', 'red', 'magenta', 'green', 'cyan', 'yellow', 'white'];
                infoHtml = `
                    <div><span class="info-label">X:</span> <span class="info-value">${hex8(canvasX)}</span> <span class="info-dec">(${canvasX})</span> &nbsp; <span class="info-label">Y:</span> <span class="info-value">${hex8(canvasY)}</span> <span class="info-dec">(${canvasY})</span></div>
                    <div><span class="info-label">Border:</span> <span class="info-value">${borderColor}</span> <span class="info-dec">(${colorNames[borderColor]})</span></div>
                `;
            }
            
            screenInfoPopup.innerHTML = infoHtml;
            
            // Position popup off-screen first to measure, then position correctly
            screenInfoPopup.style.left = '-9999px';
            screenInfoPopup.style.top = '-9999px';
            screenInfoPopup.classList.remove('hidden');
            
            // Get popup dimensions after content is set
            const popupRect = screenInfoPopup.getBoundingClientRect();
            const popupWidth = popupRect.width;
            const popupHeight = popupRect.height;
            
            // Position popup near click, keep within container to avoid scrollbars
            const container = canvas.parentElement;
            const containerRect = container.getBoundingClientRect();
            
            let popupX = e.clientX - containerRect.left + 15;
            let popupY = e.clientY - containerRect.top + 15;
            
            // Adjust to keep popup within visible area
            const maxX = container.clientWidth - popupWidth - 5;
            const maxY = container.clientHeight - popupHeight - 5;
            
            if (popupX > maxX) popupX = Math.max(5, e.clientX - containerRect.left - popupWidth - 15);
            if (popupY > maxY) popupY = Math.max(5, e.clientY - containerRect.top - popupHeight - 15);
            
            screenInfoPopup.style.left = popupX + 'px';
            screenInfoPopup.style.top = popupY + 'px';
        });
        
        // Hide popup when mouse leaves canvas (with small delay)
        let hideTimeout = null;
        
        canvas.addEventListener('mouseleave', () => {
            hideTimeout = setTimeout(() => {
                screenInfoPopup.classList.add('hidden');
            }, 200);
        });
        
        canvas.addEventListener('mouseenter', () => {
            if (hideTimeout) {
                clearTimeout(hideTimeout);
                hideTimeout = null;
            }
        });
        
        // Hide popup when clicking elsewhere
        document.addEventListener('click', (e) => {
            if (e.target !== canvas && !screenInfoPopup.contains(e.target)) {
                screenInfoPopup.classList.add('hidden');
            }
        });

        // =====================================================================
        // Game Browser (ZXInfo API / Spectrum Computing)
        // =====================================================================
        const gameBrowserDialog = document.getElementById('gameBrowserDialog');
        const btnGameBrowserClose = document.getElementById('btnGameBrowserClose');
        const gameBrowserSearch = document.getElementById('gameBrowserSearch');
        const btnGameBrowserSearchGo = document.getElementById('btnGameBrowserSearchGo');
        const gameBrowserResults = document.getElementById('gameBrowserResults');
        const gameBrowserDetail = document.getElementById('gameBrowserDetail');
        const gameBrowserDetailTitle = document.getElementById('gameBrowserDetailTitle');
        const gameBrowserDetailScreen = document.getElementById('gameBrowserDetailScreen');
        const gameBrowserDetailInfo = document.getElementById('gameBrowserDetailInfo');
        const gameBrowserReleasesList = document.getElementById('gameBrowserReleasesList');
        const gameBrowserExternal = document.getElementById('gameBrowserExternal');
        const btnGameBrowserPrev = document.getElementById('btnGameBrowserPrev');
        const btnGameBrowserNext = document.getElementById('btnGameBrowserNext');
        const gameBrowserPageInfo = document.getElementById('gameBrowserPageInfo');

        // Game browser state
        const gameBrowser = {
            allResults: [],  // All fetched results for client-side pagination
            results: [],     // Current page results
            selectedGame: null,
            page: 0,
            pageSize: 10,
            totalResults: 0,
            loading: false,
            lastQuery: '',
            jsonpCounter: 0
        };

        // JSONP helper - creates script tag to bypass CORS
        function jsonp(url) {
            return new Promise((resolve, reject) => {
                const callbackName = `wosCallback_${++gameBrowser.jsonpCounter}_${Date.now()}`;
                const script = document.createElement('script');

                // Timeout handler
                const timeout = setTimeout(() => {
                    cleanup();
                    reject(new Error('Request timeout'));
                }, 15000);

                function cleanup() {
                    clearTimeout(timeout);
                    delete window[callbackName];
                    if (script.parentNode) script.parentNode.removeChild(script);
                }

                window[callbackName] = (data) => {
                    cleanup();
                    resolve(data);
                };

                script.onerror = () => {
                    cleanup();
                    reject(new Error('Network error'));
                };

                script.src = url + (url.includes('?') ? '&' : '?') + `callback=${callbackName}`;
                document.head.appendChild(script);
            });
        }

        // Close game browser dialog
        btnGameBrowserClose.addEventListener('click', () => {
            gameBrowserDialog.classList.add('hidden');
        });

        gameBrowserDialog.addEventListener('click', (e) => {
            if (e.target === gameBrowserDialog) {
                gameBrowserDialog.classList.add('hidden');
            }
        });

        // Search handler - fetches results and paginates client-side
        // (ZXInfo API offset parameter doesn't work reliably)
        async function gameBrowserDoSearch(resetPage = true) {
            const query = gameBrowserSearch.value.trim();
            if (!query) return;

            if (resetPage) {
                gameBrowser.page = 0;
                gameBrowser.lastQuery = query;
                gameBrowser.allResults = [];
            }

            // If we already have results and just changing page, use cached results
            if (!resetPage && gameBrowser.allResults.length > 0) {
                gameBrowserRenderCurrentPage();
                return;
            }

            gameBrowser.loading = true;
            gameBrowserResults.innerHTML = '<div class="gamebrowser-status"><div class="gamebrowser-loading"><div class="gamebrowser-spinner"></div><div>Searching...</div></div></div>';
            gameBrowserDetail.classList.add('hidden');

            // Search using ZXInfo API - fetch up to 100 results at once for client-side pagination
            try {
                const url = `https://api.zxinfo.dk/v3/search?query=${encodeURIComponent(query)}&mode=compact&size=100&titlesonly=true&sort=title_asc`;

                const response = await fetch(url, {
                    headers: {
                        'Accept': 'application/json'
                    }
                });

                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }

                const data = await response.json();
                const hitsArray = data.hits?.hits || [];

                gameBrowser.allResults = hitsArray.map(hit => {
                    const src = hit._source || {};
                    let screenshotUrl = '';
                    if (src.screens && src.screens.length > 0) {
                        screenshotUrl = `https://zxinfo.dk/media${src.screens[0].url}`;
                    }
                    return {
                        id: hit._id,
                        title: src.title || 'Unknown',
                        year: src.originalYearOfRelease || src.yearOfRelease || '',
                        publisher: src.publishers?.[0]?.name || '',
                        genre: src.genreType || src.type || '',
                        screenshotUrl: screenshotUrl,
                        source: 'zxinfo'
                    };
                });

                gameBrowser.totalResults = gameBrowser.allResults.length;
                gameBrowserRenderCurrentPage();
                gameBrowser.loading = false;
            } catch (error) {
                console.error('Game browser search error:', error);
                gameBrowserResults.innerHTML = `<div class="gamebrowser-status gamebrowser-error">Search failed: ${error.message}</div>`;
                gameBrowser.loading = false;
            }
        }

        // Render current page from cached results
        function gameBrowserRenderCurrentPage() {
            const start = gameBrowser.page * gameBrowser.pageSize;
            const end = start + gameBrowser.pageSize;
            gameBrowser.results = gameBrowser.allResults.slice(start, end);
            gameBrowserRenderResults();
            gameBrowserResults.scrollTop = 0; // Scroll to top when changing pages
        }

        // Render search results
        function gameBrowserRenderResults() {
            if (gameBrowser.results.length === 0) {
                gameBrowserResults.innerHTML = '<div class="gamebrowser-status">No results found</div>';
                gameBrowserUpdatePagination();
                return;
            }

            // Helper to safely convert values to strings
            const str = (v) => typeof v === 'string' ? v : (Array.isArray(v) ? v.join(', ') : String(v || ''));

            let html = '';
            for (const game of gameBrowser.results) {
                // ZXArt provides screenshot URLs, WoS doesn't - show placeholder if no image
                const thumbContent = game.screenshotUrl
                    ? `<img src="${game.screenshotUrl}" alt="" onerror="this.parentElement.innerHTML='<div class=\\'gamebrowser-thumb-placeholder\\'></div>'">`
                    : '<div class="gamebrowser-thumb-placeholder"></div>';
                const unavailable = game.availability_id && game.availability_id !== '1' ? '<span class="gamebrowser-unavailable">N/A</span>' : '';
                const yearStr = game.year ? `<span>${game.year}</span>` : '';
                const votesStr = game.votes ? `<span class="gamebrowser-score">★${game.votes}</span>` : '';

                html += `
                    <div class="gamebrowser-item" data-id="${game.id}" data-source="${game.source}">
                        <div class="gamebrowser-thumb">${thumbContent}</div>
                        <div class="gamebrowser-info">
                            <div class="gamebrowser-title">${escapeHtml(str(game.title))}</div>
                            <div class="gamebrowser-meta">
                                ${yearStr}
                                <span>${escapeHtml(str(game.publisher) || 'Unknown')}</span>
                                <span>${escapeHtml(str(game.genre))}</span>
                                ${votesStr}
                                ${unavailable}
                            </div>
                        </div>
                    </div>
                `;
            }

            gameBrowserResults.innerHTML = html;
            gameBrowserUpdatePagination();

            // Add click handlers
            gameBrowserResults.querySelectorAll('.gamebrowser-item').forEach(item => {
                item.addEventListener('click', () => {
                    gameBrowserResults.querySelectorAll('.gamebrowser-item').forEach(i => i.classList.remove('selected'));
                    item.classList.add('selected');
                    gameBrowserSelectGame(item.dataset.id, item.dataset.source);
                });
            });
        }

        // Update pagination
        function gameBrowserUpdatePagination() {
            const totalPages = Math.ceil(gameBrowser.totalResults / gameBrowser.pageSize);
            const currentPage = gameBrowser.page + 1;

            gameBrowserPageInfo.textContent = `Page ${currentPage} of ${totalPages || 1} (${gameBrowser.totalResults} results)`;
            btnGameBrowserPrev.disabled = gameBrowser.page === 0;
            btnGameBrowserNext.disabled = currentPage >= totalPages;
        }

        // Select a game and show details
        async function gameBrowserSelectGame(id, source) {
            gameBrowser.selectedGame = { id, source };
            gameBrowserDetail.classList.remove('hidden');
            gameBrowserDetailTitle.textContent = 'Loading...';
            gameBrowserDetailScreen.style.display = 'none';
            gameBrowserDetailScreen.innerHTML = '';
            gameBrowserDetailInfo.innerHTML = '<div class="gamebrowser-spinner"></div>';
            gameBrowserReleasesList.innerHTML = '';
            gameBrowserExternal.innerHTML = '';

            try {
                if (source === 'zxinfo') {
                    // Fetch from ZXInfo API
                    const url = `https://api.zxinfo.dk/v3/games/${encodeURIComponent(id)}?mode=full`;
                    const response = await fetch(url, {
                        headers: { 'Accept': 'application/json' }
                    });
                    if (!response.ok) throw new Error(`API error: ${response.status}`);
                    const data = await response.json();

                    if (!data._source) {
                        throw new Error('Game not found');
                    }

                    const game = data._source;

                    // Title
                    gameBrowserDetailTitle.textContent = game.title || 'Unknown';

                    // Screenshot - show placeholder if no image or on load error
                    gameBrowserDetailScreen.style.display = '';
                    if (game.screens && game.screens.length > 0) {
                        const screenUrl = `https://zxinfo.dk/media${game.screens[0].url}`;
                        gameBrowserDetailScreen.innerHTML = `<img src="${screenUrl}" alt="${escapeHtml(game.title || '')}" onerror="this.parentElement.innerHTML='<div class=\\'gamebrowser-thumb-placeholder\\'></div>'">`;
                    } else {
                        gameBrowserDetailScreen.innerHTML = '<div class="gamebrowser-thumb-placeholder"></div>';
                    }

                    // Build info
                    let infoHtml = '';
                    const year = game.originalYearOfRelease || game.yearOfRelease;
                    if (year) infoHtml += `<p><strong>Year:</strong> ${year}</p>`;
                    if (game.publishers?.length) {
                        const pubs = game.publishers.map(p => p.name).filter(Boolean);
                        if (pubs.length) infoHtml += `<p><strong>Publisher:</strong> ${pubs.map(n => escapeHtml(n)).join(', ')}</p>`;
                    }
                    if (game.genreType) infoHtml += `<p><strong>Genre:</strong> ${escapeHtml(game.genreType)}</p>`;
                    if (game.authors?.length) {
                        const auths = game.authors.map(a => a.name).filter(Boolean);
                        if (auths.length) infoHtml += `<p><strong>Authors:</strong> ${auths.map(n => escapeHtml(n)).join(', ')}</p>`;
                    }
                    if (game.score?.votes) infoHtml += `<p><strong>Rating:</strong> ★${game.score.score} (${game.score.votes} votes)</p>`;
                    if (game.machineType) infoHtml += `<p><strong>Machine:</strong> ${escapeHtml(game.machineType)}</p>`;
                    gameBrowserDetailInfo.innerHTML = infoHtml;

                    // Build releases list with direct load buttons
                    const scUrl = `https://spectrumcomputing.co.uk/entry/${encodeURIComponent(id)}`;
                    let releasesHtml = '';

                    // Collect all loadable files from releases
                    const loadableFiles = [];
                    if (game.releases) {
                        for (const rel of game.releases) {
                            if (rel.files) {
                                for (const f of rel.files) {
                                    if (f.path && /\.(tap|tzx|z80|sna|szx)(\.zip)?$/i.test(f.path)) {
                                        const filename = f.path.split('/').pop();
                                        const format = f.format || filename.replace(/\.zip$/i, '').split('.').pop().toUpperCase();
                                        loadableFiles.push({
                                            path: f.path,
                                            filename: filename,
                                            format: format,
                                            release: rel.releaseTitle || rel.publishers?.[0]?.name || ''
                                        });
                                    }
                                }
                            }
                        }
                    }

                    if (loadableFiles.length > 0) {
                        // Limit to first 10 files to avoid overwhelming UI
                        const filesToShow = loadableFiles.slice(0, 10);
                        for (const f of filesToShow) {
                            const releaseInfo = f.release ? ` <span class="gamebrowser-release-info">(${escapeHtml(f.release)})</span>` : '';
                            const downloadUrl = `https://spectrumcomputing.co.uk${f.path}`;
                            releasesHtml += `<div class="gamebrowser-release">
                                <span class="gamebrowser-release-format">${escapeHtml(f.format)}</span>
                                <a href="${downloadUrl}" download="${escapeHtml(f.filename)}" class="gamebrowser-download-btn">Download</a>
                                ${releaseInfo}
                            </div>`;
                        }
                        releasesHtml += `<div class="gamebrowser-release-note">Download, then drag file into emulator</div>`;
                        if (loadableFiles.length > 10) {
                            releasesHtml += `<div class="gamebrowser-release-note">${loadableFiles.length - 10} more files on Spectrum Computing</div>`;
                        }
                    }

                    releasesHtml += `<div class="gamebrowser-release gamebrowser-release-link">
                        <a href="${scUrl}" target="_blank">View all on Spectrum Computing →</a>
                    </div>`;

                    gameBrowserReleasesList.innerHTML = releasesHtml;

                } else {
                    throw new Error('Unknown source');
                }

            } catch (error) {
                console.error('Failed to load game details:', error);
                gameBrowserDetailTitle.textContent = 'Error loading details';
                gameBrowserDetailScreen.innerHTML = '';
                gameBrowserDetailInfo.innerHTML = `<p class="gamebrowser-error">${error.message}</p>`;
            }
        }

        // Search button and enter key
        btnGameBrowserSearchGo.addEventListener('click', () => gameBrowserDoSearch());
        gameBrowserSearch.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') gameBrowserDoSearch();
        });

        // Pagination
        btnGameBrowserPrev.addEventListener('click', () => {
            if (gameBrowser.page > 0) {
                gameBrowser.page--;
                gameBrowserDoSearch(false);
            }
        });

        btnGameBrowserNext.addEventListener('click', () => {
            gameBrowser.page++;
            gameBrowserDoSearch(false);
        });

        // Initial black screen
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Try to auto-load ROMs, show dialog only if not found
        tryLoadRomsFromDirectory();
        
        console.log('');
        console.log('Usage:');
        console.log('1. Place ROMs in roms/ directory (48.rom, 128.rom, plus2.rom, plus2a.rom, pentagon.rom, scorpion.rom, trdos.rom)');
        console.log('2. Or select ROM files in dialog if not found');
        console.log('3. Load SNA/Z80/SZX snapshots, TAP/TZX tapes, or TRD/SCL disk images');
    </script>
</body>
</html>
